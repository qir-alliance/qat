# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

from os import path
import os
import logging
import subprocess
import sys

from .settings import PROJECT_ROOT
from .toolchain import discover_formatter
from typing import Union, List, Optional, Callable
import difflib
import re

OptionalInt = Optional[int]
OptionalStr = Union[str, None]
IPipeline = List[Callable]

logger = logging.getLogger("FormatChecker")
CLANG_FORMAT_EXE = discover_formatter()

QUANTUM_SYMBOL_PATTERN = re.compile(
    r"(?P<start>[ \"@'])(?P<full>__quantum__(?P<type>(qis|rt))__(?P<instr>[\w\d\_]+))(?P<end>[ \"'])?")
VALID_INSTRUCTIONS = [
    "cnot",
    "h",
    "s",
    "mz",
    "x",
    "y",
    "z",
    "toffoli",
    "cz",
    "cx",
    "cy",
    "rz",
    "rx",
    "ry",
    "r",
    "measure",
    "reset",
    "crz",
    "m",
    "t",
    "sqrt",
    "dumpregister",
    "read_result",
    "arcsin",
    "drawrandomint"
]


def require_token(token: str, filename: str, contents: str,
                  cursor: int, fix_issues: bool) -> int:
    """
    Validator function to require that the next part of the document is a specific token.
    """
    failed = False
    if not contents[cursor:].startswith(token):
        logger.error("{}: File must have {} at position {}".format(
            filename, token, cursor))
        failed = True
    return cursor + len(token), failed


def require_pragma_once(filename: str, contents: str,
                        cursor: int, fix_issues: bool) -> int:
    """
    Validator function that requires '#pragma once' in headers
    """
    return require_token("#pragma once\n", filename,
                         contents, cursor, fix_issues)


def enforce_cpp_license(filename: str, contents: str,
                        cursor: int, fix_issues: bool) -> int:
    """
    Validator function that requires copyrights in C++ files
    """
    return require_token("""// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

""", filename, contents, cursor, fix_issues)


def enforce_py_license(filename: str, contents: str,
                       cursor: int, fix_issues: bool) -> int:
    """
    Validator function that requires copyrights in Python files
    """
    # Allowing empty files
    if contents.strip() == "":
        return cursor, False

    return require_token("""# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

""", filename, contents, cursor, fix_issues)


def enforce_py_formatting(filename: str, contents: str,
                          cursor: int, fix_issues: bool) -> int:
    """
    Validator function that tests whether the style of the C++
    source file follows that dictated by `.clang-format`.
    """

    # Opening a pipe with autopep8
    try:
        p = subprocess.Popen(
            ["autopep8", "--aggressive", filename],
            stdout=subprocess.PIPE,
            stdin=subprocess.PIPE,
            cwd=PROJECT_ROOT)
    except:  # noqa: E722
        logger.error("Error: autopep8 not available. Please install it")
        return cursor, True

    # Passing the contents of the file
    output = p.communicate(input=contents.encode())[0]

    # In case something went wrong, we raise an exception
    if p.returncode != 0:
        raise Exception('Could not format contents')

    # Otherwise we check that the input is the same as the output
    formatted = output.decode('utf-8')
    if formatted != contents:

        # Updating the contents of the file if requested by the user
        if fix_issues:
            logger.info("Formatting {}".format(filename))
            with open(filename, "w") as filebuffer:
                filebuffer.write(formatted)
            return cursor, False
        else:
            logger.error("{} was not correctly formatted.".format(filename))
            sys.stdout.writelines(difflib.unified_diff(contents, formatted,
                                                       fromfile=filename, tofile="formatted_{}".format(filename)))
            sys.stdout.writelines("\n\n")
        return cursor, True

    return cursor, False


def enforce_cpp_formatting(
        filename: str, contents: str, cursor: int, fix_issues: bool) -> int:
    """
    Validator function that tests whether the style of the C++
    source file follows that dictated by `.clang-format`.
    """

    # Opening a pipe with Clang format
    p = subprocess.Popen(
        [CLANG_FORMAT_EXE, '-style=file'],
        stdout=subprocess.PIPE,
        stdin=subprocess.PIPE,
        cwd=PROJECT_ROOT)

    # Passing the contents of the file
    output = p.communicate(input=contents.encode())[0]

    # In case something went wrong, we raise an exception
    if p.returncode != 0:
        raise Exception('Could not format contents')

    # Otherwise we check that the input is the same as the output
    formatted = output.decode('utf-8')
    if formatted != contents:

        # Updating the contents of the file if requested by the user
        if fix_issues:
            logger.info("Formatting {}".format(filename))
            with open(filename, "w") as filebuffer:
                filebuffer.write(formatted)
            return cursor, False
        else:
            logger.error("{} was not correctly formatted.".format(filename))
            sys.stdout.writelines(difflib.unified_diff(contents, formatted,
                                                       fromfile=filename, tofile="formatted_{}".format(filename)))
            sys.stdout.writelines("\n\n")

        return cursor, True

    return cursor, False


def enforce_quantum_symbols(
        filename: str, contents: str, cursor: int, fix_issues: bool) -> int:
    fail = False
    for match in QUANTUM_SYMBOL_PATTERN.finditer(contents):
        start = match.group("start")
        end = match.group("end")
        instr = match.group("instr")
        full = match.group("full")
        type = match.group("type")
        specialisation = ""
        try:
            instr, specialisation = instr.rsplit("__", 1)
        except:  # noqa: E722
            pass

        if type == "qis":
            if instr not in VALID_INSTRUCTIONS:
                logger.error(
                    "Invalid instruction '{}' in {}".format(instr, filename))
                fail = True
            elif specialisation not in ["body", "ctl", "adj", "adjctl"]:
                logger.error(
                    "Missing specialisation for quantum symbol: {} in {}".format(full, filename))
                fail = True

        if (start == '"' or end == '"') and start != end:
            logger.error("Invalid string format for: '{}{}{}' in {}".format(
                start, full, end, filename))
        elif (start == '"' or end == '"') and start != end:
            logger.error("Invalid string format for: \"{}{}{}\" in {}".format(
                start, full, end, filename))

    return cursor, fail


def enforce_prettier_formatting(
        basedir: str, extensions: str, fix_issues: bool, options: Optional[List[str]] = None) -> bool:
    options = options or []
    mode = "--check"

    if fix_issues:
        mode = "--write"

    pr = PROJECT_ROOT

    if not pr.endswith("/"):
        pr += "/"

    if not basedir.endswith("/"):
        basedir += "/"

    basedir = basedir.replace(pr, "")
    if "," in extensions:
        cmd = ["prettier"] + options + [mode,
                                        '"{}'.format(basedir) + '(**/)?*.{' + extensions + '}"']
    else:
        cmd = ["prettier"] + options + [mode,
                                        '"{}'.format(basedir) + '(**/)?*.' + extensions + '"']

    try:
        p = subprocess.Popen(
            " ".join(cmd),
            cwd=PROJECT_ROOT, shell=True)
    except:  # noqa: E722
        logger.error("prettier not available. Please install it")
        return False

    # Waiting for the process to finish
    p.communicate()

    if p.returncode != 0:
        logger.error("Files in documentation does not follow style guide")
        return False

    return True


def enforce_markdown_linting(
        basedir: str, fix_issues: bool) -> bool:

    pr = PROJECT_ROOT

    if not pr.endswith("/"):
        pr += "/"

    if not basedir.endswith("/"):
        basedir += "/"

    basedir = basedir.replace(pr, "")

    cmd = ["markdownlint", "-c", "./mdlint.yml", basedir]
    print("Running {}".format(" ".join(cmd)))
    try:
        p = subprocess.Popen(
            " ".join(cmd),
            cwd=PROJECT_ROOT, shell=True)
    except:  # noqa: E722
        logger.error("markdownlint not available. Please install it")
        return False

    # Waiting for the process to finish
    p.communicate()

    if p.returncode != 0:
        logger.error("Files in documentation does not follow style guide")
        return False

    return True


def enforce_prettier_yaml_formatting(
        basedir: str, fix_issues: bool) -> bool:
    return enforce_prettier_formatting(basedir, "yaml,yml", fix_issues)


def enforce_prettier_json_formatting(
        basedir: str, fix_issues: bool) -> bool:
    return enforce_prettier_formatting(basedir, "json", fix_issues)


def enforce_prettier_docs_formatting(
        basedir: str, fix_issues: bool) -> bool:
    return enforce_prettier_formatting(basedir, "md", fix_issues, options=["--prose-wrap", "always"]) and \
        enforce_prettier_formatting(
        basedir, "css,scss,js,html", fix_issues)  # and \
#        enforce_markdown_linting(basedir, fix_issues)


# Source pipeline definitions. These instructs the next part of
# the code on how to validate each source file.


SOURCE_PIPELINES = [
    {
        "name": "C++ Main",
        "src": path.join(PROJECT_ROOT, "qir/qat"),
        "filter": None,
        "pipelines": {
            "hpp": [
                require_pragma_once,
                enforce_cpp_license,
                enforce_cpp_formatting,
                enforce_quantum_symbols
            ],
            "cpp": [
                enforce_cpp_license,
                enforce_cpp_formatting,
                enforce_quantum_symbols
            ]
        }
    },
    {
        "name": "C/C++ stdlib",
        "src": path.join(PROJECT_ROOT, "qir/stdlib"),
        "filter": None,
        "pipelines": {
            "hpp": [
                require_pragma_once,
                enforce_cpp_license,
                enforce_cpp_formatting,
                enforce_quantum_symbols
            ],
            "h": [
                require_pragma_once,
                enforce_cpp_license,
                enforce_cpp_formatting,
                enforce_quantum_symbols
            ],
            "cpp": [
                enforce_cpp_license,
                enforce_cpp_formatting,
                enforce_quantum_symbols
            ],
            "c": [
                enforce_cpp_license,
                enforce_cpp_formatting,
                enforce_quantum_symbols
            ]
        }
    },
    {
        "name": "Python Libraries",
        "src": path.join(PROJECT_ROOT, "site-packages"),

        "pipelines": {
            "py": [
                enforce_py_license,
                enforce_py_formatting,
                enforce_quantum_symbols
            ],
        }
    },
    {
        "name": "Documentation",
        "src": PROJECT_ROOT,
        "bulk-apply": enforce_prettier_docs_formatting
    },
    {
        "name": "YAML",
        "src": PROJECT_ROOT,
        "bulk-apply": enforce_prettier_yaml_formatting
    },
    {
        "name": "JSON",
        "src": PROJECT_ROOT,
        "bulk-apply": enforce_prettier_json_formatting
    }
]


def execute_pipeline(pipeline: IPipeline, filename: str,
                     fix_issues: bool) -> bool:
    """
    Helper function to execute a pipeline for a specific file
    """
    logger.info("Executing pipeline for {}".format(filename))
    cursor = 0

    # Reading the file
    with open(filename, "r") as fb:
        contents = fb.read()

    # Executing each step of the pipeline
    failed = False
    for fnc in pipeline:
        cursor, f = fnc(filename, contents, cursor, fix_issues)
        failed = failed or f

    return failed


def main(fix_issues: bool = False) -> None:
    """
    This function runs a pipeline for every file that
    matches the description given in SOURCE_PIPELINES.
    """
    failed = False

    # Iterating through every definition
    for language in SOURCE_PIPELINES:

        logger.info("Formatting {}".format(language["name"]))
        basedir = language["src"]

        if "bulk-apply" in language:
            f = language["bulk-apply"]
            if not f(basedir, fix_issues):
                logger.error("Failed checks for {} ".format(language["name"]))
                failed = True
            continue

        # Finding all files whose location matches that of the
        # definition
        pipelines = language["pipelines"]
        for root, dirs, files in os.walk(basedir):

            for filename in files:
                if "." not in filename:
                    continue

                # Executing the pipeline if appropriate
                _, ext = filename.rsplit(".", 1)
                if ext in pipelines:
                    f = execute_pipeline(pipelines[ext], path.join(
                        root, filename), fix_issues)
                    if f:
                        logger.error(
                            "Failed checks for {}.{} ".format(
                                language["name"], ext))
                    failed = failed or f

    if failed:
        logger.error("Your code did not pass formatting.")
        sys.exit(-1)


if __name__ == "__main__":
    main()
