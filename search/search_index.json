{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"QIR Adaptor Tool Welcome to the QIR Adaptor Tool (QAT), a tool to transform a generic QIR into a QIR targeted to specific set of requirements. The goal of this framework is to create tools that allow quantum hardware vendors to adapt a generic QIR to their specific hardware requirements and restrictions. Outline: Introduction Quick start Supported systems Building with Bazel Building with CMake Running QAT Using QAT Targeting a QIR Debugging a QIR QAT: Assumptions and Restrictions Developer guide Architecture Overview Writing an adaptor Rule based adaptors Grouping QIS Additional developer info: Contributing Code quality Developer FAQ Introduction The QIR adapter tool (QAT) is a tool that is intended to transform a generic QIR to a QIR targeted to a specific backend and validate that it is compliant with the backend requirements. A QIR target describes a subset of the generic QIR functionality and conventions. It is anticipated that most usages of the QIR specification will need to only use a subset of it. These subsets may further be subject to constraints such as how one allocate or acquire a qubit handle. We refer to such a subset with constraints as a target. For instance, it is likely that early versions of quantum backend will have a limited set of classical instructions available. With this in mind, the vendor or user of said backend would define a profile that only contains a specified subset. A target consists of a set of classical capabililties refered to as a profile and a quantum instruction set (QIS). One example of such a target is the base profile with any QIS, which only allows function calls and jumps, but no arithmetic, classical memory, or classical data types. The generation of the generic QIR according to the spec with no constraints would typically be performed by the frontend. A couple of examples are Q# or OpenQASM 3.0. However, for the generated QIR to be practical it is necessary to reduce it using a profile which is compatible with the target platform: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Frontend \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 QIR \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 QIR Adaptor Tool \u2502 <\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Targeting the QIR \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 Adapted QIR \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Backend \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 As an example, a backend based quantum platform may only have support for sequential gates with no branching or ability for subroutines. Likewise, some quantum platforms only allow for a single measurement at the end of executing the pipeline of quantum gates. Profiles suppose to express these nuances and restrictions which are absent in the generic QIR.","title":"QIR Adaptor Tool"},{"location":"#qir-adaptor-tool","text":"Welcome to the QIR Adaptor Tool (QAT), a tool to transform a generic QIR into a QIR targeted to specific set of requirements. The goal of this framework is to create tools that allow quantum hardware vendors to adapt a generic QIR to their specific hardware requirements and restrictions. Outline: Introduction Quick start Supported systems Building with Bazel Building with CMake Running QAT Using QAT Targeting a QIR Debugging a QIR QAT: Assumptions and Restrictions Developer guide Architecture Overview Writing an adaptor Rule based adaptors Grouping QIS Additional developer info: Contributing Code quality Developer FAQ","title":"QIR Adaptor Tool"},{"location":"#introduction","text":"The QIR adapter tool (QAT) is a tool that is intended to transform a generic QIR to a QIR targeted to a specific backend and validate that it is compliant with the backend requirements. A QIR target describes a subset of the generic QIR functionality and conventions. It is anticipated that most usages of the QIR specification will need to only use a subset of it. These subsets may further be subject to constraints such as how one allocate or acquire a qubit handle. We refer to such a subset with constraints as a target. For instance, it is likely that early versions of quantum backend will have a limited set of classical instructions available. With this in mind, the vendor or user of said backend would define a profile that only contains a specified subset. A target consists of a set of classical capabililties refered to as a profile and a quantum instruction set (QIS). One example of such a target is the base profile with any QIS, which only allows function calls and jumps, but no arithmetic, classical memory, or classical data types. The generation of the generic QIR according to the spec with no constraints would typically be performed by the frontend. A couple of examples are Q# or OpenQASM 3.0. However, for the generated QIR to be practical it is necessary to reduce it using a profile which is compatible with the target platform: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Frontend \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 QIR \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 QIR Adaptor Tool \u2502 <\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Targeting the QIR \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 Adapted QIR \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Backend \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 As an example, a backend based quantum platform may only have support for sequential gates with no branching or ability for subroutines. Likewise, some quantum platforms only allow for a single measurement at the end of executing the pipeline of quantum gates. Profiles suppose to express these nuances and restrictions which are absent in the generic QIR.","title":"Introduction"},{"location":"Api/","text":"API Documentation","title":"API Documentation"},{"location":"Api/#api-documentation","text":"","title":"API Documentation"},{"location":"Api/Classes/","text":"Classes namespace microsoft namespace quantum struct AllocationAnalysis struct ResourceAccessLocation class AllocationAnalysisPass class AllocationAnalysisPassPrinter class AnyPattern Pattern that matches any operand. class BasicAllocationManager struct AllocatedMemoryBlock class BasicBlockPattern class BitCastPattern class BranchPattern class CallPattern class CommentLogger Concrete ILogger implementation that prints all messages as IR comments to llvm::errs(). class ConfigBind class ConfigurableQirAdaptorFactory class ConfigurationManager struct Section class ConstIntPattern class DebugInfoUpdater class DeferMeasurementPass class DeferredValue class DivisionByZeroPass class FunctionAnnotatorPass struct FunctionRegister class FunctionReplacementAnalysisPass class FunctionReplacementAnalysisPassPrinter class FunctionReplacementConfiguration class FunctionReplacementPass class FunctionToModule class FunctionValidationPass struct GroupAnalysis class GroupingAnalysisPass class GroupingAnalysisPassPrinter class GroupingPass struct ResourceAnalysis class GroupingPassConfiguration struct HasQatSerializers class IAllocationManager class IConfigBind class ILogger struct Location Class that holds the location of where the incident happened. struct Message Struct to hold a message together with its type and location. class IOperandPrototype class InstructionLocationTable class IntToPtrPattern class IrManipulationTestHelper class LlvmPassesConfiguration class LoadPattern class LogCollection class ModuleLoader class SingleModuleTransformation class OpcodeSet class OpcodeValue class ParameterParser struct ParsedValue Struct that contains parsed and interpreted values of command line arguments. class PhiPattern class PostTransformValidationPass class PostTransformValidationPassConfiguration class QirAdaptor class QirAdaptorFactory class QubitRemapPass class RemoveDisallowedAttributesPass class RemoveNonEntrypointFunctionsPass class RemoveNonEntrypointFunctionsPassConfiguration class ReplaceQubitOnResetPass class ReplacementRule class ResourceAnnotationPass class RuleFactory class RuleSet class SelectPattern class SourceLocation class SpecConfiguration class StaticResourceComponentConfiguration class StorePattern class SwitchPattern class TargetProfileConfiguration struct TargetProfileMappingConfiguration class TargetQisConfiguration class TargetQisMappingPass class TargetQisMappingPassConfiguration Configuration class for the RuleTransformation pass. class TestProgram class TestVM class UnnamedInvokePattern class ValidationPass class Validator class ZExtPattern class ZExtTransformPass namespace details namespace notation class Capture namespace version namespace microsoft::quantum::@65 namespace std struct hash< microsoft::quantum::OpcodeValue > namespace version_builder Updated on 28 October 2022 at 19:30:16 UTC","title":"Classes"},{"location":"Api/Classes/#classes","text":"namespace microsoft namespace quantum struct AllocationAnalysis struct ResourceAccessLocation class AllocationAnalysisPass class AllocationAnalysisPassPrinter class AnyPattern Pattern that matches any operand. class BasicAllocationManager struct AllocatedMemoryBlock class BasicBlockPattern class BitCastPattern class BranchPattern class CallPattern class CommentLogger Concrete ILogger implementation that prints all messages as IR comments to llvm::errs(). class ConfigBind class ConfigurableQirAdaptorFactory class ConfigurationManager struct Section class ConstIntPattern class DebugInfoUpdater class DeferMeasurementPass class DeferredValue class DivisionByZeroPass class FunctionAnnotatorPass struct FunctionRegister class FunctionReplacementAnalysisPass class FunctionReplacementAnalysisPassPrinter class FunctionReplacementConfiguration class FunctionReplacementPass class FunctionToModule class FunctionValidationPass struct GroupAnalysis class GroupingAnalysisPass class GroupingAnalysisPassPrinter class GroupingPass struct ResourceAnalysis class GroupingPassConfiguration struct HasQatSerializers class IAllocationManager class IConfigBind class ILogger struct Location Class that holds the location of where the incident happened. struct Message Struct to hold a message together with its type and location. class IOperandPrototype class InstructionLocationTable class IntToPtrPattern class IrManipulationTestHelper class LlvmPassesConfiguration class LoadPattern class LogCollection class ModuleLoader class SingleModuleTransformation class OpcodeSet class OpcodeValue class ParameterParser struct ParsedValue Struct that contains parsed and interpreted values of command line arguments. class PhiPattern class PostTransformValidationPass class PostTransformValidationPassConfiguration class QirAdaptor class QirAdaptorFactory class QubitRemapPass class RemoveDisallowedAttributesPass class RemoveNonEntrypointFunctionsPass class RemoveNonEntrypointFunctionsPassConfiguration class ReplaceQubitOnResetPass class ReplacementRule class ResourceAnnotationPass class RuleFactory class RuleSet class SelectPattern class SourceLocation class SpecConfiguration class StaticResourceComponentConfiguration class StorePattern class SwitchPattern class TargetProfileConfiguration struct TargetProfileMappingConfiguration class TargetQisConfiguration class TargetQisMappingPass class TargetQisMappingPassConfiguration Configuration class for the RuleTransformation pass. class TestProgram class TestVM class UnnamedInvokePattern class ValidationPass class Validator class ZExtPattern class ZExtTransformPass namespace details namespace notation class Capture namespace version namespace microsoft::quantum::@65 namespace std struct hash< microsoft::quantum::OpcodeValue > namespace version_builder Updated on 28 October 2022 at 19:30:16 UTC","title":"Classes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/","text":"microsoft::quantum::AllocationAnalysisPass Inherits from llvm::AnalysisInfoMixin< AllocationAnalysisPass > Public Types Name using AllocationAnalysis Result using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using std::unordered_set< llvm::BasicBlock * > BlockSet using AllocationAnalysis::ResourceType ResourceType using AllocationAnalysis::ResourceAccessLocation ResourceAccessLocation Public Functions Name AllocationAnalysisPass (ILoggerPtr const & logger) AllocationAnalysisPass ( AllocationAnalysisPass const & ) Copy construction is banned. AllocationAnalysisPass ( AllocationAnalysisPass && ) =default We allow move semantics. ~AllocationAnalysisPass () =default Default destruction. Result run (llvm::Function & function, llvm::FunctionAnalysisManager & fam) bool isRequired () Whether or not this pass is required to run. Friends Name struct llvm::AnalysisInfoMixin< AllocationAnalysisPass > Public Types Documentation using Result using microsoft::quantum::AllocationAnalysisPass::Result = AllocationAnalysis; using Instruction using microsoft::quantum::AllocationAnalysisPass::Instruction = llvm::Instruction; using Value using microsoft::quantum::AllocationAnalysisPass::Value = llvm::Value; using ILoggerPtr using microsoft::quantum::AllocationAnalysisPass::ILoggerPtr = ILogger::ILoggerPtr; using BlockSet using microsoft::quantum::AllocationAnalysisPass::BlockSet = std::unordered_set<llvm::BasicBlock*>; using ResourceType using microsoft::quantum::AllocationAnalysisPass::ResourceType = AllocationAnalysis::ResourceType; using ResourceAccessLocation using microsoft::quantum::AllocationAnalysisPass::ResourceAccessLocation = AllocationAnalysis::ResourceAccessLocation; Public Functions Documentation function AllocationAnalysisPass inline explicit AllocationAnalysisPass( ILoggerPtr const & logger ) function AllocationAnalysisPass AllocationAnalysisPass( AllocationAnalysisPass const & ) Copy construction is banned. function AllocationAnalysisPass AllocationAnalysisPass( AllocationAnalysisPass && ) =default We allow move semantics. function ~AllocationAnalysisPass ~AllocationAnalysisPass() =default Default destruction. function run Result run( llvm::Function & function, llvm::FunctionAnalysisManager & fam ) function isRequired static bool isRequired() Whether or not this pass is required to run. Friends friend llvm::AnalysisInfoMixin< AllocationAnalysisPass > friend struct llvm::AnalysisInfoMixin< AllocationAnalysisPass >(); Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::AllocationAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/#microsoftquantumallocationanalysispass","text":"Inherits from llvm::AnalysisInfoMixin< AllocationAnalysisPass >","title":"microsoft::quantum::AllocationAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/#public-types","text":"Name using AllocationAnalysis Result using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using std::unordered_set< llvm::BasicBlock * > BlockSet using AllocationAnalysis::ResourceType ResourceType using AllocationAnalysis::ResourceAccessLocation ResourceAccessLocation","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/#public-functions","text":"Name AllocationAnalysisPass (ILoggerPtr const & logger) AllocationAnalysisPass ( AllocationAnalysisPass const & ) Copy construction is banned. AllocationAnalysisPass ( AllocationAnalysisPass && ) =default We allow move semantics. ~AllocationAnalysisPass () =default Default destruction. Result run (llvm::Function & function, llvm::FunctionAnalysisManager & fam) bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/#friends","text":"Name struct llvm::AnalysisInfoMixin< AllocationAnalysisPass >","title":"Friends"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/#using-result","text":"using microsoft::quantum::AllocationAnalysisPass::Result = AllocationAnalysis;","title":"using Result"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/#using-instruction","text":"using microsoft::quantum::AllocationAnalysisPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/#using-value","text":"using microsoft::quantum::AllocationAnalysisPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/#using-iloggerptr","text":"using microsoft::quantum::AllocationAnalysisPass::ILoggerPtr = ILogger::ILoggerPtr;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/#using-blockset","text":"using microsoft::quantum::AllocationAnalysisPass::BlockSet = std::unordered_set<llvm::BasicBlock*>;","title":"using BlockSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/#using-resourcetype","text":"using microsoft::quantum::AllocationAnalysisPass::ResourceType = AllocationAnalysis::ResourceType;","title":"using ResourceType"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/#using-resourceaccesslocation","text":"using microsoft::quantum::AllocationAnalysisPass::ResourceAccessLocation = AllocationAnalysis::ResourceAccessLocation;","title":"using ResourceAccessLocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/#function-allocationanalysispass","text":"inline explicit AllocationAnalysisPass( ILoggerPtr const & logger )","title":"function AllocationAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/#function-allocationanalysispass_1","text":"AllocationAnalysisPass( AllocationAnalysisPass const & ) Copy construction is banned.","title":"function AllocationAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/#function-allocationanalysispass_2","text":"AllocationAnalysisPass( AllocationAnalysisPass && ) =default We allow move semantics.","title":"function AllocationAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/#function-allocationanalysispass_3","text":"~AllocationAnalysisPass() =default Default destruction.","title":"function ~AllocationAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/#function-run","text":"Result run( llvm::Function & function, llvm::FunctionAnalysisManager & fam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run.","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/#friends_1","text":"","title":"Friends"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass/#friend-llvmanalysisinfomixin-allocationanalysispass","text":"friend struct llvm::AnalysisInfoMixin< AllocationAnalysisPass >(); Updated on 28 October 2022 at 19:30:15 UTC","title":"friend llvm::AnalysisInfoMixin&lt; AllocationAnalysisPass &gt;"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass_printer/","text":"microsoft::quantum::AllocationAnalysisPassPrinter Inherits from llvm::PassInfoMixin< AllocationAnalysisPassPrinter > Public Functions Name llvm::PreservedAnalyses run (llvm::Function & module, llvm::FunctionAnalysisManager & mam) bool isRequired () Public Functions Documentation function run llvm::PreservedAnalyses run( llvm::Function & module, llvm::FunctionAnalysisManager & mam ) function isRequired static inline bool isRequired() Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::AllocationAnalysisPassPrinter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass_printer/#microsoftquantumallocationanalysispassprinter","text":"Inherits from llvm::PassInfoMixin< AllocationAnalysisPassPrinter >","title":"microsoft::quantum::AllocationAnalysisPassPrinter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass_printer/#public-functions","text":"Name llvm::PreservedAnalyses run (llvm::Function & module, llvm::FunctionAnalysisManager & mam) bool isRequired ()","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass_printer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass_printer/#function-run","text":"llvm::PreservedAnalyses run( llvm::Function & module, llvm::FunctionAnalysisManager & mam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_allocation_analysis_pass_printer/#function-isrequired","text":"static inline bool isRequired() Updated on 28 October 2022 at 19:30:15 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/","text":"microsoft::quantum::AnyPattern Pattern that matches any operand. #include <Rules/Patterns/AnyPattern.hpp> Inherits from microsoft::quantum::IOperandPrototype Public Functions Name AnyPattern () ~AnyPattern () override virtual bool match (Value * instr, Captures & captures) const override Match of any operand always returns true and ignores children. virtual Child copy () const override Creates a copy of the AnyPattern instance. Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function AnyPattern AnyPattern() function ~AnyPattern ~AnyPattern() override function match virtual bool match( Value * instr, Captures & captures ) const override Match of any operand always returns true and ignores children. Reimplements : microsoft::quantum::IOperandPrototype::match function copy virtual Child copy() const override Creates a copy of the AnyPattern instance. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::AnyPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#microsoftquantumanypattern","text":"Pattern that matches any operand. #include <Rules/Patterns/AnyPattern.hpp> Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::AnyPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#public-functions","text":"Name AnyPattern () ~AnyPattern () override virtual bool match (Value * instr, Captures & captures) const override Match of any operand always returns true and ignores children. virtual Child copy () const override Creates a copy of the AnyPattern instance.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#function-anypattern","text":"AnyPattern()","title":"function AnyPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#function-anypattern_1","text":"~AnyPattern() override","title":"function ~AnyPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#function-match","text":"virtual bool match( Value * instr, Captures & captures ) const override Match of any operand always returns true and ignores children. Reimplements : microsoft::quantum::IOperandPrototype::match","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#function-copy","text":"virtual Child copy() const override Creates a copy of the AnyPattern instance. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 28 October 2022 at 19:30:15 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/","text":"microsoft::quantum::BasicAllocationManager More... #include <AllocationManager/AllocationManager.hpp> Inherits from microsoft::quantum::IAllocationManager Public Classes Name struct AllocatedMemoryBlock Public Types Name using std::vector< AllocatedMemoryBlock > Mappings Vector of memory segments. using std::shared_ptr< BasicAllocationManager > BasicAllocationManagerPtr Allocator pointer type. Public Functions Name BasicAllocationManagerPtr createNew () virtual Address allocate (String const & name =\"\", Index const & count =1) override virtual void release ( Address const & address) override Releases the segment by address. virtual void reset () override Resets the allocation manager and all its statistics. void setReuseRegisters (bool val) Additional inherited members Public Types inherited from microsoft::quantum::IAllocationManager Name using uint64_t Address Value type for address. using uint64_t Index Index type used to access an array element. using std::shared_ptr< IAllocationManager > AllocationManagerPtr Pointer interface. Public Functions inherited from microsoft::quantum::IAllocationManager Name IAllocationManager ( IAllocationManager const & ) IAllocationManager ( IAllocationManager && ) IAllocationManager & operator= ( IAllocationManager const & ) IAllocationManager & operator= ( IAllocationManager && ) virtual ~IAllocationManager () uint64_t allocationsInUse () const uint64_t maxAllocationsUsed () const Protected Functions inherited from microsoft::quantum::IAllocationManager Name IAllocationManager () =default void updateRegistersInUse (uint64_t n) Detailed Description class microsoft::quantum::BasicAllocationManager; AllocationManager is a simple qubit and results allocator that can be used at compile-time. It is based on an assumption that all qubit allocating function calls are inlined and that qubits/results can be allocated with strictly growing IDs. Public Types Documentation using Mappings using microsoft::quantum::BasicAllocationManager::Mappings = std::vector<AllocatedMemoryBlock>; Vector of memory segments. using BasicAllocationManagerPtr using microsoft::quantum::BasicAllocationManager::BasicAllocationManagerPtr = std::shared_ptr<BasicAllocationManager>; Allocator pointer type. Public Functions Documentation function createNew static BasicAllocationManagerPtr createNew() Creates a new allocation manager. The manager is kept as a shared pointer to enable allocation across different passes and/or replacement rules. function allocate virtual Address allocate( String const & name =\"\", Index const & count =1 ) override Reimplements : microsoft::quantum::IAllocationManager::allocate Allocates a possibly named segment of a given count. Calling allocate without and arguments allocates a single anonymous resource and returns the address. In case of a larger segment, the function returns the address pointing to the first element. Allocation is guaranteed to be sequential. function release virtual void release( Address const & address ) override Releases the segment by address. Reimplements : microsoft::quantum::IAllocationManager::release function reset virtual void reset() override Resets the allocation manager and all its statistics. Reimplements : microsoft::quantum::IAllocationManager::reset function setReuseRegisters void setReuseRegisters( bool val ) Configuration function to set mode of qubit allocation. If function argument is true, the allocation manager will reuse qubits. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::BasicAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#microsoftquantumbasicallocationmanager","text":"More... #include <AllocationManager/AllocationManager.hpp> Inherits from microsoft::quantum::IAllocationManager","title":"microsoft::quantum::BasicAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#public-classes","text":"Name struct AllocatedMemoryBlock","title":"Public Classes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#public-types","text":"Name using std::vector< AllocatedMemoryBlock > Mappings Vector of memory segments. using std::shared_ptr< BasicAllocationManager > BasicAllocationManagerPtr Allocator pointer type.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#public-functions","text":"Name BasicAllocationManagerPtr createNew () virtual Address allocate (String const & name =\"\", Index const & count =1) override virtual void release ( Address const & address) override Releases the segment by address. virtual void reset () override Resets the allocation manager and all its statistics. void setReuseRegisters (bool val)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IAllocationManager Name using uint64_t Address Value type for address. using uint64_t Index Index type used to access an array element. using std::shared_ptr< IAllocationManager > AllocationManagerPtr Pointer interface. Public Functions inherited from microsoft::quantum::IAllocationManager Name IAllocationManager ( IAllocationManager const & ) IAllocationManager ( IAllocationManager && ) IAllocationManager & operator= ( IAllocationManager const & ) IAllocationManager & operator= ( IAllocationManager && ) virtual ~IAllocationManager () uint64_t allocationsInUse () const uint64_t maxAllocationsUsed () const Protected Functions inherited from microsoft::quantum::IAllocationManager Name IAllocationManager () =default void updateRegistersInUse (uint64_t n)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#detailed-description","text":"class microsoft::quantum::BasicAllocationManager; AllocationManager is a simple qubit and results allocator that can be used at compile-time. It is based on an assumption that all qubit allocating function calls are inlined and that qubits/results can be allocated with strictly growing IDs.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#using-mappings","text":"using microsoft::quantum::BasicAllocationManager::Mappings = std::vector<AllocatedMemoryBlock>; Vector of memory segments.","title":"using Mappings"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#using-basicallocationmanagerptr","text":"using microsoft::quantum::BasicAllocationManager::BasicAllocationManagerPtr = std::shared_ptr<BasicAllocationManager>; Allocator pointer type.","title":"using BasicAllocationManagerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#function-createnew","text":"static BasicAllocationManagerPtr createNew() Creates a new allocation manager. The manager is kept as a shared pointer to enable allocation across different passes and/or replacement rules.","title":"function createNew"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#function-allocate","text":"virtual Address allocate( String const & name =\"\", Index const & count =1 ) override Reimplements : microsoft::quantum::IAllocationManager::allocate Allocates a possibly named segment of a given count. Calling allocate without and arguments allocates a single anonymous resource and returns the address. In case of a larger segment, the function returns the address pointing to the first element. Allocation is guaranteed to be sequential.","title":"function allocate"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#function-release","text":"virtual void release( Address const & address ) override Releases the segment by address. Reimplements : microsoft::quantum::IAllocationManager::release","title":"function release"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#function-reset","text":"virtual void reset() override Resets the allocation manager and all its statistics. Reimplements : microsoft::quantum::IAllocationManager::reset","title":"function reset"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#function-setreuseregisters","text":"void setReuseRegisters( bool val ) Configuration function to set mode of qubit allocation. If function argument is true, the allocation manager will reuse qubits. Updated on 28 October 2022 at 19:30:15 UTC","title":"function setReuseRegisters"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_block_pattern/","text":"microsoft::quantum::BasicBlockPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::BasicBlockPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_block_pattern/#microsoftquantumbasicblockpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::BasicBlockPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_block_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_block_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_block_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_block_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_block_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 28 October 2022 at 19:30:15 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_bit_cast_pattern/","text":"microsoft::quantum::BitCastPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::BitCastPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_bit_cast_pattern/#microsoftquantumbitcastpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::BitCastPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_bit_cast_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_bit_cast_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_bit_cast_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_bit_cast_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_bit_cast_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 28 October 2022 at 19:30:15 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_branch_pattern/","text":"microsoft::quantum::BranchPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::BranchPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_branch_pattern/#microsoftquantumbranchpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::BranchPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_branch_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_branch_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_branch_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_branch_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_branch_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 28 October 2022 at 19:30:15 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/","text":"microsoft::quantum::CallPattern Inherits from microsoft::quantum::IOperandPrototype Public Types Name using std::string String Public Functions Name CallPattern (String const & name) Construction by name. CallPattern ( CallPattern const & other) Copy construction prohibited. CallPattern ( CallPattern && other) =default Move construction allowed. ~CallPattern () override Destructor implementation. virtual bool match (Value * instr, Captures & captures) const override Matches the callee by name. virtual Child copy () const override Creates a copy of itself. Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Types Documentation using String using microsoft::quantum::CallPattern::String = std::string; Public Functions Documentation function CallPattern explicit CallPattern( String const & name ) Construction by name. function CallPattern CallPattern( CallPattern const & other ) Copy construction prohibited. function CallPattern CallPattern( CallPattern && other ) =default Move construction allowed. function ~CallPattern ~CallPattern() override Destructor implementation. function match virtual bool match( Value * instr, Captures & captures ) const override Matches the callee by name. Reimplements : microsoft::quantum::IOperandPrototype::match function copy virtual Child copy() const override Creates a copy of itself. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::CallPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#microsoftquantumcallpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::CallPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#public-types","text":"Name using std::string String","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#public-functions","text":"Name CallPattern (String const & name) Construction by name. CallPattern ( CallPattern const & other) Copy construction prohibited. CallPattern ( CallPattern && other) =default Move construction allowed. ~CallPattern () override Destructor implementation. virtual bool match (Value * instr, Captures & captures) const override Matches the callee by name. virtual Child copy () const override Creates a copy of itself.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#using-string","text":"using microsoft::quantum::CallPattern::String = std::string;","title":"using String"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#function-callpattern","text":"explicit CallPattern( String const & name ) Construction by name.","title":"function CallPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#function-callpattern_1","text":"CallPattern( CallPattern const & other ) Copy construction prohibited.","title":"function CallPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#function-callpattern_2","text":"CallPattern( CallPattern && other ) =default Move construction allowed.","title":"function CallPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#function-callpattern_3","text":"~CallPattern() override Destructor implementation.","title":"function ~CallPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#function-match","text":"virtual bool match( Value * instr, Captures & captures ) const override Matches the callee by name. Reimplements : microsoft::quantum::IOperandPrototype::match","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#function-copy","text":"virtual Child copy() const override Creates a copy of itself. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 28 October 2022 at 19:30:15 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/","text":"microsoft::quantum::CommentLogger Concrete ILogger implementation that prints all messages as IR comments to llvm::errs(). #include <Logging/CommentLogger.hpp> Inherits from microsoft::quantum::ILogger Public Functions Name virtual void debug (String const & message) override Adds a debug message to the list. virtual void info (String const & message) override Adds an info message to the list. virtual void warning (String const & message) override Adds a warning message to the list. virtual void error (String const & message) override Adds an error message to the list. virtual void internalError (String const & message) override Adds an internal error message to the list. virtual void setLocation ( SourceLocation const & loc) override Function that allows to set the current location. virtual void setLlvmHint (String const & value) override Sets the value of the LLVM instruction causing the issue. virtual void setFrontendHint (String const & value) override Sets the value of the frontend instruction causing the issue. Additional inherited members Public Classes inherited from microsoft::quantum::ILogger Name struct Location Class that holds the location of where the incident happened. struct Message Struct to hold a message together with its type and location. Public Types inherited from microsoft::quantum::ILogger Name enum class Type { Debug, Info, Warning, Error, InternalError} Enum description what type of information we are conveying. using llvm::Value Value using std::function< SourceLocation (Value const *)> LocationResolver using std::function< SourceLocation (String const &)> LocationFromNameResolver using std::shared_ptr< ILogger > ILoggerPtr using std::vector< Message > Messages List of messages defined as alias. Public Functions inherited from microsoft::quantum::ILogger Name ILogger () =default ILogger ( ILogger const & ) ILogger ( ILogger && ) ILogger & operator= ( ILogger const & ) ILogger & operator= ( ILogger && ) virtual ~ILogger () virtual Messages const & messages () const virtual void dump (std::ostream & out) const void setLocationFromValue (llvm::Value const * value) Sets the logger position based on a LLVM value. void setLocationFromFunctionName (String const & name) Sets the logger position based on function name. void setLocationResolver (LocationResolver const & r) Sets a resolver which that translates a LLVM value into a position in the source. void setLocationFromNameResolver (LocationFromNameResolver const & r) Sets a resolver which that translates function name into a position in the source. SourceLocation resolveLocation (llvm::Value const * value) Returns a source location from the value pointer (if possible) bool hadErrors () const Whether or not errors were logged. bool hadWarnings () const Whether or not warnings were logged. void errorWithLocation (String const & message, llvm::Value * ptr =nullptr) void warningWithLocation (String const & message, llvm::Value * ptr =nullptr) virtual void errorCouldNotDeleteNode (llvm::Value * ptr =nullptr) Standard messages. virtual void errorExpectedStraightLineCodeMultipleFunctions (llvm::Value * ptr =nullptr) virtual void errorExpectedStraightLineCodeMultipleBlocks (llvm::Value * ptr =nullptr) virtual void errorReleaseFailNonStandardAlloc (llvm::Value * ptr =nullptr) virtual void warningReleasePhiNodeQubit (llvm::Value * ptr =nullptr) virtual void errorFunctionInliningMaxRecursion (uint64_t n, llvm::Value * ptr =nullptr) virtual void errorNoQubitsPresent (llvm::Value * ptr =nullptr, String const & name =\"unnamed\") virtual void errorNoResultsPresent (llvm::Value * ptr =nullptr, String const & name =\"unnamed\") virtual void errorOpcodeNotAllowed (String const & code, String const & target_name, llvm::Value * ptr =nullptr) virtual void errorCustomFunctionsNotAllowed (llvm::Value * ptr =nullptr) virtual void errorExternalCallsNotAllowed (String const & function_name, String const & target_name, llvm::Value * ptr =nullptr) virtual void errorTypeNotAllowed (String const & type_name, String const & target_name, llvm::Value * ptr =nullptr) virtual void errorPoisonNotAllowed (String const & target_name, llvm::Value * ptr =nullptr) virtual void errorUndefNotAllowed (String const & target_name, llvm::Value * ptr =nullptr) virtual void errorExpectedStringValueForAttr (String const & function_name, String const & attr_name) virtual void warningWeakLinkReplacementNotPossible (String const & function_name, String const & replacement) virtual void errorReplacementSignatureMismatch (String const & function_name, String const & signature1, String const & signature2) Protected Functions inherited from microsoft::quantum::ILogger Name void setHasErrors (bool value) void setHasWarnings (bool value) Public Functions Documentation function debug virtual void debug( String const & message ) override Adds a debug message to the list. Reimplements : microsoft::quantum::ILogger::debug function info virtual void info( String const & message ) override Adds an info message to the list. Reimplements : microsoft::quantum::ILogger::info function warning virtual void warning( String const & message ) override Adds a warning message to the list. Reimplements : microsoft::quantum::ILogger::warning function error virtual void error( String const & message ) override Adds an error message to the list. Reimplements : microsoft::quantum::ILogger::error function internalError virtual void internalError( String const & message ) override Adds an internal error message to the list. Reimplements : microsoft::quantum::ILogger::internalError function setLocation virtual void setLocation( SourceLocation const & loc ) override Function that allows to set the current location. Reimplements : microsoft::quantum::ILogger::setLocation function setLlvmHint virtual void setLlvmHint( String const & value ) override Sets the value of the LLVM instruction causing the issue. Reimplements : microsoft::quantum::ILogger::setLlvmHint function setFrontendHint virtual void setFrontendHint( String const & value ) override Sets the value of the frontend instruction causing the issue. Reimplements : microsoft::quantum::ILogger::setFrontendHint Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::CommentLogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#microsoftquantumcommentlogger","text":"Concrete ILogger implementation that prints all messages as IR comments to llvm::errs(). #include <Logging/CommentLogger.hpp> Inherits from microsoft::quantum::ILogger","title":"microsoft::quantum::CommentLogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#public-functions","text":"Name virtual void debug (String const & message) override Adds a debug message to the list. virtual void info (String const & message) override Adds an info message to the list. virtual void warning (String const & message) override Adds a warning message to the list. virtual void error (String const & message) override Adds an error message to the list. virtual void internalError (String const & message) override Adds an internal error message to the list. virtual void setLocation ( SourceLocation const & loc) override Function that allows to set the current location. virtual void setLlvmHint (String const & value) override Sets the value of the LLVM instruction causing the issue. virtual void setFrontendHint (String const & value) override Sets the value of the frontend instruction causing the issue.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#additional-inherited-members","text":"Public Classes inherited from microsoft::quantum::ILogger Name struct Location Class that holds the location of where the incident happened. struct Message Struct to hold a message together with its type and location. Public Types inherited from microsoft::quantum::ILogger Name enum class Type { Debug, Info, Warning, Error, InternalError} Enum description what type of information we are conveying. using llvm::Value Value using std::function< SourceLocation (Value const *)> LocationResolver using std::function< SourceLocation (String const &)> LocationFromNameResolver using std::shared_ptr< ILogger > ILoggerPtr using std::vector< Message > Messages List of messages defined as alias. Public Functions inherited from microsoft::quantum::ILogger Name ILogger () =default ILogger ( ILogger const & ) ILogger ( ILogger && ) ILogger & operator= ( ILogger const & ) ILogger & operator= ( ILogger && ) virtual ~ILogger () virtual Messages const & messages () const virtual void dump (std::ostream & out) const void setLocationFromValue (llvm::Value const * value) Sets the logger position based on a LLVM value. void setLocationFromFunctionName (String const & name) Sets the logger position based on function name. void setLocationResolver (LocationResolver const & r) Sets a resolver which that translates a LLVM value into a position in the source. void setLocationFromNameResolver (LocationFromNameResolver const & r) Sets a resolver which that translates function name into a position in the source. SourceLocation resolveLocation (llvm::Value const * value) Returns a source location from the value pointer (if possible) bool hadErrors () const Whether or not errors were logged. bool hadWarnings () const Whether or not warnings were logged. void errorWithLocation (String const & message, llvm::Value * ptr =nullptr) void warningWithLocation (String const & message, llvm::Value * ptr =nullptr) virtual void errorCouldNotDeleteNode (llvm::Value * ptr =nullptr) Standard messages. virtual void errorExpectedStraightLineCodeMultipleFunctions (llvm::Value * ptr =nullptr) virtual void errorExpectedStraightLineCodeMultipleBlocks (llvm::Value * ptr =nullptr) virtual void errorReleaseFailNonStandardAlloc (llvm::Value * ptr =nullptr) virtual void warningReleasePhiNodeQubit (llvm::Value * ptr =nullptr) virtual void errorFunctionInliningMaxRecursion (uint64_t n, llvm::Value * ptr =nullptr) virtual void errorNoQubitsPresent (llvm::Value * ptr =nullptr, String const & name =\"unnamed\") virtual void errorNoResultsPresent (llvm::Value * ptr =nullptr, String const & name =\"unnamed\") virtual void errorOpcodeNotAllowed (String const & code, String const & target_name, llvm::Value * ptr =nullptr) virtual void errorCustomFunctionsNotAllowed (llvm::Value * ptr =nullptr) virtual void errorExternalCallsNotAllowed (String const & function_name, String const & target_name, llvm::Value * ptr =nullptr) virtual void errorTypeNotAllowed (String const & type_name, String const & target_name, llvm::Value * ptr =nullptr) virtual void errorPoisonNotAllowed (String const & target_name, llvm::Value * ptr =nullptr) virtual void errorUndefNotAllowed (String const & target_name, llvm::Value * ptr =nullptr) virtual void errorExpectedStringValueForAttr (String const & function_name, String const & attr_name) virtual void warningWeakLinkReplacementNotPossible (String const & function_name, String const & replacement) virtual void errorReplacementSignatureMismatch (String const & function_name, String const & signature1, String const & signature2) Protected Functions inherited from microsoft::quantum::ILogger Name void setHasErrors (bool value) void setHasWarnings (bool value)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-debug","text":"virtual void debug( String const & message ) override Adds a debug message to the list. Reimplements : microsoft::quantum::ILogger::debug","title":"function debug"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-info","text":"virtual void info( String const & message ) override Adds an info message to the list. Reimplements : microsoft::quantum::ILogger::info","title":"function info"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-warning","text":"virtual void warning( String const & message ) override Adds a warning message to the list. Reimplements : microsoft::quantum::ILogger::warning","title":"function warning"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-error","text":"virtual void error( String const & message ) override Adds an error message to the list. Reimplements : microsoft::quantum::ILogger::error","title":"function error"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-internalerror","text":"virtual void internalError( String const & message ) override Adds an internal error message to the list. Reimplements : microsoft::quantum::ILogger::internalError","title":"function internalError"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-setlocation","text":"virtual void setLocation( SourceLocation const & loc ) override Function that allows to set the current location. Reimplements : microsoft::quantum::ILogger::setLocation","title":"function setLocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-setllvmhint","text":"virtual void setLlvmHint( String const & value ) override Sets the value of the LLVM instruction causing the issue. Reimplements : microsoft::quantum::ILogger::setLlvmHint","title":"function setLlvmHint"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-setfrontendhint","text":"virtual void setFrontendHint( String const & value ) override Sets the value of the frontend instruction causing the issue. Reimplements : microsoft::quantum::ILogger::setFrontendHint Updated on 28 October 2022 at 19:30:15 UTC","title":"function setFrontendHint"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/","text":"microsoft::quantum::ConfigBind More... #include <Commandline/ConfigBind.hpp> Inherits from microsoft::quantum::IConfigBind Public Types Name using typename std::decay< T >::type Type using std::unordered_set< std::string > StringSet using std::vector< std::string > StringList template <typename A ,typename B ,typename R > using typename std::enable_if< std::is_same< A, B >:: value , R >::type EnableIf Helper template to conditionally disable implementation unless a specific type is used. Public Functions Name ConfigBind () ConfigBind ( ConfigBind const & ) ConfigBind ( ConfigBind && ) ConfigBind & operator= ( ConfigBind const & ) ConfigBind & operator= ( ConfigBind && ) ~ConfigBind () override =default ConfigBind (Type & bind, T default_value, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig) void markAsExperimental (Type const & off_value) virtual bool setupArguments ( ParameterParser & parser) override Adds the argument to the parser. virtual bool configure ( ParameterParser & parser, bool experimental_mode) override virtual void reset () override Resets the current value to the default value. virtual String value () override String representation of the bound value. virtual void * pointer () const override Pointer to underlying data. virtual void * pointerDefaultValue () override Pointer to underlying default value. virtual std::type_index valueType () const override Type index of contained data. virtual void setValueFromYamlNode (YAML::Node const & node) override Method to load value from YAML configuration. virtual void updateValueInYamlNode (YAML::Node & node) override Dumps the current value to the node. template <typename R > ConfigBind < T >::template EnableIfNotSerializable< R, void > alterNameBasedOnType (R const & default_value) template <typename R > ConfigBind < T >::template EnableIfSerializable< R, void > alterNameBasedOnType (R const & ) template <typename A > ConfigBind < T >::template EnableIfNotSerializable< A, String > valueAsString (A const & val) template <typename A > ConfigBind < T >::template EnableIfSerializable< A, String > valueAsString (A const & ) template <typename A > ConfigBind < T >::template EnableIfNotSerializable< A, void > loadValue ( ParameterParser & parser, A const & ) template <typename A > ConfigBind < T >::template EnableIfSerializable< A, void > loadValue ( ParameterParser & parser, A const & ) template <typename R > ConfigBind < T >::template EnableIfNotSerializable< R, void > loadYaml (YAML::Node const & node, R & value) template <typename R > ConfigBind < T >::template EnableIfNotSerializable< R, void > saveYaml (YAML::Node & node, R const & value) template <typename R > ConfigBind < T >::template EnableIfSerializable< R, void > loadYaml (YAML::Node const & node, R & value) template <typename R > ConfigBind < T >::template EnableIfSerializable< R, void > saveYaml (YAML::Node & node, R const & value) Additional inherited members Public Types inherited from microsoft::quantum::IConfigBind Name enum ParameterVisibility { None, CliOnly, ConfigOnly, CliAndConfig} Public Functions inherited from microsoft::quantum::IConfigBind Name IConfigBind ( IConfigBind const & ) IConfigBind ( IConfigBind && ) virtual ~IConfigBind () String name () const Returns the name of the bound configuration variable. String description () const Returns the description of the configuration variable. bool isFlag () const Indicates whether or not this. String defaultValue () const Returns the default value for the flag. bool isExperimental () const Indicates whether or not this is an experimental config. bool isLoadAndSavable () const bool isAvailableToCli () const Indicates whether or not this paramter is available to the CLI. void setShorthandNotation (String const & name) Set shorthand notation. String shorthandNotation () const Gets shorthand notation. Protected Functions inherited from microsoft::quantum::IConfigBind Name IConfigBind (String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig) void setName (String const & name) Sets the name of the configuration variable. void markAsFlag () Marks the variable as a flag. void setDefault (String const & v) Sets the default value as a string. void makeSettingExperimental () Marks the config as experimental. Detailed Description template <typename T > class microsoft::quantum::ConfigBind; Generic implementation of the bind interface for different types. This class holds the name of the command line parameter and a reference variable corresponding to it. It implements serializers and deserializers to allow transforming strings to native values and vice versa. Public Types Documentation using Type using microsoft::quantum::ConfigBind< T >::Type = typename std::decay<T>::type; using StringSet using microsoft::quantum::ConfigBind< T >::StringSet = std::unordered_set<std::string>; using StringList using microsoft::quantum::ConfigBind< T >::StringList = std::vector<std::string>; using EnableIf template <typename A , typename B , typename R > using microsoft::quantum::ConfigBind< T >::EnableIf = typename std::enable_if<std::is_same<A, B>::value, R>::type; Helper template to conditionally disable implementation unless a specific type is used. Public Functions Documentation function ConfigBind ConfigBind() function ConfigBind ConfigBind( ConfigBind const & ) function ConfigBind ConfigBind( ConfigBind && ) function operator= ConfigBind & operator=( ConfigBind const & ) function operator= ConfigBind & operator=( ConfigBind && ) function ~ConfigBind ~ConfigBind() override =default function ConfigBind ConfigBind( Type & bind, T default_value, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig ) Constructor to bind value to parameter. This class holds a reference to a variable together with the name it is expected to have when passed through the parameter parser. function markAsExperimental void markAsExperimental( Type const & off_value ) function setupArguments virtual bool setupArguments( ParameterParser & parser ) override Adds the argument to the parser. Reimplements : microsoft::quantum::IConfigBind::setupArguments function configure virtual bool configure( ParameterParser & parser, bool experimental_mode ) override Reimplements : microsoft::quantum::IConfigBind::configure Configures the bound value. This method examines the parsed input and use updates the bound value accordingly. function reset virtual void reset() override Resets the current value to the default value. Reimplements : microsoft::quantum::IConfigBind::reset function value virtual String value() override String representation of the bound value. Reimplements : microsoft::quantum::IConfigBind::value function pointer virtual void * pointer() const override Pointer to underlying data. Reimplements : microsoft::quantum::IConfigBind::pointer function pointerDefaultValue virtual void * pointerDefaultValue() override Pointer to underlying default value. Reimplements : microsoft::quantum::IConfigBind::pointerDefaultValue function valueType virtual std::type_index valueType() const override Type index of contained data. Reimplements : microsoft::quantum::IConfigBind::valueType function setValueFromYamlNode virtual void setValueFromYamlNode( YAML::Node const & node ) override Method to load value from YAML configuration. Reimplements : microsoft::quantum::IConfigBind::setValueFromYamlNode function updateValueInYamlNode virtual void updateValueInYamlNode( YAML::Node & node ) override Dumps the current value to the node. Reimplements : microsoft::quantum::IConfigBind::updateValueInYamlNode function alterNameBasedOnType template <typename R > ConfigBind< T >::template EnableIfNotSerializable< R, void > alterNameBasedOnType( R const & default_value ) function alterNameBasedOnType template <typename R > ConfigBind< T >::template EnableIfSerializable< R, void > alterNameBasedOnType( R const & ) function valueAsString template <typename A > ConfigBind< T >::template EnableIfNotSerializable< A, String > valueAsString( A const & val ) function valueAsString template <typename A > ConfigBind< T >::template EnableIfSerializable< A, String > valueAsString( A const & ) function loadValue template <typename A > ConfigBind< T >::template EnableIfNotSerializable< A, void > loadValue( ParameterParser & parser, A const & ) function loadValue template <typename A > ConfigBind< T >::template EnableIfSerializable< A, void > loadValue( ParameterParser & parser, A const & ) function loadYaml template <typename R > ConfigBind< T >::template EnableIfNotSerializable< R, void > loadYaml( YAML::Node const & node, R & value ) function saveYaml template <typename R > ConfigBind< T >::template EnableIfNotSerializable< R, void > saveYaml( YAML::Node & node, R const & value ) function loadYaml template <typename R > ConfigBind< T >::template EnableIfSerializable< R, void > loadYaml( YAML::Node const & node, R & value ) function saveYaml template <typename R > ConfigBind< T >::template EnableIfSerializable< R, void > saveYaml( YAML::Node & node, R const & value ) Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::ConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#microsoftquantumconfigbind","text":"More... #include <Commandline/ConfigBind.hpp> Inherits from microsoft::quantum::IConfigBind","title":"microsoft::quantum::ConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#public-types","text":"Name using typename std::decay< T >::type Type using std::unordered_set< std::string > StringSet using std::vector< std::string > StringList template <typename A ,typename B ,typename R > using typename std::enable_if< std::is_same< A, B >:: value , R >::type EnableIf Helper template to conditionally disable implementation unless a specific type is used.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#public-functions","text":"Name ConfigBind () ConfigBind ( ConfigBind const & ) ConfigBind ( ConfigBind && ) ConfigBind & operator= ( ConfigBind const & ) ConfigBind & operator= ( ConfigBind && ) ~ConfigBind () override =default ConfigBind (Type & bind, T default_value, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig) void markAsExperimental (Type const & off_value) virtual bool setupArguments ( ParameterParser & parser) override Adds the argument to the parser. virtual bool configure ( ParameterParser & parser, bool experimental_mode) override virtual void reset () override Resets the current value to the default value. virtual String value () override String representation of the bound value. virtual void * pointer () const override Pointer to underlying data. virtual void * pointerDefaultValue () override Pointer to underlying default value. virtual std::type_index valueType () const override Type index of contained data. virtual void setValueFromYamlNode (YAML::Node const & node) override Method to load value from YAML configuration. virtual void updateValueInYamlNode (YAML::Node & node) override Dumps the current value to the node. template <typename R > ConfigBind < T >::template EnableIfNotSerializable< R, void > alterNameBasedOnType (R const & default_value) template <typename R > ConfigBind < T >::template EnableIfSerializable< R, void > alterNameBasedOnType (R const & ) template <typename A > ConfigBind < T >::template EnableIfNotSerializable< A, String > valueAsString (A const & val) template <typename A > ConfigBind < T >::template EnableIfSerializable< A, String > valueAsString (A const & ) template <typename A > ConfigBind < T >::template EnableIfNotSerializable< A, void > loadValue ( ParameterParser & parser, A const & ) template <typename A > ConfigBind < T >::template EnableIfSerializable< A, void > loadValue ( ParameterParser & parser, A const & ) template <typename R > ConfigBind < T >::template EnableIfNotSerializable< R, void > loadYaml (YAML::Node const & node, R & value) template <typename R > ConfigBind < T >::template EnableIfNotSerializable< R, void > saveYaml (YAML::Node & node, R const & value) template <typename R > ConfigBind < T >::template EnableIfSerializable< R, void > loadYaml (YAML::Node const & node, R & value) template <typename R > ConfigBind < T >::template EnableIfSerializable< R, void > saveYaml (YAML::Node & node, R const & value)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IConfigBind Name enum ParameterVisibility { None, CliOnly, ConfigOnly, CliAndConfig} Public Functions inherited from microsoft::quantum::IConfigBind Name IConfigBind ( IConfigBind const & ) IConfigBind ( IConfigBind && ) virtual ~IConfigBind () String name () const Returns the name of the bound configuration variable. String description () const Returns the description of the configuration variable. bool isFlag () const Indicates whether or not this. String defaultValue () const Returns the default value for the flag. bool isExperimental () const Indicates whether or not this is an experimental config. bool isLoadAndSavable () const bool isAvailableToCli () const Indicates whether or not this paramter is available to the CLI. void setShorthandNotation (String const & name) Set shorthand notation. String shorthandNotation () const Gets shorthand notation. Protected Functions inherited from microsoft::quantum::IConfigBind Name IConfigBind (String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig) void setName (String const & name) Sets the name of the configuration variable. void markAsFlag () Marks the variable as a flag. void setDefault (String const & v) Sets the default value as a string. void makeSettingExperimental () Marks the config as experimental.","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#detailed-description","text":"template <typename T > class microsoft::quantum::ConfigBind; Generic implementation of the bind interface for different types. This class holds the name of the command line parameter and a reference variable corresponding to it. It implements serializers and deserializers to allow transforming strings to native values and vice versa.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#using-type","text":"using microsoft::quantum::ConfigBind< T >::Type = typename std::decay<T>::type;","title":"using Type"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#using-stringset","text":"using microsoft::quantum::ConfigBind< T >::StringSet = std::unordered_set<std::string>;","title":"using StringSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#using-stringlist","text":"using microsoft::quantum::ConfigBind< T >::StringList = std::vector<std::string>;","title":"using StringList"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#using-enableif","text":"template <typename A , typename B , typename R > using microsoft::quantum::ConfigBind< T >::EnableIf = typename std::enable_if<std::is_same<A, B>::value, R>::type; Helper template to conditionally disable implementation unless a specific type is used.","title":"using EnableIf"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-configbind","text":"ConfigBind()","title":"function ConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-configbind_1","text":"ConfigBind( ConfigBind const & )","title":"function ConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-configbind_2","text":"ConfigBind( ConfigBind && )","title":"function ConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-operator","text":"ConfigBind & operator=( ConfigBind const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-operator_1","text":"ConfigBind & operator=( ConfigBind && )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-configbind_3","text":"~ConfigBind() override =default","title":"function ~ConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-configbind_4","text":"ConfigBind( Type & bind, T default_value, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig ) Constructor to bind value to parameter. This class holds a reference to a variable together with the name it is expected to have when passed through the parameter parser.","title":"function ConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-markasexperimental","text":"void markAsExperimental( Type const & off_value )","title":"function markAsExperimental"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-setuparguments","text":"virtual bool setupArguments( ParameterParser & parser ) override Adds the argument to the parser. Reimplements : microsoft::quantum::IConfigBind::setupArguments","title":"function setupArguments"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-configure","text":"virtual bool configure( ParameterParser & parser, bool experimental_mode ) override Reimplements : microsoft::quantum::IConfigBind::configure Configures the bound value. This method examines the parsed input and use updates the bound value accordingly.","title":"function configure"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-reset","text":"virtual void reset() override Resets the current value to the default value. Reimplements : microsoft::quantum::IConfigBind::reset","title":"function reset"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-value","text":"virtual String value() override String representation of the bound value. Reimplements : microsoft::quantum::IConfigBind::value","title":"function value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-pointer","text":"virtual void * pointer() const override Pointer to underlying data. Reimplements : microsoft::quantum::IConfigBind::pointer","title":"function pointer"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-pointerdefaultvalue","text":"virtual void * pointerDefaultValue() override Pointer to underlying default value. Reimplements : microsoft::quantum::IConfigBind::pointerDefaultValue","title":"function pointerDefaultValue"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-valuetype","text":"virtual std::type_index valueType() const override Type index of contained data. Reimplements : microsoft::quantum::IConfigBind::valueType","title":"function valueType"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-setvaluefromyamlnode","text":"virtual void setValueFromYamlNode( YAML::Node const & node ) override Method to load value from YAML configuration. Reimplements : microsoft::quantum::IConfigBind::setValueFromYamlNode","title":"function setValueFromYamlNode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-updatevalueinyamlnode","text":"virtual void updateValueInYamlNode( YAML::Node & node ) override Dumps the current value to the node. Reimplements : microsoft::quantum::IConfigBind::updateValueInYamlNode","title":"function updateValueInYamlNode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-alternamebasedontype","text":"template <typename R > ConfigBind< T >::template EnableIfNotSerializable< R, void > alterNameBasedOnType( R const & default_value )","title":"function alterNameBasedOnType"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-alternamebasedontype_1","text":"template <typename R > ConfigBind< T >::template EnableIfSerializable< R, void > alterNameBasedOnType( R const & )","title":"function alterNameBasedOnType"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-valueasstring","text":"template <typename A > ConfigBind< T >::template EnableIfNotSerializable< A, String > valueAsString( A const & val )","title":"function valueAsString"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-valueasstring_1","text":"template <typename A > ConfigBind< T >::template EnableIfSerializable< A, String > valueAsString( A const & )","title":"function valueAsString"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-loadvalue","text":"template <typename A > ConfigBind< T >::template EnableIfNotSerializable< A, void > loadValue( ParameterParser & parser, A const & )","title":"function loadValue"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-loadvalue_1","text":"template <typename A > ConfigBind< T >::template EnableIfSerializable< A, void > loadValue( ParameterParser & parser, A const & )","title":"function loadValue"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-loadyaml","text":"template <typename R > ConfigBind< T >::template EnableIfNotSerializable< R, void > loadYaml( YAML::Node const & node, R & value )","title":"function loadYaml"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-saveyaml","text":"template <typename R > ConfigBind< T >::template EnableIfNotSerializable< R, void > saveYaml( YAML::Node & node, R const & value )","title":"function saveYaml"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-loadyaml_1","text":"template <typename R > ConfigBind< T >::template EnableIfSerializable< R, void > loadYaml( YAML::Node const & node, R & value )","title":"function loadYaml"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-saveyaml_1","text":"template <typename R > ConfigBind< T >::template EnableIfSerializable< R, void > saveYaml( YAML::Node & node, R const & value ) Updated on 28 October 2022 at 19:30:15 UTC","title":"function saveYaml"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_qir_adaptor_factory/","text":"microsoft::quantum::ConfigurableQirAdaptorFactory More... #include <AdaptorFactory/ConfigurableQirAdaptorFactory.hpp> Inherits from microsoft::quantum::QirAdaptorFactory Public Types Name enum class SetupMode { DoNothing, SetupPipeline} using std::function< void( RuleSet &)> ConfigureFunction Function type that configures a rule set. Public Functions Name ConfigurableQirAdaptorFactory ( ConfigurationManager & configuration_manager, SetupMode const & mode =SetupMode::SetupPipeline) ConfigurableQirAdaptorFactory ( ConfigurationManager & configuration_manager, ConfigureFunction const & configure, TargetQisMappingPassConfiguration const & adaptor_pass_config = TargetQisMappingPassConfiguration::createDisabled (), LlvmPassesConfiguration const & llvm_config = LlvmPassesConfiguration::createDisabled ()) TargetQisMappingPassConfiguration const & ruleTransformationConfig () const Returns a constant reference to the rule transformation configuration. LlvmPassesConfiguration const & llvmPassesConfig () const Returns a constant reference to the LLVM passes configuration. Additional inherited members Public Types inherited from microsoft::quantum::QirAdaptorFactory Name using llvm::PassBuilder PassBuilder using llvm::OptimizationLevel OptimizationLevel using llvm::FunctionAnalysisManager FunctionAnalysisManager using std::shared_ptr< QirAdaptor > QirAdaptorPtr using std::shared_ptr< BasicAllocationManager > BasicAllocationManagerPtr using llvm::FunctionPassManager FunctionPassManager template <typename R > using std::function< void(R const &, QirAdaptor &)> SetupFunction using std::function< void( QirAdaptorFactory &, QirAdaptor &)> SetupFunctionWrapper Wrapper function type for invoking the adaptor setup function. using std::vector< std::pair< String, SetupFunctionWrapper > > Components List of components to be configured. using ILogger::ILoggerPtr ILoggerPtr Public Functions inherited from microsoft::quantum::QirAdaptorFactory Name QirAdaptorFactory ( ConfigurationManager & configuration_manager) ~QirAdaptorFactory () =default QirAdaptorFactory ( QirAdaptorFactory const & ) QirAdaptorFactory ( QirAdaptorFactory && ) QirAdaptorFactory & operator= ( QirAdaptorFactory const & ) QirAdaptorFactory & operator= ( QirAdaptorFactory && ) ConfigurationManager & configurationManager () ConfigurationManager const & configurationManager () const QirAdaptorPtr newQirAdaptor (String const & name, OptimizationLevel const & optimization_level, bool debug) void newAdaptorContext (String const & name, bool debug =false) Prepares a new adaptor context. void addComponent (String const & name) Adds a component to the current context. QirAdaptorPtr finalizeAdaptor () Finalizes the context and returns the QIR adaptor. template <typename R > void registerAdaptorComponent (String const & id, SetupFunction < R > setup) template <typename R > void replaceAdaptorComponent (String const & id, SetupFunction < R > setup) template <typename R > void registerAnonymousAdaptorComponent ( SetupFunction < R > setup) void replicateAdaptorComponent (String const & id) bool isDebugMode () const Flag indicating whether we are operating in debug mode or not. void setupDefaultComponentPipeline () Sets the default pipeline up. void setLogger (ILoggerPtr const & logger =nullptr) Protected Functions inherited from microsoft::quantum::QirAdaptorFactory Name llvm::ModulePassManager createValidationModulePass (PassBuilder & pass_builder, OptimizationLevel const & optimization_level, bool debug) Detailed Description class microsoft::quantum::ConfigurableQirAdaptorFactory; ConfigurableQirAdaptorFactory defines a adaptor that configures the rule set used by the QirAdaptor pass. This adaptor is useful for generating dynamic adaptors and is well suited for testing purposes or YAML configured transformation of the IR. Public Types Documentation enum SetupMode Enumerator Value Description DoNothing SetupPipeline using ConfigureFunction using microsoft::quantum::ConfigurableQirAdaptorFactory::ConfigureFunction = std::function<void(RuleSet&)>; Function type that configures a rule set. Public Functions Documentation function ConfigurableQirAdaptorFactory explicit ConfigurableQirAdaptorFactory( ConfigurationManager & configuration_manager, SetupMode const & mode =SetupMode::SetupPipeline ) Default constructor. This constructor adds components for rule transformation and LLVM passes. These are configurable through the corresponding configuration classes which can be access through the configuration manager. function ConfigurableQirAdaptorFactory explicit ConfigurableQirAdaptorFactory( ConfigurationManager & configuration_manager, ConfigureFunction const & configure, TargetQisMappingPassConfiguration const & adaptor_pass_config =TargetQisMappingPassConfiguration::createDisabled(), LlvmPassesConfiguration const & llvm_config =LlvmPassesConfiguration::createDisabled() ) The constructor takes a lambda function which configures the rule set. This function is invoked during the creation of the generation module. This constructor further overrides the default configuration function ruleTransformationConfig TargetQisMappingPassConfiguration const & ruleTransformationConfig() const Returns a constant reference to the rule transformation configuration. function llvmPassesConfig LlvmPassesConfiguration const & llvmPassesConfig() const Returns a constant reference to the LLVM passes configuration. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::ConfigurableQirAdaptorFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_qir_adaptor_factory/#microsoftquantumconfigurableqiradaptorfactory","text":"More... #include <AdaptorFactory/ConfigurableQirAdaptorFactory.hpp> Inherits from microsoft::quantum::QirAdaptorFactory","title":"microsoft::quantum::ConfigurableQirAdaptorFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_qir_adaptor_factory/#public-types","text":"Name enum class SetupMode { DoNothing, SetupPipeline} using std::function< void( RuleSet &)> ConfigureFunction Function type that configures a rule set.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_qir_adaptor_factory/#public-functions","text":"Name ConfigurableQirAdaptorFactory ( ConfigurationManager & configuration_manager, SetupMode const & mode =SetupMode::SetupPipeline) ConfigurableQirAdaptorFactory ( ConfigurationManager & configuration_manager, ConfigureFunction const & configure, TargetQisMappingPassConfiguration const & adaptor_pass_config = TargetQisMappingPassConfiguration::createDisabled (), LlvmPassesConfiguration const & llvm_config = LlvmPassesConfiguration::createDisabled ()) TargetQisMappingPassConfiguration const & ruleTransformationConfig () const Returns a constant reference to the rule transformation configuration. LlvmPassesConfiguration const & llvmPassesConfig () const Returns a constant reference to the LLVM passes configuration.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_qir_adaptor_factory/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::QirAdaptorFactory Name using llvm::PassBuilder PassBuilder using llvm::OptimizationLevel OptimizationLevel using llvm::FunctionAnalysisManager FunctionAnalysisManager using std::shared_ptr< QirAdaptor > QirAdaptorPtr using std::shared_ptr< BasicAllocationManager > BasicAllocationManagerPtr using llvm::FunctionPassManager FunctionPassManager template <typename R > using std::function< void(R const &, QirAdaptor &)> SetupFunction using std::function< void( QirAdaptorFactory &, QirAdaptor &)> SetupFunctionWrapper Wrapper function type for invoking the adaptor setup function. using std::vector< std::pair< String, SetupFunctionWrapper > > Components List of components to be configured. using ILogger::ILoggerPtr ILoggerPtr Public Functions inherited from microsoft::quantum::QirAdaptorFactory Name QirAdaptorFactory ( ConfigurationManager & configuration_manager) ~QirAdaptorFactory () =default QirAdaptorFactory ( QirAdaptorFactory const & ) QirAdaptorFactory ( QirAdaptorFactory && ) QirAdaptorFactory & operator= ( QirAdaptorFactory const & ) QirAdaptorFactory & operator= ( QirAdaptorFactory && ) ConfigurationManager & configurationManager () ConfigurationManager const & configurationManager () const QirAdaptorPtr newQirAdaptor (String const & name, OptimizationLevel const & optimization_level, bool debug) void newAdaptorContext (String const & name, bool debug =false) Prepares a new adaptor context. void addComponent (String const & name) Adds a component to the current context. QirAdaptorPtr finalizeAdaptor () Finalizes the context and returns the QIR adaptor. template <typename R > void registerAdaptorComponent (String const & id, SetupFunction < R > setup) template <typename R > void replaceAdaptorComponent (String const & id, SetupFunction < R > setup) template <typename R > void registerAnonymousAdaptorComponent ( SetupFunction < R > setup) void replicateAdaptorComponent (String const & id) bool isDebugMode () const Flag indicating whether we are operating in debug mode or not. void setupDefaultComponentPipeline () Sets the default pipeline up. void setLogger (ILoggerPtr const & logger =nullptr) Protected Functions inherited from microsoft::quantum::QirAdaptorFactory Name llvm::ModulePassManager createValidationModulePass (PassBuilder & pass_builder, OptimizationLevel const & optimization_level, bool debug)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_qir_adaptor_factory/#detailed-description","text":"class microsoft::quantum::ConfigurableQirAdaptorFactory; ConfigurableQirAdaptorFactory defines a adaptor that configures the rule set used by the QirAdaptor pass. This adaptor is useful for generating dynamic adaptors and is well suited for testing purposes or YAML configured transformation of the IR.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_qir_adaptor_factory/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_qir_adaptor_factory/#enum-setupmode","text":"Enumerator Value Description DoNothing SetupPipeline","title":"enum SetupMode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_qir_adaptor_factory/#using-configurefunction","text":"using microsoft::quantum::ConfigurableQirAdaptorFactory::ConfigureFunction = std::function<void(RuleSet&)>; Function type that configures a rule set.","title":"using ConfigureFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_qir_adaptor_factory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_qir_adaptor_factory/#function-configurableqiradaptorfactory","text":"explicit ConfigurableQirAdaptorFactory( ConfigurationManager & configuration_manager, SetupMode const & mode =SetupMode::SetupPipeline ) Default constructor. This constructor adds components for rule transformation and LLVM passes. These are configurable through the corresponding configuration classes which can be access through the configuration manager.","title":"function ConfigurableQirAdaptorFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_qir_adaptor_factory/#function-configurableqiradaptorfactory_1","text":"explicit ConfigurableQirAdaptorFactory( ConfigurationManager & configuration_manager, ConfigureFunction const & configure, TargetQisMappingPassConfiguration const & adaptor_pass_config =TargetQisMappingPassConfiguration::createDisabled(), LlvmPassesConfiguration const & llvm_config =LlvmPassesConfiguration::createDisabled() ) The constructor takes a lambda function which configures the rule set. This function is invoked during the creation of the generation module. This constructor further overrides the default configuration","title":"function ConfigurableQirAdaptorFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_qir_adaptor_factory/#function-ruletransformationconfig","text":"TargetQisMappingPassConfiguration const & ruleTransformationConfig() const Returns a constant reference to the rule transformation configuration.","title":"function ruleTransformationConfig"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_qir_adaptor_factory/#function-llvmpassesconfig","text":"LlvmPassesConfiguration const & llvmPassesConfig() const Returns a constant reference to the LLVM passes configuration. Updated on 28 October 2022 at 19:30:15 UTC","title":"function llvmPassesConfig"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/","text":"microsoft::quantum::ConfigurationManager More... #include <Commandline/ConfigurationManager.hpp> Public Classes Name struct Section Public Types Name using std::shared_ptr< IConfigBind > IConfigBindPtr Pointer class used to bind a parameter to a value. using std::vector< IConfigBindPtr > ConfigList List of bound variables. using std::shared_ptr< void > VoidPtr Type-erased configuration pointer. using std::type_index TypeId Type index class. using std::shared_ptr< bool > BoolPtr using std::unordered_map< String, IConfigBindPtr > Parameters using DeferredValue::DeferredValuePtr DeferredValuePtr using std::unordered_map< String, DeferredValuePtr > DeferredRefs using IConfigBind::ParameterVisibility ParameterVisibility using std::vector< Section > Sections List of available sections. Public Functions Name ConfigurationManager () Configuration manager is default constructible, non-copyable and non-movable. ConfigurationManager ( ConfigurationManager const & ) ConfigurationManager ( ConfigurationManager && ) ConfigurationManager & operator= ( ConfigurationManager const & ) ConfigurationManager & operator= ( ConfigurationManager && ) ~ConfigurationManager () void setupArguments ( ParameterParser & parser) Adds all bound variables as parser arguments. void configure ( ParameterParser & parser, bool experimental_mode =false) Configures the value of each bound variable given a parser instance. template <typename T > void setConfig (T const & value) Given an instance of the ConfigurationManager , this method override settings of class T. template <typename T > T const & get () const Gets the configuration instance of type T. void printHelp (bool experimental_mode) const Prints options for configurability to the terminal. void printConfiguration () const template <typename T > void addConfig (String const & id =\"\", T const & default_value =T()) Adds a new configuration of type T. template <typename T > bool configWasRegistered () Whether or not a configuration of type previously registered. template <typename T > bool isActive () Whether or not the component associated with T is active. void setSectionName (String const & name, String const & description) void disableSectionByDefault () Disables the last section added to the manager. void disableSectionById (String const & id) Disables a named section. void enableSectionById (String const & id) Enables a named section. void allowDisableSectionById (String const & id) Allow disabling the full section. template <typename T > void addParameter (T & bind, T default_value, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig) void addShorthandNotation (String const & parameter, String const & shorthand) template <typename T > void addParameter (T & bind, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig) template <typename T > void addExperimentalParameter (T & bind, T default_value, T off_value, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig) template <typename T > void addExperimentalParameter (T & bind, T default_value, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig) template <typename T > void addExperimentalParameter (T & bind, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig) DeferredValuePtr getParameter (String const & name) template <typename T > bool has () const Checks whether a configuration section exists. template <typename T > void updateParameter (String const & name, T const & value) void loadConfig (String const & filename) Loads a configuration file. void saveConfig (String const & filename) Saves the configuration to the specified file. Detailed Description class microsoft::quantum::ConfigurationManager; ConfigurationManager is a class that holds a collection of configurations (sections). Each of these sections are embodied in their own class with a one-to-one mapping between configuration section and the configuration type. As an example, if one wishes to make a configuration for the class Foo, one would create a class FooConfig which would hold all the variables that are configurable and then add FooConfig to the ConfigurationManager using [addConfig()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addconfig) . For FooConfig to fulfill the concept of a configuration, it must implement a setup functions whose first argument is the ConfigurationManager . Public Types Documentation using IConfigBindPtr using microsoft::quantum::ConfigurationManager::IConfigBindPtr = std::shared_ptr<IConfigBind>; Pointer class used to bind a parameter to a value. using ConfigList using microsoft::quantum::ConfigurationManager::ConfigList = std::vector<IConfigBindPtr>; List of bound variables. using VoidPtr using microsoft::quantum::ConfigurationManager::VoidPtr = std::shared_ptr<void>; Type-erased configuration pointer. using TypeId using microsoft::quantum::ConfigurationManager::TypeId = std::type_index; Type index class. using BoolPtr using microsoft::quantum::ConfigurationManager::BoolPtr = std::shared_ptr<bool>; using Parameters using microsoft::quantum::ConfigurationManager::Parameters = std::unordered_map<String, IConfigBindPtr>; using DeferredValuePtr using microsoft::quantum::ConfigurationManager::DeferredValuePtr = DeferredValue::DeferredValuePtr; using DeferredRefs using microsoft::quantum::ConfigurationManager::DeferredRefs = std::unordered_map<String, DeferredValuePtr>; using ParameterVisibility using microsoft::quantum::ConfigurationManager::ParameterVisibility = IConfigBind::ParameterVisibility; using Sections using microsoft::quantum::ConfigurationManager::Sections = std::vector<Section>; List of available sections. Public Functions Documentation function ConfigurationManager ConfigurationManager() Configuration manager is default constructible, non-copyable and non-movable. function ConfigurationManager ConfigurationManager( ConfigurationManager const & ) function ConfigurationManager ConfigurationManager( ConfigurationManager && ) function operator= ConfigurationManager & operator=( ConfigurationManager const & ) function operator= ConfigurationManager & operator=( ConfigurationManager && ) function ~ConfigurationManager inline ~ConfigurationManager() function setupArguments void setupArguments( ParameterParser & parser ) Adds all bound variables as parser arguments. function configure void configure( ParameterParser & parser, bool experimental_mode =false ) Configures the value of each bound variable given a parser instance. function setConfig template <typename T > inline void setConfig( T const & value ) Given an instance of the ConfigurationManager , this method override settings of class T. function get template <typename T > inline T const & get() const Gets the configuration instance of type T. function printHelp void printHelp( bool experimental_mode ) const Prints options for configurability to the terminal. function printConfiguration void printConfiguration() const Prints the configuration to the terminal. The configuration print is LLVM IR compatible meaning that every line starts with a semicolon ; to ensure that it is interpreted as a comment. function addConfig template <typename T > inline void addConfig( String const & id =\"\", T const & default_value =T() ) Adds a new configuration of type T. function configWasRegistered template <typename T > inline bool configWasRegistered() Whether or not a configuration of type previously registered. function isActive template <typename T > inline bool isActive() Whether or not the component associated with T is active. function setSectionName void setSectionName( String const & name, String const & description ) Sets the section name. This method is used by the configuration class to set a section name. function disableSectionByDefault void disableSectionByDefault() Disables the last section added to the manager. function disableSectionById void disableSectionById( String const & id ) Disables a named section. function enableSectionById void enableSectionById( String const & id ) Enables a named section. function allowDisableSectionById void allowDisableSectionById( String const & id ) Allow disabling the full section. function addParameter template <typename T > inline void addParameter( T & bind, T default_value, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig ) Adds a new parameter with a default value to the configuration section. This function should be used by the configuration class. function addShorthandNotation void addShorthandNotation( String const & parameter, String const & shorthand ) function addParameter template <typename T > inline void addParameter( T & bind, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig ) Adds a new parameter to the configuration section. This method uses the bound variable value as default value. This function should be used by the configuration class. function addExperimentalParameter template <typename T > inline void addExperimentalParameter( T & bind, T default_value, T off_value, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig ) Adds an experimental parameter with a default value and an experimental \"off\" value to the configuration section. This function should be used by the configuration class. The difference to addParameter is that this function marks the parameter as experimental and has a default \"off\" value function addExperimentalParameter template <typename T > inline void addExperimentalParameter( T & bind, T default_value, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig ) Adds an experimental parameter with a default value to the configuration section. The experimental off value will be set to the default value of parameter. This function should be used by the configuration class. function addExperimentalParameter template <typename T > inline void addExperimentalParameter( T & bind, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig ) Adds an experimental parameter. The default value and the experimental off value will be the value of the parameter added. This function should be used by the configuration class. function getParameter DeferredValuePtr getParameter( String const & name ) function has template <typename T > inline bool has() const Checks whether a configuration section exists. function updateParameter template <typename T > inline void updateParameter( String const & name, T const & value ) function loadConfig void loadConfig( String const & filename ) Loads a configuration file. function saveConfig void saveConfig( String const & filename ) Saves the configuration to the specified file. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::ConfigurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#microsoftquantumconfigurationmanager","text":"More... #include <Commandline/ConfigurationManager.hpp>","title":"microsoft::quantum::ConfigurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#public-classes","text":"Name struct Section","title":"Public Classes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#public-types","text":"Name using std::shared_ptr< IConfigBind > IConfigBindPtr Pointer class used to bind a parameter to a value. using std::vector< IConfigBindPtr > ConfigList List of bound variables. using std::shared_ptr< void > VoidPtr Type-erased configuration pointer. using std::type_index TypeId Type index class. using std::shared_ptr< bool > BoolPtr using std::unordered_map< String, IConfigBindPtr > Parameters using DeferredValue::DeferredValuePtr DeferredValuePtr using std::unordered_map< String, DeferredValuePtr > DeferredRefs using IConfigBind::ParameterVisibility ParameterVisibility using std::vector< Section > Sections List of available sections.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#public-functions","text":"Name ConfigurationManager () Configuration manager is default constructible, non-copyable and non-movable. ConfigurationManager ( ConfigurationManager const & ) ConfigurationManager ( ConfigurationManager && ) ConfigurationManager & operator= ( ConfigurationManager const & ) ConfigurationManager & operator= ( ConfigurationManager && ) ~ConfigurationManager () void setupArguments ( ParameterParser & parser) Adds all bound variables as parser arguments. void configure ( ParameterParser & parser, bool experimental_mode =false) Configures the value of each bound variable given a parser instance. template <typename T > void setConfig (T const & value) Given an instance of the ConfigurationManager , this method override settings of class T. template <typename T > T const & get () const Gets the configuration instance of type T. void printHelp (bool experimental_mode) const Prints options for configurability to the terminal. void printConfiguration () const template <typename T > void addConfig (String const & id =\"\", T const & default_value =T()) Adds a new configuration of type T. template <typename T > bool configWasRegistered () Whether or not a configuration of type previously registered. template <typename T > bool isActive () Whether or not the component associated with T is active. void setSectionName (String const & name, String const & description) void disableSectionByDefault () Disables the last section added to the manager. void disableSectionById (String const & id) Disables a named section. void enableSectionById (String const & id) Enables a named section. void allowDisableSectionById (String const & id) Allow disabling the full section. template <typename T > void addParameter (T & bind, T default_value, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig) void addShorthandNotation (String const & parameter, String const & shorthand) template <typename T > void addParameter (T & bind, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig) template <typename T > void addExperimentalParameter (T & bind, T default_value, T off_value, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig) template <typename T > void addExperimentalParameter (T & bind, T default_value, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig) template <typename T > void addExperimentalParameter (T & bind, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig) DeferredValuePtr getParameter (String const & name) template <typename T > bool has () const Checks whether a configuration section exists. template <typename T > void updateParameter (String const & name, T const & value) void loadConfig (String const & filename) Loads a configuration file. void saveConfig (String const & filename) Saves the configuration to the specified file.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#detailed-description","text":"class microsoft::quantum::ConfigurationManager; ConfigurationManager is a class that holds a collection of configurations (sections). Each of these sections are embodied in their own class with a one-to-one mapping between configuration section and the configuration type. As an example, if one wishes to make a configuration for the class Foo, one would create a class FooConfig which would hold all the variables that are configurable and then add FooConfig to the ConfigurationManager using [addConfig()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addconfig) . For FooConfig to fulfill the concept of a configuration, it must implement a setup functions whose first argument is the ConfigurationManager .","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-iconfigbindptr","text":"using microsoft::quantum::ConfigurationManager::IConfigBindPtr = std::shared_ptr<IConfigBind>; Pointer class used to bind a parameter to a value.","title":"using IConfigBindPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-configlist","text":"using microsoft::quantum::ConfigurationManager::ConfigList = std::vector<IConfigBindPtr>; List of bound variables.","title":"using ConfigList"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-voidptr","text":"using microsoft::quantum::ConfigurationManager::VoidPtr = std::shared_ptr<void>; Type-erased configuration pointer.","title":"using VoidPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-typeid","text":"using microsoft::quantum::ConfigurationManager::TypeId = std::type_index; Type index class.","title":"using TypeId"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-boolptr","text":"using microsoft::quantum::ConfigurationManager::BoolPtr = std::shared_ptr<bool>;","title":"using BoolPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-parameters","text":"using microsoft::quantum::ConfigurationManager::Parameters = std::unordered_map<String, IConfigBindPtr>;","title":"using Parameters"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-deferredvalueptr","text":"using microsoft::quantum::ConfigurationManager::DeferredValuePtr = DeferredValue::DeferredValuePtr;","title":"using DeferredValuePtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-deferredrefs","text":"using microsoft::quantum::ConfigurationManager::DeferredRefs = std::unordered_map<String, DeferredValuePtr>;","title":"using DeferredRefs"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-parametervisibility","text":"using microsoft::quantum::ConfigurationManager::ParameterVisibility = IConfigBind::ParameterVisibility;","title":"using ParameterVisibility"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-sections","text":"using microsoft::quantum::ConfigurationManager::Sections = std::vector<Section>; List of available sections.","title":"using Sections"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-configurationmanager","text":"ConfigurationManager() Configuration manager is default constructible, non-copyable and non-movable.","title":"function ConfigurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-configurationmanager_1","text":"ConfigurationManager( ConfigurationManager const & )","title":"function ConfigurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-configurationmanager_2","text":"ConfigurationManager( ConfigurationManager && )","title":"function ConfigurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-operator","text":"ConfigurationManager & operator=( ConfigurationManager const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-operator_1","text":"ConfigurationManager & operator=( ConfigurationManager && )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-configurationmanager_3","text":"inline ~ConfigurationManager()","title":"function ~ConfigurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-setuparguments","text":"void setupArguments( ParameterParser & parser ) Adds all bound variables as parser arguments.","title":"function setupArguments"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-configure","text":"void configure( ParameterParser & parser, bool experimental_mode =false ) Configures the value of each bound variable given a parser instance.","title":"function configure"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-setconfig","text":"template <typename T > inline void setConfig( T const & value ) Given an instance of the ConfigurationManager , this method override settings of class T.","title":"function setConfig"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-get","text":"template <typename T > inline T const & get() const Gets the configuration instance of type T.","title":"function get"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-printhelp","text":"void printHelp( bool experimental_mode ) const Prints options for configurability to the terminal.","title":"function printHelp"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-printconfiguration","text":"void printConfiguration() const Prints the configuration to the terminal. The configuration print is LLVM IR compatible meaning that every line starts with a semicolon ; to ensure that it is interpreted as a comment.","title":"function printConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addconfig","text":"template <typename T > inline void addConfig( String const & id =\"\", T const & default_value =T() ) Adds a new configuration of type T.","title":"function addConfig"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-configwasregistered","text":"template <typename T > inline bool configWasRegistered() Whether or not a configuration of type previously registered.","title":"function configWasRegistered"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-isactive","text":"template <typename T > inline bool isActive() Whether or not the component associated with T is active.","title":"function isActive"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-setsectionname","text":"void setSectionName( String const & name, String const & description ) Sets the section name. This method is used by the configuration class to set a section name.","title":"function setSectionName"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-disablesectionbydefault","text":"void disableSectionByDefault() Disables the last section added to the manager.","title":"function disableSectionByDefault"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-disablesectionbyid","text":"void disableSectionById( String const & id ) Disables a named section.","title":"function disableSectionById"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-enablesectionbyid","text":"void enableSectionById( String const & id ) Enables a named section.","title":"function enableSectionById"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-allowdisablesectionbyid","text":"void allowDisableSectionById( String const & id ) Allow disabling the full section.","title":"function allowDisableSectionById"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addparameter","text":"template <typename T > inline void addParameter( T & bind, T default_value, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig ) Adds a new parameter with a default value to the configuration section. This function should be used by the configuration class.","title":"function addParameter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addshorthandnotation","text":"void addShorthandNotation( String const & parameter, String const & shorthand )","title":"function addShorthandNotation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addparameter_1","text":"template <typename T > inline void addParameter( T & bind, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig ) Adds a new parameter to the configuration section. This method uses the bound variable value as default value. This function should be used by the configuration class.","title":"function addParameter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addexperimentalparameter","text":"template <typename T > inline void addExperimentalParameter( T & bind, T default_value, T off_value, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig ) Adds an experimental parameter with a default value and an experimental \"off\" value to the configuration section. This function should be used by the configuration class. The difference to addParameter is that this function marks the parameter as experimental and has a default \"off\" value","title":"function addExperimentalParameter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addexperimentalparameter_1","text":"template <typename T > inline void addExperimentalParameter( T & bind, T default_value, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig ) Adds an experimental parameter with a default value to the configuration section. The experimental off value will be set to the default value of parameter. This function should be used by the configuration class.","title":"function addExperimentalParameter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addexperimentalparameter_2","text":"template <typename T > inline void addExperimentalParameter( T & bind, String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig ) Adds an experimental parameter. The default value and the experimental off value will be the value of the parameter added. This function should be used by the configuration class.","title":"function addExperimentalParameter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-getparameter","text":"DeferredValuePtr getParameter( String const & name )","title":"function getParameter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-has","text":"template <typename T > inline bool has() const Checks whether a configuration section exists.","title":"function has"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-updateparameter","text":"template <typename T > inline void updateParameter( String const & name, T const & value )","title":"function updateParameter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-loadconfig","text":"void loadConfig( String const & filename ) Loads a configuration file.","title":"function loadConfig"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-saveconfig","text":"void saveConfig( String const & filename ) Saves the configuration to the specified file. Updated on 28 October 2022 at 19:30:15 UTC","title":"function saveConfig"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_const_int_pattern/","text":"microsoft::quantum::ConstIntPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::ConstIntPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_const_int_pattern/#microsoftquantumconstintpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::ConstIntPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_const_int_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_const_int_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_const_int_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_const_int_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_const_int_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 28 October 2022 at 19:30:15 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/","text":"microsoft::quantum::DebugInfoUpdater Inherits from llvm::InstVisitor< DebugInfoUpdater > Public Types Name using llvm::DIBuilder DIBuilder using llvm::DataLayout DataLayout using llvm::Module Module using llvm::Function Function using llvm::Instruction Instruction using llvm::DIType DIType using llvm::StringRef StringRef Public Functions Name DebugInfoUpdater (InstructionLocationTablePtr const & debug_info, Module & module, StringRef const & directory, StringRef const & filename) void update () void visitFunction (Function & function) void visitInstruction (Instruction & instr) Protected Functions Name llvm::DISubroutineType * createFunctionType (Function const * function) DIType * createVoidType (llvm::Type * type) DIType * createPointerType (llvm::Type * type) DIType * createOpaqueType (llvm::Type * type) DIType * getOrCreateType (llvm::Type * type) DIType * getType (llvm::Type * type) Public Types Documentation using DIBuilder using microsoft::quantum::DebugInfoUpdater::DIBuilder = llvm::DIBuilder; using DataLayout using microsoft::quantum::DebugInfoUpdater::DataLayout = llvm::DataLayout; using Module using microsoft::quantum::DebugInfoUpdater::Module = llvm::Module; using Function using microsoft::quantum::DebugInfoUpdater::Function = llvm::Function; using Instruction using microsoft::quantum::DebugInfoUpdater::Instruction = llvm::Instruction; using DIType using microsoft::quantum::DebugInfoUpdater::DIType = llvm::DIType; using StringRef using microsoft::quantum::DebugInfoUpdater::StringRef = llvm::StringRef; Public Functions Documentation function DebugInfoUpdater DebugInfoUpdater( InstructionLocationTablePtr const & debug_info, Module & module, StringRef const & directory, StringRef const & filename ) function update void update() function visitFunction void visitFunction( Function & function ) function visitInstruction void visitInstruction( Instruction & instr ) Protected Functions Documentation function createFunctionType llvm::DISubroutineType * createFunctionType( Function const * function ) function createVoidType DIType * createVoidType( llvm::Type * type ) function createPointerType DIType * createPointerType( llvm::Type * type ) function createOpaqueType DIType * createOpaqueType( llvm::Type * type ) function getOrCreateType DIType * getOrCreateType( llvm::Type * type ) function getType DIType * getType( llvm::Type * type ) Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::DebugInfoUpdater"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#microsoftquantumdebuginfoupdater","text":"Inherits from llvm::InstVisitor< DebugInfoUpdater >","title":"microsoft::quantum::DebugInfoUpdater"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#public-types","text":"Name using llvm::DIBuilder DIBuilder using llvm::DataLayout DataLayout using llvm::Module Module using llvm::Function Function using llvm::Instruction Instruction using llvm::DIType DIType using llvm::StringRef StringRef","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#public-functions","text":"Name DebugInfoUpdater (InstructionLocationTablePtr const & debug_info, Module & module, StringRef const & directory, StringRef const & filename) void update () void visitFunction (Function & function) void visitInstruction (Instruction & instr)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#protected-functions","text":"Name llvm::DISubroutineType * createFunctionType (Function const * function) DIType * createVoidType (llvm::Type * type) DIType * createPointerType (llvm::Type * type) DIType * createOpaqueType (llvm::Type * type) DIType * getOrCreateType (llvm::Type * type) DIType * getType (llvm::Type * type)","title":"Protected Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#using-dibuilder","text":"using microsoft::quantum::DebugInfoUpdater::DIBuilder = llvm::DIBuilder;","title":"using DIBuilder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#using-datalayout","text":"using microsoft::quantum::DebugInfoUpdater::DataLayout = llvm::DataLayout;","title":"using DataLayout"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#using-module","text":"using microsoft::quantum::DebugInfoUpdater::Module = llvm::Module;","title":"using Module"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#using-function","text":"using microsoft::quantum::DebugInfoUpdater::Function = llvm::Function;","title":"using Function"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#using-instruction","text":"using microsoft::quantum::DebugInfoUpdater::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#using-ditype","text":"using microsoft::quantum::DebugInfoUpdater::DIType = llvm::DIType;","title":"using DIType"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#using-stringref","text":"using microsoft::quantum::DebugInfoUpdater::StringRef = llvm::StringRef;","title":"using StringRef"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#function-debuginfoupdater","text":"DebugInfoUpdater( InstructionLocationTablePtr const & debug_info, Module & module, StringRef const & directory, StringRef const & filename )","title":"function DebugInfoUpdater"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#function-update","text":"void update()","title":"function update"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#function-visitfunction","text":"void visitFunction( Function & function )","title":"function visitFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#function-visitinstruction","text":"void visitInstruction( Instruction & instr )","title":"function visitInstruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#function-createfunctiontype","text":"llvm::DISubroutineType * createFunctionType( Function const * function )","title":"function createFunctionType"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#function-createvoidtype","text":"DIType * createVoidType( llvm::Type * type )","title":"function createVoidType"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#function-createpointertype","text":"DIType * createPointerType( llvm::Type * type )","title":"function createPointerType"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#function-createopaquetype","text":"DIType * createOpaqueType( llvm::Type * type )","title":"function createOpaqueType"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#function-getorcreatetype","text":"DIType * getOrCreateType( llvm::Type * type )","title":"function getOrCreateType"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_debug_info_updater/#function-gettype","text":"DIType * getType( llvm::Type * type ) Updated on 28 October 2022 at 19:30:15 UTC","title":"function getType"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_defer_measurement_pass/","text":"microsoft::quantum::DeferMeasurementPass Inherits from llvm::PassInfoMixin< DeferMeasurementPass > Public Types Name using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using ILogger::Location Location using llvm::StringRef StringRef Public Functions Name DeferMeasurementPass () DeferMeasurementPass ( DeferMeasurementPass const & ) Copy construction is banned. DeferMeasurementPass ( DeferMeasurementPass && ) =default We allow move semantics. ~DeferMeasurementPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Function & function, llvm::FunctionAnalysisManager & fam) bool isRequired () Whether or not this pass is required to run. Public Attributes Name const std::string RECORD_INSTR_END Public Types Documentation using Instruction using microsoft::quantum::DeferMeasurementPass::Instruction = llvm::Instruction; using Value using microsoft::quantum::DeferMeasurementPass::Value = llvm::Value; using ILoggerPtr using microsoft::quantum::DeferMeasurementPass::ILoggerPtr = ILogger::ILoggerPtr; using Location using microsoft::quantum::DeferMeasurementPass::Location = ILogger::Location; using StringRef using microsoft::quantum::DeferMeasurementPass::StringRef = llvm::StringRef; Public Functions Documentation function DeferMeasurementPass DeferMeasurementPass() function DeferMeasurementPass DeferMeasurementPass( DeferMeasurementPass const & ) Copy construction is banned. function DeferMeasurementPass DeferMeasurementPass( DeferMeasurementPass && ) =default We allow move semantics. function ~DeferMeasurementPass ~DeferMeasurementPass() =default Default destruction. function run llvm::PreservedAnalyses run( llvm::Function & function, llvm::FunctionAnalysisManager & fam ) function isRequired static bool isRequired() Whether or not this pass is required to run. Public Attributes Documentation variable RECORD_INSTR_END static const std::string RECORD_INSTR_END = \"_record_output\"; Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::DeferMeasurementPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_defer_measurement_pass/#microsoftquantumdefermeasurementpass","text":"Inherits from llvm::PassInfoMixin< DeferMeasurementPass >","title":"microsoft::quantum::DeferMeasurementPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_defer_measurement_pass/#public-types","text":"Name using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using ILogger::Location Location using llvm::StringRef StringRef","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_defer_measurement_pass/#public-functions","text":"Name DeferMeasurementPass () DeferMeasurementPass ( DeferMeasurementPass const & ) Copy construction is banned. DeferMeasurementPass ( DeferMeasurementPass && ) =default We allow move semantics. ~DeferMeasurementPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Function & function, llvm::FunctionAnalysisManager & fam) bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_defer_measurement_pass/#public-attributes","text":"Name const std::string RECORD_INSTR_END","title":"Public Attributes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_defer_measurement_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_defer_measurement_pass/#using-instruction","text":"using microsoft::quantum::DeferMeasurementPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_defer_measurement_pass/#using-value","text":"using microsoft::quantum::DeferMeasurementPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_defer_measurement_pass/#using-iloggerptr","text":"using microsoft::quantum::DeferMeasurementPass::ILoggerPtr = ILogger::ILoggerPtr;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_defer_measurement_pass/#using-location","text":"using microsoft::quantum::DeferMeasurementPass::Location = ILogger::Location;","title":"using Location"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_defer_measurement_pass/#using-stringref","text":"using microsoft::quantum::DeferMeasurementPass::StringRef = llvm::StringRef;","title":"using StringRef"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_defer_measurement_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_defer_measurement_pass/#function-defermeasurementpass","text":"DeferMeasurementPass()","title":"function DeferMeasurementPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_defer_measurement_pass/#function-defermeasurementpass_1","text":"DeferMeasurementPass( DeferMeasurementPass const & ) Copy construction is banned.","title":"function DeferMeasurementPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_defer_measurement_pass/#function-defermeasurementpass_2","text":"DeferMeasurementPass( DeferMeasurementPass && ) =default We allow move semantics.","title":"function DeferMeasurementPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_defer_measurement_pass/#function-defermeasurementpass_3","text":"~DeferMeasurementPass() =default Default destruction.","title":"function ~DeferMeasurementPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_defer_measurement_pass/#function-run","text":"llvm::PreservedAnalyses run( llvm::Function & function, llvm::FunctionAnalysisManager & fam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_defer_measurement_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run.","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_defer_measurement_pass/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_defer_measurement_pass/#variable-record_instr_end","text":"static const std::string RECORD_INSTR_END = \"_record_output\"; Updated on 28 October 2022 at 19:30:15 UTC","title":"variable RECORD_INSTR_END"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_deferred_value/","text":"microsoft::quantum::DeferredValue Public Types Name using std::shared_ptr< DeferredValue > DeferredValuePtr using std::shared_ptr< IConfigBind > IConfigBindPtr Public Functions Name DeferredValuePtr create () void setReference (IConfigBindPtr const & value) bool isDereferenceable () const template <typename T > T value () const Public Types Documentation using DeferredValuePtr using microsoft::quantum::DeferredValue::DeferredValuePtr = std::shared_ptr<DeferredValue>; using IConfigBindPtr using microsoft::quantum::DeferredValue::IConfigBindPtr = std::shared_ptr<IConfigBind>; Public Functions Documentation function create static inline DeferredValuePtr create() function setReference inline void setReference( IConfigBindPtr const & value ) function isDereferenceable inline bool isDereferenceable() const function value template <typename T > inline T value() const Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::DeferredValue"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_deferred_value/#microsoftquantumdeferredvalue","text":"","title":"microsoft::quantum::DeferredValue"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_deferred_value/#public-types","text":"Name using std::shared_ptr< DeferredValue > DeferredValuePtr using std::shared_ptr< IConfigBind > IConfigBindPtr","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_deferred_value/#public-functions","text":"Name DeferredValuePtr create () void setReference (IConfigBindPtr const & value) bool isDereferenceable () const template <typename T > T value () const","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_deferred_value/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_deferred_value/#using-deferredvalueptr","text":"using microsoft::quantum::DeferredValue::DeferredValuePtr = std::shared_ptr<DeferredValue>;","title":"using DeferredValuePtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_deferred_value/#using-iconfigbindptr","text":"using microsoft::quantum::DeferredValue::IConfigBindPtr = std::shared_ptr<IConfigBind>;","title":"using IConfigBindPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_deferred_value/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_deferred_value/#function-create","text":"static inline DeferredValuePtr create()","title":"function create"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_deferred_value/#function-setreference","text":"inline void setReference( IConfigBindPtr const & value )","title":"function setReference"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_deferred_value/#function-isdereferenceable","text":"inline bool isDereferenceable() const","title":"function isDereferenceable"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_deferred_value/#function-value","text":"template <typename T > inline T value() const Updated on 28 October 2022 at 19:30:15 UTC","title":"function value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/","text":"microsoft::quantum::DivisionByZeroPass Inherits from llvm::PassInfoMixin< DivisionByZeroPass > Public Types Name using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using ILogger::Location Location using llvm::StringRef StringRef Public Functions Name DivisionByZeroPass () =default DivisionByZeroPass ( DivisionByZeroPass const & ) Copy construction is banned. DivisionByZeroPass ( DivisionByZeroPass && ) =default We allow move semantics. ~DivisionByZeroPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void raiseError (int64_t error_code, llvm::Module & module, llvm::Instruction * instr) bool isRequired () Whether or not this pass is required to run. Public Attributes Name const char *const EC_VARIABLE_NAME const char *const EC_REPORT_FUNCTION const int64_t EC_QIR_DIVISION_BY_ZERO Public Types Documentation using Instruction using microsoft::quantum::DivisionByZeroPass::Instruction = llvm::Instruction; using Value using microsoft::quantum::DivisionByZeroPass::Value = llvm::Value; using ILoggerPtr using microsoft::quantum::DivisionByZeroPass::ILoggerPtr = ILogger::ILoggerPtr; using Location using microsoft::quantum::DivisionByZeroPass::Location = ILogger::Location; using StringRef using microsoft::quantum::DivisionByZeroPass::StringRef = llvm::StringRef; Public Functions Documentation function DivisionByZeroPass DivisionByZeroPass() =default function DivisionByZeroPass DivisionByZeroPass( DivisionByZeroPass const & ) Copy construction is banned. function DivisionByZeroPass DivisionByZeroPass( DivisionByZeroPass && ) =default We allow move semantics. function ~DivisionByZeroPass ~DivisionByZeroPass() =default Default destruction. function run llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function raiseError void raiseError( int64_t error_code, llvm::Module & module, llvm::Instruction * instr ) function isRequired static bool isRequired() Whether or not this pass is required to run. Public Attributes Documentation variable EC_VARIABLE_NAME static const char *const EC_VARIABLE_NAME = \"__qir__error_code\"; variable EC_REPORT_FUNCTION static const char *const EC_REPORT_FUNCTION = \"__qir__report_error_value\"; variable EC_QIR_DIVISION_BY_ZERO static const int64_t EC_QIR_DIVISION_BY_ZERO = 1100; Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::DivisionByZeroPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#microsoftquantumdivisionbyzeropass","text":"Inherits from llvm::PassInfoMixin< DivisionByZeroPass >","title":"microsoft::quantum::DivisionByZeroPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#public-types","text":"Name using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using ILogger::Location Location using llvm::StringRef StringRef","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#public-functions","text":"Name DivisionByZeroPass () =default DivisionByZeroPass ( DivisionByZeroPass const & ) Copy construction is banned. DivisionByZeroPass ( DivisionByZeroPass && ) =default We allow move semantics. ~DivisionByZeroPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void raiseError (int64_t error_code, llvm::Module & module, llvm::Instruction * instr) bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#public-attributes","text":"Name const char *const EC_VARIABLE_NAME const char *const EC_REPORT_FUNCTION const int64_t EC_QIR_DIVISION_BY_ZERO","title":"Public Attributes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#using-instruction","text":"using microsoft::quantum::DivisionByZeroPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#using-value","text":"using microsoft::quantum::DivisionByZeroPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#using-iloggerptr","text":"using microsoft::quantum::DivisionByZeroPass::ILoggerPtr = ILogger::ILoggerPtr;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#using-location","text":"using microsoft::quantum::DivisionByZeroPass::Location = ILogger::Location;","title":"using Location"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#using-stringref","text":"using microsoft::quantum::DivisionByZeroPass::StringRef = llvm::StringRef;","title":"using StringRef"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#function-divisionbyzeropass","text":"DivisionByZeroPass() =default","title":"function DivisionByZeroPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#function-divisionbyzeropass_1","text":"DivisionByZeroPass( DivisionByZeroPass const & ) Copy construction is banned.","title":"function DivisionByZeroPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#function-divisionbyzeropass_2","text":"DivisionByZeroPass( DivisionByZeroPass && ) =default We allow move semantics.","title":"function DivisionByZeroPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#function-divisionbyzeropass_3","text":"~DivisionByZeroPass() =default Default destruction.","title":"function ~DivisionByZeroPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#function-run","text":"llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#function-raiseerror","text":"void raiseError( int64_t error_code, llvm::Module & module, llvm::Instruction * instr )","title":"function raiseError"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run.","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#variable-ec_variable_name","text":"static const char *const EC_VARIABLE_NAME = \"__qir__error_code\";","title":"variable EC_VARIABLE_NAME"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#variable-ec_report_function","text":"static const char *const EC_REPORT_FUNCTION = \"__qir__report_error_value\";","title":"variable EC_REPORT_FUNCTION"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_division_by_zero_pass/#variable-ec_qir_division_by_zero","text":"static const int64_t EC_QIR_DIVISION_BY_ZERO = 1100; Updated on 28 October 2022 at 19:30:15 UTC","title":"variable EC_QIR_DIVISION_BY_ZERO"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_annotator_pass/","text":"microsoft::quantum::FunctionAnnotatorPass Inherits from llvm::PassInfoMixin< FunctionAnnotatorPass > Public Types Name using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using std::unordered_set< llvm::BasicBlock * > BlockSet using std::shared_ptr< llvm::IRBuilder<> > SharedBuilder Public Functions Name FunctionAnnotatorPass ( FunctionReplacementConfiguration const & cfg) FunctionAnnotatorPass ( FunctionAnnotatorPass const & ) Copy construction is banned. FunctionAnnotatorPass ( FunctionAnnotatorPass && ) =default We allow move semantics. ~FunctionAnnotatorPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void setLogger (ILoggerPtr logger) Sets the logger. bool isRequired () Whether or not this pass is required to run. Public Types Documentation using Instruction using microsoft::quantum::FunctionAnnotatorPass::Instruction = llvm::Instruction; using Value using microsoft::quantum::FunctionAnnotatorPass::Value = llvm::Value; using ILoggerPtr using microsoft::quantum::FunctionAnnotatorPass::ILoggerPtr = ILogger::ILoggerPtr; using BlockSet using microsoft::quantum::FunctionAnnotatorPass::BlockSet = std::unordered_set<llvm::BasicBlock*>; using SharedBuilder using microsoft::quantum::FunctionAnnotatorPass::SharedBuilder = std::shared_ptr<llvm::IRBuilder<> >; Public Functions Documentation function FunctionAnnotatorPass inline explicit FunctionAnnotatorPass( FunctionReplacementConfiguration const & cfg ) function FunctionAnnotatorPass FunctionAnnotatorPass( FunctionAnnotatorPass const & ) Copy construction is banned. function FunctionAnnotatorPass FunctionAnnotatorPass( FunctionAnnotatorPass && ) =default We allow move semantics. function ~FunctionAnnotatorPass ~FunctionAnnotatorPass() =default Default destruction. function run llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function setLogger void setLogger( ILoggerPtr logger ) Sets the logger. function isRequired static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::FunctionAnnotatorPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_annotator_pass/#microsoftquantumfunctionannotatorpass","text":"Inherits from llvm::PassInfoMixin< FunctionAnnotatorPass >","title":"microsoft::quantum::FunctionAnnotatorPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_annotator_pass/#public-types","text":"Name using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using std::unordered_set< llvm::BasicBlock * > BlockSet using std::shared_ptr< llvm::IRBuilder<> > SharedBuilder","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_annotator_pass/#public-functions","text":"Name FunctionAnnotatorPass ( FunctionReplacementConfiguration const & cfg) FunctionAnnotatorPass ( FunctionAnnotatorPass const & ) Copy construction is banned. FunctionAnnotatorPass ( FunctionAnnotatorPass && ) =default We allow move semantics. ~FunctionAnnotatorPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void setLogger (ILoggerPtr logger) Sets the logger. bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_annotator_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_annotator_pass/#using-instruction","text":"using microsoft::quantum::FunctionAnnotatorPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_annotator_pass/#using-value","text":"using microsoft::quantum::FunctionAnnotatorPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_annotator_pass/#using-iloggerptr","text":"using microsoft::quantum::FunctionAnnotatorPass::ILoggerPtr = ILogger::ILoggerPtr;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_annotator_pass/#using-blockset","text":"using microsoft::quantum::FunctionAnnotatorPass::BlockSet = std::unordered_set<llvm::BasicBlock*>;","title":"using BlockSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_annotator_pass/#using-sharedbuilder","text":"using microsoft::quantum::FunctionAnnotatorPass::SharedBuilder = std::shared_ptr<llvm::IRBuilder<> >;","title":"using SharedBuilder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_annotator_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_annotator_pass/#function-functionannotatorpass","text":"inline explicit FunctionAnnotatorPass( FunctionReplacementConfiguration const & cfg )","title":"function FunctionAnnotatorPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_annotator_pass/#function-functionannotatorpass_1","text":"FunctionAnnotatorPass( FunctionAnnotatorPass const & ) Copy construction is banned.","title":"function FunctionAnnotatorPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_annotator_pass/#function-functionannotatorpass_2","text":"FunctionAnnotatorPass( FunctionAnnotatorPass && ) =default We allow move semantics.","title":"function FunctionAnnotatorPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_annotator_pass/#function-functionannotatorpass_3","text":"~FunctionAnnotatorPass() =default Default destruction.","title":"function ~FunctionAnnotatorPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_annotator_pass/#function-run","text":"llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_annotator_pass/#function-setlogger","text":"void setLogger( ILoggerPtr logger ) Sets the logger.","title":"function setLogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_annotator_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass/","text":"microsoft::quantum::FunctionReplacementAnalysisPass Inherits from llvm::AnalysisInfoMixin< FunctionReplacementAnalysisPass > Public Types Name using FunctionRegister Result using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using std::unordered_set< llvm::BasicBlock * > BlockSet Public Functions Name FunctionReplacementAnalysisPass ( FunctionReplacementConfiguration const & cfg, ILoggerPtr const & logger) FunctionReplacementAnalysisPass ( FunctionReplacementAnalysisPass const & ) Copy construction is banned. FunctionReplacementAnalysisPass ( FunctionReplacementAnalysisPass && ) =default We allow move semantics. ~FunctionReplacementAnalysisPass () =default Default destruction. Result run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runBlockAnalysis (llvm::Module & module) bool isRequired () Whether or not this pass is required to run. Friends Name struct llvm::AnalysisInfoMixin< FunctionReplacementAnalysisPass > Public Types Documentation using Result using microsoft::quantum::FunctionReplacementAnalysisPass::Result = FunctionRegister; using Instruction using microsoft::quantum::FunctionReplacementAnalysisPass::Instruction = llvm::Instruction; using Value using microsoft::quantum::FunctionReplacementAnalysisPass::Value = llvm::Value; using ILoggerPtr using microsoft::quantum::FunctionReplacementAnalysisPass::ILoggerPtr = ILogger::ILoggerPtr; using BlockSet using microsoft::quantum::FunctionReplacementAnalysisPass::BlockSet = std::unordered_set<llvm::BasicBlock*>; Public Functions Documentation function FunctionReplacementAnalysisPass inline explicit FunctionReplacementAnalysisPass( FunctionReplacementConfiguration const & cfg, ILoggerPtr const & logger ) function FunctionReplacementAnalysisPass FunctionReplacementAnalysisPass( FunctionReplacementAnalysisPass const & ) Copy construction is banned. function FunctionReplacementAnalysisPass FunctionReplacementAnalysisPass( FunctionReplacementAnalysisPass && ) =default We allow move semantics. function ~FunctionReplacementAnalysisPass ~FunctionReplacementAnalysisPass() =default Default destruction. function run Result run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function runBlockAnalysis void runBlockAnalysis( llvm::Module & module ) function isRequired static bool isRequired() Whether or not this pass is required to run. Friends friend llvm::AnalysisInfoMixin< FunctionReplacementAnalysisPass > friend struct llvm::AnalysisInfoMixin< FunctionReplacementAnalysisPass >(); Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::FunctionReplacementAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass/#microsoftquantumfunctionreplacementanalysispass","text":"Inherits from llvm::AnalysisInfoMixin< FunctionReplacementAnalysisPass >","title":"microsoft::quantum::FunctionReplacementAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass/#public-types","text":"Name using FunctionRegister Result using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using std::unordered_set< llvm::BasicBlock * > BlockSet","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass/#public-functions","text":"Name FunctionReplacementAnalysisPass ( FunctionReplacementConfiguration const & cfg, ILoggerPtr const & logger) FunctionReplacementAnalysisPass ( FunctionReplacementAnalysisPass const & ) Copy construction is banned. FunctionReplacementAnalysisPass ( FunctionReplacementAnalysisPass && ) =default We allow move semantics. ~FunctionReplacementAnalysisPass () =default Default destruction. Result run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runBlockAnalysis (llvm::Module & module) bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass/#friends","text":"Name struct llvm::AnalysisInfoMixin< FunctionReplacementAnalysisPass >","title":"Friends"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass/#using-result","text":"using microsoft::quantum::FunctionReplacementAnalysisPass::Result = FunctionRegister;","title":"using Result"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass/#using-instruction","text":"using microsoft::quantum::FunctionReplacementAnalysisPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass/#using-value","text":"using microsoft::quantum::FunctionReplacementAnalysisPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass/#using-iloggerptr","text":"using microsoft::quantum::FunctionReplacementAnalysisPass::ILoggerPtr = ILogger::ILoggerPtr;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass/#using-blockset","text":"using microsoft::quantum::FunctionReplacementAnalysisPass::BlockSet = std::unordered_set<llvm::BasicBlock*>;","title":"using BlockSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass/#function-functionreplacementanalysispass","text":"inline explicit FunctionReplacementAnalysisPass( FunctionReplacementConfiguration const & cfg, ILoggerPtr const & logger )","title":"function FunctionReplacementAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass/#function-functionreplacementanalysispass_1","text":"FunctionReplacementAnalysisPass( FunctionReplacementAnalysisPass const & ) Copy construction is banned.","title":"function FunctionReplacementAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass/#function-functionreplacementanalysispass_2","text":"FunctionReplacementAnalysisPass( FunctionReplacementAnalysisPass && ) =default We allow move semantics.","title":"function FunctionReplacementAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass/#function-functionreplacementanalysispass_3","text":"~FunctionReplacementAnalysisPass() =default Default destruction.","title":"function ~FunctionReplacementAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass/#function-run","text":"Result run( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass/#function-runblockanalysis","text":"void runBlockAnalysis( llvm::Module & module )","title":"function runBlockAnalysis"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run.","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass/#friends_1","text":"","title":"Friends"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass/#friend-llvmanalysisinfomixin-functionreplacementanalysispass","text":"friend struct llvm::AnalysisInfoMixin< FunctionReplacementAnalysisPass >(); Updated on 28 October 2022 at 19:30:15 UTC","title":"friend llvm::AnalysisInfoMixin&lt; FunctionReplacementAnalysisPass &gt;"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass_printer/","text":"microsoft::quantum::FunctionReplacementAnalysisPassPrinter Inherits from llvm::PassInfoMixin< FunctionReplacementAnalysisPassPrinter > Public Functions Name llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool isRequired () Public Functions Documentation function run llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function isRequired static inline bool isRequired() Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::FunctionReplacementAnalysisPassPrinter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass_printer/#microsoftquantumfunctionreplacementanalysispassprinter","text":"Inherits from llvm::PassInfoMixin< FunctionReplacementAnalysisPassPrinter >","title":"microsoft::quantum::FunctionReplacementAnalysisPassPrinter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass_printer/#public-functions","text":"Name llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool isRequired ()","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass_printer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass_printer/#function-run","text":"llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_analysis_pass_printer/#function-isrequired","text":"static inline bool isRequired() Updated on 28 October 2022 at 19:30:15 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_configuration/","text":"microsoft::quantum::FunctionReplacementConfiguration Public Types Name using std::unordered_set< std::string > Set Public Functions Name void setup ( ConfigurationManager & config) StringMap const & injectedAnnotations () const bool shouldRemoveCallAttributes () const FunctionReplacementConfiguration createDisabled () Public Types Documentation using Set using microsoft::quantum::FunctionReplacementConfiguration::Set = std::unordered_set<std::string>; Public Functions Documentation function setup inline void setup( ConfigurationManager & config ) Setup function that adds the configuration flags to the ConfigurationManager . See the ConfigurationManager documentation for more details on how the setup process is implemented. function injectedAnnotations inline StringMap const & injectedAnnotations() const function shouldRemoveCallAttributes inline bool shouldRemoveCallAttributes() const function createDisabled static inline FunctionReplacementConfiguration createDisabled() Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::FunctionReplacementConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_configuration/#microsoftquantumfunctionreplacementconfiguration","text":"","title":"microsoft::quantum::FunctionReplacementConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_configuration/#public-types","text":"Name using std::unordered_set< std::string > Set","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_configuration/#public-functions","text":"Name void setup ( ConfigurationManager & config) StringMap const & injectedAnnotations () const bool shouldRemoveCallAttributes () const FunctionReplacementConfiguration createDisabled ()","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_configuration/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_configuration/#using-set","text":"using microsoft::quantum::FunctionReplacementConfiguration::Set = std::unordered_set<std::string>;","title":"using Set"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_configuration/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_configuration/#function-setup","text":"inline void setup( ConfigurationManager & config ) Setup function that adds the configuration flags to the ConfigurationManager . See the ConfigurationManager documentation for more details on how the setup process is implemented.","title":"function setup"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_configuration/#function-injectedannotations","text":"inline StringMap const & injectedAnnotations() const","title":"function injectedAnnotations"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_configuration/#function-shouldremovecallattributes","text":"inline bool shouldRemoveCallAttributes() const","title":"function shouldRemoveCallAttributes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_configuration/#function-createdisabled","text":"static inline FunctionReplacementConfiguration createDisabled() Updated on 28 October 2022 at 19:30:15 UTC","title":"function createDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_pass/","text":"microsoft::quantum::FunctionReplacementPass Inherits from llvm::PassInfoMixin< FunctionReplacementPass > Public Types Name using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using std::unordered_set< llvm::BasicBlock * > BlockSet using std::shared_ptr< llvm::IRBuilder<> > SharedBuilder Public Functions Name FunctionReplacementPass ( FunctionReplacementConfiguration const & cfg) FunctionReplacementPass ( FunctionReplacementPass const & ) Copy construction is banned. FunctionReplacementPass ( FunctionReplacementPass && ) =default We allow move semantics. ~FunctionReplacementPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void setLogger (ILoggerPtr logger) Sets the logger. bool isRequired () Whether or not this pass is required to run. Public Types Documentation using Instruction using microsoft::quantum::FunctionReplacementPass::Instruction = llvm::Instruction; using Value using microsoft::quantum::FunctionReplacementPass::Value = llvm::Value; using ILoggerPtr using microsoft::quantum::FunctionReplacementPass::ILoggerPtr = ILogger::ILoggerPtr; using BlockSet using microsoft::quantum::FunctionReplacementPass::BlockSet = std::unordered_set<llvm::BasicBlock*>; using SharedBuilder using microsoft::quantum::FunctionReplacementPass::SharedBuilder = std::shared_ptr<llvm::IRBuilder<> >; Public Functions Documentation function FunctionReplacementPass inline explicit FunctionReplacementPass( FunctionReplacementConfiguration const & cfg ) function FunctionReplacementPass FunctionReplacementPass( FunctionReplacementPass const & ) Copy construction is banned. function FunctionReplacementPass FunctionReplacementPass( FunctionReplacementPass && ) =default We allow move semantics. function ~FunctionReplacementPass ~FunctionReplacementPass() =default Default destruction. function run llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function setLogger void setLogger( ILoggerPtr logger ) Sets the logger. function isRequired static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::FunctionReplacementPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_pass/#microsoftquantumfunctionreplacementpass","text":"Inherits from llvm::PassInfoMixin< FunctionReplacementPass >","title":"microsoft::quantum::FunctionReplacementPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_pass/#public-types","text":"Name using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using std::unordered_set< llvm::BasicBlock * > BlockSet using std::shared_ptr< llvm::IRBuilder<> > SharedBuilder","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_pass/#public-functions","text":"Name FunctionReplacementPass ( FunctionReplacementConfiguration const & cfg) FunctionReplacementPass ( FunctionReplacementPass const & ) Copy construction is banned. FunctionReplacementPass ( FunctionReplacementPass && ) =default We allow move semantics. ~FunctionReplacementPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void setLogger (ILoggerPtr logger) Sets the logger. bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_pass/#using-instruction","text":"using microsoft::quantum::FunctionReplacementPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_pass/#using-value","text":"using microsoft::quantum::FunctionReplacementPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_pass/#using-iloggerptr","text":"using microsoft::quantum::FunctionReplacementPass::ILoggerPtr = ILogger::ILoggerPtr;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_pass/#using-blockset","text":"using microsoft::quantum::FunctionReplacementPass::BlockSet = std::unordered_set<llvm::BasicBlock*>;","title":"using BlockSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_pass/#using-sharedbuilder","text":"using microsoft::quantum::FunctionReplacementPass::SharedBuilder = std::shared_ptr<llvm::IRBuilder<> >;","title":"using SharedBuilder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_pass/#function-functionreplacementpass","text":"inline explicit FunctionReplacementPass( FunctionReplacementConfiguration const & cfg )","title":"function FunctionReplacementPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_pass/#function-functionreplacementpass_1","text":"FunctionReplacementPass( FunctionReplacementPass const & ) Copy construction is banned.","title":"function FunctionReplacementPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_pass/#function-functionreplacementpass_2","text":"FunctionReplacementPass( FunctionReplacementPass && ) =default We allow move semantics.","title":"function FunctionReplacementPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_pass/#function-functionreplacementpass_3","text":"~FunctionReplacementPass() =default Default destruction.","title":"function ~FunctionReplacementPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_pass/#function-run","text":"llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_pass/#function-setlogger","text":"void setLogger( ILoggerPtr logger ) Sets the logger.","title":"function setLogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_replacement_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_to_module/","text":"microsoft::quantum::FunctionToModule Inherits from llvm::PassInfoMixin< FunctionToModule > Public Functions Name FunctionToModule (llvm::FunctionPassManager && manager) FunctionToModule ( FunctionToModule const & ) Copy construction is banned. FunctionToModule ( FunctionToModule && ) =default We allow move semantics. ~FunctionToModule () =default Default destruction. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool isRequired () Whether or not this pass is required to run. Public Functions Documentation function FunctionToModule inline explicit FunctionToModule( llvm::FunctionPassManager && manager ) function FunctionToModule FunctionToModule( FunctionToModule const & ) Copy construction is banned. function FunctionToModule FunctionToModule( FunctionToModule && ) =default We allow move semantics. function ~FunctionToModule ~FunctionToModule() =default Default destruction. function run inline llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function isRequired static inline bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::FunctionToModule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_to_module/#microsoftquantumfunctiontomodule","text":"Inherits from llvm::PassInfoMixin< FunctionToModule >","title":"microsoft::quantum::FunctionToModule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_to_module/#public-functions","text":"Name FunctionToModule (llvm::FunctionPassManager && manager) FunctionToModule ( FunctionToModule const & ) Copy construction is banned. FunctionToModule ( FunctionToModule && ) =default We allow move semantics. ~FunctionToModule () =default Default destruction. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_to_module/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_to_module/#function-functiontomodule","text":"inline explicit FunctionToModule( llvm::FunctionPassManager && manager )","title":"function FunctionToModule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_to_module/#function-functiontomodule_1","text":"FunctionToModule( FunctionToModule const & ) Copy construction is banned.","title":"function FunctionToModule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_to_module/#function-functiontomodule_2","text":"FunctionToModule( FunctionToModule && ) =default We allow move semantics.","title":"function FunctionToModule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_to_module/#function-functiontomodule_3","text":"~FunctionToModule() =default Default destruction.","title":"function ~FunctionToModule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_to_module/#function-run","text":"inline llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_to_module/#function-isrequired","text":"static inline bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_validation_pass/","text":"microsoft::quantum::FunctionValidationPass Inherits from llvm::PassInfoMixin< FunctionValidationPass > Public Types Name using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using ILogger::Location Location using llvm::StringRef StringRef Public Functions Name FunctionValidationPass ( TargetProfileConfiguration const & profile_config, TargetQisConfiguration const & qis_config, ILoggerPtr const & logger =nullptr) FunctionValidationPass ( FunctionValidationPass const & ) Copy construction is banned. FunctionValidationPass ( FunctionValidationPass && ) =default We allow move semantics. ~FunctionValidationPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Function & function, llvm::FunctionAnalysisManager & fam) bool isRequired () Whether or not this pass is required to run. Public Types Documentation using Instruction using microsoft::quantum::FunctionValidationPass::Instruction = llvm::Instruction; using Value using microsoft::quantum::FunctionValidationPass::Value = llvm::Value; using ILoggerPtr using microsoft::quantum::FunctionValidationPass::ILoggerPtr = ILogger::ILoggerPtr; using Location using microsoft::quantum::FunctionValidationPass::Location = ILogger::Location; using StringRef using microsoft::quantum::FunctionValidationPass::StringRef = llvm::StringRef; Public Functions Documentation function FunctionValidationPass explicit FunctionValidationPass( TargetProfileConfiguration const & profile_config, TargetQisConfiguration const & qis_config, ILoggerPtr const & logger =nullptr ) function FunctionValidationPass FunctionValidationPass( FunctionValidationPass const & ) Copy construction is banned. function FunctionValidationPass FunctionValidationPass( FunctionValidationPass && ) =default We allow move semantics. function ~FunctionValidationPass ~FunctionValidationPass() =default Default destruction. function run llvm::PreservedAnalyses run( llvm::Function & function, llvm::FunctionAnalysisManager & fam ) function isRequired static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::FunctionValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_validation_pass/#microsoftquantumfunctionvalidationpass","text":"Inherits from llvm::PassInfoMixin< FunctionValidationPass >","title":"microsoft::quantum::FunctionValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_validation_pass/#public-types","text":"Name using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using ILogger::Location Location using llvm::StringRef StringRef","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_validation_pass/#public-functions","text":"Name FunctionValidationPass ( TargetProfileConfiguration const & profile_config, TargetQisConfiguration const & qis_config, ILoggerPtr const & logger =nullptr) FunctionValidationPass ( FunctionValidationPass const & ) Copy construction is banned. FunctionValidationPass ( FunctionValidationPass && ) =default We allow move semantics. ~FunctionValidationPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Function & function, llvm::FunctionAnalysisManager & fam) bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_validation_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_validation_pass/#using-instruction","text":"using microsoft::quantum::FunctionValidationPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_validation_pass/#using-value","text":"using microsoft::quantum::FunctionValidationPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_validation_pass/#using-iloggerptr","text":"using microsoft::quantum::FunctionValidationPass::ILoggerPtr = ILogger::ILoggerPtr;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_validation_pass/#using-location","text":"using microsoft::quantum::FunctionValidationPass::Location = ILogger::Location;","title":"using Location"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_validation_pass/#using-stringref","text":"using microsoft::quantum::FunctionValidationPass::StringRef = llvm::StringRef;","title":"using StringRef"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_validation_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_validation_pass/#function-functionvalidationpass","text":"explicit FunctionValidationPass( TargetProfileConfiguration const & profile_config, TargetQisConfiguration const & qis_config, ILoggerPtr const & logger =nullptr )","title":"function FunctionValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_validation_pass/#function-functionvalidationpass_1","text":"FunctionValidationPass( FunctionValidationPass const & ) Copy construction is banned.","title":"function FunctionValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_validation_pass/#function-functionvalidationpass_2","text":"FunctionValidationPass( FunctionValidationPass && ) =default We allow move semantics.","title":"function FunctionValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_validation_pass/#function-functionvalidationpass_3","text":"~FunctionValidationPass() =default Default destruction.","title":"function ~FunctionValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_validation_pass/#function-run","text":"llvm::PreservedAnalyses run( llvm::Function & function, llvm::FunctionAnalysisManager & fam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_function_validation_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/","text":"microsoft::quantum::GroupingAnalysisPass Inherits from llvm::AnalysisInfoMixin< GroupingAnalysisPass > Public Types Name using GroupAnalysis Result using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using std::unordered_set< llvm::BasicBlock * > BlockSet Public Functions Name GroupingAnalysisPass ( GroupingPassConfiguration const & cfg, ILoggerPtr const & logger) GroupingAnalysisPass ( GroupingAnalysisPass const & ) Copy construction is banned. GroupingAnalysisPass ( GroupingAnalysisPass && ) =default We allow move semantics. ~GroupingAnalysisPass () =default Default destruction. Result run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runBlockAnalysis (llvm::Module & module) bool isRequired () Whether or not this pass is required to run. Public Attributes Name const String QIS_START const String READ_INSTR_START Friends Name struct llvm::AnalysisInfoMixin< GroupingAnalysisPass > Public Types Documentation using Result using microsoft::quantum::GroupingAnalysisPass::Result = GroupAnalysis; using Instruction using microsoft::quantum::GroupingAnalysisPass::Instruction = llvm::Instruction; using Value using microsoft::quantum::GroupingAnalysisPass::Value = llvm::Value; using ILoggerPtr using microsoft::quantum::GroupingAnalysisPass::ILoggerPtr = ILogger::ILoggerPtr; using BlockSet using microsoft::quantum::GroupingAnalysisPass::BlockSet = std::unordered_set<llvm::BasicBlock*>; Public Functions Documentation function GroupingAnalysisPass inline explicit GroupingAnalysisPass( GroupingPassConfiguration const & cfg, ILoggerPtr const & logger ) function GroupingAnalysisPass GroupingAnalysisPass( GroupingAnalysisPass const & ) Copy construction is banned. function GroupingAnalysisPass GroupingAnalysisPass( GroupingAnalysisPass && ) =default We allow move semantics. function ~GroupingAnalysisPass ~GroupingAnalysisPass() =default Default destruction. function run Result run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function runBlockAnalysis void runBlockAnalysis( llvm::Module & module ) function isRequired static bool isRequired() Whether or not this pass is required to run. Public Attributes Documentation variable QIS_START static const String QIS_START = \"__quantum\" \"__qis_\"; variable READ_INSTR_START static const String READ_INSTR_START = \"__quantum\" \"__qis__read_\"; Friends friend llvm::AnalysisInfoMixin< GroupingAnalysisPass > friend struct llvm::AnalysisInfoMixin< GroupingAnalysisPass >(); Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::GroupingAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#microsoftquantumgroupinganalysispass","text":"Inherits from llvm::AnalysisInfoMixin< GroupingAnalysisPass >","title":"microsoft::quantum::GroupingAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#public-types","text":"Name using GroupAnalysis Result using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using std::unordered_set< llvm::BasicBlock * > BlockSet","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#public-functions","text":"Name GroupingAnalysisPass ( GroupingPassConfiguration const & cfg, ILoggerPtr const & logger) GroupingAnalysisPass ( GroupingAnalysisPass const & ) Copy construction is banned. GroupingAnalysisPass ( GroupingAnalysisPass && ) =default We allow move semantics. ~GroupingAnalysisPass () =default Default destruction. Result run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runBlockAnalysis (llvm::Module & module) bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#public-attributes","text":"Name const String QIS_START const String READ_INSTR_START","title":"Public Attributes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#friends","text":"Name struct llvm::AnalysisInfoMixin< GroupingAnalysisPass >","title":"Friends"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#using-result","text":"using microsoft::quantum::GroupingAnalysisPass::Result = GroupAnalysis;","title":"using Result"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#using-instruction","text":"using microsoft::quantum::GroupingAnalysisPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#using-value","text":"using microsoft::quantum::GroupingAnalysisPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#using-iloggerptr","text":"using microsoft::quantum::GroupingAnalysisPass::ILoggerPtr = ILogger::ILoggerPtr;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#using-blockset","text":"using microsoft::quantum::GroupingAnalysisPass::BlockSet = std::unordered_set<llvm::BasicBlock*>;","title":"using BlockSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#function-groupinganalysispass","text":"inline explicit GroupingAnalysisPass( GroupingPassConfiguration const & cfg, ILoggerPtr const & logger )","title":"function GroupingAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#function-groupinganalysispass_1","text":"GroupingAnalysisPass( GroupingAnalysisPass const & ) Copy construction is banned.","title":"function GroupingAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#function-groupinganalysispass_2","text":"GroupingAnalysisPass( GroupingAnalysisPass && ) =default We allow move semantics.","title":"function GroupingAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#function-groupinganalysispass_3","text":"~GroupingAnalysisPass() =default Default destruction.","title":"function ~GroupingAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#function-run","text":"Result run( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#function-runblockanalysis","text":"void runBlockAnalysis( llvm::Module & module )","title":"function runBlockAnalysis"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run.","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#variable-qis_start","text":"static const String QIS_START = \"__quantum\" \"__qis_\";","title":"variable QIS_START"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#variable-read_instr_start","text":"static const String READ_INSTR_START = \"__quantum\" \"__qis__read_\";","title":"variable READ_INSTR_START"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#friends_1","text":"","title":"Friends"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#friend-llvmanalysisinfomixin-groupinganalysispass","text":"friend struct llvm::AnalysisInfoMixin< GroupingAnalysisPass >(); Updated on 28 October 2022 at 19:30:15 UTC","title":"friend llvm::AnalysisInfoMixin&lt; GroupingAnalysisPass &gt;"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass_printer/","text":"microsoft::quantum::GroupingAnalysisPassPrinter Inherits from llvm::PassInfoMixin< GroupingAnalysisPassPrinter > Public Functions Name llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool isRequired () Public Functions Documentation function run llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function isRequired static inline bool isRequired() Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::GroupingAnalysisPassPrinter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass_printer/#microsoftquantumgroupinganalysispassprinter","text":"Inherits from llvm::PassInfoMixin< GroupingAnalysisPassPrinter >","title":"microsoft::quantum::GroupingAnalysisPassPrinter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass_printer/#public-functions","text":"Name llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool isRequired ()","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass_printer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass_printer/#function-run","text":"llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass_printer/#function-isrequired","text":"static inline bool isRequired() Updated on 28 October 2022 at 19:30:15 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/","text":"microsoft::quantum::GroupingPass More... #include <Passes/GroupingPass/GroupingPass.hpp> Inherits from llvm::PassInfoMixin< GroupingPass > Public Classes Name struct ResourceAnalysis Public Types Name enum class ResourceType { UNDEFINED, QUBIT, RESULT} enum @1 { PureClassical = 0, SourceQuantum = 1, DestQuantum = 2, PureQuantum = SourceQuantum using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using std::unordered_set< llvm::BasicBlock * > BlockSet using std::shared_ptr< llvm::IRBuilder<> > SharedBuilder Public Functions Name GroupingPass ( GroupingPassConfiguration const & cfg) GroupingPass ( GroupingPass const & ) Copy construction is banned. GroupingPass ( GroupingPass && ) =default We allow move semantics. ~GroupingPass () =default Default destruction. void prepareSourceSeparation (llvm::Module & module, llvm::BasicBlock * block) void nextQuantumCycle (llvm::Module & module, llvm::BasicBlock * block) void expandBasedOnSource (llvm::Module & module, llvm::BasicBlock * block) void expandBasedOnDest (llvm::Module & module, llvm::BasicBlock * block, bool move_quatum, String const & name) bool isQuantumRegister (llvm::Type const * type) int64_t classifyInstruction (llvm::Instruction const * instr) llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runBlockAnalysis (llvm::Module & module) void setLogger (ILoggerPtr logger) Sets the logger. bool isRequired () Whether or not this pass is required to run. Detailed Description class microsoft::quantum::GroupingPass; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 No measurements \u2502\u2502\u2502 With measurements \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 Before After \u2502 Before After \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 [entry] \u2502 [entry] \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500 [entry] \u2502 [entry] \u2502 \u2502 \u250c\u2500\u2500\u2500 \u2502 \u2502 \u2502 [bb head cc] \u2502 \u2502 \u2502 \u2502 [bb cc] \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 [bb qc] [mixed qc/cc] \u2500\u2500\u25b6 \u2502 [mixed qc/mc/cc]\u2500\u2500\u25b6 \u2502 \u2502 \u2502 \u2502 \u2502 [bb qc] \u2502 \u2502 \u2502 [bb mc] \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500 \u2502 \u2502 [bb2] \u2502 \u2502 [bb2] \u2502 \u2502 [bb tail cc] \u2502 \u2502 [bb2] \u2502 \u2514\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 [bb2] \u2502 Public Types Documentation enum ResourceType Enumerator Value Description UNDEFINED QUBIT RESULT enum @1 Enumerator Value Description PureClassical 0 SourceQuantum 1 DestQuantum 2 PureQuantum SourceQuantum DestQuantum TransferClassicalToQuantum DestQuantum TransferQuantumToClassical SourceQuantum InvalidMixedLocation -1 using Instruction using microsoft::quantum::GroupingPass::Instruction = llvm::Instruction; using Value using microsoft::quantum::GroupingPass::Value = llvm::Value; using ILoggerPtr using microsoft::quantum::GroupingPass::ILoggerPtr = ILogger::ILoggerPtr; using BlockSet using microsoft::quantum::GroupingPass::BlockSet = std::unordered_set<llvm::BasicBlock*>; using SharedBuilder using microsoft::quantum::GroupingPass::SharedBuilder = std::shared_ptr<llvm::IRBuilder<> >; Public Functions Documentation function GroupingPass inline explicit GroupingPass( GroupingPassConfiguration const & cfg ) function GroupingPass GroupingPass( GroupingPass const & ) Copy construction is banned. function GroupingPass GroupingPass( GroupingPass && ) =default We allow move semantics. function ~GroupingPass ~GroupingPass() =default Default destruction. function prepareSourceSeparation void prepareSourceSeparation( llvm::Module & module, llvm::BasicBlock * block ) function nextQuantumCycle void nextQuantumCycle( llvm::Module & module, llvm::BasicBlock * block ) function expandBasedOnSource void expandBasedOnSource( llvm::Module & module, llvm::BasicBlock * block ) function expandBasedOnDest void expandBasedOnDest( llvm::Module & module, llvm::BasicBlock * block, bool move_quatum, String const & name ) function isQuantumRegister bool isQuantumRegister( llvm::Type const * type ) function classifyInstruction int64_t classifyInstruction( llvm::Instruction const * instr ) function run llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function runBlockAnalysis void runBlockAnalysis( llvm::Module & module ) function setLogger void setLogger( ILoggerPtr logger ) Sets the logger. function isRequired static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::GroupingPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#microsoftquantumgroupingpass","text":"More... #include <Passes/GroupingPass/GroupingPass.hpp> Inherits from llvm::PassInfoMixin< GroupingPass >","title":"microsoft::quantum::GroupingPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#public-classes","text":"Name struct ResourceAnalysis","title":"Public Classes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#public-types","text":"Name enum class ResourceType { UNDEFINED, QUBIT, RESULT} enum @1 { PureClassical = 0, SourceQuantum = 1, DestQuantum = 2, PureQuantum = SourceQuantum using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using std::unordered_set< llvm::BasicBlock * > BlockSet using std::shared_ptr< llvm::IRBuilder<> > SharedBuilder","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#public-functions","text":"Name GroupingPass ( GroupingPassConfiguration const & cfg) GroupingPass ( GroupingPass const & ) Copy construction is banned. GroupingPass ( GroupingPass && ) =default We allow move semantics. ~GroupingPass () =default Default destruction. void prepareSourceSeparation (llvm::Module & module, llvm::BasicBlock * block) void nextQuantumCycle (llvm::Module & module, llvm::BasicBlock * block) void expandBasedOnSource (llvm::Module & module, llvm::BasicBlock * block) void expandBasedOnDest (llvm::Module & module, llvm::BasicBlock * block, bool move_quatum, String const & name) bool isQuantumRegister (llvm::Type const * type) int64_t classifyInstruction (llvm::Instruction const * instr) llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runBlockAnalysis (llvm::Module & module) void setLogger (ILoggerPtr logger) Sets the logger. bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#detailed-description","text":"class microsoft::quantum::GroupingPass; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 No measurements \u2502\u2502\u2502 With measurements \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 Before After \u2502 Before After \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 [entry] \u2502 [entry] \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500 [entry] \u2502 [entry] \u2502 \u2502 \u250c\u2500\u2500\u2500 \u2502 \u2502 \u2502 [bb head cc] \u2502 \u2502 \u2502 \u2502 [bb cc] \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 [bb qc] [mixed qc/cc] \u2500\u2500\u25b6 \u2502 [mixed qc/mc/cc]\u2500\u2500\u25b6 \u2502 \u2502 \u2502 \u2502 \u2502 [bb qc] \u2502 \u2502 \u2502 [bb mc] \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500 \u2502 \u2502 [bb2] \u2502 \u2502 [bb2] \u2502 \u2502 [bb tail cc] \u2502 \u2502 [bb2] \u2502 \u2514\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 [bb2] \u2502","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#enum-resourcetype","text":"Enumerator Value Description UNDEFINED QUBIT RESULT","title":"enum ResourceType"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#enum-1","text":"Enumerator Value Description PureClassical 0 SourceQuantum 1 DestQuantum 2 PureQuantum SourceQuantum DestQuantum TransferClassicalToQuantum DestQuantum TransferQuantumToClassical SourceQuantum InvalidMixedLocation -1","title":"enum @1"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#using-instruction","text":"using microsoft::quantum::GroupingPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#using-value","text":"using microsoft::quantum::GroupingPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#using-iloggerptr","text":"using microsoft::quantum::GroupingPass::ILoggerPtr = ILogger::ILoggerPtr;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#using-blockset","text":"using microsoft::quantum::GroupingPass::BlockSet = std::unordered_set<llvm::BasicBlock*>;","title":"using BlockSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#using-sharedbuilder","text":"using microsoft::quantum::GroupingPass::SharedBuilder = std::shared_ptr<llvm::IRBuilder<> >;","title":"using SharedBuilder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-groupingpass","text":"inline explicit GroupingPass( GroupingPassConfiguration const & cfg )","title":"function GroupingPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-groupingpass_1","text":"GroupingPass( GroupingPass const & ) Copy construction is banned.","title":"function GroupingPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-groupingpass_2","text":"GroupingPass( GroupingPass && ) =default We allow move semantics.","title":"function GroupingPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-groupingpass_3","text":"~GroupingPass() =default Default destruction.","title":"function ~GroupingPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-preparesourceseparation","text":"void prepareSourceSeparation( llvm::Module & module, llvm::BasicBlock * block )","title":"function prepareSourceSeparation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-nextquantumcycle","text":"void nextQuantumCycle( llvm::Module & module, llvm::BasicBlock * block )","title":"function nextQuantumCycle"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-expandbasedonsource","text":"void expandBasedOnSource( llvm::Module & module, llvm::BasicBlock * block )","title":"function expandBasedOnSource"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-expandbasedondest","text":"void expandBasedOnDest( llvm::Module & module, llvm::BasicBlock * block, bool move_quatum, String const & name )","title":"function expandBasedOnDest"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-isquantumregister","text":"bool isQuantumRegister( llvm::Type const * type )","title":"function isQuantumRegister"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-classifyinstruction","text":"int64_t classifyInstruction( llvm::Instruction const * instr )","title":"function classifyInstruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-run","text":"llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-runblockanalysis","text":"void runBlockAnalysis( llvm::Module & module )","title":"function runBlockAnalysis"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-setlogger","text":"void setLogger( ILoggerPtr logger ) Sets the logger.","title":"function setLogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/","text":"microsoft::quantum::GroupingPassConfiguration Public Types Name using std::unordered_set< std::string > Set using DeferredValue::DeferredValuePtr DeferredValuePtr Public Functions Name void setup ( ConfigurationManager & config) bool groupQis () const Set irreversibleOperations () const String qirRuntimePrefix () const GroupingPassConfiguration createDisabled () Public Types Documentation using Set using microsoft::quantum::GroupingPassConfiguration::Set = std::unordered_set<std::string>; using DeferredValuePtr using microsoft::quantum::GroupingPassConfiguration::DeferredValuePtr = DeferredValue::DeferredValuePtr; Public Functions Documentation function setup inline void setup( ConfigurationManager & config ) Setup function that adds the configuration flags to the ConfigurationManager . See the ConfigurationManager documentation for more details on how the setup process is implemented. function groupQis inline bool groupQis() const function irreversibleOperations inline Set irreversibleOperations() const function qirRuntimePrefix inline String qirRuntimePrefix() const function createDisabled static inline GroupingPassConfiguration createDisabled() Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::GroupingPassConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/#microsoftquantumgroupingpassconfiguration","text":"","title":"microsoft::quantum::GroupingPassConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/#public-types","text":"Name using std::unordered_set< std::string > Set using DeferredValue::DeferredValuePtr DeferredValuePtr","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/#public-functions","text":"Name void setup ( ConfigurationManager & config) bool groupQis () const Set irreversibleOperations () const String qirRuntimePrefix () const GroupingPassConfiguration createDisabled ()","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/#using-set","text":"using microsoft::quantum::GroupingPassConfiguration::Set = std::unordered_set<std::string>;","title":"using Set"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/#using-deferredvalueptr","text":"using microsoft::quantum::GroupingPassConfiguration::DeferredValuePtr = DeferredValue::DeferredValuePtr;","title":"using DeferredValuePtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/#function-setup","text":"inline void setup( ConfigurationManager & config ) Setup function that adds the configuration flags to the ConfigurationManager . See the ConfigurationManager documentation for more details on how the setup process is implemented.","title":"function setup"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/#function-groupqis","text":"inline bool groupQis() const","title":"function groupQis"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/#function-irreversibleoperations","text":"inline Set irreversibleOperations() const","title":"function irreversibleOperations"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/#function-qirruntimeprefix","text":"inline String qirRuntimePrefix() const","title":"function qirRuntimePrefix"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/#function-createdisabled","text":"static inline GroupingPassConfiguration createDisabled() Updated on 28 October 2022 at 19:30:15 UTC","title":"function createDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/","text":"microsoft::quantum::IAllocationManager More... #include <AllocationManager/IAllocationManager.hpp> Inherited by microsoft::quantum::BasicAllocationManager Public Types Name using uint64_t Address Value type for address. using uint64_t Index Index type used to access an array element. using std::shared_ptr< IAllocationManager > AllocationManagerPtr Pointer interface. Public Functions Name IAllocationManager ( IAllocationManager const & ) IAllocationManager ( IAllocationManager && ) IAllocationManager & operator= ( IAllocationManager const & ) IAllocationManager & operator= ( IAllocationManager && ) virtual ~IAllocationManager () virtual Address allocate (String const & name =\"\", Index const & count =1) =0 virtual void release ( Address const & address) =0 virtual void reset () =0 uint64_t allocationsInUse () const uint64_t maxAllocationsUsed () const Protected Functions Name IAllocationManager () =default void updateRegistersInUse (uint64_t n) Detailed Description class microsoft::quantum::IAllocationManager; Interface class for allocation management. This interface provides means to allocate and release statically allocated resources such as qubits and results. In a future version, it may be extended with get and store in order to support Arrays and Tuples. Public Types Documentation using Address using microsoft::quantum::IAllocationManager::Address = uint64_t; Value type for address. using Index using microsoft::quantum::IAllocationManager::Index = uint64_t; Index type used to access an array element. using AllocationManagerPtr using microsoft::quantum::IAllocationManager::AllocationManagerPtr = std::shared_ptr<IAllocationManager>; Pointer interface. Public Functions Documentation function IAllocationManager IAllocationManager( IAllocationManager const & ) function IAllocationManager IAllocationManager( IAllocationManager && ) function operator= IAllocationManager & operator=( IAllocationManager const & ) function operator= IAllocationManager & operator=( IAllocationManager && ) function ~IAllocationManager virtual ~IAllocationManager() function allocate virtual Address allocate( String const & name =\"\", Index const & count =1 ) =0 Reimplemented by : microsoft::quantum::BasicAllocationManager::allocate Abstract member function to allocate an element or sequence of elements. The developer should not assume continuity of the address segment as this is not guaranteed. Note this function may throw if allocation is not possible. function release virtual void release( Address const & address ) =0 Reimplemented by : microsoft::quantum::BasicAllocationManager::release Abstract member function to release a previously allocated function. Note this function may throw if an invalid address is passed. function reset virtual void reset() =0 Reimplemented by : microsoft::quantum::BasicAllocationManager::reset Abstract member function to reset the allocation manager. This function clears all allocations and resets all statistics. function allocationsInUse uint64_t allocationsInUse() const Current number of registers in use. This function is used to inquire about the current number registers/resources in use. function maxAllocationsUsed uint64_t maxAllocationsUsed() const Maximum number of registers in use at any one time. The maximum number of registers used at any one time. As an example of usage, this function is useful to calculate the total number of qubits required to execute the entry function. Protected Functions Documentation function IAllocationManager IAllocationManager() =default function updateRegistersInUse void updateRegistersInUse( uint64_t n ) Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::IAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#microsoftquantumiallocationmanager","text":"More... #include <AllocationManager/IAllocationManager.hpp> Inherited by microsoft::quantum::BasicAllocationManager","title":"microsoft::quantum::IAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#public-types","text":"Name using uint64_t Address Value type for address. using uint64_t Index Index type used to access an array element. using std::shared_ptr< IAllocationManager > AllocationManagerPtr Pointer interface.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#public-functions","text":"Name IAllocationManager ( IAllocationManager const & ) IAllocationManager ( IAllocationManager && ) IAllocationManager & operator= ( IAllocationManager const & ) IAllocationManager & operator= ( IAllocationManager && ) virtual ~IAllocationManager () virtual Address allocate (String const & name =\"\", Index const & count =1) =0 virtual void release ( Address const & address) =0 virtual void reset () =0 uint64_t allocationsInUse () const uint64_t maxAllocationsUsed () const","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#protected-functions","text":"Name IAllocationManager () =default void updateRegistersInUse (uint64_t n)","title":"Protected Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#detailed-description","text":"class microsoft::quantum::IAllocationManager; Interface class for allocation management. This interface provides means to allocate and release statically allocated resources such as qubits and results. In a future version, it may be extended with get and store in order to support Arrays and Tuples.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#using-address","text":"using microsoft::quantum::IAllocationManager::Address = uint64_t; Value type for address.","title":"using Address"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#using-index","text":"using microsoft::quantum::IAllocationManager::Index = uint64_t; Index type used to access an array element.","title":"using Index"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#using-allocationmanagerptr","text":"using microsoft::quantum::IAllocationManager::AllocationManagerPtr = std::shared_ptr<IAllocationManager>; Pointer interface.","title":"using AllocationManagerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-iallocationmanager","text":"IAllocationManager( IAllocationManager const & )","title":"function IAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-iallocationmanager_1","text":"IAllocationManager( IAllocationManager && )","title":"function IAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-operator","text":"IAllocationManager & operator=( IAllocationManager const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-operator_1","text":"IAllocationManager & operator=( IAllocationManager && )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-iallocationmanager_2","text":"virtual ~IAllocationManager()","title":"function ~IAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-allocate","text":"virtual Address allocate( String const & name =\"\", Index const & count =1 ) =0 Reimplemented by : microsoft::quantum::BasicAllocationManager::allocate Abstract member function to allocate an element or sequence of elements. The developer should not assume continuity of the address segment as this is not guaranteed. Note this function may throw if allocation is not possible.","title":"function allocate"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-release","text":"virtual void release( Address const & address ) =0 Reimplemented by : microsoft::quantum::BasicAllocationManager::release Abstract member function to release a previously allocated function. Note this function may throw if an invalid address is passed.","title":"function release"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-reset","text":"virtual void reset() =0 Reimplemented by : microsoft::quantum::BasicAllocationManager::reset Abstract member function to reset the allocation manager. This function clears all allocations and resets all statistics.","title":"function reset"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-allocationsinuse","text":"uint64_t allocationsInUse() const Current number of registers in use. This function is used to inquire about the current number registers/resources in use.","title":"function allocationsInUse"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-maxallocationsused","text":"uint64_t maxAllocationsUsed() const Maximum number of registers in use at any one time. The maximum number of registers used at any one time. As an example of usage, this function is useful to calculate the total number of qubits required to execute the entry function.","title":"function maxAllocationsUsed"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-iallocationmanager_3","text":"IAllocationManager() =default","title":"function IAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-updateregistersinuse","text":"void updateRegistersInUse( uint64_t n ) Updated on 28 October 2022 at 19:30:15 UTC","title":"function updateRegistersInUse"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/","text":"microsoft::quantum::IConfigBind More... #include <Commandline/IConfigBind.hpp> Inherited by microsoft::quantum::ConfigBind< T > Public Types Name enum ParameterVisibility { None = 0, CliOnly = 1, ConfigOnly = 2, CliAndConfig = CliOnly Public Functions Name IConfigBind ( IConfigBind const & ) IConfigBind ( IConfigBind && ) IConfigBind & operator= ( IConfigBind const & ) IConfigBind & operator= ( IConfigBind && ) virtual ~IConfigBind () virtual bool setupArguments ( ParameterParser & parser) =0 virtual bool configure ( ParameterParser & parser, bool experimental_mode) =0 virtual void reset () =0 Resets the value to the default value. virtual String value () =0 virtual void * pointer () const =0 Pointer to underlying data. virtual void * pointerDefaultValue () =0 Pointer to underlying default value. virtual std::type_index valueType () const =0 Type index of contained data. virtual void setValueFromYamlNode (YAML::Node const & node) =0 Method to load value from YAML configuration. virtual void updateValueInYamlNode (YAML::Node & node) =0 Dumps the current value to the node. String name () const Returns the name of the bound configuration variable. String description () const Returns the description of the configuration variable. bool isFlag () const Indicates whether or not this. String defaultValue () const Returns the default value for the flag. bool isExperimental () const Indicates whether or not this is an experimental config. bool isLoadAndSavable () const bool isAvailableToCli () const Indicates whether or not this paramter is available to the CLI. void setShorthandNotation (String const & name) Set shorthand notation. String shorthandNotation () const Gets shorthand notation. Protected Functions Name IConfigBind (String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig) void setName (String const & name) Sets the name of the configuration variable. void markAsFlag () Marks the variable as a flag. void setDefault (String const & v) Sets the default value as a string. void makeSettingExperimental () Marks the config as experimental. Detailed Description class microsoft::quantum::IConfigBind; Interface class to bind a variable to a configuration flag. This class provides the necessary interface to bind variables and populate their value based on given command-line arguments. Public Types Documentation enum ParameterVisibility Enumerator Value Description None 0 CliOnly 1 ConfigOnly 2 CliAndConfig CliOnly ConfigOnly Public Functions Documentation function IConfigBind IConfigBind( IConfigBind const & ) function IConfigBind IConfigBind( IConfigBind && ) function operator= IConfigBind & operator=( IConfigBind const & ) function operator= IConfigBind & operator=( IConfigBind && ) function ~IConfigBind virtual ~IConfigBind() function setupArguments virtual bool setupArguments( ParameterParser & parser ) =0 Reimplemented by : microsoft::quantum::ConfigBind::setupArguments Interface function to register configuration in the parser. This function register the configuration to the parameter parser. This makes the configuration available in the parameter parsers help function. This method should return true if arguments were successfully setup. function configure virtual bool configure( ParameterParser & parser, bool experimental_mode ) =0 Reimplemented by : microsoft::quantum::ConfigBind::configure Interface function to extract configuration from the command line arguments. Given an instance of the command line parameter parser, this function is meant to read the command line arguments, interpret it and set the bound variable value (if present). This method should return true if configure operation was successful. function reset virtual void reset() =0 Resets the value to the default value. Reimplemented by : microsoft::quantum::ConfigBind::reset function value virtual String value() =0 Reimplemented by : microsoft::quantum::ConfigBind::value Interface function to return a string representation of the current value of the bound variable. function pointer virtual void * pointer() const =0 Pointer to underlying data. Reimplemented by : microsoft::quantum::ConfigBind::pointer function pointerDefaultValue virtual void * pointerDefaultValue() =0 Pointer to underlying default value. Reimplemented by : microsoft::quantum::ConfigBind::pointerDefaultValue function valueType virtual std::type_index valueType() const =0 Type index of contained data. Reimplemented by : microsoft::quantum::ConfigBind::valueType function setValueFromYamlNode virtual void setValueFromYamlNode( YAML::Node const & node ) =0 Method to load value from YAML configuration. Reimplemented by : microsoft::quantum::ConfigBind::setValueFromYamlNode function updateValueInYamlNode virtual void updateValueInYamlNode( YAML::Node & node ) =0 Dumps the current value to the node. Reimplemented by : microsoft::quantum::ConfigBind::updateValueInYamlNode function name String name() const Returns the name of the bound configuration variable. function description String description() const Returns the description of the configuration variable. function isFlag bool isFlag() const Indicates whether or not this. function defaultValue String defaultValue() const Returns the default value for the flag. function isExperimental bool isExperimental() const Indicates whether or not this is an experimental config. function isLoadAndSavable bool isLoadAndSavable() const Indicates whether the load and save functions should serialize this configuration. function isAvailableToCli bool isAvailableToCli() const Indicates whether or not this paramter is available to the CLI. function setShorthandNotation void setShorthandNotation( String const & name ) Set shorthand notation. function shorthandNotation String shorthandNotation() const Gets shorthand notation. Protected Functions Documentation function IConfigBind IConfigBind( String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig ) function setName void setName( String const & name ) Sets the name of the configuration variable. function markAsFlag void markAsFlag() Marks the variable as a flag. function setDefault void setDefault( String const & v ) Sets the default value as a string. function makeSettingExperimental void makeSettingExperimental() Marks the config as experimental. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::IConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#microsoftquantumiconfigbind","text":"More... #include <Commandline/IConfigBind.hpp> Inherited by microsoft::quantum::ConfigBind< T >","title":"microsoft::quantum::IConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#public-types","text":"Name enum ParameterVisibility { None = 0, CliOnly = 1, ConfigOnly = 2, CliAndConfig = CliOnly","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#public-functions","text":"Name IConfigBind ( IConfigBind const & ) IConfigBind ( IConfigBind && ) IConfigBind & operator= ( IConfigBind const & ) IConfigBind & operator= ( IConfigBind && ) virtual ~IConfigBind () virtual bool setupArguments ( ParameterParser & parser) =0 virtual bool configure ( ParameterParser & parser, bool experimental_mode) =0 virtual void reset () =0 Resets the value to the default value. virtual String value () =0 virtual void * pointer () const =0 Pointer to underlying data. virtual void * pointerDefaultValue () =0 Pointer to underlying default value. virtual std::type_index valueType () const =0 Type index of contained data. virtual void setValueFromYamlNode (YAML::Node const & node) =0 Method to load value from YAML configuration. virtual void updateValueInYamlNode (YAML::Node & node) =0 Dumps the current value to the node. String name () const Returns the name of the bound configuration variable. String description () const Returns the description of the configuration variable. bool isFlag () const Indicates whether or not this. String defaultValue () const Returns the default value for the flag. bool isExperimental () const Indicates whether or not this is an experimental config. bool isLoadAndSavable () const bool isAvailableToCli () const Indicates whether or not this paramter is available to the CLI. void setShorthandNotation (String const & name) Set shorthand notation. String shorthandNotation () const Gets shorthand notation.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#protected-functions","text":"Name IConfigBind (String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig) void setName (String const & name) Sets the name of the configuration variable. void markAsFlag () Marks the variable as a flag. void setDefault (String const & v) Sets the default value as a string. void makeSettingExperimental () Marks the config as experimental.","title":"Protected Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#detailed-description","text":"class microsoft::quantum::IConfigBind; Interface class to bind a variable to a configuration flag. This class provides the necessary interface to bind variables and populate their value based on given command-line arguments.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#enum-parametervisibility","text":"Enumerator Value Description None 0 CliOnly 1 ConfigOnly 2 CliAndConfig CliOnly ConfigOnly","title":"enum ParameterVisibility"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-iconfigbind","text":"IConfigBind( IConfigBind const & )","title":"function IConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-iconfigbind_1","text":"IConfigBind( IConfigBind && )","title":"function IConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-operator","text":"IConfigBind & operator=( IConfigBind const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-operator_1","text":"IConfigBind & operator=( IConfigBind && )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-iconfigbind_2","text":"virtual ~IConfigBind()","title":"function ~IConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-setuparguments","text":"virtual bool setupArguments( ParameterParser & parser ) =0 Reimplemented by : microsoft::quantum::ConfigBind::setupArguments Interface function to register configuration in the parser. This function register the configuration to the parameter parser. This makes the configuration available in the parameter parsers help function. This method should return true if arguments were successfully setup.","title":"function setupArguments"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-configure","text":"virtual bool configure( ParameterParser & parser, bool experimental_mode ) =0 Reimplemented by : microsoft::quantum::ConfigBind::configure Interface function to extract configuration from the command line arguments. Given an instance of the command line parameter parser, this function is meant to read the command line arguments, interpret it and set the bound variable value (if present). This method should return true if configure operation was successful.","title":"function configure"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-reset","text":"virtual void reset() =0 Resets the value to the default value. Reimplemented by : microsoft::quantum::ConfigBind::reset","title":"function reset"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-value","text":"virtual String value() =0 Reimplemented by : microsoft::quantum::ConfigBind::value Interface function to return a string representation of the current value of the bound variable.","title":"function value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-pointer","text":"virtual void * pointer() const =0 Pointer to underlying data. Reimplemented by : microsoft::quantum::ConfigBind::pointer","title":"function pointer"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-pointerdefaultvalue","text":"virtual void * pointerDefaultValue() =0 Pointer to underlying default value. Reimplemented by : microsoft::quantum::ConfigBind::pointerDefaultValue","title":"function pointerDefaultValue"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-valuetype","text":"virtual std::type_index valueType() const =0 Type index of contained data. Reimplemented by : microsoft::quantum::ConfigBind::valueType","title":"function valueType"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-setvaluefromyamlnode","text":"virtual void setValueFromYamlNode( YAML::Node const & node ) =0 Method to load value from YAML configuration. Reimplemented by : microsoft::quantum::ConfigBind::setValueFromYamlNode","title":"function setValueFromYamlNode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-updatevalueinyamlnode","text":"virtual void updateValueInYamlNode( YAML::Node & node ) =0 Dumps the current value to the node. Reimplemented by : microsoft::quantum::ConfigBind::updateValueInYamlNode","title":"function updateValueInYamlNode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-name","text":"String name() const Returns the name of the bound configuration variable.","title":"function name"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-description","text":"String description() const Returns the description of the configuration variable.","title":"function description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-isflag","text":"bool isFlag() const Indicates whether or not this.","title":"function isFlag"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-defaultvalue","text":"String defaultValue() const Returns the default value for the flag.","title":"function defaultValue"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-isexperimental","text":"bool isExperimental() const Indicates whether or not this is an experimental config.","title":"function isExperimental"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-isloadandsavable","text":"bool isLoadAndSavable() const Indicates whether the load and save functions should serialize this configuration.","title":"function isLoadAndSavable"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-isavailabletocli","text":"bool isAvailableToCli() const Indicates whether or not this paramter is available to the CLI.","title":"function isAvailableToCli"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-setshorthandnotation","text":"void setShorthandNotation( String const & name ) Set shorthand notation.","title":"function setShorthandNotation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-shorthandnotation","text":"String shorthandNotation() const Gets shorthand notation.","title":"function shorthandNotation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-iconfigbind_3","text":"IConfigBind( String const & name, String const & description, ParameterVisibility visibility =ParameterVisibility::CliAndConfig )","title":"function IConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-setname","text":"void setName( String const & name ) Sets the name of the configuration variable.","title":"function setName"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-markasflag","text":"void markAsFlag() Marks the variable as a flag.","title":"function markAsFlag"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-setdefault","text":"void setDefault( String const & v ) Sets the default value as a string.","title":"function setDefault"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-makesettingexperimental","text":"void makeSettingExperimental() Marks the config as experimental. Updated on 28 October 2022 at 19:30:15 UTC","title":"function makeSettingExperimental"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/","text":"microsoft::quantum::ILogger More... #include <Logging/ILogger.hpp> Inherited by microsoft::quantum::CommentLogger , microsoft::quantum::LogCollection Public Classes Name struct Location Class that holds the location of where the incident happened. struct Message Struct to hold a message together with its type and location. Public Types Name enum class Type { Debug, Info, Warning, Error, InternalError} Enum description what type of information we are conveying. using llvm::Value Value using std::function< SourceLocation (Value const *)> LocationResolver using std::function< SourceLocation (String const &)> LocationFromNameResolver using std::shared_ptr< ILogger > ILoggerPtr using std::vector< Message > Messages List of messages defined as alias. Public Functions Name ILogger () =default ILogger ( ILogger const & ) ILogger ( ILogger && ) ILogger & operator= ( ILogger const & ) ILogger & operator= ( ILogger && ) virtual ~ILogger () virtual void debug (String const & message) =0 Reports a debug message. virtual void info (String const & message) =0 Reports an info message. virtual void warning (String const & message) =0 Reports a warning message. virtual void error (String const & message) =0 Reports an error message. virtual void internalError (String const & message) =0 Reports an internal error message. virtual void setLocation ( SourceLocation const & location) =0 virtual void setLlvmHint (String const & value) =0 Sets the value of the LLVM instruction causing the issue. virtual void setFrontendHint (String const & value) =0 Sets the value of the frontend instruction causing the issue. virtual Messages const & messages () const virtual void dump (std::ostream & out) const void setLocationFromValue (llvm::Value const * value) Sets the logger position based on a LLVM value. void setLocationFromFunctionName (String const & name) Sets the logger position based on function name. void setLocationResolver (LocationResolver const & r) Sets a resolver which that translates a LLVM value into a position in the source. void setLocationFromNameResolver (LocationFromNameResolver const & r) Sets a resolver which that translates function name into a position in the source. SourceLocation resolveLocation (llvm::Value const * value) Returns a source location from the value pointer (if possible) bool hadErrors () const Whether or not errors were logged. bool hadWarnings () const Whether or not warnings were logged. void errorWithLocation (String const & message, llvm::Value * ptr =nullptr) void warningWithLocation (String const & message, llvm::Value * ptr =nullptr) virtual void errorCouldNotDeleteNode (llvm::Value * ptr =nullptr) Standard messages. virtual void errorExpectedStraightLineCodeMultipleFunctions (llvm::Value * ptr =nullptr) virtual void errorExpectedStraightLineCodeMultipleBlocks (llvm::Value * ptr =nullptr) virtual void errorReleaseFailNonStandardAlloc (llvm::Value * ptr =nullptr) virtual void warningReleasePhiNodeQubit (llvm::Value * ptr =nullptr) virtual void errorFunctionInliningMaxRecursion (uint64_t n, llvm::Value * ptr =nullptr) virtual void errorNoQubitsPresent (llvm::Value * ptr =nullptr, String const & name =\"unnamed\") virtual void errorNoResultsPresent (llvm::Value * ptr =nullptr, String const & name =\"unnamed\") virtual void errorOpcodeNotAllowed (String const & code, String const & target_name, llvm::Value * ptr =nullptr) virtual void errorCustomFunctionsNotAllowed (llvm::Value * ptr =nullptr) virtual void errorExternalCallsNotAllowed (String const & function_name, String const & target_name, llvm::Value * ptr =nullptr) virtual void errorTypeNotAllowed (String const & type_name, String const & target_name, llvm::Value * ptr =nullptr) virtual void errorPoisonNotAllowed (String const & target_name, llvm::Value * ptr =nullptr) virtual void errorUndefNotAllowed (String const & target_name, llvm::Value * ptr =nullptr) virtual void errorExpectedStringValueForAttr (String const & function_name, String const & attr_name) virtual void warningWeakLinkReplacementNotPossible (String const & function_name, String const & replacement) virtual void errorReplacementSignatureMismatch (String const & function_name, String const & signature1, String const & signature2) Protected Functions Name void setHasErrors (bool value) void setHasWarnings (bool value) Detailed Description class microsoft::quantum::ILogger; Logger interface to allow the collection of different types of messages during QIR transformation and/or validation. Public Types Documentation enum Type Enumerator Value Description Debug Info Warning Error InternalError Enum description what type of information we are conveying. using Value using microsoft::quantum::ILogger::Value = llvm::Value; using LocationResolver using microsoft::quantum::ILogger::LocationResolver = std::function<SourceLocation(Value const*)>; using LocationFromNameResolver using microsoft::quantum::ILogger::LocationFromNameResolver = std::function<SourceLocation(String const&)>; using ILoggerPtr using microsoft::quantum::ILogger::ILoggerPtr = std::shared_ptr<ILogger>; using Messages using microsoft::quantum::ILogger::Messages = std::vector<Message>; List of messages defined as alias. Public Functions Documentation function ILogger ILogger() =default function ILogger ILogger( ILogger const & ) function ILogger ILogger( ILogger && ) function operator= ILogger & operator=( ILogger const & ) function operator= ILogger & operator=( ILogger && ) function ~ILogger virtual ~ILogger() function debug virtual void debug( String const & message ) =0 Reports a debug message. Reimplemented by : microsoft::quantum::CommentLogger::debug , microsoft::quantum::LogCollection::debug function info virtual void info( String const & message ) =0 Reports an info message. Reimplemented by : microsoft::quantum::CommentLogger::info , microsoft::quantum::LogCollection::info function warning virtual void warning( String const & message ) =0 Reports a warning message. Reimplemented by : microsoft::quantum::CommentLogger::warning , microsoft::quantum::LogCollection::warning function error virtual void error( String const & message ) =0 Reports an error message. Reimplemented by : microsoft::quantum::CommentLogger::error , microsoft::quantum::LogCollection::error function internalError virtual void internalError( String const & message ) =0 Reports an internal error message. Reimplemented by : microsoft::quantum::CommentLogger::internalError , microsoft::quantum::LogCollection::internalError function setLocation virtual void setLocation( SourceLocation const & location ) =0 Reimplemented by : microsoft::quantum::CommentLogger::setLocation , microsoft::quantum::LogCollection::setLocation Sets the current location. Importantly, the location can be set independently of the reported messages. This allows one to update the location upon updating the cursor position without having to worry about keeping a copy of the location to pass when reporting messages. The most obvious case of this is file path (name) with a line and character (line, col). function setLlvmHint virtual void setLlvmHint( String const & value ) =0 Sets the value of the LLVM instruction causing the issue. Reimplemented by : microsoft::quantum::CommentLogger::setLlvmHint , microsoft::quantum::LogCollection::setLlvmHint function setFrontendHint virtual void setFrontendHint( String const & value ) =0 Sets the value of the frontend instruction causing the issue. Reimplemented by : microsoft::quantum::CommentLogger::setFrontendHint , microsoft::quantum::LogCollection::setFrontendHint function messages virtual Messages const & messages() const Reimplemented by : microsoft::quantum::LogCollection::messages function dump virtual void dump( std::ostream & out ) const Reimplemented by : microsoft::quantum::LogCollection::dump function setLocationFromValue void setLocationFromValue( llvm::Value const * value ) Sets the logger position based on a LLVM value. function setLocationFromFunctionName void setLocationFromFunctionName( String const & name ) Sets the logger position based on function name. function setLocationResolver void setLocationResolver( LocationResolver const & r ) Sets a resolver which that translates a LLVM value into a position in the source. function setLocationFromNameResolver void setLocationFromNameResolver( LocationFromNameResolver const & r ) Sets a resolver which that translates function name into a position in the source. function resolveLocation SourceLocation resolveLocation( llvm::Value const * value ) Returns a source location from the value pointer (if possible) function hadErrors bool hadErrors() const Whether or not errors were logged. function hadWarnings bool hadWarnings() const Whether or not warnings were logged. function errorWithLocation void errorWithLocation( String const & message, llvm::Value * ptr =nullptr ) function warningWithLocation void warningWithLocation( String const & message, llvm::Value * ptr =nullptr ) function errorCouldNotDeleteNode virtual void errorCouldNotDeleteNode( llvm::Value * ptr =nullptr ) Standard messages. function errorExpectedStraightLineCodeMultipleFunctions virtual void errorExpectedStraightLineCodeMultipleFunctions( llvm::Value * ptr =nullptr ) function errorExpectedStraightLineCodeMultipleBlocks virtual void errorExpectedStraightLineCodeMultipleBlocks( llvm::Value * ptr =nullptr ) function errorReleaseFailNonStandardAlloc virtual void errorReleaseFailNonStandardAlloc( llvm::Value * ptr =nullptr ) function warningReleasePhiNodeQubit virtual void warningReleasePhiNodeQubit( llvm::Value * ptr =nullptr ) function errorFunctionInliningMaxRecursion virtual void errorFunctionInliningMaxRecursion( uint64_t n, llvm::Value * ptr =nullptr ) function errorNoQubitsPresent virtual void errorNoQubitsPresent( llvm::Value * ptr =nullptr, String const & name =\"unnamed\" ) function errorNoResultsPresent virtual void errorNoResultsPresent( llvm::Value * ptr =nullptr, String const & name =\"unnamed\" ) function errorOpcodeNotAllowed virtual void errorOpcodeNotAllowed( String const & code, String const & target_name, llvm::Value * ptr =nullptr ) function errorCustomFunctionsNotAllowed virtual void errorCustomFunctionsNotAllowed( llvm::Value * ptr =nullptr ) function errorExternalCallsNotAllowed virtual void errorExternalCallsNotAllowed( String const & function_name, String const & target_name, llvm::Value * ptr =nullptr ) function errorTypeNotAllowed virtual void errorTypeNotAllowed( String const & type_name, String const & target_name, llvm::Value * ptr =nullptr ) function errorPoisonNotAllowed virtual void errorPoisonNotAllowed( String const & target_name, llvm::Value * ptr =nullptr ) function errorUndefNotAllowed virtual void errorUndefNotAllowed( String const & target_name, llvm::Value * ptr =nullptr ) function errorExpectedStringValueForAttr virtual void errorExpectedStringValueForAttr( String const & function_name, String const & attr_name ) function warningWeakLinkReplacementNotPossible virtual void warningWeakLinkReplacementNotPossible( String const & function_name, String const & replacement ) function errorReplacementSignatureMismatch virtual void errorReplacementSignatureMismatch( String const & function_name, String const & signature1, String const & signature2 ) Protected Functions Documentation function setHasErrors void setHasErrors( bool value ) function setHasWarnings void setHasWarnings( bool value ) Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::ILogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#microsoftquantumilogger","text":"More... #include <Logging/ILogger.hpp> Inherited by microsoft::quantum::CommentLogger , microsoft::quantum::LogCollection","title":"microsoft::quantum::ILogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#public-classes","text":"Name struct Location Class that holds the location of where the incident happened. struct Message Struct to hold a message together with its type and location.","title":"Public Classes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#public-types","text":"Name enum class Type { Debug, Info, Warning, Error, InternalError} Enum description what type of information we are conveying. using llvm::Value Value using std::function< SourceLocation (Value const *)> LocationResolver using std::function< SourceLocation (String const &)> LocationFromNameResolver using std::shared_ptr< ILogger > ILoggerPtr using std::vector< Message > Messages List of messages defined as alias.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#public-functions","text":"Name ILogger () =default ILogger ( ILogger const & ) ILogger ( ILogger && ) ILogger & operator= ( ILogger const & ) ILogger & operator= ( ILogger && ) virtual ~ILogger () virtual void debug (String const & message) =0 Reports a debug message. virtual void info (String const & message) =0 Reports an info message. virtual void warning (String const & message) =0 Reports a warning message. virtual void error (String const & message) =0 Reports an error message. virtual void internalError (String const & message) =0 Reports an internal error message. virtual void setLocation ( SourceLocation const & location) =0 virtual void setLlvmHint (String const & value) =0 Sets the value of the LLVM instruction causing the issue. virtual void setFrontendHint (String const & value) =0 Sets the value of the frontend instruction causing the issue. virtual Messages const & messages () const virtual void dump (std::ostream & out) const void setLocationFromValue (llvm::Value const * value) Sets the logger position based on a LLVM value. void setLocationFromFunctionName (String const & name) Sets the logger position based on function name. void setLocationResolver (LocationResolver const & r) Sets a resolver which that translates a LLVM value into a position in the source. void setLocationFromNameResolver (LocationFromNameResolver const & r) Sets a resolver which that translates function name into a position in the source. SourceLocation resolveLocation (llvm::Value const * value) Returns a source location from the value pointer (if possible) bool hadErrors () const Whether or not errors were logged. bool hadWarnings () const Whether or not warnings were logged. void errorWithLocation (String const & message, llvm::Value * ptr =nullptr) void warningWithLocation (String const & message, llvm::Value * ptr =nullptr) virtual void errorCouldNotDeleteNode (llvm::Value * ptr =nullptr) Standard messages. virtual void errorExpectedStraightLineCodeMultipleFunctions (llvm::Value * ptr =nullptr) virtual void errorExpectedStraightLineCodeMultipleBlocks (llvm::Value * ptr =nullptr) virtual void errorReleaseFailNonStandardAlloc (llvm::Value * ptr =nullptr) virtual void warningReleasePhiNodeQubit (llvm::Value * ptr =nullptr) virtual void errorFunctionInliningMaxRecursion (uint64_t n, llvm::Value * ptr =nullptr) virtual void errorNoQubitsPresent (llvm::Value * ptr =nullptr, String const & name =\"unnamed\") virtual void errorNoResultsPresent (llvm::Value * ptr =nullptr, String const & name =\"unnamed\") virtual void errorOpcodeNotAllowed (String const & code, String const & target_name, llvm::Value * ptr =nullptr) virtual void errorCustomFunctionsNotAllowed (llvm::Value * ptr =nullptr) virtual void errorExternalCallsNotAllowed (String const & function_name, String const & target_name, llvm::Value * ptr =nullptr) virtual void errorTypeNotAllowed (String const & type_name, String const & target_name, llvm::Value * ptr =nullptr) virtual void errorPoisonNotAllowed (String const & target_name, llvm::Value * ptr =nullptr) virtual void errorUndefNotAllowed (String const & target_name, llvm::Value * ptr =nullptr) virtual void errorExpectedStringValueForAttr (String const & function_name, String const & attr_name) virtual void warningWeakLinkReplacementNotPossible (String const & function_name, String const & replacement) virtual void errorReplacementSignatureMismatch (String const & function_name, String const & signature1, String const & signature2)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#protected-functions","text":"Name void setHasErrors (bool value) void setHasWarnings (bool value)","title":"Protected Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#detailed-description","text":"class microsoft::quantum::ILogger; Logger interface to allow the collection of different types of messages during QIR transformation and/or validation.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#enum-type","text":"Enumerator Value Description Debug Info Warning Error InternalError Enum description what type of information we are conveying.","title":"enum Type"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#using-value","text":"using microsoft::quantum::ILogger::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#using-locationresolver","text":"using microsoft::quantum::ILogger::LocationResolver = std::function<SourceLocation(Value const*)>;","title":"using LocationResolver"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#using-locationfromnameresolver","text":"using microsoft::quantum::ILogger::LocationFromNameResolver = std::function<SourceLocation(String const&)>;","title":"using LocationFromNameResolver"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#using-iloggerptr","text":"using microsoft::quantum::ILogger::ILoggerPtr = std::shared_ptr<ILogger>;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#using-messages","text":"using microsoft::quantum::ILogger::Messages = std::vector<Message>; List of messages defined as alias.","title":"using Messages"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-ilogger","text":"ILogger() =default","title":"function ILogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-ilogger_1","text":"ILogger( ILogger const & )","title":"function ILogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-ilogger_2","text":"ILogger( ILogger && )","title":"function ILogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-operator","text":"ILogger & operator=( ILogger const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-operator_1","text":"ILogger & operator=( ILogger && )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-ilogger_3","text":"virtual ~ILogger()","title":"function ~ILogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-debug","text":"virtual void debug( String const & message ) =0 Reports a debug message. Reimplemented by : microsoft::quantum::CommentLogger::debug , microsoft::quantum::LogCollection::debug","title":"function debug"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-info","text":"virtual void info( String const & message ) =0 Reports an info message. Reimplemented by : microsoft::quantum::CommentLogger::info , microsoft::quantum::LogCollection::info","title":"function info"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-warning","text":"virtual void warning( String const & message ) =0 Reports a warning message. Reimplemented by : microsoft::quantum::CommentLogger::warning , microsoft::quantum::LogCollection::warning","title":"function warning"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-error","text":"virtual void error( String const & message ) =0 Reports an error message. Reimplemented by : microsoft::quantum::CommentLogger::error , microsoft::quantum::LogCollection::error","title":"function error"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-internalerror","text":"virtual void internalError( String const & message ) =0 Reports an internal error message. Reimplemented by : microsoft::quantum::CommentLogger::internalError , microsoft::quantum::LogCollection::internalError","title":"function internalError"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-setlocation","text":"virtual void setLocation( SourceLocation const & location ) =0 Reimplemented by : microsoft::quantum::CommentLogger::setLocation , microsoft::quantum::LogCollection::setLocation Sets the current location. Importantly, the location can be set independently of the reported messages. This allows one to update the location upon updating the cursor position without having to worry about keeping a copy of the location to pass when reporting messages. The most obvious case of this is file path (name) with a line and character (line, col).","title":"function setLocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-setllvmhint","text":"virtual void setLlvmHint( String const & value ) =0 Sets the value of the LLVM instruction causing the issue. Reimplemented by : microsoft::quantum::CommentLogger::setLlvmHint , microsoft::quantum::LogCollection::setLlvmHint","title":"function setLlvmHint"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-setfrontendhint","text":"virtual void setFrontendHint( String const & value ) =0 Sets the value of the frontend instruction causing the issue. Reimplemented by : microsoft::quantum::CommentLogger::setFrontendHint , microsoft::quantum::LogCollection::setFrontendHint","title":"function setFrontendHint"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-messages","text":"virtual Messages const & messages() const Reimplemented by : microsoft::quantum::LogCollection::messages","title":"function messages"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-dump","text":"virtual void dump( std::ostream & out ) const Reimplemented by : microsoft::quantum::LogCollection::dump","title":"function dump"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-setlocationfromvalue","text":"void setLocationFromValue( llvm::Value const * value ) Sets the logger position based on a LLVM value.","title":"function setLocationFromValue"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-setlocationfromfunctionname","text":"void setLocationFromFunctionName( String const & name ) Sets the logger position based on function name.","title":"function setLocationFromFunctionName"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-setlocationresolver","text":"void setLocationResolver( LocationResolver const & r ) Sets a resolver which that translates a LLVM value into a position in the source.","title":"function setLocationResolver"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-setlocationfromnameresolver","text":"void setLocationFromNameResolver( LocationFromNameResolver const & r ) Sets a resolver which that translates function name into a position in the source.","title":"function setLocationFromNameResolver"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-resolvelocation","text":"SourceLocation resolveLocation( llvm::Value const * value ) Returns a source location from the value pointer (if possible)","title":"function resolveLocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-haderrors","text":"bool hadErrors() const Whether or not errors were logged.","title":"function hadErrors"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-hadwarnings","text":"bool hadWarnings() const Whether or not warnings were logged.","title":"function hadWarnings"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-errorwithlocation","text":"void errorWithLocation( String const & message, llvm::Value * ptr =nullptr )","title":"function errorWithLocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-warningwithlocation","text":"void warningWithLocation( String const & message, llvm::Value * ptr =nullptr )","title":"function warningWithLocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-errorcouldnotdeletenode","text":"virtual void errorCouldNotDeleteNode( llvm::Value * ptr =nullptr ) Standard messages.","title":"function errorCouldNotDeleteNode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-errorexpectedstraightlinecodemultiplefunctions","text":"virtual void errorExpectedStraightLineCodeMultipleFunctions( llvm::Value * ptr =nullptr )","title":"function errorExpectedStraightLineCodeMultipleFunctions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-errorexpectedstraightlinecodemultipleblocks","text":"virtual void errorExpectedStraightLineCodeMultipleBlocks( llvm::Value * ptr =nullptr )","title":"function errorExpectedStraightLineCodeMultipleBlocks"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-errorreleasefailnonstandardalloc","text":"virtual void errorReleaseFailNonStandardAlloc( llvm::Value * ptr =nullptr )","title":"function errorReleaseFailNonStandardAlloc"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-warningreleasephinodequbit","text":"virtual void warningReleasePhiNodeQubit( llvm::Value * ptr =nullptr )","title":"function warningReleasePhiNodeQubit"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-errorfunctioninliningmaxrecursion","text":"virtual void errorFunctionInliningMaxRecursion( uint64_t n, llvm::Value * ptr =nullptr )","title":"function errorFunctionInliningMaxRecursion"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-errornoqubitspresent","text":"virtual void errorNoQubitsPresent( llvm::Value * ptr =nullptr, String const & name =\"unnamed\" )","title":"function errorNoQubitsPresent"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-errornoresultspresent","text":"virtual void errorNoResultsPresent( llvm::Value * ptr =nullptr, String const & name =\"unnamed\" )","title":"function errorNoResultsPresent"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-erroropcodenotallowed","text":"virtual void errorOpcodeNotAllowed( String const & code, String const & target_name, llvm::Value * ptr =nullptr )","title":"function errorOpcodeNotAllowed"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-errorcustomfunctionsnotallowed","text":"virtual void errorCustomFunctionsNotAllowed( llvm::Value * ptr =nullptr )","title":"function errorCustomFunctionsNotAllowed"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-errorexternalcallsnotallowed","text":"virtual void errorExternalCallsNotAllowed( String const & function_name, String const & target_name, llvm::Value * ptr =nullptr )","title":"function errorExternalCallsNotAllowed"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-errortypenotallowed","text":"virtual void errorTypeNotAllowed( String const & type_name, String const & target_name, llvm::Value * ptr =nullptr )","title":"function errorTypeNotAllowed"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-errorpoisonnotallowed","text":"virtual void errorPoisonNotAllowed( String const & target_name, llvm::Value * ptr =nullptr )","title":"function errorPoisonNotAllowed"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-errorundefnotallowed","text":"virtual void errorUndefNotAllowed( String const & target_name, llvm::Value * ptr =nullptr )","title":"function errorUndefNotAllowed"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-errorexpectedstringvalueforattr","text":"virtual void errorExpectedStringValueForAttr( String const & function_name, String const & attr_name )","title":"function errorExpectedStringValueForAttr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-warningweaklinkreplacementnotpossible","text":"virtual void warningWeakLinkReplacementNotPossible( String const & function_name, String const & replacement )","title":"function warningWeakLinkReplacementNotPossible"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-errorreplacementsignaturemismatch","text":"virtual void errorReplacementSignatureMismatch( String const & function_name, String const & signature1, String const & signature2 )","title":"function errorReplacementSignatureMismatch"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-sethaserrors","text":"void setHasErrors( bool value )","title":"function setHasErrors"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-sethaswarnings","text":"void setHasWarnings( bool value ) Updated on 28 October 2022 at 19:30:15 UTC","title":"function setHasWarnings"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/","text":"microsoft::quantum::IOperandPrototype More... #include <Rules/IOperandPrototype.hpp> Inherited by microsoft::quantum::AnyPattern , microsoft::quantum::BasicBlockPattern , microsoft::quantum::BitCastPattern , microsoft::quantum::BranchPattern , microsoft::quantum::CallPattern , microsoft::quantum::ConstIntPattern , microsoft::quantum::IntToPtrPattern , microsoft::quantum::LoadPattern , microsoft::quantum::PhiPattern , microsoft::quantum::SelectPattern , microsoft::quantum::StorePattern , microsoft::quantum::SwitchPattern , microsoft::quantum::UnnamedInvokePattern , microsoft::quantum::ZExtPattern Public Types Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions Name IOperandPrototype () =default virtual ~IOperandPrototype () virtual bool match (Value * value, Captures & captures) const =0 virtual Child copy () const =0 void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Detailed Description class microsoft::quantum::IOperandPrototype; IOperandPrototype describes an IR pattern and allows matching against LLVMs llvm::Value type. Each value may or may not be captured during the matching process which means that they are stored in a map under a given name. Capturing is enabled using captureAs(name) which sets the name the value should be stored under. Public Types Documentation using Instruction using microsoft::quantum::IOperandPrototype::Instruction = llvm::Instruction; using String using microsoft::quantum::IOperandPrototype::String = std::string; using Value using microsoft::quantum::IOperandPrototype::Value = llvm::Value; using Child using microsoft::quantum::IOperandPrototype::Child = std::shared_ptr<IOperandPrototype>; using Children using microsoft::quantum::IOperandPrototype::Children = std::vector<Child>; using Captures using microsoft::quantum::IOperandPrototype::Captures = std::unordered_map<std::string, Value*>; Public Functions Documentation function IOperandPrototype IOperandPrototype() =default function ~IOperandPrototype virtual ~IOperandPrototype() function match virtual bool match( Value * value, Captures & captures ) const =0 Reimplemented by : microsoft::quantum::StorePattern::match , microsoft::quantum::LoadPattern::match , microsoft::quantum::AnyPattern::match , microsoft::quantum::BitCastPattern::match , microsoft::quantum::UnnamedInvokePattern::match , microsoft::quantum::PhiPattern::match , microsoft::quantum::IntToPtrPattern::match , microsoft::quantum::CallPattern::match , microsoft::quantum::ConstIntPattern::match , microsoft::quantum::BranchPattern::match , microsoft::quantum::SelectPattern::match , microsoft::quantum::BasicBlockPattern::match , microsoft::quantum::SwitchPattern::match , microsoft::quantum::ZExtPattern::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const =0 Reimplemented by : microsoft::quantum::StorePattern::copy , microsoft::quantum::LoadPattern::copy , microsoft::quantum::AnyPattern::copy , microsoft::quantum::BitCastPattern::copy , microsoft::quantum::IntToPtrPattern::copy , microsoft::quantum::UnnamedInvokePattern::copy , microsoft::quantum::PhiPattern::copy , microsoft::quantum::CallPattern::copy , microsoft::quantum::ConstIntPattern::copy , microsoft::quantum::BranchPattern::copy , microsoft::quantum::SelectPattern::copy , microsoft::quantum::BasicBlockPattern::copy , microsoft::quantum::SwitchPattern::copy , microsoft::quantum::ZExtPattern::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. function addChild void addChild( Child const & child ) Adds a child to be matched against the matches children. Children are matched in order and by size. function captureAs void captureAs( std::string capture_name ) Flags that this operand should be captured. This function ensures that the captured operand is given a name. The subsequent logic in this class is responsible for capturing (upon match) and uncapturing (upon backtrack) with specified name Protected Functions Documentation function fail bool fail( Value * value, Captures & captures ) const Function which should be called whenever a match fails. function success bool success( Value * value, Captures & captures ) const Function which should be called whenever a match is successful. function matchChildren bool matchChildren( Value * value, Captures & captures ) const Subroutine to match all children. function copyPropertiesFrom inline void copyPropertiesFrom( IOperandPrototype const & other ) Shallow copy of the operand to allow name change of the capture Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::IOperandPrototype"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#microsoftquantumioperandprototype","text":"More... #include <Rules/IOperandPrototype.hpp> Inherited by microsoft::quantum::AnyPattern , microsoft::quantum::BasicBlockPattern , microsoft::quantum::BitCastPattern , microsoft::quantum::BranchPattern , microsoft::quantum::CallPattern , microsoft::quantum::ConstIntPattern , microsoft::quantum::IntToPtrPattern , microsoft::quantum::LoadPattern , microsoft::quantum::PhiPattern , microsoft::quantum::SelectPattern , microsoft::quantum::StorePattern , microsoft::quantum::SwitchPattern , microsoft::quantum::UnnamedInvokePattern , microsoft::quantum::ZExtPattern","title":"microsoft::quantum::IOperandPrototype"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#public-types","text":"Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#public-functions","text":"Name IOperandPrototype () =default virtual ~IOperandPrototype () virtual bool match (Value * value, Captures & captures) const =0 virtual Child copy () const =0 void addChild (Child const & child) void captureAs (std::string capture_name)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#protected-functions","text":"Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Protected Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#detailed-description","text":"class microsoft::quantum::IOperandPrototype; IOperandPrototype describes an IR pattern and allows matching against LLVMs llvm::Value type. Each value may or may not be captured during the matching process which means that they are stored in a map under a given name. Capturing is enabled using captureAs(name) which sets the name the value should be stored under.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#using-instruction","text":"using microsoft::quantum::IOperandPrototype::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#using-string","text":"using microsoft::quantum::IOperandPrototype::String = std::string;","title":"using String"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#using-value","text":"using microsoft::quantum::IOperandPrototype::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#using-child","text":"using microsoft::quantum::IOperandPrototype::Child = std::shared_ptr<IOperandPrototype>;","title":"using Child"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#using-children","text":"using microsoft::quantum::IOperandPrototype::Children = std::vector<Child>;","title":"using Children"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#using-captures","text":"using microsoft::quantum::IOperandPrototype::Captures = std::unordered_map<std::string, Value*>;","title":"using Captures"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-ioperandprototype","text":"IOperandPrototype() =default","title":"function IOperandPrototype"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-ioperandprototype_1","text":"virtual ~IOperandPrototype()","title":"function ~IOperandPrototype"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const =0 Reimplemented by : microsoft::quantum::StorePattern::match , microsoft::quantum::LoadPattern::match , microsoft::quantum::AnyPattern::match , microsoft::quantum::BitCastPattern::match , microsoft::quantum::UnnamedInvokePattern::match , microsoft::quantum::PhiPattern::match , microsoft::quantum::IntToPtrPattern::match , microsoft::quantum::CallPattern::match , microsoft::quantum::ConstIntPattern::match , microsoft::quantum::BranchPattern::match , microsoft::quantum::SelectPattern::match , microsoft::quantum::BasicBlockPattern::match , microsoft::quantum::SwitchPattern::match , microsoft::quantum::ZExtPattern::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-copy","text":"virtual Child copy() const =0 Reimplemented by : microsoft::quantum::StorePattern::copy , microsoft::quantum::LoadPattern::copy , microsoft::quantum::AnyPattern::copy , microsoft::quantum::BitCastPattern::copy , microsoft::quantum::IntToPtrPattern::copy , microsoft::quantum::UnnamedInvokePattern::copy , microsoft::quantum::PhiPattern::copy , microsoft::quantum::CallPattern::copy , microsoft::quantum::ConstIntPattern::copy , microsoft::quantum::BranchPattern::copy , microsoft::quantum::SelectPattern::copy , microsoft::quantum::BasicBlockPattern::copy , microsoft::quantum::SwitchPattern::copy , microsoft::quantum::ZExtPattern::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy.","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-addchild","text":"void addChild( Child const & child ) Adds a child to be matched against the matches children. Children are matched in order and by size.","title":"function addChild"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-captureas","text":"void captureAs( std::string capture_name ) Flags that this operand should be captured. This function ensures that the captured operand is given a name. The subsequent logic in this class is responsible for capturing (upon match) and uncapturing (upon backtrack) with specified name","title":"function captureAs"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail","text":"bool fail( Value * value, Captures & captures ) const Function which should be called whenever a match fails.","title":"function fail"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success","text":"bool success( Value * value, Captures & captures ) const Function which should be called whenever a match is successful.","title":"function success"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-matchchildren","text":"bool matchChildren( Value * value, Captures & captures ) const Subroutine to match all children.","title":"function matchChildren"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-copypropertiesfrom","text":"inline void copyPropertiesFrom( IOperandPrototype const & other ) Shallow copy of the operand to allow name change of the capture Updated on 28 October 2022 at 19:30:15 UTC","title":"function copyPropertiesFrom"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/","text":"microsoft::quantum::InstructionLocationTable Inherits from AssemblyAnnotationWriter Public Types Name using SourceLocation Position using llvm::StringRef StringRef using llvm::BasicBlock BasicBlock using llvm::Function Function using llvm::Value Value using llvm::Module Module using std::unordered_map< Value const *, Position > Positions using std::unordered_map< String, Position > FunctionPositions using std::shared_ptr< InstructionLocationTable > InstructionLocationTablePtr Public Functions Name InstructionLocationTablePtr create () Pointer constructor for the debug table. Position getPosition (Value const * value) const Gets the position of a LLVM value. Position getPositionFromFunctionName (String const & name) const Gets the position from a function name. void registerModule (StringRef const & filename, Module const * module) Registers a module in debug table. Protected Functions Name void printInfoComment (Value const & value, llvm::formatted_raw_ostream & outstream) override void emitBasicBlockStartAnnot (BasicBlock const * block, llvm::formatted_raw_ostream & outstream) override void emitFunctionAnnot (Function const * function, llvm::formatted_raw_ostream & outstream) override Public Types Documentation using Position using microsoft::quantum::InstructionLocationTable::Position = SourceLocation; using StringRef using microsoft::quantum::InstructionLocationTable::StringRef = llvm::StringRef; using BasicBlock using microsoft::quantum::InstructionLocationTable::BasicBlock = llvm::BasicBlock; using Function using microsoft::quantum::InstructionLocationTable::Function = llvm::Function; using Value using microsoft::quantum::InstructionLocationTable::Value = llvm::Value; using Module using microsoft::quantum::InstructionLocationTable::Module = llvm::Module; using Positions using microsoft::quantum::InstructionLocationTable::Positions = std::unordered_map<Value const*, Position>; using FunctionPositions using microsoft::quantum::InstructionLocationTable::FunctionPositions = std::unordered_map<String, Position>; using InstructionLocationTablePtr using microsoft::quantum::InstructionLocationTable::InstructionLocationTablePtr = std::shared_ptr<InstructionLocationTable>; Public Functions Documentation function create static InstructionLocationTablePtr create() Pointer constructor for the debug table. function getPosition Position getPosition( Value const * value ) const Gets the position of a LLVM value. function getPositionFromFunctionName Position getPositionFromFunctionName( String const & name ) const Gets the position from a function name. function registerModule void registerModule( StringRef const & filename, Module const * module ) Registers a module in debug table. Protected Functions Documentation function printInfoComment void printInfoComment( Value const & value, llvm::formatted_raw_ostream & outstream ) override function emitBasicBlockStartAnnot void emitBasicBlockStartAnnot( BasicBlock const * block, llvm::formatted_raw_ostream & outstream ) override function emitFunctionAnnot void emitFunctionAnnot( Function const * function, llvm::formatted_raw_ostream & outstream ) override Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::InstructionLocationTable"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#microsoftquantuminstructionlocationtable","text":"Inherits from AssemblyAnnotationWriter","title":"microsoft::quantum::InstructionLocationTable"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#public-types","text":"Name using SourceLocation Position using llvm::StringRef StringRef using llvm::BasicBlock BasicBlock using llvm::Function Function using llvm::Value Value using llvm::Module Module using std::unordered_map< Value const *, Position > Positions using std::unordered_map< String, Position > FunctionPositions using std::shared_ptr< InstructionLocationTable > InstructionLocationTablePtr","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#public-functions","text":"Name InstructionLocationTablePtr create () Pointer constructor for the debug table. Position getPosition (Value const * value) const Gets the position of a LLVM value. Position getPositionFromFunctionName (String const & name) const Gets the position from a function name. void registerModule (StringRef const & filename, Module const * module) Registers a module in debug table.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#protected-functions","text":"Name void printInfoComment (Value const & value, llvm::formatted_raw_ostream & outstream) override void emitBasicBlockStartAnnot (BasicBlock const * block, llvm::formatted_raw_ostream & outstream) override void emitFunctionAnnot (Function const * function, llvm::formatted_raw_ostream & outstream) override","title":"Protected Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#using-position","text":"using microsoft::quantum::InstructionLocationTable::Position = SourceLocation;","title":"using Position"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#using-stringref","text":"using microsoft::quantum::InstructionLocationTable::StringRef = llvm::StringRef;","title":"using StringRef"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#using-basicblock","text":"using microsoft::quantum::InstructionLocationTable::BasicBlock = llvm::BasicBlock;","title":"using BasicBlock"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#using-function","text":"using microsoft::quantum::InstructionLocationTable::Function = llvm::Function;","title":"using Function"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#using-value","text":"using microsoft::quantum::InstructionLocationTable::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#using-module","text":"using microsoft::quantum::InstructionLocationTable::Module = llvm::Module;","title":"using Module"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#using-positions","text":"using microsoft::quantum::InstructionLocationTable::Positions = std::unordered_map<Value const*, Position>;","title":"using Positions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#using-functionpositions","text":"using microsoft::quantum::InstructionLocationTable::FunctionPositions = std::unordered_map<String, Position>;","title":"using FunctionPositions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#using-instructionlocationtableptr","text":"using microsoft::quantum::InstructionLocationTable::InstructionLocationTablePtr = std::shared_ptr<InstructionLocationTable>;","title":"using InstructionLocationTablePtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#function-create","text":"static InstructionLocationTablePtr create() Pointer constructor for the debug table.","title":"function create"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#function-getposition","text":"Position getPosition( Value const * value ) const Gets the position of a LLVM value.","title":"function getPosition"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#function-getpositionfromfunctionname","text":"Position getPositionFromFunctionName( String const & name ) const Gets the position from a function name.","title":"function getPositionFromFunctionName"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#function-registermodule","text":"void registerModule( StringRef const & filename, Module const * module ) Registers a module in debug table.","title":"function registerModule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#function-printinfocomment","text":"void printInfoComment( Value const & value, llvm::formatted_raw_ostream & outstream ) override","title":"function printInfoComment"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#function-emitbasicblockstartannot","text":"void emitBasicBlockStartAnnot( BasicBlock const * block, llvm::formatted_raw_ostream & outstream ) override","title":"function emitBasicBlockStartAnnot"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_instruction_location_table/#function-emitfunctionannot","text":"void emitFunctionAnnot( Function const * function, llvm::formatted_raw_ostream & outstream ) override Updated on 28 October 2022 at 19:30:15 UTC","title":"function emitFunctionAnnot"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_int_to_ptr_pattern/","text":"microsoft::quantum::IntToPtrPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::IntToPtrPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_int_to_ptr_pattern/#microsoftquantuminttoptrpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::IntToPtrPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_int_to_ptr_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_int_to_ptr_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_int_to_ptr_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_int_to_ptr_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_int_to_ptr_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 28 October 2022 at 19:30:15 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/","text":"microsoft::quantum::IrManipulationTestHelper Public Types Name using std::string String using std::vector< String > Strings using llvm::LLVMContext LLVMContext using llvm::SMDiagnostic SMDiagnostic using llvm::Module Module using std::unique_ptr< LLVMContext > ContextPtr using std::unique_ptr< Module > ModulePtr using llvm::OptimizationLevel OptimizationLevel using std::shared_ptr< QirAdaptorFactory > GeneratorPtr Public Functions Name IrManipulationTestHelper () =default IrManipulationTestHelper ( IrManipulationTestHelper const & ) IrManipulationTestHelper & operator= ( IrManipulationTestHelper const & ) IrManipulationTestHelper ( IrManipulationTestHelper && ) IrManipulationTestHelper & operator= ( IrManipulationTestHelper && ) String toString () const Generates a string for the IR currently held in the module. Strings toBodyInstructions (String const & block_name =\"\") Generates a list of instructions for the main function in the module. TestProgram toProgram () bool hasInstructionSequence (Strings const & instructions, String const & block_name =\"\") void applyQirAdaptor (GeneratorPtr const & generator, OptimizationLevel const & optimization_level =OptimizationLevel::O0, bool debug =false) bool validateQirAdaptor (GeneratorPtr const & generator, String const & target_name =\"generic\", bool debug =false) bool containsValidationErrors (GeneratorPtr const & generator, String const & target_name, Strings const & errors, bool debug =false) const bool containsExactValidationErrors (GeneratorPtr const & generator, String const & target_name, Strings const & errors, bool debug =false) const void declareOpaque (String const & name) void declareFunction (String const & declaration) bool fromBodyString (String const & body, String const & args =\"\") String generateScript (String const & body, String const & args =\"\") const Generates a script given the body of the main function. bool fromString (String const & data) String getErrorMessage () const Gets an error message if the compilation failed. bool isModuleBroken () Whether or not the module is broken. ModulePtr & module () Returns a reference to the module. Public Types Documentation using String using microsoft::quantum::IrManipulationTestHelper::String = std::string; using Strings using microsoft::quantum::IrManipulationTestHelper::Strings = std::vector<String>; using LLVMContext using microsoft::quantum::IrManipulationTestHelper::LLVMContext = llvm::LLVMContext; using SMDiagnostic using microsoft::quantum::IrManipulationTestHelper::SMDiagnostic = llvm::SMDiagnostic; using Module using microsoft::quantum::IrManipulationTestHelper::Module = llvm::Module; using ContextPtr using microsoft::quantum::IrManipulationTestHelper::ContextPtr = std::unique_ptr<LLVMContext>; using ModulePtr using microsoft::quantum::IrManipulationTestHelper::ModulePtr = std::unique_ptr<Module>; using OptimizationLevel using microsoft::quantum::IrManipulationTestHelper::OptimizationLevel = llvm::OptimizationLevel; using GeneratorPtr using microsoft::quantum::IrManipulationTestHelper::GeneratorPtr = std::shared_ptr<QirAdaptorFactory>; Public Functions Documentation function IrManipulationTestHelper IrManipulationTestHelper() =default function IrManipulationTestHelper IrManipulationTestHelper( IrManipulationTestHelper const & ) function operator= IrManipulationTestHelper & operator=( IrManipulationTestHelper const & ) function IrManipulationTestHelper IrManipulationTestHelper( IrManipulationTestHelper && ) function operator= IrManipulationTestHelper & operator=( IrManipulationTestHelper && ) function toString String toString() const Generates a string for the IR currently held in the module. function toBodyInstructions Strings toBodyInstructions( String const & block_name =\"\" ) Generates a list of instructions for the main function in the module. function toProgram TestProgram toProgram() function hasInstructionSequence bool hasInstructionSequence( Strings const & instructions, String const & block_name =\"\" ) Tests whether the main body contains a sequence of instructions. This function ignores instructions in-between the instruction set given. If block name is specified then only instructions within this block are extracted function applyQirAdaptor void applyQirAdaptor( GeneratorPtr const & generator, OptimizationLevel const & optimization_level =OptimizationLevel::O0, bool debug =false ) Applies a adaptor to the module to allow which transforms the IR. This allow us to write small adaptors to test a single piece of transformation. function validateQirAdaptor bool validateQirAdaptor( GeneratorPtr const & generator, String const & target_name =\"generic\", bool debug =false ) Validates a adaptor to the module to allow which transforms the IR. This allow us to write small adaptors to test a single piece of transformation. function containsValidationErrors bool containsValidationErrors( GeneratorPtr const & generator, String const & target_name, Strings const & errors, bool debug =false ) const Tests whether a given set of errors (LLVM hints) are present in the validation errors for a specific adaptor. This method only checks if errors are present but does not fail if there are more errors than requested through the API. function containsExactValidationErrors bool containsExactValidationErrors( GeneratorPtr const & generator, String const & target_name, Strings const & errors, bool debug =false ) const Tests whether a given set of errors (LLVM hints) are present in the validation errors for a specific adaptor. In contrast to containsValidationErrors, this function expect an exact match in the actual and expected errors. function declareOpaque void declareOpaque( String const & name ) Declares a opaque type. Only the name of the type should be supplied to this function. Example usage irmanip.declareOpaque(\"Qubit\"); function declareFunction void declareFunction( String const & declaration ) Declares a function. The full signature should be supplied to as the first argument. Example usage irmanip.declareOpaque(\"%Result* @__quantum__rt__result_get_zero()\"); function fromBodyString bool fromBodyString( String const & body, String const & args =\"\" ) Creates an LLVM module given a function body. This function makes use of the inputs from IrManipulationTestHelper::declareOpaque and IrManipulationTestHelper::declareFunction to construct the full IR. Example usage: irmanip.fromBodyString(R\"script( %leftMessage = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %leftMessage) )script\"); Returns false if the IR is invalid. function generateScript String generateScript( String const & body, String const & args =\"\" ) const Generates a script given the body of the main function. function fromString bool fromString( String const & data ) Creates an LLVM module given from a fully specified IR. This function ignores all inputs from IrManipulationTestHelper::declareOpaque and IrManipulationTestHelper::declareFunction . Returns false if the IR is invalid. function getErrorMessage String getErrorMessage() const Gets an error message if the compilation failed. function isModuleBroken bool isModuleBroken() Whether or not the module is broken. function module ModulePtr & module() Returns a reference to the module. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::IrManipulationTestHelper"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#microsoftquantumirmanipulationtesthelper","text":"","title":"microsoft::quantum::IrManipulationTestHelper"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#public-types","text":"Name using std::string String using std::vector< String > Strings using llvm::LLVMContext LLVMContext using llvm::SMDiagnostic SMDiagnostic using llvm::Module Module using std::unique_ptr< LLVMContext > ContextPtr using std::unique_ptr< Module > ModulePtr using llvm::OptimizationLevel OptimizationLevel using std::shared_ptr< QirAdaptorFactory > GeneratorPtr","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#public-functions","text":"Name IrManipulationTestHelper () =default IrManipulationTestHelper ( IrManipulationTestHelper const & ) IrManipulationTestHelper & operator= ( IrManipulationTestHelper const & ) IrManipulationTestHelper ( IrManipulationTestHelper && ) IrManipulationTestHelper & operator= ( IrManipulationTestHelper && ) String toString () const Generates a string for the IR currently held in the module. Strings toBodyInstructions (String const & block_name =\"\") Generates a list of instructions for the main function in the module. TestProgram toProgram () bool hasInstructionSequence (Strings const & instructions, String const & block_name =\"\") void applyQirAdaptor (GeneratorPtr const & generator, OptimizationLevel const & optimization_level =OptimizationLevel::O0, bool debug =false) bool validateQirAdaptor (GeneratorPtr const & generator, String const & target_name =\"generic\", bool debug =false) bool containsValidationErrors (GeneratorPtr const & generator, String const & target_name, Strings const & errors, bool debug =false) const bool containsExactValidationErrors (GeneratorPtr const & generator, String const & target_name, Strings const & errors, bool debug =false) const void declareOpaque (String const & name) void declareFunction (String const & declaration) bool fromBodyString (String const & body, String const & args =\"\") String generateScript (String const & body, String const & args =\"\") const Generates a script given the body of the main function. bool fromString (String const & data) String getErrorMessage () const Gets an error message if the compilation failed. bool isModuleBroken () Whether or not the module is broken. ModulePtr & module () Returns a reference to the module.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-string","text":"using microsoft::quantum::IrManipulationTestHelper::String = std::string;","title":"using String"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-strings","text":"using microsoft::quantum::IrManipulationTestHelper::Strings = std::vector<String>;","title":"using Strings"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-llvmcontext","text":"using microsoft::quantum::IrManipulationTestHelper::LLVMContext = llvm::LLVMContext;","title":"using LLVMContext"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-smdiagnostic","text":"using microsoft::quantum::IrManipulationTestHelper::SMDiagnostic = llvm::SMDiagnostic;","title":"using SMDiagnostic"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-module","text":"using microsoft::quantum::IrManipulationTestHelper::Module = llvm::Module;","title":"using Module"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-contextptr","text":"using microsoft::quantum::IrManipulationTestHelper::ContextPtr = std::unique_ptr<LLVMContext>;","title":"using ContextPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-moduleptr","text":"using microsoft::quantum::IrManipulationTestHelper::ModulePtr = std::unique_ptr<Module>;","title":"using ModulePtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-optimizationlevel","text":"using microsoft::quantum::IrManipulationTestHelper::OptimizationLevel = llvm::OptimizationLevel;","title":"using OptimizationLevel"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-generatorptr","text":"using microsoft::quantum::IrManipulationTestHelper::GeneratorPtr = std::shared_ptr<QirAdaptorFactory>;","title":"using GeneratorPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-irmanipulationtesthelper","text":"IrManipulationTestHelper() =default","title":"function IrManipulationTestHelper"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-irmanipulationtesthelper_1","text":"IrManipulationTestHelper( IrManipulationTestHelper const & )","title":"function IrManipulationTestHelper"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-operator","text":"IrManipulationTestHelper & operator=( IrManipulationTestHelper const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-irmanipulationtesthelper_2","text":"IrManipulationTestHelper( IrManipulationTestHelper && )","title":"function IrManipulationTestHelper"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-operator_1","text":"IrManipulationTestHelper & operator=( IrManipulationTestHelper && )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-tostring","text":"String toString() const Generates a string for the IR currently held in the module.","title":"function toString"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-tobodyinstructions","text":"Strings toBodyInstructions( String const & block_name =\"\" ) Generates a list of instructions for the main function in the module.","title":"function toBodyInstructions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-toprogram","text":"TestProgram toProgram()","title":"function toProgram"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-hasinstructionsequence","text":"bool hasInstructionSequence( Strings const & instructions, String const & block_name =\"\" ) Tests whether the main body contains a sequence of instructions. This function ignores instructions in-between the instruction set given. If block name is specified then only instructions within this block are extracted","title":"function hasInstructionSequence"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-applyqiradaptor","text":"void applyQirAdaptor( GeneratorPtr const & generator, OptimizationLevel const & optimization_level =OptimizationLevel::O0, bool debug =false ) Applies a adaptor to the module to allow which transforms the IR. This allow us to write small adaptors to test a single piece of transformation.","title":"function applyQirAdaptor"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-validateqiradaptor","text":"bool validateQirAdaptor( GeneratorPtr const & generator, String const & target_name =\"generic\", bool debug =false ) Validates a adaptor to the module to allow which transforms the IR. This allow us to write small adaptors to test a single piece of transformation.","title":"function validateQirAdaptor"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-containsvalidationerrors","text":"bool containsValidationErrors( GeneratorPtr const & generator, String const & target_name, Strings const & errors, bool debug =false ) const Tests whether a given set of errors (LLVM hints) are present in the validation errors for a specific adaptor. This method only checks if errors are present but does not fail if there are more errors than requested through the API.","title":"function containsValidationErrors"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-containsexactvalidationerrors","text":"bool containsExactValidationErrors( GeneratorPtr const & generator, String const & target_name, Strings const & errors, bool debug =false ) const Tests whether a given set of errors (LLVM hints) are present in the validation errors for a specific adaptor. In contrast to containsValidationErrors, this function expect an exact match in the actual and expected errors.","title":"function containsExactValidationErrors"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-declareopaque","text":"void declareOpaque( String const & name ) Declares a opaque type. Only the name of the type should be supplied to this function. Example usage irmanip.declareOpaque(\"Qubit\");","title":"function declareOpaque"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-declarefunction","text":"void declareFunction( String const & declaration ) Declares a function. The full signature should be supplied to as the first argument. Example usage irmanip.declareOpaque(\"%Result* @__quantum__rt__result_get_zero()\");","title":"function declareFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-frombodystring","text":"bool fromBodyString( String const & body, String const & args =\"\" ) Creates an LLVM module given a function body. This function makes use of the inputs from IrManipulationTestHelper::declareOpaque and IrManipulationTestHelper::declareFunction to construct the full IR. Example usage: irmanip.fromBodyString(R\"script( %leftMessage = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %leftMessage) )script\"); Returns false if the IR is invalid.","title":"function fromBodyString"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-generatescript","text":"String generateScript( String const & body, String const & args =\"\" ) const Generates a script given the body of the main function.","title":"function generateScript"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-fromstring","text":"bool fromString( String const & data ) Creates an LLVM module given from a fully specified IR. This function ignores all inputs from IrManipulationTestHelper::declareOpaque and IrManipulationTestHelper::declareFunction . Returns false if the IR is invalid.","title":"function fromString"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-geterrormessage","text":"String getErrorMessage() const Gets an error message if the compilation failed.","title":"function getErrorMessage"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-ismodulebroken","text":"bool isModuleBroken() Whether or not the module is broken.","title":"function isModuleBroken"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-module","text":"ModulePtr & module() Returns a reference to the module. Updated on 28 October 2022 at 19:30:15 UTC","title":"function module"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/","text":"microsoft::quantum::LlvmPassesConfiguration Public Functions Name void setup ( ConfigurationManager & config) bool alwaysInline () const Whether or not the LLVM AlwaysInline pass should be added to the adaptor. bool unrollLoops () const Whether or not the LLVM LoopUnroll pass should be added to the adaptor. int32_t inlineParameter () const Parameter that defines the maximum number of lines of code allowed for inlining. bool unrollAllowPartial () const Whether or not to allow partial unrolling. When disable only full unrolling will be used. bool unrollAllowPeeling () const Whether or not to allow peeling. bool unrollAllowRuntime () const bool unrollAllowUpperBound () const Enables or disables the usage of trip counting in loop unrolling. bool unrollAllowProfilBasedPeeling () const uint64_t unrolFullUnrollCount () const The max count full unroll count. int32_t unrollOptLevel () const The optimization level for the loop unrolling pass. bool unrollOnlyWhenForced () const bool unrollForgeScev () const bool eliminateConstants () const Whether or not to add a pass to eliminate constants. bool eliminateDeadCode () const Whether or not to add a pass to eliminate dead code. bool eliminateMemory () const Whether or not memory allocations should be attempted to be mapped into registers. bool isDisabled () const Checking if the configuration amounts to being disabled. bool operator== ( LlvmPassesConfiguration const & o) const Checking whether two configurations are identical. LlvmPassesConfiguration createDisabled () Creating a configuration that disables all passes and/or their effect on the IR. LlvmPassesConfiguration createUnrollInline () Creates a configuration that unrolls and inlines code. Public Functions Documentation function setup void setup( ConfigurationManager & config ) function alwaysInline bool alwaysInline() const Whether or not the LLVM AlwaysInline pass should be added to the adaptor. function unrollLoops bool unrollLoops() const Whether or not the LLVM LoopUnroll pass should be added to the adaptor. function inlineParameter int32_t inlineParameter() const Parameter that defines the maximum number of lines of code allowed for inlining. function unrollAllowPartial bool unrollAllowPartial() const Whether or not to allow partial unrolling. When disable only full unrolling will be used. function unrollAllowPeeling bool unrollAllowPeeling() const Whether or not to allow peeling. function unrollAllowRuntime bool unrollAllowRuntime() const Whether or not to allow unrolling of loops with runtime trip counts. See implementation for details. function unrollAllowUpperBound bool unrollAllowUpperBound() const Enables or disables the usage of trip counting in loop unrolling. function unrollAllowProfilBasedPeeling bool unrollAllowProfilBasedPeeling() const function unrolFullUnrollCount uint64_t unrolFullUnrollCount() const The max count full unroll count. function unrollOptLevel int32_t unrollOptLevel() const The optimization level for the loop unrolling pass. function unrollOnlyWhenForced bool unrollOnlyWhenForced() const Whether or not to limit unrolling to which are requested to be unrolled via meta data is consider. When false, a cost model is used to determine whether or not to unroll a loop. function unrollForgeScev bool unrollForgeScev() const function eliminateConstants bool eliminateConstants() const Whether or not to add a pass to eliminate constants. function eliminateDeadCode bool eliminateDeadCode() const Whether or not to add a pass to eliminate dead code. function eliminateMemory bool eliminateMemory() const Whether or not memory allocations should be attempted to be mapped into registers. function isDisabled bool isDisabled() const Checking if the configuration amounts to being disabled. function operator== inline bool operator==( LlvmPassesConfiguration const & o ) const Checking whether two configurations are identical. function createDisabled static LlvmPassesConfiguration createDisabled() Creating a configuration that disables all passes and/or their effect on the IR. function createUnrollInline static LlvmPassesConfiguration createUnrollInline() Creates a configuration that unrolls and inlines code. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::LlvmPassesConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#microsoftquantumllvmpassesconfiguration","text":"","title":"microsoft::quantum::LlvmPassesConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#public-functions","text":"Name void setup ( ConfigurationManager & config) bool alwaysInline () const Whether or not the LLVM AlwaysInline pass should be added to the adaptor. bool unrollLoops () const Whether or not the LLVM LoopUnroll pass should be added to the adaptor. int32_t inlineParameter () const Parameter that defines the maximum number of lines of code allowed for inlining. bool unrollAllowPartial () const Whether or not to allow partial unrolling. When disable only full unrolling will be used. bool unrollAllowPeeling () const Whether or not to allow peeling. bool unrollAllowRuntime () const bool unrollAllowUpperBound () const Enables or disables the usage of trip counting in loop unrolling. bool unrollAllowProfilBasedPeeling () const uint64_t unrolFullUnrollCount () const The max count full unroll count. int32_t unrollOptLevel () const The optimization level for the loop unrolling pass. bool unrollOnlyWhenForced () const bool unrollForgeScev () const bool eliminateConstants () const Whether or not to add a pass to eliminate constants. bool eliminateDeadCode () const Whether or not to add a pass to eliminate dead code. bool eliminateMemory () const Whether or not memory allocations should be attempted to be mapped into registers. bool isDisabled () const Checking if the configuration amounts to being disabled. bool operator== ( LlvmPassesConfiguration const & o) const Checking whether two configurations are identical. LlvmPassesConfiguration createDisabled () Creating a configuration that disables all passes and/or their effect on the IR. LlvmPassesConfiguration createUnrollInline () Creates a configuration that unrolls and inlines code.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-setup","text":"void setup( ConfigurationManager & config )","title":"function setup"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-alwaysinline","text":"bool alwaysInline() const Whether or not the LLVM AlwaysInline pass should be added to the adaptor.","title":"function alwaysInline"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-unrollloops","text":"bool unrollLoops() const Whether or not the LLVM LoopUnroll pass should be added to the adaptor.","title":"function unrollLoops"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-inlineparameter","text":"int32_t inlineParameter() const Parameter that defines the maximum number of lines of code allowed for inlining.","title":"function inlineParameter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-unrollallowpartial","text":"bool unrollAllowPartial() const Whether or not to allow partial unrolling. When disable only full unrolling will be used.","title":"function unrollAllowPartial"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-unrollallowpeeling","text":"bool unrollAllowPeeling() const Whether or not to allow peeling.","title":"function unrollAllowPeeling"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-unrollallowruntime","text":"bool unrollAllowRuntime() const Whether or not to allow unrolling of loops with runtime trip counts. See implementation for details.","title":"function unrollAllowRuntime"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-unrollallowupperbound","text":"bool unrollAllowUpperBound() const Enables or disables the usage of trip counting in loop unrolling.","title":"function unrollAllowUpperBound"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-unrollallowprofilbasedpeeling","text":"bool unrollAllowProfilBasedPeeling() const","title":"function unrollAllowProfilBasedPeeling"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-unrolfullunrollcount","text":"uint64_t unrolFullUnrollCount() const The max count full unroll count.","title":"function unrolFullUnrollCount"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-unrolloptlevel","text":"int32_t unrollOptLevel() const The optimization level for the loop unrolling pass.","title":"function unrollOptLevel"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-unrollonlywhenforced","text":"bool unrollOnlyWhenForced() const Whether or not to limit unrolling to which are requested to be unrolled via meta data is consider. When false, a cost model is used to determine whether or not to unroll a loop.","title":"function unrollOnlyWhenForced"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-unrollforgescev","text":"bool unrollForgeScev() const","title":"function unrollForgeScev"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-eliminateconstants","text":"bool eliminateConstants() const Whether or not to add a pass to eliminate constants.","title":"function eliminateConstants"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-eliminatedeadcode","text":"bool eliminateDeadCode() const Whether or not to add a pass to eliminate dead code.","title":"function eliminateDeadCode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-eliminatememory","text":"bool eliminateMemory() const Whether or not memory allocations should be attempted to be mapped into registers.","title":"function eliminateMemory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-isdisabled","text":"bool isDisabled() const Checking if the configuration amounts to being disabled.","title":"function isDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-operator","text":"inline bool operator==( LlvmPassesConfiguration const & o ) const Checking whether two configurations are identical.","title":"function operator=="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-createdisabled","text":"static LlvmPassesConfiguration createDisabled() Creating a configuration that disables all passes and/or their effect on the IR.","title":"function createDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-createunrollinline","text":"static LlvmPassesConfiguration createUnrollInline() Creates a configuration that unrolls and inlines code. Updated on 28 October 2022 at 19:30:15 UTC","title":"function createUnrollInline"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_load_pattern/","text":"microsoft::quantum::LoadPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::LoadPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_load_pattern/#microsoftquantumloadpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::LoadPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_load_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_load_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_load_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_load_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_load_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 28 October 2022 at 19:30:15 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/","text":"microsoft::quantum::LogCollection More... #include <Logging/LogCollection.hpp> Inherits from microsoft::quantum::ILogger Public Functions Name virtual void debug (String const & message) override Adds a debug message to the list. virtual void info (String const & message) override Adds an info message to the list. virtual void warning (String const & message) override Adds a warning message to the list. virtual void error (String const & message) override Adds an error message to the list. virtual void internalError (String const & message) override Adds an internal error message to the list. virtual void setLocation ( SourceLocation const & loc) override Function that allows to set the current location. virtual void setLlvmHint (String const & value) override Sets the value of the LLVM instruction causing the issue. virtual void setFrontendHint (String const & value) override Sets the value of the frontend instruction causing the issue. virtual Messages const & messages () const override Accessor to the messages. virtual void dump (std::ostream & out) const override Enabling dumping collection to a file. Additional inherited members Public Classes inherited from microsoft::quantum::ILogger Name struct Location Class that holds the location of where the incident happened. struct Message Struct to hold a message together with its type and location. Public Types inherited from microsoft::quantum::ILogger Name enum class Type { Debug, Info, Warning, Error, InternalError} Enum description what type of information we are conveying. using llvm::Value Value using std::function< SourceLocation (Value const *)> LocationResolver using std::function< SourceLocation (String const &)> LocationFromNameResolver using std::shared_ptr< ILogger > ILoggerPtr using std::vector< Message > Messages List of messages defined as alias. Public Functions inherited from microsoft::quantum::ILogger Name ILogger () =default ILogger ( ILogger const & ) ILogger ( ILogger && ) ILogger & operator= ( ILogger const & ) ILogger & operator= ( ILogger && ) virtual ~ILogger () void setLocationFromValue (llvm::Value const * value) Sets the logger position based on a LLVM value. void setLocationFromFunctionName (String const & name) Sets the logger position based on function name. void setLocationResolver (LocationResolver const & r) Sets a resolver which that translates a LLVM value into a position in the source. void setLocationFromNameResolver (LocationFromNameResolver const & r) Sets a resolver which that translates function name into a position in the source. SourceLocation resolveLocation (llvm::Value const * value) Returns a source location from the value pointer (if possible) bool hadErrors () const Whether or not errors were logged. bool hadWarnings () const Whether or not warnings were logged. void errorWithLocation (String const & message, llvm::Value * ptr =nullptr) void warningWithLocation (String const & message, llvm::Value * ptr =nullptr) virtual void errorCouldNotDeleteNode (llvm::Value * ptr =nullptr) Standard messages. virtual void errorExpectedStraightLineCodeMultipleFunctions (llvm::Value * ptr =nullptr) virtual void errorExpectedStraightLineCodeMultipleBlocks (llvm::Value * ptr =nullptr) virtual void errorReleaseFailNonStandardAlloc (llvm::Value * ptr =nullptr) virtual void warningReleasePhiNodeQubit (llvm::Value * ptr =nullptr) virtual void errorFunctionInliningMaxRecursion (uint64_t n, llvm::Value * ptr =nullptr) virtual void errorNoQubitsPresent (llvm::Value * ptr =nullptr, String const & name =\"unnamed\") virtual void errorNoResultsPresent (llvm::Value * ptr =nullptr, String const & name =\"unnamed\") virtual void errorOpcodeNotAllowed (String const & code, String const & target_name, llvm::Value * ptr =nullptr) virtual void errorCustomFunctionsNotAllowed (llvm::Value * ptr =nullptr) virtual void errorExternalCallsNotAllowed (String const & function_name, String const & target_name, llvm::Value * ptr =nullptr) virtual void errorTypeNotAllowed (String const & type_name, String const & target_name, llvm::Value * ptr =nullptr) virtual void errorPoisonNotAllowed (String const & target_name, llvm::Value * ptr =nullptr) virtual void errorUndefNotAllowed (String const & target_name, llvm::Value * ptr =nullptr) virtual void errorExpectedStringValueForAttr (String const & function_name, String const & attr_name) virtual void warningWeakLinkReplacementNotPossible (String const & function_name, String const & replacement) virtual void errorReplacementSignatureMismatch (String const & function_name, String const & signature1, String const & signature2) Protected Functions inherited from microsoft::quantum::ILogger Name void setHasErrors (bool value) void setHasWarnings (bool value) Detailed Description class microsoft::quantum::LogCollection; Concrete ILogger implementation that collects all messages and their corresponding location in a list that can be traversed later on. Public Functions Documentation function debug virtual void debug( String const & message ) override Adds a debug message to the list. Reimplements : microsoft::quantum::ILogger::debug function info virtual void info( String const & message ) override Adds an info message to the list. Reimplements : microsoft::quantum::ILogger::info function warning virtual void warning( String const & message ) override Adds a warning message to the list. Reimplements : microsoft::quantum::ILogger::warning function error virtual void error( String const & message ) override Adds an error message to the list. Reimplements : microsoft::quantum::ILogger::error function internalError virtual void internalError( String const & message ) override Adds an internal error message to the list. Reimplements : microsoft::quantum::ILogger::internalError function setLocation virtual void setLocation( SourceLocation const & loc ) override Function that allows to set the current location. Reimplements : microsoft::quantum::ILogger::setLocation function setLlvmHint virtual void setLlvmHint( String const & value ) override Sets the value of the LLVM instruction causing the issue. Reimplements : microsoft::quantum::ILogger::setLlvmHint function setFrontendHint virtual void setFrontendHint( String const & value ) override Sets the value of the frontend instruction causing the issue. Reimplements : microsoft::quantum::ILogger::setFrontendHint function messages virtual Messages const & messages() const override Accessor to the messages. Reimplements : microsoft::quantum::ILogger::messages function dump virtual void dump( std::ostream & out ) const override Enabling dumping collection to a file. Reimplements : microsoft::quantum::ILogger::dump Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::LogCollection"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#microsoftquantumlogcollection","text":"More... #include <Logging/LogCollection.hpp> Inherits from microsoft::quantum::ILogger","title":"microsoft::quantum::LogCollection"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#public-functions","text":"Name virtual void debug (String const & message) override Adds a debug message to the list. virtual void info (String const & message) override Adds an info message to the list. virtual void warning (String const & message) override Adds a warning message to the list. virtual void error (String const & message) override Adds an error message to the list. virtual void internalError (String const & message) override Adds an internal error message to the list. virtual void setLocation ( SourceLocation const & loc) override Function that allows to set the current location. virtual void setLlvmHint (String const & value) override Sets the value of the LLVM instruction causing the issue. virtual void setFrontendHint (String const & value) override Sets the value of the frontend instruction causing the issue. virtual Messages const & messages () const override Accessor to the messages. virtual void dump (std::ostream & out) const override Enabling dumping collection to a file.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#additional-inherited-members","text":"Public Classes inherited from microsoft::quantum::ILogger Name struct Location Class that holds the location of where the incident happened. struct Message Struct to hold a message together with its type and location. Public Types inherited from microsoft::quantum::ILogger Name enum class Type { Debug, Info, Warning, Error, InternalError} Enum description what type of information we are conveying. using llvm::Value Value using std::function< SourceLocation (Value const *)> LocationResolver using std::function< SourceLocation (String const &)> LocationFromNameResolver using std::shared_ptr< ILogger > ILoggerPtr using std::vector< Message > Messages List of messages defined as alias. Public Functions inherited from microsoft::quantum::ILogger Name ILogger () =default ILogger ( ILogger const & ) ILogger ( ILogger && ) ILogger & operator= ( ILogger const & ) ILogger & operator= ( ILogger && ) virtual ~ILogger () void setLocationFromValue (llvm::Value const * value) Sets the logger position based on a LLVM value. void setLocationFromFunctionName (String const & name) Sets the logger position based on function name. void setLocationResolver (LocationResolver const & r) Sets a resolver which that translates a LLVM value into a position in the source. void setLocationFromNameResolver (LocationFromNameResolver const & r) Sets a resolver which that translates function name into a position in the source. SourceLocation resolveLocation (llvm::Value const * value) Returns a source location from the value pointer (if possible) bool hadErrors () const Whether or not errors were logged. bool hadWarnings () const Whether or not warnings were logged. void errorWithLocation (String const & message, llvm::Value * ptr =nullptr) void warningWithLocation (String const & message, llvm::Value * ptr =nullptr) virtual void errorCouldNotDeleteNode (llvm::Value * ptr =nullptr) Standard messages. virtual void errorExpectedStraightLineCodeMultipleFunctions (llvm::Value * ptr =nullptr) virtual void errorExpectedStraightLineCodeMultipleBlocks (llvm::Value * ptr =nullptr) virtual void errorReleaseFailNonStandardAlloc (llvm::Value * ptr =nullptr) virtual void warningReleasePhiNodeQubit (llvm::Value * ptr =nullptr) virtual void errorFunctionInliningMaxRecursion (uint64_t n, llvm::Value * ptr =nullptr) virtual void errorNoQubitsPresent (llvm::Value * ptr =nullptr, String const & name =\"unnamed\") virtual void errorNoResultsPresent (llvm::Value * ptr =nullptr, String const & name =\"unnamed\") virtual void errorOpcodeNotAllowed (String const & code, String const & target_name, llvm::Value * ptr =nullptr) virtual void errorCustomFunctionsNotAllowed (llvm::Value * ptr =nullptr) virtual void errorExternalCallsNotAllowed (String const & function_name, String const & target_name, llvm::Value * ptr =nullptr) virtual void errorTypeNotAllowed (String const & type_name, String const & target_name, llvm::Value * ptr =nullptr) virtual void errorPoisonNotAllowed (String const & target_name, llvm::Value * ptr =nullptr) virtual void errorUndefNotAllowed (String const & target_name, llvm::Value * ptr =nullptr) virtual void errorExpectedStringValueForAttr (String const & function_name, String const & attr_name) virtual void warningWeakLinkReplacementNotPossible (String const & function_name, String const & replacement) virtual void errorReplacementSignatureMismatch (String const & function_name, String const & signature1, String const & signature2) Protected Functions inherited from microsoft::quantum::ILogger Name void setHasErrors (bool value) void setHasWarnings (bool value)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#detailed-description","text":"class microsoft::quantum::LogCollection; Concrete ILogger implementation that collects all messages and their corresponding location in a list that can be traversed later on.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-debug","text":"virtual void debug( String const & message ) override Adds a debug message to the list. Reimplements : microsoft::quantum::ILogger::debug","title":"function debug"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-info","text":"virtual void info( String const & message ) override Adds an info message to the list. Reimplements : microsoft::quantum::ILogger::info","title":"function info"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-warning","text":"virtual void warning( String const & message ) override Adds a warning message to the list. Reimplements : microsoft::quantum::ILogger::warning","title":"function warning"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-error","text":"virtual void error( String const & message ) override Adds an error message to the list. Reimplements : microsoft::quantum::ILogger::error","title":"function error"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-internalerror","text":"virtual void internalError( String const & message ) override Adds an internal error message to the list. Reimplements : microsoft::quantum::ILogger::internalError","title":"function internalError"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-setlocation","text":"virtual void setLocation( SourceLocation const & loc ) override Function that allows to set the current location. Reimplements : microsoft::quantum::ILogger::setLocation","title":"function setLocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-setllvmhint","text":"virtual void setLlvmHint( String const & value ) override Sets the value of the LLVM instruction causing the issue. Reimplements : microsoft::quantum::ILogger::setLlvmHint","title":"function setLlvmHint"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-setfrontendhint","text":"virtual void setFrontendHint( String const & value ) override Sets the value of the frontend instruction causing the issue. Reimplements : microsoft::quantum::ILogger::setFrontendHint","title":"function setFrontendHint"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-messages","text":"virtual Messages const & messages() const override Accessor to the messages. Reimplements : microsoft::quantum::ILogger::messages","title":"function messages"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-dump","text":"virtual void dump( std::ostream & out ) const override Enabling dumping collection to a file. Reimplements : microsoft::quantum::ILogger::dump Updated on 28 October 2022 at 19:30:15 UTC","title":"function dump"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/","text":"microsoft::quantum::ModuleLoader Public Types Name using llvm::Module Module using llvm::Linker Linker using llvm::SMDiagnostic SMDiagnostic Public Functions Name ModuleLoader ( SpecConfiguration const & spec, Module * final_module, bool strip_existing_debug =false, bool add_ir_debug_info =false) bool addModule (std::unique_ptr< Module > && module, String const & filename =\"unknown\") bool addIrFile (String input_file) InstructionLocationTablePtr locationTable () const Public Types Documentation using Module using microsoft::quantum::ModuleLoader::Module = llvm::Module; using Linker using microsoft::quantum::ModuleLoader::Linker = llvm::Linker; using SMDiagnostic using microsoft::quantum::ModuleLoader::SMDiagnostic = llvm::SMDiagnostic; Public Functions Documentation function ModuleLoader inline explicit ModuleLoader( SpecConfiguration const & spec, Module * final_module, bool strip_existing_debug =false, bool add_ir_debug_info =false ) function addModule inline bool addModule( std::unique_ptr< Module > && module, String const & filename =\"unknown\" ) function addIrFile inline bool addIrFile( String input_file ) function locationTable inline InstructionLocationTablePtr locationTable() const Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::ModuleLoader"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#microsoftquantummoduleloader","text":"","title":"microsoft::quantum::ModuleLoader"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#public-types","text":"Name using llvm::Module Module using llvm::Linker Linker using llvm::SMDiagnostic SMDiagnostic","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#public-functions","text":"Name ModuleLoader ( SpecConfiguration const & spec, Module * final_module, bool strip_existing_debug =false, bool add_ir_debug_info =false) bool addModule (std::unique_ptr< Module > && module, String const & filename =\"unknown\") bool addIrFile (String input_file) InstructionLocationTablePtr locationTable () const","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#using-module","text":"using microsoft::quantum::ModuleLoader::Module = llvm::Module;","title":"using Module"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#using-linker","text":"using microsoft::quantum::ModuleLoader::Linker = llvm::Linker;","title":"using Linker"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#using-smdiagnostic","text":"using microsoft::quantum::ModuleLoader::SMDiagnostic = llvm::SMDiagnostic;","title":"using SMDiagnostic"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#function-moduleloader","text":"inline explicit ModuleLoader( SpecConfiguration const & spec, Module * final_module, bool strip_existing_debug =false, bool add_ir_debug_info =false )","title":"function ModuleLoader"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#function-addmodule","text":"inline bool addModule( std::unique_ptr< Module > && module, String const & filename =\"unknown\" )","title":"function addModule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#function-addirfile","text":"inline bool addIrFile( String input_file )","title":"function addIrFile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#function-locationtable","text":"inline InstructionLocationTablePtr locationTable() const Updated on 28 October 2022 at 19:30:15 UTC","title":"function locationTable"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/","text":"microsoft::quantum::ModuleLoader::SingleModuleTransformation Public Types Name using llvm::PassBuilder PassBuilder using llvm::OptimizationLevel OptimizationLevel using llvm::FunctionAnalysisManager FunctionAnalysisManager Public Functions Name SingleModuleTransformation ( SpecConfiguration const & spec, OptimizationLevel const & optimization_level =OptimizationLevel::O0, bool debug =false) bool apply (llvm::Module * module) bool isDebugMode () const Public Types Documentation using PassBuilder using microsoft::quantum::ModuleLoader::SingleModuleTransformation::PassBuilder = llvm::PassBuilder; using OptimizationLevel using microsoft::quantum::ModuleLoader::SingleModuleTransformation::OptimizationLevel = llvm::OptimizationLevel; using FunctionAnalysisManager using microsoft::quantum::ModuleLoader::SingleModuleTransformation::FunctionAnalysisManager = llvm::FunctionAnalysisManager; Public Functions Documentation function SingleModuleTransformation inline explicit SingleModuleTransformation( SpecConfiguration const & spec, OptimizationLevel const & optimization_level =OptimizationLevel::O0, bool debug =false ) function apply inline bool apply( llvm::Module * module ) function isDebugMode inline bool isDebugMode() const Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::ModuleLoader::SingleModuleTransformation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#microsoftquantummoduleloadersinglemoduletransformation","text":"","title":"microsoft::quantum::ModuleLoader::SingleModuleTransformation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#public-types","text":"Name using llvm::PassBuilder PassBuilder using llvm::OptimizationLevel OptimizationLevel using llvm::FunctionAnalysisManager FunctionAnalysisManager","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#public-functions","text":"Name SingleModuleTransformation ( SpecConfiguration const & spec, OptimizationLevel const & optimization_level =OptimizationLevel::O0, bool debug =false) bool apply (llvm::Module * module) bool isDebugMode () const","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#using-passbuilder","text":"using microsoft::quantum::ModuleLoader::SingleModuleTransformation::PassBuilder = llvm::PassBuilder;","title":"using PassBuilder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#using-optimizationlevel","text":"using microsoft::quantum::ModuleLoader::SingleModuleTransformation::OptimizationLevel = llvm::OptimizationLevel;","title":"using OptimizationLevel"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#using-functionanalysismanager","text":"using microsoft::quantum::ModuleLoader::SingleModuleTransformation::FunctionAnalysisManager = llvm::FunctionAnalysisManager;","title":"using FunctionAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#function-singlemoduletransformation","text":"inline explicit SingleModuleTransformation( SpecConfiguration const & spec, OptimizationLevel const & optimization_level =OptimizationLevel::O0, bool debug =false )","title":"function SingleModuleTransformation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#function-apply","text":"inline bool apply( llvm::Module * module )","title":"function apply"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#function-isdebugmode","text":"inline bool isDebugMode() const Updated on 28 October 2022 at 19:30:15 UTC","title":"function isDebugMode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_set/","text":"microsoft::quantum::OpcodeSet Public Types Name using std::unordered_set< OpcodeValue > Container Public Functions Name OpcodeSet (Container const & data ={}) OpcodeSet (Container && data) Container & data () Container const & data () const void toString (String & value) const void insertPart (String const & part) void fromString (String const & value) void toYaml (YAML::Node & node) const void fromYaml (YAML::Node const & node) Public Types Documentation using Container using microsoft::quantum::OpcodeSet::Container = std::unordered_set<OpcodeValue>; Public Functions Documentation function OpcodeSet inline explicit OpcodeSet( Container const & data ={} ) function OpcodeSet inline explicit OpcodeSet( Container && data ) function data inline Container & data() function data inline Container const & data() const function toString inline void toString( String & value ) const function insertPart inline void insertPart( String const & part ) function fromString inline void fromString( String const & value ) function toYaml inline void toYaml( YAML::Node & node ) const function fromYaml inline void fromYaml( YAML::Node const & node ) Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::OpcodeSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_set/#microsoftquantumopcodeset","text":"","title":"microsoft::quantum::OpcodeSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_set/#public-types","text":"Name using std::unordered_set< OpcodeValue > Container","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_set/#public-functions","text":"Name OpcodeSet (Container const & data ={}) OpcodeSet (Container && data) Container & data () Container const & data () const void toString (String & value) const void insertPart (String const & part) void fromString (String const & value) void toYaml (YAML::Node & node) const void fromYaml (YAML::Node const & node)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_set/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_set/#using-container","text":"using microsoft::quantum::OpcodeSet::Container = std::unordered_set<OpcodeValue>;","title":"using Container"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_set/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_set/#function-opcodeset","text":"inline explicit OpcodeSet( Container const & data ={} )","title":"function OpcodeSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_set/#function-opcodeset_1","text":"inline explicit OpcodeSet( Container && data )","title":"function OpcodeSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_set/#function-data","text":"inline Container & data()","title":"function data"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_set/#function-data_1","text":"inline Container const & data() const","title":"function data"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_set/#function-tostring","text":"inline void toString( String & value ) const","title":"function toString"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_set/#function-insertpart","text":"inline void insertPart( String const & part )","title":"function insertPart"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_set/#function-fromstring","text":"inline void fromString( String const & value )","title":"function fromString"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_set/#function-toyaml","text":"inline void toYaml( YAML::Node & node ) const","title":"function toYaml"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_set/#function-fromyaml","text":"inline void fromYaml( YAML::Node const & node ) Updated on 28 October 2022 at 19:30:15 UTC","title":"function fromYaml"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_value/","text":"microsoft::quantum::OpcodeValue Public Functions Name OpcodeValue (String const & name, String const & fi =\"\") OpcodeValue () =default OpcodeValue ( OpcodeValue && ) =default OpcodeValue ( OpcodeValue const & ) =default OpcodeValue & operator= ( OpcodeValue && ) =default OpcodeValue & operator= ( OpcodeValue const & ) =default bool operator== ( OpcodeValue const & other) const String & id () String const & id () const String & predicate () String const & predicate () const Public Functions Documentation function OpcodeValue inline OpcodeValue( String const & name, String const & fi =\"\" ) function OpcodeValue OpcodeValue() =default function OpcodeValue OpcodeValue( OpcodeValue && ) =default function OpcodeValue OpcodeValue( OpcodeValue const & ) =default function operator= OpcodeValue & operator=( OpcodeValue && ) =default function operator= OpcodeValue & operator=( OpcodeValue const & ) =default function operator== inline bool operator==( OpcodeValue const & other ) const function id inline String & id() function id inline String const & id() const function predicate inline String & predicate() function predicate inline String const & predicate() const Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::OpcodeValue"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_value/#microsoftquantumopcodevalue","text":"","title":"microsoft::quantum::OpcodeValue"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_value/#public-functions","text":"Name OpcodeValue (String const & name, String const & fi =\"\") OpcodeValue () =default OpcodeValue ( OpcodeValue && ) =default OpcodeValue ( OpcodeValue const & ) =default OpcodeValue & operator= ( OpcodeValue && ) =default OpcodeValue & operator= ( OpcodeValue const & ) =default bool operator== ( OpcodeValue const & other) const String & id () String const & id () const String & predicate () String const & predicate () const","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_value/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_value/#function-opcodevalue","text":"inline OpcodeValue( String const & name, String const & fi =\"\" )","title":"function OpcodeValue"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_value/#function-opcodevalue_1","text":"OpcodeValue() =default","title":"function OpcodeValue"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_value/#function-opcodevalue_2","text":"OpcodeValue( OpcodeValue && ) =default","title":"function OpcodeValue"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_value/#function-opcodevalue_3","text":"OpcodeValue( OpcodeValue const & ) =default","title":"function OpcodeValue"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_value/#function-operator","text":"OpcodeValue & operator=( OpcodeValue && ) =default","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_value/#function-operator_1","text":"OpcodeValue & operator=( OpcodeValue const & ) =default","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_value/#function-operator_2","text":"inline bool operator==( OpcodeValue const & other ) const","title":"function operator=="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_value/#function-id","text":"inline String & id()","title":"function id"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_value/#function-id_1","text":"inline String const & id() const","title":"function id"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_value/#function-predicate","text":"inline String & predicate()","title":"function predicate"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_opcode_value/#function-predicate_1","text":"inline String const & predicate() const Updated on 28 October 2022 at 19:30:15 UTC","title":"function predicate"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/","text":"microsoft::quantum::ParameterParser More... #include <Commandline/ParameterParser.hpp> Public Types Name using std::vector< String > Arguments using std::unordered_set< String > Flags using std::unordered_map< String, String > SettingsMap using std::unordered_set< String > UnusedSettings using std::unordered_map< String, String > ShorthandNotation Public Functions Name ParameterParser () =default ParameterParser ( ParameterParser const & other) ParameterParser ( ParameterParser && other) =default ~ParameterParser () =default void addFlag (String const & v) void parseArgs (int argc, char const ** argv) Arguments const & arguments () const String const & getArg (Arguments::size_type const & n) const Returns the n'th commandline argument. String const & get (String const & name, String const & default_value) Gets a named setting, falling back to a default if the key is not found. String const & get (String const & name) Gets a named setting. This method throws if the setting is not present. void markAsUsed (String const & name) Marks a flag as used. bool has (String const & name) const Checks whether or not a given parameter is present. void reset () Resets the state of the parser to its construction state. UnusedSettings const & unusedSettings () const Lists unknown settings. void addShorthandNotation (String const & parameter, String const & shorthand) Adds short hand notation to paramters. Detailed Description class microsoft::quantum::ParameterParser; Parameter parser class which allows the developer to specify a set of default settings and update those using the commandline argc and argv. Public Types Documentation using Arguments using microsoft::quantum::ParameterParser::Arguments = std::vector<String>; using Flags using microsoft::quantum::ParameterParser::Flags = std::unordered_set<String>; using SettingsMap using microsoft::quantum::ParameterParser::SettingsMap = std::unordered_map<String, String>; using UnusedSettings using microsoft::quantum::ParameterParser::UnusedSettings = std::unordered_set<String>; using ShorthandNotation using microsoft::quantum::ParameterParser::ShorthandNotation = std::unordered_map<String, String>; Public Functions Documentation function ParameterParser ParameterParser() =default function ParameterParser ParameterParser( ParameterParser const & other ) function ParameterParser ParameterParser( ParameterParser && other ) =default function ~ParameterParser ~ParameterParser() =default function addFlag void addFlag( String const & v ) Marks a name as a flag (as opposed to an option). This ensures that no parameter is expected after the flag is specified. For instance --debug is a flag as opposed to --log-level 3 which is an option. function parseArgs void parseArgs( int argc, char const ** argv ) Parses the command line arguments given the argc and argv from the main function. function arguments Arguments const & arguments() const Returns list of arguments without flags and/or options included. function getArg String const & getArg( Arguments::size_type const & n ) const Returns the n'th commandline argument. function get String const & get( String const & name, String const & default_value ) Gets a named setting, falling back to a default if the key is not found. function get String const & get( String const & name ) Gets a named setting. This method throws if the setting is not present. function markAsUsed void markAsUsed( String const & name ) Marks a flag as used. function has bool has( String const & name ) const Checks whether or not a given parameter is present. function reset void reset() Resets the state of the parser to its construction state. function unusedSettings UnusedSettings const & unusedSettings() const Lists unknown settings. function addShorthandNotation void addShorthandNotation( String const & parameter, String const & shorthand ) Adds short hand notation to paramters. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::ParameterParser"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#microsoftquantumparameterparser","text":"More... #include <Commandline/ParameterParser.hpp>","title":"microsoft::quantum::ParameterParser"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#public-types","text":"Name using std::vector< String > Arguments using std::unordered_set< String > Flags using std::unordered_map< String, String > SettingsMap using std::unordered_set< String > UnusedSettings using std::unordered_map< String, String > ShorthandNotation","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#public-functions","text":"Name ParameterParser () =default ParameterParser ( ParameterParser const & other) ParameterParser ( ParameterParser && other) =default ~ParameterParser () =default void addFlag (String const & v) void parseArgs (int argc, char const ** argv) Arguments const & arguments () const String const & getArg (Arguments::size_type const & n) const Returns the n'th commandline argument. String const & get (String const & name, String const & default_value) Gets a named setting, falling back to a default if the key is not found. String const & get (String const & name) Gets a named setting. This method throws if the setting is not present. void markAsUsed (String const & name) Marks a flag as used. bool has (String const & name) const Checks whether or not a given parameter is present. void reset () Resets the state of the parser to its construction state. UnusedSettings const & unusedSettings () const Lists unknown settings. void addShorthandNotation (String const & parameter, String const & shorthand) Adds short hand notation to paramters.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#detailed-description","text":"class microsoft::quantum::ParameterParser; Parameter parser class which allows the developer to specify a set of default settings and update those using the commandline argc and argv.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#using-arguments","text":"using microsoft::quantum::ParameterParser::Arguments = std::vector<String>;","title":"using Arguments"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#using-flags","text":"using microsoft::quantum::ParameterParser::Flags = std::unordered_set<String>;","title":"using Flags"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#using-settingsmap","text":"using microsoft::quantum::ParameterParser::SettingsMap = std::unordered_map<String, String>;","title":"using SettingsMap"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#using-unusedsettings","text":"using microsoft::quantum::ParameterParser::UnusedSettings = std::unordered_set<String>;","title":"using UnusedSettings"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#using-shorthandnotation","text":"using microsoft::quantum::ParameterParser::ShorthandNotation = std::unordered_map<String, String>;","title":"using ShorthandNotation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-parameterparser","text":"ParameterParser() =default","title":"function ParameterParser"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-parameterparser_1","text":"ParameterParser( ParameterParser const & other )","title":"function ParameterParser"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-parameterparser_2","text":"ParameterParser( ParameterParser && other ) =default","title":"function ParameterParser"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-parameterparser_3","text":"~ParameterParser() =default","title":"function ~ParameterParser"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-addflag","text":"void addFlag( String const & v ) Marks a name as a flag (as opposed to an option). This ensures that no parameter is expected after the flag is specified. For instance --debug is a flag as opposed to --log-level 3 which is an option.","title":"function addFlag"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-parseargs","text":"void parseArgs( int argc, char const ** argv ) Parses the command line arguments given the argc and argv from the main function.","title":"function parseArgs"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-arguments","text":"Arguments const & arguments() const Returns list of arguments without flags and/or options included.","title":"function arguments"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-getarg","text":"String const & getArg( Arguments::size_type const & n ) const Returns the n'th commandline argument.","title":"function getArg"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-get","text":"String const & get( String const & name, String const & default_value ) Gets a named setting, falling back to a default if the key is not found.","title":"function get"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-get_1","text":"String const & get( String const & name ) Gets a named setting. This method throws if the setting is not present.","title":"function get"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-markasused","text":"void markAsUsed( String const & name ) Marks a flag as used.","title":"function markAsUsed"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-has","text":"bool has( String const & name ) const Checks whether or not a given parameter is present.","title":"function has"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-reset","text":"void reset() Resets the state of the parser to its construction state.","title":"function reset"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-unusedsettings","text":"UnusedSettings const & unusedSettings() const Lists unknown settings.","title":"function unusedSettings"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-addshorthandnotation","text":"void addShorthandNotation( String const & parameter, String const & shorthand ) Adds short hand notation to paramters. Updated on 28 October 2022 at 19:30:15 UTC","title":"function addShorthandNotation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/","text":"microsoft::quantum::PhiPattern Inherits from microsoft::quantum::IOperandPrototype Public Types Name using std::string String Public Functions Name PhiPattern () =default Construction by name. PhiPattern ( PhiPattern const & other) Copy construction prohibited. PhiPattern ( PhiPattern && other) =default Move construction allowed. ~PhiPattern () override Destructor implementation. virtual bool match (Value * instr, Captures & captures) const override Matches the phi node. virtual Child copy () const override Creates a copy of itself. Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Types Documentation using String using microsoft::quantum::PhiPattern::String = std::string; Public Functions Documentation function PhiPattern PhiPattern() =default Construction by name. function PhiPattern PhiPattern( PhiPattern const & other ) Copy construction prohibited. function PhiPattern PhiPattern( PhiPattern && other ) =default Move construction allowed. function ~PhiPattern ~PhiPattern() override Destructor implementation. function match virtual bool match( Value * instr, Captures & captures ) const override Matches the phi node. Reimplements : microsoft::quantum::IOperandPrototype::match function copy virtual Child copy() const override Creates a copy of itself. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::PhiPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#microsoftquantumphipattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::PhiPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#public-types","text":"Name using std::string String","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#public-functions","text":"Name PhiPattern () =default Construction by name. PhiPattern ( PhiPattern const & other) Copy construction prohibited. PhiPattern ( PhiPattern && other) =default Move construction allowed. ~PhiPattern () override Destructor implementation. virtual bool match (Value * instr, Captures & captures) const override Matches the phi node. virtual Child copy () const override Creates a copy of itself.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#using-string","text":"using microsoft::quantum::PhiPattern::String = std::string;","title":"using String"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#function-phipattern","text":"PhiPattern() =default Construction by name.","title":"function PhiPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#function-phipattern_1","text":"PhiPattern( PhiPattern const & other ) Copy construction prohibited.","title":"function PhiPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#function-phipattern_2","text":"PhiPattern( PhiPattern && other ) =default Move construction allowed.","title":"function PhiPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#function-phipattern_3","text":"~PhiPattern() override Destructor implementation.","title":"function ~PhiPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#function-match","text":"virtual bool match( Value * instr, Captures & captures ) const override Matches the phi node. Reimplements : microsoft::quantum::IOperandPrototype::match","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#function-copy","text":"virtual Child copy() const override Creates a copy of itself. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 28 October 2022 at 19:30:15 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass/","text":"microsoft::quantum::PostTransformValidationPass Inherits from llvm::PassInfoMixin< PostTransformValidationPass > Public Types Name using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using ILogger::Location Location using llvm::StringRef StringRef Public Functions Name PostTransformValidationPass ( PostTransformValidationPassConfiguration const & cfg, ILoggerPtr const & logger =nullptr) PostTransformValidationPass ( PostTransformValidationPass const & ) Copy construction is banned. PostTransformValidationPass ( PostTransformValidationPass && ) =default We allow move semantics. ~PostTransformValidationPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool isRequired () Whether or not this pass is required to run. Public Types Documentation using Instruction using microsoft::quantum::PostTransformValidationPass::Instruction = llvm::Instruction; using Value using microsoft::quantum::PostTransformValidationPass::Value = llvm::Value; using ILoggerPtr using microsoft::quantum::PostTransformValidationPass::ILoggerPtr = ILogger::ILoggerPtr; using Location using microsoft::quantum::PostTransformValidationPass::Location = ILogger::Location; using StringRef using microsoft::quantum::PostTransformValidationPass::StringRef = llvm::StringRef; Public Functions Documentation function PostTransformValidationPass explicit PostTransformValidationPass( PostTransformValidationPassConfiguration const & cfg, ILoggerPtr const & logger =nullptr ) function PostTransformValidationPass PostTransformValidationPass( PostTransformValidationPass const & ) Copy construction is banned. function PostTransformValidationPass PostTransformValidationPass( PostTransformValidationPass && ) =default We allow move semantics. function ~PostTransformValidationPass ~PostTransformValidationPass() =default Default destruction. function run llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function isRequired static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::PostTransformValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass/#microsoftquantumposttransformvalidationpass","text":"Inherits from llvm::PassInfoMixin< PostTransformValidationPass >","title":"microsoft::quantum::PostTransformValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass/#public-types","text":"Name using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using ILogger::Location Location using llvm::StringRef StringRef","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass/#public-functions","text":"Name PostTransformValidationPass ( PostTransformValidationPassConfiguration const & cfg, ILoggerPtr const & logger =nullptr) PostTransformValidationPass ( PostTransformValidationPass const & ) Copy construction is banned. PostTransformValidationPass ( PostTransformValidationPass && ) =default We allow move semantics. ~PostTransformValidationPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass/#using-instruction","text":"using microsoft::quantum::PostTransformValidationPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass/#using-value","text":"using microsoft::quantum::PostTransformValidationPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass/#using-iloggerptr","text":"using microsoft::quantum::PostTransformValidationPass::ILoggerPtr = ILogger::ILoggerPtr;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass/#using-location","text":"using microsoft::quantum::PostTransformValidationPass::Location = ILogger::Location;","title":"using Location"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass/#using-stringref","text":"using microsoft::quantum::PostTransformValidationPass::StringRef = llvm::StringRef;","title":"using StringRef"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass/#function-posttransformvalidationpass","text":"explicit PostTransformValidationPass( PostTransformValidationPassConfiguration const & cfg, ILoggerPtr const & logger =nullptr )","title":"function PostTransformValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass/#function-posttransformvalidationpass_1","text":"PostTransformValidationPass( PostTransformValidationPass const & ) Copy construction is banned.","title":"function PostTransformValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass/#function-posttransformvalidationpass_2","text":"PostTransformValidationPass( PostTransformValidationPass && ) =default We allow move semantics.","title":"function PostTransformValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass/#function-posttransformvalidationpass_3","text":"~PostTransformValidationPass() =default Default destruction.","title":"function ~PostTransformValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass/#function-run","text":"llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass_configuration/","text":"microsoft::quantum::PostTransformValidationPassConfiguration Public Types Name using DeferredValue::DeferredValuePtr DeferredValuePtr Public Functions Name void setup ( ConfigurationManager & config) bool requireStraightLineCode () const PostTransformValidationPassConfiguration createDisabled () Public Types Documentation using DeferredValuePtr using microsoft::quantum::PostTransformValidationPassConfiguration::DeferredValuePtr = DeferredValue::DeferredValuePtr; Public Functions Documentation function setup inline void setup( ConfigurationManager & config ) function requireStraightLineCode inline bool requireStraightLineCode() const function createDisabled static inline PostTransformValidationPassConfiguration createDisabled() Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::PostTransformValidationPassConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass_configuration/#microsoftquantumposttransformvalidationpassconfiguration","text":"","title":"microsoft::quantum::PostTransformValidationPassConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass_configuration/#public-types","text":"Name using DeferredValue::DeferredValuePtr DeferredValuePtr","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass_configuration/#public-functions","text":"Name void setup ( ConfigurationManager & config) bool requireStraightLineCode () const PostTransformValidationPassConfiguration createDisabled ()","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass_configuration/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass_configuration/#using-deferredvalueptr","text":"using microsoft::quantum::PostTransformValidationPassConfiguration::DeferredValuePtr = DeferredValue::DeferredValuePtr;","title":"using DeferredValuePtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass_configuration/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass_configuration/#function-setup","text":"inline void setup( ConfigurationManager & config )","title":"function setup"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass_configuration/#function-requirestraightlinecode","text":"inline bool requireStraightLineCode() const","title":"function requireStraightLineCode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_post_transform_validation_pass_configuration/#function-createdisabled","text":"static inline PostTransformValidationPassConfiguration createDisabled() Updated on 28 October 2022 at 19:30:15 UTC","title":"function createDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/","text":"microsoft::quantum::QirAdaptor More... #include <QirAdaptor/QirAdaptor.hpp> Public Types Name using IAllocationManager::AllocationManagerPtr AllocationManagerPtr using Validator::ValidatorPtr ValidatorPtr Validator class used to check that an IR fulfils a given specification. using std::shared_ptr< ILogger > ILoggerPtr Public Functions Name QirAdaptor ( ConfigurationManager & configuration_manager, String const & name, ILoggerPtr const & logger, bool debug, llvm::TargetMachine * target_machine =nullptr, AllocationManagerPtr qubit_allocation_manager = BasicAllocationManager::createNew (), AllocationManagerPtr result_allocation_manager = BasicAllocationManager::createNew ()) QirAdaptor () QirAdaptor ( QirAdaptor const & ) QirAdaptor ( QirAdaptor && ) QirAdaptor & operator= ( QirAdaptor const & ) QirAdaptor & operator= ( QirAdaptor && ) ~QirAdaptor () =default void apply (llvm::Module & module) Applies the adaptor to a module. bool verify (llvm::Module & module) Verifies that a module is a valid LLVM IR. bool validate (llvm::Module & module) Validates that a module complies with the specified QIR adaptor. AllocationManagerPtr getQubitAllocationManager () AllocationManagerPtr getResultAllocationManager () String const & name () const llvm::PassBuilder & passBuilder () Returns a reference to the pass builder. llvm::LoopAnalysisManager & loopAnalysisManager () Returns a reference to the loop analysis manager. llvm::FunctionAnalysisManager & functionAnalysisManager () Returns a reference to the function analysis manager. llvm::CGSCCAnalysisManager & gsccAnalysisManager () Returns a reference to the GSCC analysis manager. llvm::ModuleAnalysisManager & moduleAnalysisManager () Returns a reference to the module analysis manager. llvm::ModulePassManager & modulePassManager () Returns the module pass manager associated with the adaptor. ConfigurationManager & configurationManager () Returns the configuration manager. Protected Functions Name void setValidator ( ValidatorPtr && validator) Sets the validator. Friends Name class QirAdaptorFactory Detailed Description class microsoft::quantum::QirAdaptor; QirAdaptor class that defines a set of rules which constitutes the adaptor definition. Each of the rules can be used to transform a generic QIR and/or validate that the QIR is compliant with said rule. Public Types Documentation using AllocationManagerPtr using microsoft::quantum::QirAdaptor::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; Allocation manager pointer type. Used to reference to concrete allocation manager implementations which defines the allocation logic of the adaptor. using ValidatorPtr using microsoft::quantum::QirAdaptor::ValidatorPtr = Validator::ValidatorPtr; Validator class used to check that an IR fulfils a given specification. using ILoggerPtr using microsoft::quantum::QirAdaptor::ILoggerPtr = std::shared_ptr<ILogger>; Public Functions Documentation function QirAdaptor explicit QirAdaptor( ConfigurationManager & configuration_manager, String const & name, ILoggerPtr const & logger, bool debug, llvm::TargetMachine * target_machine =nullptr, AllocationManagerPtr qubit_allocation_manager =BasicAllocationManager::createNew(), AllocationManagerPtr result_allocation_manager =BasicAllocationManager::createNew() ) function QirAdaptor QirAdaptor() function QirAdaptor QirAdaptor( QirAdaptor const & ) function QirAdaptor QirAdaptor( QirAdaptor && ) function operator= QirAdaptor & operator=( QirAdaptor const & ) function operator= QirAdaptor & operator=( QirAdaptor && ) function ~QirAdaptor ~QirAdaptor() =default function apply void apply( llvm::Module & module ) Applies the adaptor to a module. function verify bool verify( llvm::Module & module ) Verifies that a module is a valid LLVM IR. function validate bool validate( llvm::Module & module ) Validates that a module complies with the specified QIR adaptor. function getQubitAllocationManager AllocationManagerPtr getQubitAllocationManager() function getResultAllocationManager AllocationManagerPtr getResultAllocationManager() function name String const & name() const function passBuilder llvm::PassBuilder & passBuilder() Returns a reference to the pass builder. function loopAnalysisManager llvm::LoopAnalysisManager & loopAnalysisManager() Returns a reference to the loop analysis manager. function functionAnalysisManager llvm::FunctionAnalysisManager & functionAnalysisManager() Returns a reference to the function analysis manager. function gsccAnalysisManager llvm::CGSCCAnalysisManager & gsccAnalysisManager() Returns a reference to the GSCC analysis manager. function moduleAnalysisManager llvm::ModuleAnalysisManager & moduleAnalysisManager() Returns a reference to the module analysis manager. function modulePassManager llvm::ModulePassManager & modulePassManager() Returns the module pass manager associated with the adaptor. function configurationManager inline ConfigurationManager & configurationManager() Returns the configuration manager. Protected Functions Documentation function setValidator void setValidator( ValidatorPtr && validator ) Sets the validator. Friends friend QirAdaptorFactory friend class QirAdaptorFactory; Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::QirAdaptor"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#microsoftquantumqiradaptor","text":"More... #include <QirAdaptor/QirAdaptor.hpp>","title":"microsoft::quantum::QirAdaptor"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#public-types","text":"Name using IAllocationManager::AllocationManagerPtr AllocationManagerPtr using Validator::ValidatorPtr ValidatorPtr Validator class used to check that an IR fulfils a given specification. using std::shared_ptr< ILogger > ILoggerPtr","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#public-functions","text":"Name QirAdaptor ( ConfigurationManager & configuration_manager, String const & name, ILoggerPtr const & logger, bool debug, llvm::TargetMachine * target_machine =nullptr, AllocationManagerPtr qubit_allocation_manager = BasicAllocationManager::createNew (), AllocationManagerPtr result_allocation_manager = BasicAllocationManager::createNew ()) QirAdaptor () QirAdaptor ( QirAdaptor const & ) QirAdaptor ( QirAdaptor && ) QirAdaptor & operator= ( QirAdaptor const & ) QirAdaptor & operator= ( QirAdaptor && ) ~QirAdaptor () =default void apply (llvm::Module & module) Applies the adaptor to a module. bool verify (llvm::Module & module) Verifies that a module is a valid LLVM IR. bool validate (llvm::Module & module) Validates that a module complies with the specified QIR adaptor. AllocationManagerPtr getQubitAllocationManager () AllocationManagerPtr getResultAllocationManager () String const & name () const llvm::PassBuilder & passBuilder () Returns a reference to the pass builder. llvm::LoopAnalysisManager & loopAnalysisManager () Returns a reference to the loop analysis manager. llvm::FunctionAnalysisManager & functionAnalysisManager () Returns a reference to the function analysis manager. llvm::CGSCCAnalysisManager & gsccAnalysisManager () Returns a reference to the GSCC analysis manager. llvm::ModuleAnalysisManager & moduleAnalysisManager () Returns a reference to the module analysis manager. llvm::ModulePassManager & modulePassManager () Returns the module pass manager associated with the adaptor. ConfigurationManager & configurationManager () Returns the configuration manager.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#protected-functions","text":"Name void setValidator ( ValidatorPtr && validator) Sets the validator.","title":"Protected Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#friends","text":"Name class QirAdaptorFactory","title":"Friends"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#detailed-description","text":"class microsoft::quantum::QirAdaptor; QirAdaptor class that defines a set of rules which constitutes the adaptor definition. Each of the rules can be used to transform a generic QIR and/or validate that the QIR is compliant with said rule.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#using-allocationmanagerptr","text":"using microsoft::quantum::QirAdaptor::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; Allocation manager pointer type. Used to reference to concrete allocation manager implementations which defines the allocation logic of the adaptor.","title":"using AllocationManagerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#using-validatorptr","text":"using microsoft::quantum::QirAdaptor::ValidatorPtr = Validator::ValidatorPtr; Validator class used to check that an IR fulfils a given specification.","title":"using ValidatorPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#using-iloggerptr","text":"using microsoft::quantum::QirAdaptor::ILoggerPtr = std::shared_ptr<ILogger>;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#function-qiradaptor","text":"explicit QirAdaptor( ConfigurationManager & configuration_manager, String const & name, ILoggerPtr const & logger, bool debug, llvm::TargetMachine * target_machine =nullptr, AllocationManagerPtr qubit_allocation_manager =BasicAllocationManager::createNew(), AllocationManagerPtr result_allocation_manager =BasicAllocationManager::createNew() )","title":"function QirAdaptor"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#function-qiradaptor_1","text":"QirAdaptor()","title":"function QirAdaptor"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#function-qiradaptor_2","text":"QirAdaptor( QirAdaptor const & )","title":"function QirAdaptor"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#function-qiradaptor_3","text":"QirAdaptor( QirAdaptor && )","title":"function QirAdaptor"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#function-operator","text":"QirAdaptor & operator=( QirAdaptor const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#function-operator_1","text":"QirAdaptor & operator=( QirAdaptor && )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#function-qiradaptor_4","text":"~QirAdaptor() =default","title":"function ~QirAdaptor"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#function-apply","text":"void apply( llvm::Module & module ) Applies the adaptor to a module.","title":"function apply"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#function-verify","text":"bool verify( llvm::Module & module ) Verifies that a module is a valid LLVM IR.","title":"function verify"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#function-validate","text":"bool validate( llvm::Module & module ) Validates that a module complies with the specified QIR adaptor.","title":"function validate"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#function-getqubitallocationmanager","text":"AllocationManagerPtr getQubitAllocationManager()","title":"function getQubitAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#function-getresultallocationmanager","text":"AllocationManagerPtr getResultAllocationManager()","title":"function getResultAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#function-name","text":"String const & name() const","title":"function name"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#function-passbuilder","text":"llvm::PassBuilder & passBuilder() Returns a reference to the pass builder.","title":"function passBuilder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#function-loopanalysismanager","text":"llvm::LoopAnalysisManager & loopAnalysisManager() Returns a reference to the loop analysis manager.","title":"function loopAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#function-functionanalysismanager","text":"llvm::FunctionAnalysisManager & functionAnalysisManager() Returns a reference to the function analysis manager.","title":"function functionAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#function-gsccanalysismanager","text":"llvm::CGSCCAnalysisManager & gsccAnalysisManager() Returns a reference to the GSCC analysis manager.","title":"function gsccAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#function-moduleanalysismanager","text":"llvm::ModuleAnalysisManager & moduleAnalysisManager() Returns a reference to the module analysis manager.","title":"function moduleAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#function-modulepassmanager","text":"llvm::ModulePassManager & modulePassManager() Returns the module pass manager associated with the adaptor.","title":"function modulePassManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#function-configurationmanager","text":"inline ConfigurationManager & configurationManager() Returns the configuration manager.","title":"function configurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#function-setvalidator","text":"void setValidator( ValidatorPtr && validator ) Sets the validator.","title":"function setValidator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#friends_1","text":"","title":"Friends"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor/#friend-qiradaptorfactory","text":"friend class QirAdaptorFactory; Updated on 28 October 2022 at 19:30:15 UTC","title":"friend QirAdaptorFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/","text":"microsoft::quantum::QirAdaptorFactory Inherited by microsoft::quantum::ConfigurableQirAdaptorFactory Public Types Name using llvm::PassBuilder PassBuilder using llvm::OptimizationLevel OptimizationLevel using llvm::FunctionAnalysisManager FunctionAnalysisManager using std::shared_ptr< QirAdaptor > QirAdaptorPtr using std::shared_ptr< BasicAllocationManager > BasicAllocationManagerPtr using llvm::FunctionPassManager FunctionPassManager template <typename R > using std::function< void(R const &, QirAdaptor &)> SetupFunction using std::function< void( QirAdaptorFactory &, QirAdaptor &)> SetupFunctionWrapper Wrapper function type for invoking the adaptor setup function. using std::vector< std::pair< String, SetupFunctionWrapper > > Components List of components to be configured. using ILogger::ILoggerPtr ILoggerPtr Public Functions Name QirAdaptorFactory ( ConfigurationManager & configuration_manager) ~QirAdaptorFactory () =default QirAdaptorFactory ( QirAdaptorFactory const & ) QirAdaptorFactory ( QirAdaptorFactory && ) QirAdaptorFactory & operator= ( QirAdaptorFactory const & ) QirAdaptorFactory & operator= ( QirAdaptorFactory && ) ConfigurationManager & configurationManager () ConfigurationManager const & configurationManager () const QirAdaptorPtr newQirAdaptor (String const & name, OptimizationLevel const & optimization_level, bool debug) void newAdaptorContext (String const & name, bool debug =false) Prepares a new adaptor context. void addComponent (String const & name) Adds a component to the current context. QirAdaptorPtr finalizeAdaptor () Finalizes the context and returns the QIR adaptor. template <typename R > void registerAdaptorComponent (String const & id, SetupFunction < R > setup) template <typename R > void replaceAdaptorComponent (String const & id, SetupFunction < R > setup) template <typename R > void registerAnonymousAdaptorComponent ( SetupFunction < R > setup) void replicateAdaptorComponent (String const & id) bool isDebugMode () const Flag indicating whether we are operating in debug mode or not. void setupDefaultComponentPipeline () Sets the default pipeline up. void setLogger (ILoggerPtr const & logger =nullptr) Protected Functions Name llvm::ModulePassManager createValidationModulePass (PassBuilder & pass_builder, OptimizationLevel const & optimization_level, bool debug) Public Types Documentation using PassBuilder using microsoft::quantum::QirAdaptorFactory::PassBuilder = llvm::PassBuilder; using OptimizationLevel using microsoft::quantum::QirAdaptorFactory::OptimizationLevel = llvm::OptimizationLevel; using FunctionAnalysisManager using microsoft::quantum::QirAdaptorFactory::FunctionAnalysisManager = llvm::FunctionAnalysisManager; using QirAdaptorPtr using microsoft::quantum::QirAdaptorFactory::QirAdaptorPtr = std::shared_ptr<QirAdaptor>; using BasicAllocationManagerPtr using microsoft::quantum::QirAdaptorFactory::BasicAllocationManagerPtr = std::shared_ptr<BasicAllocationManager>; using FunctionPassManager using microsoft::quantum::QirAdaptorFactory::FunctionPassManager = llvm::FunctionPassManager; using SetupFunction template <typename R > using microsoft::quantum::QirAdaptorFactory::SetupFunction = std::function<void(R const&, QirAdaptor&)>; Setup function that uses a configuration type R to configure the adaptor and/or generator. using SetupFunctionWrapper using microsoft::quantum::QirAdaptorFactory::SetupFunctionWrapper = std::function<void(QirAdaptorFactory&, QirAdaptor&)>; Wrapper function type for invoking the adaptor setup function. using Components using microsoft::quantum::QirAdaptorFactory::Components = std::vector<std::pair<String, SetupFunctionWrapper> >; List of components to be configured. using ILoggerPtr using microsoft::quantum::QirAdaptorFactory::ILoggerPtr = ILogger::ILoggerPtr; Public Functions Documentation function QirAdaptorFactory inline explicit QirAdaptorFactory( ConfigurationManager & configuration_manager ) function ~QirAdaptorFactory ~QirAdaptorFactory() =default function QirAdaptorFactory QirAdaptorFactory( QirAdaptorFactory const & ) function QirAdaptorFactory QirAdaptorFactory( QirAdaptorFactory && ) function operator= QirAdaptorFactory & operator=( QirAdaptorFactory const & ) function operator= QirAdaptorFactory & operator=( QirAdaptorFactory && ) function configurationManager ConfigurationManager & configurationManager() Reference to configuration manager. This property allows to access and modify configurations of the generator. This property is intended for managing the configuration. function configurationManager ConfigurationManager const & configurationManager() const Constant reference to the configuration manager. This property allows read access to the configuration manager and is intended for adaptor generation. function newQirAdaptor QirAdaptorPtr newQirAdaptor( String const & name, OptimizationLevel const & optimization_level, bool debug ) Creates a new adaptor based on the registered components, optimization level and debug requirements. The returned adaptor can be applied to an IR to transform it in accordance with the configurations given. function newAdaptorContext void newAdaptorContext( String const & name, bool debug =false ) Prepares a new adaptor context. function addComponent void addComponent( String const & name ) Adds a component to the current context. function finalizeAdaptor QirAdaptorPtr finalizeAdaptor() Finalizes the context and returns the QIR adaptor. function registerAdaptorComponent template <typename R > void registerAdaptorComponent( String const & id, SetupFunction< R > setup ) Registers a new adaptor component with a given configuration R. The adaptor component is given a name and a setup function which is responsible for configuring the adaptor in accordance with the configuration. function replaceAdaptorComponent template <typename R > void replaceAdaptorComponent( String const & id, SetupFunction< R > setup ) Replaces a adaptor component. This function is useful for testing purposes and alteration to the default set of components. For instance, one can setup a production set of components and then replace a single component to test the effects of this single replacement while keeping all other components actually as they are in production. function registerAnonymousAdaptorComponent template <typename R > void registerAnonymousAdaptorComponent( SetupFunction< R > setup ) Registers a new adaptor component with a given configuration R. Unlike registerAdaptorComponent this component will not have an ID. function replicateAdaptorComponent void replicateAdaptorComponent( String const & id ) Replicates an existing component as an anonymous component. The original component is found by its id and then copied as an anonymous component which is appended to the list of components. function isDebugMode bool isDebugMode() const Flag indicating whether we are operating in debug mode or not. function setupDefaultComponentPipeline void setupDefaultComponentPipeline() Sets the default pipeline up. More unroll parameters https://llvm.org/doxygen/LoopUnrollPass_8cpp.html Header https://llvm.org/doxygen/LoopUnrollPass_8h.html function setLogger void setLogger( ILoggerPtr const & logger =nullptr ) Protected Functions Documentation function createValidationModulePass llvm::ModulePassManager createValidationModulePass( PassBuilder & pass_builder, OptimizationLevel const & optimization_level, bool debug ) Internal function that creates a module pass for QIR validation. At the moment, this function is a placeholder for future functionality. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::QirAdaptorFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#microsoftquantumqiradaptorfactory","text":"Inherited by microsoft::quantum::ConfigurableQirAdaptorFactory","title":"microsoft::quantum::QirAdaptorFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#public-types","text":"Name using llvm::PassBuilder PassBuilder using llvm::OptimizationLevel OptimizationLevel using llvm::FunctionAnalysisManager FunctionAnalysisManager using std::shared_ptr< QirAdaptor > QirAdaptorPtr using std::shared_ptr< BasicAllocationManager > BasicAllocationManagerPtr using llvm::FunctionPassManager FunctionPassManager template <typename R > using std::function< void(R const &, QirAdaptor &)> SetupFunction using std::function< void( QirAdaptorFactory &, QirAdaptor &)> SetupFunctionWrapper Wrapper function type for invoking the adaptor setup function. using std::vector< std::pair< String, SetupFunctionWrapper > > Components List of components to be configured. using ILogger::ILoggerPtr ILoggerPtr","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#public-functions","text":"Name QirAdaptorFactory ( ConfigurationManager & configuration_manager) ~QirAdaptorFactory () =default QirAdaptorFactory ( QirAdaptorFactory const & ) QirAdaptorFactory ( QirAdaptorFactory && ) QirAdaptorFactory & operator= ( QirAdaptorFactory const & ) QirAdaptorFactory & operator= ( QirAdaptorFactory && ) ConfigurationManager & configurationManager () ConfigurationManager const & configurationManager () const QirAdaptorPtr newQirAdaptor (String const & name, OptimizationLevel const & optimization_level, bool debug) void newAdaptorContext (String const & name, bool debug =false) Prepares a new adaptor context. void addComponent (String const & name) Adds a component to the current context. QirAdaptorPtr finalizeAdaptor () Finalizes the context and returns the QIR adaptor. template <typename R > void registerAdaptorComponent (String const & id, SetupFunction < R > setup) template <typename R > void replaceAdaptorComponent (String const & id, SetupFunction < R > setup) template <typename R > void registerAnonymousAdaptorComponent ( SetupFunction < R > setup) void replicateAdaptorComponent (String const & id) bool isDebugMode () const Flag indicating whether we are operating in debug mode or not. void setupDefaultComponentPipeline () Sets the default pipeline up. void setLogger (ILoggerPtr const & logger =nullptr)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#protected-functions","text":"Name llvm::ModulePassManager createValidationModulePass (PassBuilder & pass_builder, OptimizationLevel const & optimization_level, bool debug)","title":"Protected Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#using-passbuilder","text":"using microsoft::quantum::QirAdaptorFactory::PassBuilder = llvm::PassBuilder;","title":"using PassBuilder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#using-optimizationlevel","text":"using microsoft::quantum::QirAdaptorFactory::OptimizationLevel = llvm::OptimizationLevel;","title":"using OptimizationLevel"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#using-functionanalysismanager","text":"using microsoft::quantum::QirAdaptorFactory::FunctionAnalysisManager = llvm::FunctionAnalysisManager;","title":"using FunctionAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#using-qiradaptorptr","text":"using microsoft::quantum::QirAdaptorFactory::QirAdaptorPtr = std::shared_ptr<QirAdaptor>;","title":"using QirAdaptorPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#using-basicallocationmanagerptr","text":"using microsoft::quantum::QirAdaptorFactory::BasicAllocationManagerPtr = std::shared_ptr<BasicAllocationManager>;","title":"using BasicAllocationManagerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#using-functionpassmanager","text":"using microsoft::quantum::QirAdaptorFactory::FunctionPassManager = llvm::FunctionPassManager;","title":"using FunctionPassManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#using-setupfunction","text":"template <typename R > using microsoft::quantum::QirAdaptorFactory::SetupFunction = std::function<void(R const&, QirAdaptor&)>; Setup function that uses a configuration type R to configure the adaptor and/or generator.","title":"using SetupFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#using-setupfunctionwrapper","text":"using microsoft::quantum::QirAdaptorFactory::SetupFunctionWrapper = std::function<void(QirAdaptorFactory&, QirAdaptor&)>; Wrapper function type for invoking the adaptor setup function.","title":"using SetupFunctionWrapper"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#using-components","text":"using microsoft::quantum::QirAdaptorFactory::Components = std::vector<std::pair<String, SetupFunctionWrapper> >; List of components to be configured.","title":"using Components"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#using-iloggerptr","text":"using microsoft::quantum::QirAdaptorFactory::ILoggerPtr = ILogger::ILoggerPtr;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#function-qiradaptorfactory","text":"inline explicit QirAdaptorFactory( ConfigurationManager & configuration_manager )","title":"function QirAdaptorFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#function-qiradaptorfactory_1","text":"~QirAdaptorFactory() =default","title":"function ~QirAdaptorFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#function-qiradaptorfactory_2","text":"QirAdaptorFactory( QirAdaptorFactory const & )","title":"function QirAdaptorFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#function-qiradaptorfactory_3","text":"QirAdaptorFactory( QirAdaptorFactory && )","title":"function QirAdaptorFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#function-operator","text":"QirAdaptorFactory & operator=( QirAdaptorFactory const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#function-operator_1","text":"QirAdaptorFactory & operator=( QirAdaptorFactory && )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#function-configurationmanager","text":"ConfigurationManager & configurationManager() Reference to configuration manager. This property allows to access and modify configurations of the generator. This property is intended for managing the configuration.","title":"function configurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#function-configurationmanager_1","text":"ConfigurationManager const & configurationManager() const Constant reference to the configuration manager. This property allows read access to the configuration manager and is intended for adaptor generation.","title":"function configurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#function-newqiradaptor","text":"QirAdaptorPtr newQirAdaptor( String const & name, OptimizationLevel const & optimization_level, bool debug ) Creates a new adaptor based on the registered components, optimization level and debug requirements. The returned adaptor can be applied to an IR to transform it in accordance with the configurations given.","title":"function newQirAdaptor"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#function-newadaptorcontext","text":"void newAdaptorContext( String const & name, bool debug =false ) Prepares a new adaptor context.","title":"function newAdaptorContext"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#function-addcomponent","text":"void addComponent( String const & name ) Adds a component to the current context.","title":"function addComponent"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#function-finalizeadaptor","text":"QirAdaptorPtr finalizeAdaptor() Finalizes the context and returns the QIR adaptor.","title":"function finalizeAdaptor"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#function-registeradaptorcomponent","text":"template <typename R > void registerAdaptorComponent( String const & id, SetupFunction< R > setup ) Registers a new adaptor component with a given configuration R. The adaptor component is given a name and a setup function which is responsible for configuring the adaptor in accordance with the configuration.","title":"function registerAdaptorComponent"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#function-replaceadaptorcomponent","text":"template <typename R > void replaceAdaptorComponent( String const & id, SetupFunction< R > setup ) Replaces a adaptor component. This function is useful for testing purposes and alteration to the default set of components. For instance, one can setup a production set of components and then replace a single component to test the effects of this single replacement while keeping all other components actually as they are in production.","title":"function replaceAdaptorComponent"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#function-registeranonymousadaptorcomponent","text":"template <typename R > void registerAnonymousAdaptorComponent( SetupFunction< R > setup ) Registers a new adaptor component with a given configuration R. Unlike registerAdaptorComponent this component will not have an ID.","title":"function registerAnonymousAdaptorComponent"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#function-replicateadaptorcomponent","text":"void replicateAdaptorComponent( String const & id ) Replicates an existing component as an anonymous component. The original component is found by its id and then copied as an anonymous component which is appended to the list of components.","title":"function replicateAdaptorComponent"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#function-isdebugmode","text":"bool isDebugMode() const Flag indicating whether we are operating in debug mode or not.","title":"function isDebugMode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#function-setupdefaultcomponentpipeline","text":"void setupDefaultComponentPipeline() Sets the default pipeline up. More unroll parameters https://llvm.org/doxygen/LoopUnrollPass_8cpp.html Header https://llvm.org/doxygen/LoopUnrollPass_8h.html","title":"function setupDefaultComponentPipeline"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#function-setlogger","text":"void setLogger( ILoggerPtr const & logger =nullptr )","title":"function setLogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qir_adaptor_factory/#function-createvalidationmodulepass","text":"llvm::ModulePassManager createValidationModulePass( PassBuilder & pass_builder, OptimizationLevel const & optimization_level, bool debug ) Internal function that creates a module pass for QIR validation. At the moment, this function is a placeholder for future functionality. Updated on 28 October 2022 at 19:30:15 UTC","title":"function createValidationModulePass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qubit_remap_pass/","text":"microsoft::quantum::QubitRemapPass Inherits from llvm::PassInfoMixin< QubitRemapPass > Public Types Name enum ResourceType { None, Qubit, Result} using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using ILogger::Location Location using llvm::StringRef StringRef Public Functions Name QubitRemapPass ( StaticResourceComponentConfiguration const & cfg, ILoggerPtr const & logger =nullptr) QubitRemapPass ( QubitRemapPass const & ) Copy construction is banned. QubitRemapPass ( QubitRemapPass && ) =default We allow move semantics. ~QubitRemapPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Function & function, llvm::FunctionAnalysisManager & mam) bool isRequired () Whether or not this pass is required to run. Public Types Documentation enum ResourceType Enumerator Value Description None Qubit Result using Instruction using microsoft::quantum::QubitRemapPass::Instruction = llvm::Instruction; using Value using microsoft::quantum::QubitRemapPass::Value = llvm::Value; using ILoggerPtr using microsoft::quantum::QubitRemapPass::ILoggerPtr = ILogger::ILoggerPtr; using Location using microsoft::quantum::QubitRemapPass::Location = ILogger::Location; using StringRef using microsoft::quantum::QubitRemapPass::StringRef = llvm::StringRef; Public Functions Documentation function QubitRemapPass explicit QubitRemapPass( StaticResourceComponentConfiguration const & cfg, ILoggerPtr const & logger =nullptr ) function QubitRemapPass QubitRemapPass( QubitRemapPass const & ) Copy construction is banned. function QubitRemapPass QubitRemapPass( QubitRemapPass && ) =default We allow move semantics. function ~QubitRemapPass ~QubitRemapPass() =default Default destruction. function run llvm::PreservedAnalyses run( llvm::Function & function, llvm::FunctionAnalysisManager & mam ) function isRequired static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::QubitRemapPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qubit_remap_pass/#microsoftquantumqubitremappass","text":"Inherits from llvm::PassInfoMixin< QubitRemapPass >","title":"microsoft::quantum::QubitRemapPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qubit_remap_pass/#public-types","text":"Name enum ResourceType { None, Qubit, Result} using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using ILogger::Location Location using llvm::StringRef StringRef","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qubit_remap_pass/#public-functions","text":"Name QubitRemapPass ( StaticResourceComponentConfiguration const & cfg, ILoggerPtr const & logger =nullptr) QubitRemapPass ( QubitRemapPass const & ) Copy construction is banned. QubitRemapPass ( QubitRemapPass && ) =default We allow move semantics. ~QubitRemapPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Function & function, llvm::FunctionAnalysisManager & mam) bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qubit_remap_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qubit_remap_pass/#enum-resourcetype","text":"Enumerator Value Description None Qubit Result","title":"enum ResourceType"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qubit_remap_pass/#using-instruction","text":"using microsoft::quantum::QubitRemapPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qubit_remap_pass/#using-value","text":"using microsoft::quantum::QubitRemapPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qubit_remap_pass/#using-iloggerptr","text":"using microsoft::quantum::QubitRemapPass::ILoggerPtr = ILogger::ILoggerPtr;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qubit_remap_pass/#using-location","text":"using microsoft::quantum::QubitRemapPass::Location = ILogger::Location;","title":"using Location"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qubit_remap_pass/#using-stringref","text":"using microsoft::quantum::QubitRemapPass::StringRef = llvm::StringRef;","title":"using StringRef"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qubit_remap_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qubit_remap_pass/#function-qubitremappass","text":"explicit QubitRemapPass( StaticResourceComponentConfiguration const & cfg, ILoggerPtr const & logger =nullptr )","title":"function QubitRemapPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qubit_remap_pass/#function-qubitremappass_1","text":"QubitRemapPass( QubitRemapPass const & ) Copy construction is banned.","title":"function QubitRemapPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qubit_remap_pass/#function-qubitremappass_2","text":"QubitRemapPass( QubitRemapPass && ) =default We allow move semantics.","title":"function QubitRemapPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qubit_remap_pass/#function-qubitremappass_3","text":"~QubitRemapPass() =default Default destruction.","title":"function ~QubitRemapPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qubit_remap_pass/#function-run","text":"llvm::PreservedAnalyses run( llvm::Function & function, llvm::FunctionAnalysisManager & mam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qubit_remap_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_disallowed_attributes_pass/","text":"microsoft::quantum::RemoveDisallowedAttributesPass Inherits from llvm::PassInfoMixin< RemoveDisallowedAttributesPass > Public Functions Name RemoveDisallowedAttributesPass ( SpecConfiguration const & spec) llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & ) Public Functions Documentation function RemoveDisallowedAttributesPass inline explicit RemoveDisallowedAttributesPass( SpecConfiguration const & spec ) function run inline llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & ) Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::RemoveDisallowedAttributesPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_disallowed_attributes_pass/#microsoftquantumremovedisallowedattributespass","text":"Inherits from llvm::PassInfoMixin< RemoveDisallowedAttributesPass >","title":"microsoft::quantum::RemoveDisallowedAttributesPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_disallowed_attributes_pass/#public-functions","text":"Name RemoveDisallowedAttributesPass ( SpecConfiguration const & spec) llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & )","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_disallowed_attributes_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_disallowed_attributes_pass/#function-removedisallowedattributespass","text":"inline explicit RemoveDisallowedAttributesPass( SpecConfiguration const & spec )","title":"function RemoveDisallowedAttributesPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_disallowed_attributes_pass/#function-run","text":"inline llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & ) Updated on 28 October 2022 at 19:30:15 UTC","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass/","text":"microsoft::quantum::RemoveNonEntrypointFunctionsPass Inherits from llvm::PassInfoMixin< RemoveNonEntrypointFunctionsPass > Public Types Name using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using ILogger::Location Location using llvm::StringRef StringRef Public Functions Name RemoveNonEntrypointFunctionsPass ( RemoveNonEntrypointFunctionsPassConfiguration const & cfg, ILoggerPtr const & logger =nullptr) RemoveNonEntrypointFunctionsPass ( RemoveNonEntrypointFunctionsPass const & ) Copy construction is banned. RemoveNonEntrypointFunctionsPass ( RemoveNonEntrypointFunctionsPass && ) =default We allow move semantics. ~RemoveNonEntrypointFunctionsPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool isRequired () Whether or not this pass is required to run. Public Types Documentation using Instruction using microsoft::quantum::RemoveNonEntrypointFunctionsPass::Instruction = llvm::Instruction; using Value using microsoft::quantum::RemoveNonEntrypointFunctionsPass::Value = llvm::Value; using ILoggerPtr using microsoft::quantum::RemoveNonEntrypointFunctionsPass::ILoggerPtr = ILogger::ILoggerPtr; using Location using microsoft::quantum::RemoveNonEntrypointFunctionsPass::Location = ILogger::Location; using StringRef using microsoft::quantum::RemoveNonEntrypointFunctionsPass::StringRef = llvm::StringRef; Public Functions Documentation function RemoveNonEntrypointFunctionsPass explicit RemoveNonEntrypointFunctionsPass( RemoveNonEntrypointFunctionsPassConfiguration const & cfg, ILoggerPtr const & logger =nullptr ) function RemoveNonEntrypointFunctionsPass RemoveNonEntrypointFunctionsPass( RemoveNonEntrypointFunctionsPass const & ) Copy construction is banned. function RemoveNonEntrypointFunctionsPass RemoveNonEntrypointFunctionsPass( RemoveNonEntrypointFunctionsPass && ) =default We allow move semantics. function ~RemoveNonEntrypointFunctionsPass ~RemoveNonEntrypointFunctionsPass() =default Default destruction. function run llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function isRequired static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::RemoveNonEntrypointFunctionsPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass/#microsoftquantumremovenonentrypointfunctionspass","text":"Inherits from llvm::PassInfoMixin< RemoveNonEntrypointFunctionsPass >","title":"microsoft::quantum::RemoveNonEntrypointFunctionsPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass/#public-types","text":"Name using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using ILogger::Location Location using llvm::StringRef StringRef","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass/#public-functions","text":"Name RemoveNonEntrypointFunctionsPass ( RemoveNonEntrypointFunctionsPassConfiguration const & cfg, ILoggerPtr const & logger =nullptr) RemoveNonEntrypointFunctionsPass ( RemoveNonEntrypointFunctionsPass const & ) Copy construction is banned. RemoveNonEntrypointFunctionsPass ( RemoveNonEntrypointFunctionsPass && ) =default We allow move semantics. ~RemoveNonEntrypointFunctionsPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass/#using-instruction","text":"using microsoft::quantum::RemoveNonEntrypointFunctionsPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass/#using-value","text":"using microsoft::quantum::RemoveNonEntrypointFunctionsPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass/#using-iloggerptr","text":"using microsoft::quantum::RemoveNonEntrypointFunctionsPass::ILoggerPtr = ILogger::ILoggerPtr;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass/#using-location","text":"using microsoft::quantum::RemoveNonEntrypointFunctionsPass::Location = ILogger::Location;","title":"using Location"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass/#using-stringref","text":"using microsoft::quantum::RemoveNonEntrypointFunctionsPass::StringRef = llvm::StringRef;","title":"using StringRef"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass/#function-removenonentrypointfunctionspass","text":"explicit RemoveNonEntrypointFunctionsPass( RemoveNonEntrypointFunctionsPassConfiguration const & cfg, ILoggerPtr const & logger =nullptr )","title":"function RemoveNonEntrypointFunctionsPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass/#function-removenonentrypointfunctionspass_1","text":"RemoveNonEntrypointFunctionsPass( RemoveNonEntrypointFunctionsPass const & ) Copy construction is banned.","title":"function RemoveNonEntrypointFunctionsPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass/#function-removenonentrypointfunctionspass_2","text":"RemoveNonEntrypointFunctionsPass( RemoveNonEntrypointFunctionsPass && ) =default We allow move semantics.","title":"function RemoveNonEntrypointFunctionsPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass/#function-removenonentrypointfunctionspass_3","text":"~RemoveNonEntrypointFunctionsPass() =default Default destruction.","title":"function ~RemoveNonEntrypointFunctionsPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass/#function-run","text":"llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass_configuration/","text":"microsoft::quantum::RemoveNonEntrypointFunctionsPassConfiguration Public Types Name using DeferredValue::DeferredValuePtr DeferredValuePtr Public Functions Name void setup ( ConfigurationManager & config) std::string entryPointAttr () const RemoveNonEntrypointFunctionsPassConfiguration createDisabled () Public Types Documentation using DeferredValuePtr using microsoft::quantum::RemoveNonEntrypointFunctionsPassConfiguration::DeferredValuePtr = DeferredValue::DeferredValuePtr; Public Functions Documentation function setup inline void setup( ConfigurationManager & config ) function entryPointAttr inline std::string entryPointAttr() const function createDisabled static inline RemoveNonEntrypointFunctionsPassConfiguration createDisabled() Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::RemoveNonEntrypointFunctionsPassConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass_configuration/#microsoftquantumremovenonentrypointfunctionspassconfiguration","text":"","title":"microsoft::quantum::RemoveNonEntrypointFunctionsPassConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass_configuration/#public-types","text":"Name using DeferredValue::DeferredValuePtr DeferredValuePtr","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass_configuration/#public-functions","text":"Name void setup ( ConfigurationManager & config) std::string entryPointAttr () const RemoveNonEntrypointFunctionsPassConfiguration createDisabled ()","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass_configuration/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass_configuration/#using-deferredvalueptr","text":"using microsoft::quantum::RemoveNonEntrypointFunctionsPassConfiguration::DeferredValuePtr = DeferredValue::DeferredValuePtr;","title":"using DeferredValuePtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass_configuration/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass_configuration/#function-setup","text":"inline void setup( ConfigurationManager & config )","title":"function setup"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass_configuration/#function-entrypointattr","text":"inline std::string entryPointAttr() const","title":"function entryPointAttr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_non_entrypoint_functions_pass_configuration/#function-createdisabled","text":"static inline RemoveNonEntrypointFunctionsPassConfiguration createDisabled() Updated on 28 October 2022 at 19:30:15 UTC","title":"function createDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replace_qubit_on_reset_pass/","text":"microsoft::quantum::ReplaceQubitOnResetPass Inherits from llvm::PassInfoMixin< ReplaceQubitOnResetPass > Public Types Name using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using ILogger::Location Location using llvm::StringRef StringRef Public Functions Name ReplaceQubitOnResetPass ( StaticResourceComponentConfiguration const & cfg, ILoggerPtr const & logger =nullptr) ReplaceQubitOnResetPass ( ReplaceQubitOnResetPass const & ) Copy construction is banned. ReplaceQubitOnResetPass ( ReplaceQubitOnResetPass && ) =default We allow move semantics. ~ReplaceQubitOnResetPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Function & function, llvm::FunctionAnalysisManager & mam) bool isRequired () Whether or not this pass is required to run. Public Types Documentation using Instruction using microsoft::quantum::ReplaceQubitOnResetPass::Instruction = llvm::Instruction; using Value using microsoft::quantum::ReplaceQubitOnResetPass::Value = llvm::Value; using ILoggerPtr using microsoft::quantum::ReplaceQubitOnResetPass::ILoggerPtr = ILogger::ILoggerPtr; using Location using microsoft::quantum::ReplaceQubitOnResetPass::Location = ILogger::Location; using StringRef using microsoft::quantum::ReplaceQubitOnResetPass::StringRef = llvm::StringRef; Public Functions Documentation function ReplaceQubitOnResetPass explicit ReplaceQubitOnResetPass( StaticResourceComponentConfiguration const & cfg, ILoggerPtr const & logger =nullptr ) function ReplaceQubitOnResetPass ReplaceQubitOnResetPass( ReplaceQubitOnResetPass const & ) Copy construction is banned. function ReplaceQubitOnResetPass ReplaceQubitOnResetPass( ReplaceQubitOnResetPass && ) =default We allow move semantics. function ~ReplaceQubitOnResetPass ~ReplaceQubitOnResetPass() =default Default destruction. function run llvm::PreservedAnalyses run( llvm::Function & function, llvm::FunctionAnalysisManager & mam ) function isRequired static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::ReplaceQubitOnResetPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replace_qubit_on_reset_pass/#microsoftquantumreplacequbitonresetpass","text":"Inherits from llvm::PassInfoMixin< ReplaceQubitOnResetPass >","title":"microsoft::quantum::ReplaceQubitOnResetPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replace_qubit_on_reset_pass/#public-types","text":"Name using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using ILogger::Location Location using llvm::StringRef StringRef","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replace_qubit_on_reset_pass/#public-functions","text":"Name ReplaceQubitOnResetPass ( StaticResourceComponentConfiguration const & cfg, ILoggerPtr const & logger =nullptr) ReplaceQubitOnResetPass ( ReplaceQubitOnResetPass const & ) Copy construction is banned. ReplaceQubitOnResetPass ( ReplaceQubitOnResetPass && ) =default We allow move semantics. ~ReplaceQubitOnResetPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Function & function, llvm::FunctionAnalysisManager & mam) bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replace_qubit_on_reset_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replace_qubit_on_reset_pass/#using-instruction","text":"using microsoft::quantum::ReplaceQubitOnResetPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replace_qubit_on_reset_pass/#using-value","text":"using microsoft::quantum::ReplaceQubitOnResetPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replace_qubit_on_reset_pass/#using-iloggerptr","text":"using microsoft::quantum::ReplaceQubitOnResetPass::ILoggerPtr = ILogger::ILoggerPtr;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replace_qubit_on_reset_pass/#using-location","text":"using microsoft::quantum::ReplaceQubitOnResetPass::Location = ILogger::Location;","title":"using Location"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replace_qubit_on_reset_pass/#using-stringref","text":"using microsoft::quantum::ReplaceQubitOnResetPass::StringRef = llvm::StringRef;","title":"using StringRef"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replace_qubit_on_reset_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replace_qubit_on_reset_pass/#function-replacequbitonresetpass","text":"explicit ReplaceQubitOnResetPass( StaticResourceComponentConfiguration const & cfg, ILoggerPtr const & logger =nullptr )","title":"function ReplaceQubitOnResetPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replace_qubit_on_reset_pass/#function-replacequbitonresetpass_1","text":"ReplaceQubitOnResetPass( ReplaceQubitOnResetPass const & ) Copy construction is banned.","title":"function ReplaceQubitOnResetPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replace_qubit_on_reset_pass/#function-replacequbitonresetpass_2","text":"ReplaceQubitOnResetPass( ReplaceQubitOnResetPass && ) =default We allow move semantics.","title":"function ReplaceQubitOnResetPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replace_qubit_on_reset_pass/#function-replacequbitonresetpass_3","text":"~ReplaceQubitOnResetPass() =default Default destruction.","title":"function ~ReplaceQubitOnResetPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replace_qubit_on_reset_pass/#function-run","text":"llvm::PreservedAnalyses run( llvm::Function & function, llvm::FunctionAnalysisManager & mam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replace_qubit_on_reset_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/","text":"microsoft::quantum::ReplacementRule More... #include <Rules/ReplacementRule.hpp> Public Types Name using IOperandPrototype::Captures Captures Table to store LLVM values using a name. using llvm::Value Value Value alias for shorthand usage. using std::shared_ptr< IOperandPrototype > IOperandPrototypePtr Pointer to the pattern type. using llvm::IRBuilder<> Builder Builder alias for shorthand notation. using std::vector< std::pair< Value *, Value * > > Replacements List of replacements. using std::function< bool( Builder &, Value *, Captures &, Replacements &)> ReplaceFunction Function to perform replacements. Public Functions Name ReplacementRule () =default ReplacementRule (String const & name, IOperandPrototypePtr && pattern, ReplaceFunction && replacer) ReplacementRule ( IOperandPrototypePtr && pattern, ReplaceFunction && replacer) void setPattern ( IOperandPrototypePtr && pattern) Sets the pattern describing logic to be replaced. void setReplacer ( ReplaceFunction const & replacer) bool match ( Value * value, Captures & captures) const bool replace ( Builder & builder, Value * value, Captures & captures, Replacements & replacements) const Invokes the replacer given a matched value and its corresponding captures. String name () const Detailed Description class microsoft::quantum::ReplacementRule; Rule that describes a pattern and how to make a replacement of the matched values. The class contains a OperandPrototype which is used to test whether an LLVM IR value follows a specific pattern. The class also holds a function pointer to logic that allows replacement of the specified value. Public Types Documentation using Captures using microsoft::quantum::ReplacementRule::Captures = IOperandPrototype::Captures; Table to store LLVM values using a name. using Value using microsoft::quantum::ReplacementRule::Value = llvm::Value; Value alias for shorthand usage. using IOperandPrototypePtr using microsoft::quantum::ReplacementRule::IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; Pointer to the pattern type. using Builder using microsoft::quantum::ReplacementRule::Builder = llvm::IRBuilder<>; Builder alias for shorthand notation. using Replacements using microsoft::quantum::ReplacementRule::Replacements = std::vector<std::pair<Value*, Value*> >; List of replacements. using ReplaceFunction using microsoft::quantum::ReplacementRule::ReplaceFunction = std::function<bool(Builder&, Value*, Captures&, Replacements&)>; Function to perform replacements. Public Functions Documentation function ReplacementRule ReplacementRule() =default function ReplacementRule ReplacementRule( String const & name, IOperandPrototypePtr && pattern, ReplaceFunction && replacer ) function ReplacementRule ReplacementRule( IOperandPrototypePtr && pattern, ReplaceFunction && replacer ) function setPattern void setPattern( IOperandPrototypePtr && pattern ) Sets the pattern describing logic to be replaced. function setReplacer void setReplacer( ReplaceFunction const & replacer ) Sets the replacer logic which given a successful match will perform a replacement on the IR. function match bool match( Value * value, Captures & captures ) const Tests whether a given value matches the rule pattern and store captures. The function returns true if the match was successful in which case captures are recorded. function replace bool replace( Builder & builder, Value * value, Captures & captures, Replacements & replacements ) const Invokes the replacer given a matched value and its corresponding captures. function name String name() const Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::ReplacementRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#microsoftquantumreplacementrule","text":"More... #include <Rules/ReplacementRule.hpp>","title":"microsoft::quantum::ReplacementRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#public-types","text":"Name using IOperandPrototype::Captures Captures Table to store LLVM values using a name. using llvm::Value Value Value alias for shorthand usage. using std::shared_ptr< IOperandPrototype > IOperandPrototypePtr Pointer to the pattern type. using llvm::IRBuilder<> Builder Builder alias for shorthand notation. using std::vector< std::pair< Value *, Value * > > Replacements List of replacements. using std::function< bool( Builder &, Value *, Captures &, Replacements &)> ReplaceFunction Function to perform replacements.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#public-functions","text":"Name ReplacementRule () =default ReplacementRule (String const & name, IOperandPrototypePtr && pattern, ReplaceFunction && replacer) ReplacementRule ( IOperandPrototypePtr && pattern, ReplaceFunction && replacer) void setPattern ( IOperandPrototypePtr && pattern) Sets the pattern describing logic to be replaced. void setReplacer ( ReplaceFunction const & replacer) bool match ( Value * value, Captures & captures) const bool replace ( Builder & builder, Value * value, Captures & captures, Replacements & replacements) const Invokes the replacer given a matched value and its corresponding captures. String name () const","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#detailed-description","text":"class microsoft::quantum::ReplacementRule; Rule that describes a pattern and how to make a replacement of the matched values. The class contains a OperandPrototype which is used to test whether an LLVM IR value follows a specific pattern. The class also holds a function pointer to logic that allows replacement of the specified value.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#using-captures","text":"using microsoft::quantum::ReplacementRule::Captures = IOperandPrototype::Captures; Table to store LLVM values using a name.","title":"using Captures"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#using-value","text":"using microsoft::quantum::ReplacementRule::Value = llvm::Value; Value alias for shorthand usage.","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#using-ioperandprototypeptr","text":"using microsoft::quantum::ReplacementRule::IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; Pointer to the pattern type.","title":"using IOperandPrototypePtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#using-builder","text":"using microsoft::quantum::ReplacementRule::Builder = llvm::IRBuilder<>; Builder alias for shorthand notation.","title":"using Builder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#using-replacements","text":"using microsoft::quantum::ReplacementRule::Replacements = std::vector<std::pair<Value*, Value*> >; List of replacements.","title":"using Replacements"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#using-replacefunction","text":"using microsoft::quantum::ReplacementRule::ReplaceFunction = std::function<bool(Builder&, Value*, Captures&, Replacements&)>; Function to perform replacements.","title":"using ReplaceFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-replacementrule","text":"ReplacementRule() =default","title":"function ReplacementRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-replacementrule_1","text":"ReplacementRule( String const & name, IOperandPrototypePtr && pattern, ReplaceFunction && replacer )","title":"function ReplacementRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-replacementrule_2","text":"ReplacementRule( IOperandPrototypePtr && pattern, ReplaceFunction && replacer )","title":"function ReplacementRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-setpattern","text":"void setPattern( IOperandPrototypePtr && pattern ) Sets the pattern describing logic to be replaced.","title":"function setPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-setreplacer","text":"void setReplacer( ReplaceFunction const & replacer ) Sets the replacer logic which given a successful match will perform a replacement on the IR.","title":"function setReplacer"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-match","text":"bool match( Value * value, Captures & captures ) const Tests whether a given value matches the rule pattern and store captures. The function returns true if the match was successful in which case captures are recorded.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-replace","text":"bool replace( Builder & builder, Value * value, Captures & captures, Replacements & replacements ) const Invokes the replacer given a matched value and its corresponding captures.","title":"function replace"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-name","text":"String name() const Updated on 28 October 2022 at 19:30:15 UTC","title":"function name"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_resource_annotation_pass/","text":"microsoft::quantum::ResourceAnnotationPass Inherits from llvm::PassInfoMixin< ResourceAnnotationPass > Public Types Name enum ResourceType { None, Qubit, Result} using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using ILogger::Location Location using llvm::StringRef StringRef Public Functions Name ResourceAnnotationPass ( StaticResourceComponentConfiguration const & cfg, ILoggerPtr const & logger =nullptr) ResourceAnnotationPass ( ResourceAnnotationPass const & ) Copy construction is banned. ResourceAnnotationPass ( ResourceAnnotationPass && ) =default We allow move semantics. ~ResourceAnnotationPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Function & function, llvm::FunctionAnalysisManager & fam) bool isRequired () Whether or not this pass is required to run. Public Types Documentation enum ResourceType Enumerator Value Description None Qubit Result using Instruction using microsoft::quantum::ResourceAnnotationPass::Instruction = llvm::Instruction; using Value using microsoft::quantum::ResourceAnnotationPass::Value = llvm::Value; using ILoggerPtr using microsoft::quantum::ResourceAnnotationPass::ILoggerPtr = ILogger::ILoggerPtr; using Location using microsoft::quantum::ResourceAnnotationPass::Location = ILogger::Location; using StringRef using microsoft::quantum::ResourceAnnotationPass::StringRef = llvm::StringRef; Public Functions Documentation function ResourceAnnotationPass explicit ResourceAnnotationPass( StaticResourceComponentConfiguration const & cfg, ILoggerPtr const & logger =nullptr ) function ResourceAnnotationPass ResourceAnnotationPass( ResourceAnnotationPass const & ) Copy construction is banned. function ResourceAnnotationPass ResourceAnnotationPass( ResourceAnnotationPass && ) =default We allow move semantics. function ~ResourceAnnotationPass ~ResourceAnnotationPass() =default Default destruction. function run llvm::PreservedAnalyses run( llvm::Function & function, llvm::FunctionAnalysisManager & fam ) function isRequired static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::ResourceAnnotationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_resource_annotation_pass/#microsoftquantumresourceannotationpass","text":"Inherits from llvm::PassInfoMixin< ResourceAnnotationPass >","title":"microsoft::quantum::ResourceAnnotationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_resource_annotation_pass/#public-types","text":"Name enum ResourceType { None, Qubit, Result} using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using ILogger::Location Location using llvm::StringRef StringRef","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_resource_annotation_pass/#public-functions","text":"Name ResourceAnnotationPass ( StaticResourceComponentConfiguration const & cfg, ILoggerPtr const & logger =nullptr) ResourceAnnotationPass ( ResourceAnnotationPass const & ) Copy construction is banned. ResourceAnnotationPass ( ResourceAnnotationPass && ) =default We allow move semantics. ~ResourceAnnotationPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Function & function, llvm::FunctionAnalysisManager & fam) bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_resource_annotation_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_resource_annotation_pass/#enum-resourcetype","text":"Enumerator Value Description None Qubit Result","title":"enum ResourceType"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_resource_annotation_pass/#using-instruction","text":"using microsoft::quantum::ResourceAnnotationPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_resource_annotation_pass/#using-value","text":"using microsoft::quantum::ResourceAnnotationPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_resource_annotation_pass/#using-iloggerptr","text":"using microsoft::quantum::ResourceAnnotationPass::ILoggerPtr = ILogger::ILoggerPtr;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_resource_annotation_pass/#using-location","text":"using microsoft::quantum::ResourceAnnotationPass::Location = ILogger::Location;","title":"using Location"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_resource_annotation_pass/#using-stringref","text":"using microsoft::quantum::ResourceAnnotationPass::StringRef = llvm::StringRef;","title":"using StringRef"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_resource_annotation_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_resource_annotation_pass/#function-resourceannotationpass","text":"explicit ResourceAnnotationPass( StaticResourceComponentConfiguration const & cfg, ILoggerPtr const & logger =nullptr )","title":"function ResourceAnnotationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_resource_annotation_pass/#function-resourceannotationpass_1","text":"ResourceAnnotationPass( ResourceAnnotationPass const & ) Copy construction is banned.","title":"function ResourceAnnotationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_resource_annotation_pass/#function-resourceannotationpass_2","text":"ResourceAnnotationPass( ResourceAnnotationPass && ) =default We allow move semantics.","title":"function ResourceAnnotationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_resource_annotation_pass/#function-resourceannotationpass_3","text":"~ResourceAnnotationPass() =default Default destruction.","title":"function ~ResourceAnnotationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_resource_annotation_pass/#function-run","text":"llvm::PreservedAnalyses run( llvm::Function & function, llvm::FunctionAnalysisManager & fam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_resource_annotation_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/","text":"microsoft::quantum::RuleFactory More... #include <Passes/TargetQisMappingPass/Factory.hpp> Public Types Name using std::shared_ptr< ReplacementRule > ReplacementRulePtr ReplacementRule pointer type used for the construction of replacement rules. using IAllocationManager::AllocationManagerPtr AllocationManagerPtr Allocation manager pointer used to hold allocation managers. using ILogger::ILoggerPtr ILoggerPtr Interface to logger. Public Functions Name RuleFactory ( RuleSet & rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager, ILoggerPtr logger) RuleFactory () RuleFactory ( RuleFactory const & ) RuleFactory ( RuleFactory && ) =default ~RuleFactory () =default void usingConfiguration ( TargetQisMappingPassConfiguration const & config) This takes a TargetQisMappingPassConfiguration as argument and enable rules accordingly. void removeFunctionCall (String const & name) void useStaticQubitArrayAllocation () void useStaticQubitAllocation () void useStaticResultAllocation () void resolveConstantArraySizes () void inlineCallables () void optimizeResultOne () void optimizeResultZero () Replaces branching of quantum results compared to zero. void optimizeConstantResult () Replaces branching of quantum constant results. void optimizeResultComparison () Replacing comparison between two results. void removeGetZeroOrOne () Removes unused quantum zeros or ones. void disableReferenceCounting () void disableAliasCounting () This method disables alias counting for arrays, strings and results. void disableStringSupport () void disableRecordOutputSupport () Removes output recording by removing related runtime instructions. void setDefaultIntegerWidth (uint32_t v) Sets the integer width used when it cannot be deducted from the context of the transformation. Detailed Description class microsoft::quantum::RuleFactory; Rule factory provides a high-level methods to build a rule set that enforces certain aspects of QIR transformation. Public Types Documentation using ReplacementRulePtr using microsoft::quantum::RuleFactory::ReplacementRulePtr = std::shared_ptr<ReplacementRule>; ReplacementRule pointer type used for the construction of replacement rules. using AllocationManagerPtr using microsoft::quantum::RuleFactory::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; Allocation manager pointer used to hold allocation managers. using ILoggerPtr using microsoft::quantum::RuleFactory::ILoggerPtr = ILogger::ILoggerPtr; Interface to logger. Public Functions Documentation function RuleFactory RuleFactory( RuleSet & rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager, ILoggerPtr logger ) function RuleFactory RuleFactory() function RuleFactory RuleFactory( RuleFactory const & ) function RuleFactory RuleFactory( RuleFactory && ) =default function ~RuleFactory ~RuleFactory() =default function usingConfiguration void usingConfiguration( TargetQisMappingPassConfiguration const & config ) This takes a TargetQisMappingPassConfiguration as argument and enable rules accordingly. function removeFunctionCall void removeFunctionCall( String const & name ) Removes all calls to functions with a specified name. This function matches on name alone and ignores function arguments. function useStaticQubitArrayAllocation void useStaticQubitArrayAllocation() Static qubit array allocation identifies allocations, array access and releases. Each of these are replaced with static values. Patterns recognized include %array = call %Array* @__quantum__rt__qubit_allocate_array(i64 10) which is replaced by a constant pointer %array = inttoptr i64 0 to %Array* The array allocation is managed through the qubit allocation manager. Access to qubit arrays %0 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %array, i64 7) %1 = bitcast i8* %0 to %Qubit** %qubit = load %Qubit*, %Qubit** %1, align 8 is replaced by off-setting the array value by 7 to get %qubit = inttoptr i64 7 to %Qubit* Finally, release is recognized and the allocation manager is invoked accordingly. Allocation This rule is replacing the allocate qubit array instruction leftPreshared = call Array* @__quantum__rt__qubit_allocate_array(i64 2) by changing it to a constant pointer leftPreshared = inttoptr i64 0 to Array* In this way, we use the Release replacement function useStaticQubitAllocation void useStaticQubitAllocation() Static qubit allocation identifies allocation and release of single qubits. It uses the qubit allocation manager to track allocation and releases of qubits. It translates %qubit1 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit2 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit3 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit4 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit5 = call %Qubit* @__quantum__rt__qubit_allocate() to %qubit1 = inttoptr i64 0 to %Qubit* %qubit2 = inttoptr i64 1 to %Qubit* %qubit3 = inttoptr i64 2 to %Qubit* %qubit4 = inttoptr i64 3 to %Qubit* %qubit5 = inttoptr i64 4 to %Qubit* if the BasicAllocationManager is used. Release replacement function useStaticResultAllocation void useStaticResultAllocation() Static allocation of results. This feature is similar to useStaticQubitAllocation but uses the result allocation manager. function resolveConstantArraySizes void resolveConstantArraySizes() function inlineCallables void inlineCallables() function optimizeResultOne void optimizeResultOne() Replaces branching of quantum results compared to one. This is a relatively advanced pattern, intended for base adaptor-like constructs where %1 = tail call %Result* @__quantum__rt__result_get_one() %2 = tail call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 is mapped into %1 = call i1 @__quantum__qis__read_result__body(%Result* %0) br i1 %1, label %then0__1, label %continue__1 which removes the need for constant one. function optimizeResultZero void optimizeResultZero() Replaces branching of quantum results compared to zero. function optimizeConstantResult void optimizeConstantResult() Replaces branching of quantum constant results. function optimizeResultComparison void optimizeResultComparison() Replacing comparison between two results. function removeGetZeroOrOne void removeGetZeroOrOne() Removes unused quantum zeros or ones. function disableReferenceCounting void disableReferenceCounting() This method disables reference counting for arrays, strings and results. It does so by simply removing the instructions and the resulting code is expected to be executed either on a stack VM or with shared pointer logic. function disableAliasCounting void disableAliasCounting() This method disables alias counting for arrays, strings and results. function disableStringSupport void disableStringSupport() Removes string support by removing string related instructions. At the moment these include __quantum__rt__string_create , __quantum__rt__string_update_reference_count , __quantum__rt__string_update_alias_count and __quantum__rt__message . function disableRecordOutputSupport void disableRecordOutputSupport() Removes output recording by removing related runtime instructions. function setDefaultIntegerWidth void setDefaultIntegerWidth( uint32_t v ) Sets the integer width used when it cannot be deducted from the context of the transformation. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::RuleFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#microsoftquantumrulefactory","text":"More... #include <Passes/TargetQisMappingPass/Factory.hpp>","title":"microsoft::quantum::RuleFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#public-types","text":"Name using std::shared_ptr< ReplacementRule > ReplacementRulePtr ReplacementRule pointer type used for the construction of replacement rules. using IAllocationManager::AllocationManagerPtr AllocationManagerPtr Allocation manager pointer used to hold allocation managers. using ILogger::ILoggerPtr ILoggerPtr Interface to logger.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#public-functions","text":"Name RuleFactory ( RuleSet & rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager, ILoggerPtr logger) RuleFactory () RuleFactory ( RuleFactory const & ) RuleFactory ( RuleFactory && ) =default ~RuleFactory () =default void usingConfiguration ( TargetQisMappingPassConfiguration const & config) This takes a TargetQisMappingPassConfiguration as argument and enable rules accordingly. void removeFunctionCall (String const & name) void useStaticQubitArrayAllocation () void useStaticQubitAllocation () void useStaticResultAllocation () void resolveConstantArraySizes () void inlineCallables () void optimizeResultOne () void optimizeResultZero () Replaces branching of quantum results compared to zero. void optimizeConstantResult () Replaces branching of quantum constant results. void optimizeResultComparison () Replacing comparison between two results. void removeGetZeroOrOne () Removes unused quantum zeros or ones. void disableReferenceCounting () void disableAliasCounting () This method disables alias counting for arrays, strings and results. void disableStringSupport () void disableRecordOutputSupport () Removes output recording by removing related runtime instructions. void setDefaultIntegerWidth (uint32_t v) Sets the integer width used when it cannot be deducted from the context of the transformation.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#detailed-description","text":"class microsoft::quantum::RuleFactory; Rule factory provides a high-level methods to build a rule set that enforces certain aspects of QIR transformation.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#using-replacementruleptr","text":"using microsoft::quantum::RuleFactory::ReplacementRulePtr = std::shared_ptr<ReplacementRule>; ReplacementRule pointer type used for the construction of replacement rules.","title":"using ReplacementRulePtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#using-allocationmanagerptr","text":"using microsoft::quantum::RuleFactory::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; Allocation manager pointer used to hold allocation managers.","title":"using AllocationManagerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#using-iloggerptr","text":"using microsoft::quantum::RuleFactory::ILoggerPtr = ILogger::ILoggerPtr; Interface to logger.","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-rulefactory","text":"RuleFactory( RuleSet & rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager, ILoggerPtr logger )","title":"function RuleFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-rulefactory_1","text":"RuleFactory()","title":"function RuleFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-rulefactory_2","text":"RuleFactory( RuleFactory const & )","title":"function RuleFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-rulefactory_3","text":"RuleFactory( RuleFactory && ) =default","title":"function RuleFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-rulefactory_4","text":"~RuleFactory() =default","title":"function ~RuleFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-usingconfiguration","text":"void usingConfiguration( TargetQisMappingPassConfiguration const & config ) This takes a TargetQisMappingPassConfiguration as argument and enable rules accordingly.","title":"function usingConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-removefunctioncall","text":"void removeFunctionCall( String const & name ) Removes all calls to functions with a specified name. This function matches on name alone and ignores function arguments.","title":"function removeFunctionCall"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-usestaticqubitarrayallocation","text":"void useStaticQubitArrayAllocation() Static qubit array allocation identifies allocations, array access and releases. Each of these are replaced with static values. Patterns recognized include %array = call %Array* @__quantum__rt__qubit_allocate_array(i64 10) which is replaced by a constant pointer %array = inttoptr i64 0 to %Array* The array allocation is managed through the qubit allocation manager. Access to qubit arrays %0 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %array, i64 7) %1 = bitcast i8* %0 to %Qubit** %qubit = load %Qubit*, %Qubit** %1, align 8 is replaced by off-setting the array value by 7 to get %qubit = inttoptr i64 7 to %Qubit* Finally, release is recognized and the allocation manager is invoked accordingly. Allocation This rule is replacing the allocate qubit array instruction leftPreshared = call Array* @__quantum__rt__qubit_allocate_array(i64 2) by changing it to a constant pointer leftPreshared = inttoptr i64 0 to Array* In this way, we use the Release replacement","title":"function useStaticQubitArrayAllocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-usestaticqubitallocation","text":"void useStaticQubitAllocation() Static qubit allocation identifies allocation and release of single qubits. It uses the qubit allocation manager to track allocation and releases of qubits. It translates %qubit1 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit2 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit3 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit4 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit5 = call %Qubit* @__quantum__rt__qubit_allocate() to %qubit1 = inttoptr i64 0 to %Qubit* %qubit2 = inttoptr i64 1 to %Qubit* %qubit3 = inttoptr i64 2 to %Qubit* %qubit4 = inttoptr i64 3 to %Qubit* %qubit5 = inttoptr i64 4 to %Qubit* if the BasicAllocationManager is used. Release replacement","title":"function useStaticQubitAllocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-usestaticresultallocation","text":"void useStaticResultAllocation() Static allocation of results. This feature is similar to useStaticQubitAllocation but uses the result allocation manager.","title":"function useStaticResultAllocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-resolveconstantarraysizes","text":"void resolveConstantArraySizes()","title":"function resolveConstantArraySizes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-inlinecallables","text":"void inlineCallables()","title":"function inlineCallables"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-optimizeresultone","text":"void optimizeResultOne() Replaces branching of quantum results compared to one. This is a relatively advanced pattern, intended for base adaptor-like constructs where %1 = tail call %Result* @__quantum__rt__result_get_one() %2 = tail call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 is mapped into %1 = call i1 @__quantum__qis__read_result__body(%Result* %0) br i1 %1, label %then0__1, label %continue__1 which removes the need for constant one.","title":"function optimizeResultOne"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-optimizeresultzero","text":"void optimizeResultZero() Replaces branching of quantum results compared to zero.","title":"function optimizeResultZero"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-optimizeconstantresult","text":"void optimizeConstantResult() Replaces branching of quantum constant results.","title":"function optimizeConstantResult"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-optimizeresultcomparison","text":"void optimizeResultComparison() Replacing comparison between two results.","title":"function optimizeResultComparison"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-removegetzeroorone","text":"void removeGetZeroOrOne() Removes unused quantum zeros or ones.","title":"function removeGetZeroOrOne"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-disablereferencecounting","text":"void disableReferenceCounting() This method disables reference counting for arrays, strings and results. It does so by simply removing the instructions and the resulting code is expected to be executed either on a stack VM or with shared pointer logic.","title":"function disableReferenceCounting"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-disablealiascounting","text":"void disableAliasCounting() This method disables alias counting for arrays, strings and results.","title":"function disableAliasCounting"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-disablestringsupport","text":"void disableStringSupport() Removes string support by removing string related instructions. At the moment these include __quantum__rt__string_create , __quantum__rt__string_update_reference_count , __quantum__rt__string_update_alias_count and __quantum__rt__message .","title":"function disableStringSupport"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-disablerecordoutputsupport","text":"void disableRecordOutputSupport() Removes output recording by removing related runtime instructions.","title":"function disableRecordOutputSupport"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-setdefaultintegerwidth","text":"void setDefaultIntegerWidth( uint32_t v ) Sets the integer width used when it cannot be deducted from the context of the transformation. Updated on 28 October 2022 at 19:30:15 UTC","title":"function setDefaultIntegerWidth"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/","text":"microsoft::quantum::RuleSet More... #include <Rules/RuleSet.hpp> Public Types Name enum ReplaceDirection { ReplaceForwards, ReplaceBackwards} using std::shared_ptr< ReplacementRule > ReplacementRulePtr using std::vector< ReplacementRulePtr > Rules using ReplacementRule::Replacements Replacements using IOperandPrototype::Captures Captures using llvm::Instruction Instruction using llvm::Value Value using ReplacementRule::Builder Builder using IAllocationManager::AllocationManagerPtr AllocationManagerPtr Public Functions Name RuleSet () =default RuleSet ( RuleSet const & ) =default RuleSet ( RuleSet && ) =default ~RuleSet () =default RuleSet & operator= ( RuleSet const & ) =default RuleSet & operator= ( RuleSet && ) =default bool matchAndReplace (Instruction * value, Replacements & replacements, ReplaceDirection const & dir =ReplaceForwards) void addRule (ReplacementRulePtr const & rule, ReplaceDirection const & dir =ReplaceForwards) Adds a new replacement rule to the set. void addRule ( ReplacementRule && rule, ReplaceDirection const & dir =ReplaceForwards) void clear () Clears the rule set for all rules. uint64_t size () const Returns the size of the rule set. Detailed Description class microsoft::quantum::RuleSet; RuleSet contains a set of replacement rules and the corresponding logic to apply the rules. The class allows one to apply the rules by which each rule is tested one-by-one until a successful attempt at performing a replace has happened, or the list was exhausted. Public Types Documentation enum ReplaceDirection Enumerator Value Description ReplaceForwards ReplaceBackwards using ReplacementRulePtr using microsoft::quantum::RuleSet::ReplacementRulePtr = std::shared_ptr<ReplacementRule>; using Rules using microsoft::quantum::RuleSet::Rules = std::vector<ReplacementRulePtr>; using Replacements using microsoft::quantum::RuleSet::Replacements = ReplacementRule::Replacements; using Captures using microsoft::quantum::RuleSet::Captures = IOperandPrototype::Captures; using Instruction using microsoft::quantum::RuleSet::Instruction = llvm::Instruction; using Value using microsoft::quantum::RuleSet::Value = llvm::Value; using Builder using microsoft::quantum::RuleSet::Builder = ReplacementRule::Builder; using AllocationManagerPtr using microsoft::quantum::RuleSet::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; Public Functions Documentation function RuleSet RuleSet() =default function RuleSet RuleSet( RuleSet const & ) =default function RuleSet RuleSet( RuleSet && ) =default function ~RuleSet ~RuleSet() =default function operator= RuleSet & operator=( RuleSet const & ) =default function operator= RuleSet & operator=( RuleSet && ) =default function matchAndReplace bool matchAndReplace( Instruction * value, Replacements & replacements, ReplaceDirection const & dir =ReplaceForwards ) Matches patterns and runs the replacement routines if a match is found. The function returns true if a pattern is matched and and the replacement was a success. In all other cases, it returns false. function addRule void addRule( ReplacementRulePtr const & rule, ReplaceDirection const & dir =ReplaceForwards ) Adds a new replacement rule to the set. function addRule void addRule( ReplacementRule && rule, ReplaceDirection const & dir =ReplaceForwards ) function clear void clear() Clears the rule set for all rules. function size uint64_t size() const Returns the size of the rule set. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::RuleSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#microsoftquantumruleset","text":"More... #include <Rules/RuleSet.hpp>","title":"microsoft::quantum::RuleSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#public-types","text":"Name enum ReplaceDirection { ReplaceForwards, ReplaceBackwards} using std::shared_ptr< ReplacementRule > ReplacementRulePtr using std::vector< ReplacementRulePtr > Rules using ReplacementRule::Replacements Replacements using IOperandPrototype::Captures Captures using llvm::Instruction Instruction using llvm::Value Value using ReplacementRule::Builder Builder using IAllocationManager::AllocationManagerPtr AllocationManagerPtr","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#public-functions","text":"Name RuleSet () =default RuleSet ( RuleSet const & ) =default RuleSet ( RuleSet && ) =default ~RuleSet () =default RuleSet & operator= ( RuleSet const & ) =default RuleSet & operator= ( RuleSet && ) =default bool matchAndReplace (Instruction * value, Replacements & replacements, ReplaceDirection const & dir =ReplaceForwards) void addRule (ReplacementRulePtr const & rule, ReplaceDirection const & dir =ReplaceForwards) Adds a new replacement rule to the set. void addRule ( ReplacementRule && rule, ReplaceDirection const & dir =ReplaceForwards) void clear () Clears the rule set for all rules. uint64_t size () const Returns the size of the rule set.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#detailed-description","text":"class microsoft::quantum::RuleSet; RuleSet contains a set of replacement rules and the corresponding logic to apply the rules. The class allows one to apply the rules by which each rule is tested one-by-one until a successful attempt at performing a replace has happened, or the list was exhausted.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#enum-replacedirection","text":"Enumerator Value Description ReplaceForwards ReplaceBackwards","title":"enum ReplaceDirection"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-replacementruleptr","text":"using microsoft::quantum::RuleSet::ReplacementRulePtr = std::shared_ptr<ReplacementRule>;","title":"using ReplacementRulePtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-rules","text":"using microsoft::quantum::RuleSet::Rules = std::vector<ReplacementRulePtr>;","title":"using Rules"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-replacements","text":"using microsoft::quantum::RuleSet::Replacements = ReplacementRule::Replacements;","title":"using Replacements"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-captures","text":"using microsoft::quantum::RuleSet::Captures = IOperandPrototype::Captures;","title":"using Captures"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-instruction","text":"using microsoft::quantum::RuleSet::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-value","text":"using microsoft::quantum::RuleSet::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-builder","text":"using microsoft::quantum::RuleSet::Builder = ReplacementRule::Builder;","title":"using Builder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-allocationmanagerptr","text":"using microsoft::quantum::RuleSet::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr;","title":"using AllocationManagerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-ruleset","text":"RuleSet() =default","title":"function RuleSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-ruleset_1","text":"RuleSet( RuleSet const & ) =default","title":"function RuleSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-ruleset_2","text":"RuleSet( RuleSet && ) =default","title":"function RuleSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-ruleset_3","text":"~RuleSet() =default","title":"function ~RuleSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-operator","text":"RuleSet & operator=( RuleSet const & ) =default","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-operator_1","text":"RuleSet & operator=( RuleSet && ) =default","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-matchandreplace","text":"bool matchAndReplace( Instruction * value, Replacements & replacements, ReplaceDirection const & dir =ReplaceForwards ) Matches patterns and runs the replacement routines if a match is found. The function returns true if a pattern is matched and and the replacement was a success. In all other cases, it returns false.","title":"function matchAndReplace"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-addrule","text":"void addRule( ReplacementRulePtr const & rule, ReplaceDirection const & dir =ReplaceForwards ) Adds a new replacement rule to the set.","title":"function addRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-addrule_1","text":"void addRule( ReplacementRule && rule, ReplaceDirection const & dir =ReplaceForwards )","title":"function addRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-clear","text":"void clear() Clears the rule set for all rules.","title":"function clear"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-size","text":"uint64_t size() const Returns the size of the rule set. Updated on 28 October 2022 at 19:30:15 UTC","title":"function size"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_select_pattern/","text":"microsoft::quantum::SelectPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::SelectPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_select_pattern/#microsoftquantumselectpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::SelectPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_select_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_select_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_select_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_select_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_select_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 28 October 2022 at 19:30:15 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_source_location/","text":"microsoft::quantum::SourceLocation Inherited by microsoft::quantum::ILogger::Location Public Types Name enum @0 { InvalidPosition = -1} using llvm::StringRef StringRef Public Functions Name SourceLocation () =default SourceLocation (String v_name, int64_t v_line, int64_t v_column) operator bool () const String & name () String const & name () const void setName (String const & name) int64_t & line () int64_t const & line () const void setLine (int64_t line) int64_t & column () int64_t const & column () const void setColumn (int64_t column) SourceLocation invalidPosition () Public Types Documentation enum @0 Enumerator Value Description InvalidPosition -1 using StringRef using microsoft::quantum::SourceLocation::StringRef = llvm::StringRef; Public Functions Documentation function SourceLocation SourceLocation() =default function SourceLocation inline SourceLocation( String v_name, int64_t v_line, int64_t v_column ) function operator bool inline explicit operator bool() const function name inline String & name() function name inline String const & name() const function setName inline void setName( String const & name ) function line inline int64_t & line() function line inline int64_t const & line() const function setLine inline void setLine( int64_t line ) function column inline int64_t & column() function column inline int64_t const & column() const function setColumn inline void setColumn( int64_t column ) function invalidPosition static inline SourceLocation invalidPosition() Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::SourceLocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_source_location/#microsoftquantumsourcelocation","text":"Inherited by microsoft::quantum::ILogger::Location","title":"microsoft::quantum::SourceLocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_source_location/#public-types","text":"Name enum @0 { InvalidPosition = -1} using llvm::StringRef StringRef","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_source_location/#public-functions","text":"Name SourceLocation () =default SourceLocation (String v_name, int64_t v_line, int64_t v_column) operator bool () const String & name () String const & name () const void setName (String const & name) int64_t & line () int64_t const & line () const void setLine (int64_t line) int64_t & column () int64_t const & column () const void setColumn (int64_t column) SourceLocation invalidPosition ()","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_source_location/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_source_location/#enum-0","text":"Enumerator Value Description InvalidPosition -1","title":"enum @0"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_source_location/#using-stringref","text":"using microsoft::quantum::SourceLocation::StringRef = llvm::StringRef;","title":"using StringRef"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_source_location/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_source_location/#function-sourcelocation","text":"SourceLocation() =default","title":"function SourceLocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_source_location/#function-sourcelocation_1","text":"inline SourceLocation( String v_name, int64_t v_line, int64_t v_column )","title":"function SourceLocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_source_location/#function-operator-bool","text":"inline explicit operator bool() const","title":"function operator bool"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_source_location/#function-name","text":"inline String & name()","title":"function name"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_source_location/#function-name_1","text":"inline String const & name() const","title":"function name"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_source_location/#function-setname","text":"inline void setName( String const & name )","title":"function setName"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_source_location/#function-line","text":"inline int64_t & line()","title":"function line"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_source_location/#function-line_1","text":"inline int64_t const & line() const","title":"function line"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_source_location/#function-setline","text":"inline void setLine( int64_t line )","title":"function setLine"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_source_location/#function-column","text":"inline int64_t & column()","title":"function column"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_source_location/#function-column_1","text":"inline int64_t const & column() const","title":"function column"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_source_location/#function-setcolumn","text":"inline void setColumn( int64_t column )","title":"function setColumn"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_source_location/#function-invalidposition","text":"static inline SourceLocation invalidPosition() Updated on 28 October 2022 at 19:30:15 UTC","title":"function invalidPosition"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_spec_configuration/","text":"microsoft::quantum::SpecConfiguration Public Functions Name void setup ( ConfigurationManager & config) String version () const String entryPointAttr () const String qirProfilesAttr () const String outputLabelingSchemaAttr () const String requiredNumQubitsAttr () const String requiredNumResultsAttr () const String replaceWithAttr () const String irreversibleAttr () const String qirRuntimePrefix () const Public Functions Documentation function setup inline void setup( ConfigurationManager & config ) function version inline String version() const function entryPointAttr inline String entryPointAttr() const function qirProfilesAttr inline String qirProfilesAttr() const function outputLabelingSchemaAttr inline String outputLabelingSchemaAttr() const function requiredNumQubitsAttr inline String requiredNumQubitsAttr() const function requiredNumResultsAttr inline String requiredNumResultsAttr() const function replaceWithAttr inline String replaceWithAttr() const function irreversibleAttr inline String irreversibleAttr() const function qirRuntimePrefix inline String qirRuntimePrefix() const Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::SpecConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_spec_configuration/#microsoftquantumspecconfiguration","text":"","title":"microsoft::quantum::SpecConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_spec_configuration/#public-functions","text":"Name void setup ( ConfigurationManager & config) String version () const String entryPointAttr () const String qirProfilesAttr () const String outputLabelingSchemaAttr () const String requiredNumQubitsAttr () const String requiredNumResultsAttr () const String replaceWithAttr () const String irreversibleAttr () const String qirRuntimePrefix () const","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_spec_configuration/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_spec_configuration/#function-setup","text":"inline void setup( ConfigurationManager & config )","title":"function setup"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_spec_configuration/#function-version","text":"inline String version() const","title":"function version"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_spec_configuration/#function-entrypointattr","text":"inline String entryPointAttr() const","title":"function entryPointAttr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_spec_configuration/#function-qirprofilesattr","text":"inline String qirProfilesAttr() const","title":"function qirProfilesAttr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_spec_configuration/#function-outputlabelingschemaattr","text":"inline String outputLabelingSchemaAttr() const","title":"function outputLabelingSchemaAttr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_spec_configuration/#function-requirednumqubitsattr","text":"inline String requiredNumQubitsAttr() const","title":"function requiredNumQubitsAttr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_spec_configuration/#function-requirednumresultsattr","text":"inline String requiredNumResultsAttr() const","title":"function requiredNumResultsAttr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_spec_configuration/#function-replacewithattr","text":"inline String replaceWithAttr() const","title":"function replaceWithAttr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_spec_configuration/#function-irreversibleattr","text":"inline String irreversibleAttr() const","title":"function irreversibleAttr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_spec_configuration/#function-qirruntimeprefix","text":"inline String qirRuntimePrefix() const Updated on 28 October 2022 at 19:30:15 UTC","title":"function qirRuntimePrefix"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/","text":"microsoft::quantum::StaticResourceComponentConfiguration Public Types Name using std::unordered_set< std::string > Set using DeferredValue::DeferredValuePtr DeferredValuePtr Public Functions Name StaticResourceComponentConfiguration () =default void setup ( ConfigurationManager & config) bool shouldAnnotateQubitUse () const Whether or not to annotate every function with the number of qubits they use. bool shouldAnnotateResultUse () const Whether or not to annotate every function with the number of results they use. bool shouldAnnotateMaxQubitIndex () const Whether or not to annotate every function with the maximum qubit index accessed. bool shouldAnnotateMaxResultIndex () const Whether or not to annotate every function with the maximum result index accessed. bool shouldReplaceQubitsOnReset () const Whether or not qubits should be replaced upon resetting. bool shouldReindexQubits () const Whether or not qubit ids should be re-indexed sequentially starting from 0. bool shouldInlineAfterIdChange () const Whether or not this component should inline after changing qubit ids. bool isChangingIds () const Whether or not the configuration is set to changing qubit ids. void enableAnnotateQubitUse () void enableAnnotateResultUse () void enableAnnotateMaxQubitIndex () void enableAnnotateMaxResultIndex () void enableReplaceQubitOnReset () void enableReindexQubits () void enableInlineAfterIdChange () String requiredNumQubitsAttr () const String requiredNumResultsAttr () const String maxIndexQubitsAttr () const String maxIndexResultsAttr () const StaticResourceComponentConfiguration createDisabled () Creates a configuration where all features are disabled. Public Types Documentation using Set using microsoft::quantum::StaticResourceComponentConfiguration::Set = std::unordered_set<std::string>; using DeferredValuePtr using microsoft::quantum::StaticResourceComponentConfiguration::DeferredValuePtr = DeferredValue::DeferredValuePtr; Public Functions Documentation function StaticResourceComponentConfiguration StaticResourceComponentConfiguration() =default function setup void setup( ConfigurationManager & config ) Setup function that adds the configuration flags to the ConfigurationManager . See the ConfigurationManager documentation for more details on how the setup process is implemented. function shouldAnnotateQubitUse bool shouldAnnotateQubitUse() const Whether or not to annotate every function with the number of qubits they use. function shouldAnnotateResultUse bool shouldAnnotateResultUse() const Whether or not to annotate every function with the number of results they use. function shouldAnnotateMaxQubitIndex bool shouldAnnotateMaxQubitIndex() const Whether or not to annotate every function with the maximum qubit index accessed. function shouldAnnotateMaxResultIndex bool shouldAnnotateMaxResultIndex() const Whether or not to annotate every function with the maximum result index accessed. function shouldReplaceQubitsOnReset bool shouldReplaceQubitsOnReset() const Whether or not qubits should be replaced upon resetting. function shouldReindexQubits bool shouldReindexQubits() const Whether or not qubit ids should be re-indexed sequentially starting from 0. function shouldInlineAfterIdChange bool shouldInlineAfterIdChange() const Whether or not this component should inline after changing qubit ids. function isChangingIds bool isChangingIds() const Whether or not the configuration is set to changing qubit ids. function enableAnnotateQubitUse void enableAnnotateQubitUse() function enableAnnotateResultUse void enableAnnotateResultUse() function enableAnnotateMaxQubitIndex void enableAnnotateMaxQubitIndex() function enableAnnotateMaxResultIndex void enableAnnotateMaxResultIndex() function enableReplaceQubitOnReset void enableReplaceQubitOnReset() function enableReindexQubits void enableReindexQubits() function enableInlineAfterIdChange void enableInlineAfterIdChange() function requiredNumQubitsAttr String requiredNumQubitsAttr() const function requiredNumResultsAttr String requiredNumResultsAttr() const function maxIndexQubitsAttr String maxIndexQubitsAttr() const function maxIndexResultsAttr String maxIndexResultsAttr() const function createDisabled static StaticResourceComponentConfiguration createDisabled() Creates a configuration where all features are disabled. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::StaticResourceComponentConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#microsoftquantumstaticresourcecomponentconfiguration","text":"","title":"microsoft::quantum::StaticResourceComponentConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#public-types","text":"Name using std::unordered_set< std::string > Set using DeferredValue::DeferredValuePtr DeferredValuePtr","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#public-functions","text":"Name StaticResourceComponentConfiguration () =default void setup ( ConfigurationManager & config) bool shouldAnnotateQubitUse () const Whether or not to annotate every function with the number of qubits they use. bool shouldAnnotateResultUse () const Whether or not to annotate every function with the number of results they use. bool shouldAnnotateMaxQubitIndex () const Whether or not to annotate every function with the maximum qubit index accessed. bool shouldAnnotateMaxResultIndex () const Whether or not to annotate every function with the maximum result index accessed. bool shouldReplaceQubitsOnReset () const Whether or not qubits should be replaced upon resetting. bool shouldReindexQubits () const Whether or not qubit ids should be re-indexed sequentially starting from 0. bool shouldInlineAfterIdChange () const Whether or not this component should inline after changing qubit ids. bool isChangingIds () const Whether or not the configuration is set to changing qubit ids. void enableAnnotateQubitUse () void enableAnnotateResultUse () void enableAnnotateMaxQubitIndex () void enableAnnotateMaxResultIndex () void enableReplaceQubitOnReset () void enableReindexQubits () void enableInlineAfterIdChange () String requiredNumQubitsAttr () const String requiredNumResultsAttr () const String maxIndexQubitsAttr () const String maxIndexResultsAttr () const StaticResourceComponentConfiguration createDisabled () Creates a configuration where all features are disabled.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#using-set","text":"using microsoft::quantum::StaticResourceComponentConfiguration::Set = std::unordered_set<std::string>;","title":"using Set"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#using-deferredvalueptr","text":"using microsoft::quantum::StaticResourceComponentConfiguration::DeferredValuePtr = DeferredValue::DeferredValuePtr;","title":"using DeferredValuePtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-staticresourcecomponentconfiguration","text":"StaticResourceComponentConfiguration() =default","title":"function StaticResourceComponentConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-setup","text":"void setup( ConfigurationManager & config ) Setup function that adds the configuration flags to the ConfigurationManager . See the ConfigurationManager documentation for more details on how the setup process is implemented.","title":"function setup"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-shouldannotatequbituse","text":"bool shouldAnnotateQubitUse() const Whether or not to annotate every function with the number of qubits they use.","title":"function shouldAnnotateQubitUse"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-shouldannotateresultuse","text":"bool shouldAnnotateResultUse() const Whether or not to annotate every function with the number of results they use.","title":"function shouldAnnotateResultUse"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-shouldannotatemaxqubitindex","text":"bool shouldAnnotateMaxQubitIndex() const Whether or not to annotate every function with the maximum qubit index accessed.","title":"function shouldAnnotateMaxQubitIndex"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-shouldannotatemaxresultindex","text":"bool shouldAnnotateMaxResultIndex() const Whether or not to annotate every function with the maximum result index accessed.","title":"function shouldAnnotateMaxResultIndex"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-shouldreplacequbitsonreset","text":"bool shouldReplaceQubitsOnReset() const Whether or not qubits should be replaced upon resetting.","title":"function shouldReplaceQubitsOnReset"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-shouldreindexqubits","text":"bool shouldReindexQubits() const Whether or not qubit ids should be re-indexed sequentially starting from 0.","title":"function shouldReindexQubits"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-shouldinlineafteridchange","text":"bool shouldInlineAfterIdChange() const Whether or not this component should inline after changing qubit ids.","title":"function shouldInlineAfterIdChange"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-ischangingids","text":"bool isChangingIds() const Whether or not the configuration is set to changing qubit ids.","title":"function isChangingIds"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-enableannotatequbituse","text":"void enableAnnotateQubitUse()","title":"function enableAnnotateQubitUse"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-enableannotateresultuse","text":"void enableAnnotateResultUse()","title":"function enableAnnotateResultUse"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-enableannotatemaxqubitindex","text":"void enableAnnotateMaxQubitIndex()","title":"function enableAnnotateMaxQubitIndex"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-enableannotatemaxresultindex","text":"void enableAnnotateMaxResultIndex()","title":"function enableAnnotateMaxResultIndex"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-enablereplacequbitonreset","text":"void enableReplaceQubitOnReset()","title":"function enableReplaceQubitOnReset"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-enablereindexqubits","text":"void enableReindexQubits()","title":"function enableReindexQubits"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-enableinlineafteridchange","text":"void enableInlineAfterIdChange()","title":"function enableInlineAfterIdChange"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-requirednumqubitsattr","text":"String requiredNumQubitsAttr() const","title":"function requiredNumQubitsAttr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-requirednumresultsattr","text":"String requiredNumResultsAttr() const","title":"function requiredNumResultsAttr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-maxindexqubitsattr","text":"String maxIndexQubitsAttr() const","title":"function maxIndexQubitsAttr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-maxindexresultsattr","text":"String maxIndexResultsAttr() const","title":"function maxIndexResultsAttr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_static_resource_component_configuration/#function-createdisabled","text":"static StaticResourceComponentConfiguration createDisabled() Creates a configuration where all features are disabled. Updated on 28 October 2022 at 19:30:15 UTC","title":"function createDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_store_pattern/","text":"microsoft::quantum::StorePattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::StorePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_store_pattern/#microsoftquantumstorepattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::StorePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_store_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_store_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_store_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_store_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_store_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 28 October 2022 at 19:30:15 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_switch_pattern/","text":"microsoft::quantum::SwitchPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::SwitchPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_switch_pattern/#microsoftquantumswitchpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::SwitchPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_switch_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_switch_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_switch_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_switch_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_switch_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 28 October 2022 at 19:30:15 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_profile_configuration/","text":"microsoft::quantum::TargetProfileConfiguration Public Types Name using std::unordered_set< std::string > Set Public Functions Name TargetProfileConfiguration () =default void setup ( ConfigurationManager & config) OpcodeSet const & allowedOpcodes () const Set const & allowedExternalCallNames () const bool allowInternalCalls () const bool allowlistOpcodes () const bool allowlistExternalCalls () const bool allowlistPointerTypes () const Set const & allowedPointerTypes () const bool allowPoison () const bool allowUndef () const String targetName () const TargetProfileConfiguration fromQirTargetName (String const & name) Public Types Documentation using Set using microsoft::quantum::TargetProfileConfiguration::Set = std::unordered_set<std::string>; Public Functions Documentation function TargetProfileConfiguration TargetProfileConfiguration() =default function setup void setup( ConfigurationManager & config ) Setup function that adds the configuration flags to the ConfigurationManager . See the ConfigurationManager documentation for more details on how the setup process is implemented. CLI and config accessible Config accessible function allowedOpcodes OpcodeSet const & allowedOpcodes() const function allowedExternalCallNames Set const & allowedExternalCallNames() const function allowInternalCalls bool allowInternalCalls() const function allowlistOpcodes bool allowlistOpcodes() const function allowlistExternalCalls bool allowlistExternalCalls() const function allowlistPointerTypes bool allowlistPointerTypes() const function allowedPointerTypes Set const & allowedPointerTypes() const function allowPoison bool allowPoison() const function allowUndef bool allowUndef() const function targetName String targetName() const function fromQirTargetName static TargetProfileConfiguration fromQirTargetName( String const & name ) Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::TargetProfileConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_profile_configuration/#microsoftquantumtargetprofileconfiguration","text":"","title":"microsoft::quantum::TargetProfileConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_profile_configuration/#public-types","text":"Name using std::unordered_set< std::string > Set","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_profile_configuration/#public-functions","text":"Name TargetProfileConfiguration () =default void setup ( ConfigurationManager & config) OpcodeSet const & allowedOpcodes () const Set const & allowedExternalCallNames () const bool allowInternalCalls () const bool allowlistOpcodes () const bool allowlistExternalCalls () const bool allowlistPointerTypes () const Set const & allowedPointerTypes () const bool allowPoison () const bool allowUndef () const String targetName () const TargetProfileConfiguration fromQirTargetName (String const & name)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_profile_configuration/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_profile_configuration/#using-set","text":"using microsoft::quantum::TargetProfileConfiguration::Set = std::unordered_set<std::string>;","title":"using Set"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_profile_configuration/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_profile_configuration/#function-targetprofileconfiguration","text":"TargetProfileConfiguration() =default","title":"function TargetProfileConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_profile_configuration/#function-setup","text":"void setup( ConfigurationManager & config ) Setup function that adds the configuration flags to the ConfigurationManager . See the ConfigurationManager documentation for more details on how the setup process is implemented. CLI and config accessible Config accessible","title":"function setup"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_profile_configuration/#function-allowedopcodes","text":"OpcodeSet const & allowedOpcodes() const","title":"function allowedOpcodes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_profile_configuration/#function-allowedexternalcallnames","text":"Set const & allowedExternalCallNames() const","title":"function allowedExternalCallNames"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_profile_configuration/#function-allowinternalcalls","text":"bool allowInternalCalls() const","title":"function allowInternalCalls"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_profile_configuration/#function-allowlistopcodes","text":"bool allowlistOpcodes() const","title":"function allowlistOpcodes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_profile_configuration/#function-allowlistexternalcalls","text":"bool allowlistExternalCalls() const","title":"function allowlistExternalCalls"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_profile_configuration/#function-allowlistpointertypes","text":"bool allowlistPointerTypes() const","title":"function allowlistPointerTypes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_profile_configuration/#function-allowedpointertypes","text":"Set const & allowedPointerTypes() const","title":"function allowedPointerTypes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_profile_configuration/#function-allowpoison","text":"bool allowPoison() const","title":"function allowPoison"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_profile_configuration/#function-allowundef","text":"bool allowUndef() const","title":"function allowUndef"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_profile_configuration/#function-targetname","text":"String targetName() const","title":"function targetName"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_profile_configuration/#function-fromqirtargetname","text":"static TargetProfileConfiguration fromQirTargetName( String const & name ) Updated on 28 October 2022 at 19:30:15 UTC","title":"function fromQirTargetName"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_configuration/","text":"microsoft::quantum::TargetQisConfiguration Public Types Name using std::unordered_set< std::string > Set Public Functions Name TargetQisConfiguration () =default void setup ( ConfigurationManager & config) Set const & allowedQis () const Set const & irreversibleOperations () const bool requiresQubits () const bool requiresResults () const String targetName () const TargetQisConfiguration fromQirTargetName (String const & name) Public Types Documentation using Set using microsoft::quantum::TargetQisConfiguration::Set = std::unordered_set<std::string>; Public Functions Documentation function TargetQisConfiguration TargetQisConfiguration() =default function setup void setup( ConfigurationManager & config ) Setup function that adds the configuration flags to the ConfigurationManager . See the ConfigurationManager documentation for more details on how the setup process is implemented. function allowedQis Set const & allowedQis() const function irreversibleOperations Set const & irreversibleOperations() const function requiresQubits bool requiresQubits() const function requiresResults bool requiresResults() const function targetName String targetName() const function fromQirTargetName static TargetQisConfiguration fromQirTargetName( String const & name ) Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::TargetQisConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_configuration/#microsoftquantumtargetqisconfiguration","text":"","title":"microsoft::quantum::TargetQisConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_configuration/#public-types","text":"Name using std::unordered_set< std::string > Set","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_configuration/#public-functions","text":"Name TargetQisConfiguration () =default void setup ( ConfigurationManager & config) Set const & allowedQis () const Set const & irreversibleOperations () const bool requiresQubits () const bool requiresResults () const String targetName () const TargetQisConfiguration fromQirTargetName (String const & name)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_configuration/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_configuration/#using-set","text":"using microsoft::quantum::TargetQisConfiguration::Set = std::unordered_set<std::string>;","title":"using Set"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_configuration/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_configuration/#function-targetqisconfiguration","text":"TargetQisConfiguration() =default","title":"function TargetQisConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_configuration/#function-setup","text":"void setup( ConfigurationManager & config ) Setup function that adds the configuration flags to the ConfigurationManager . See the ConfigurationManager documentation for more details on how the setup process is implemented.","title":"function setup"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_configuration/#function-allowedqis","text":"Set const & allowedQis() const","title":"function allowedQis"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_configuration/#function-irreversibleoperations","text":"Set const & irreversibleOperations() const","title":"function irreversibleOperations"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_configuration/#function-requiresqubits","text":"bool requiresQubits() const","title":"function requiresQubits"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_configuration/#function-requiresresults","text":"bool requiresResults() const","title":"function requiresResults"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_configuration/#function-targetname","text":"String targetName() const","title":"function targetName"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_configuration/#function-fromqirtargetname","text":"static TargetQisConfiguration fromQirTargetName( String const & name ) Updated on 28 October 2022 at 19:30:15 UTC","title":"function fromQirTargetName"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/","text":"microsoft::quantum::TargetQisMappingPass More... #include <Passes/TargetQisMappingPass/TargetQisMappingPass.hpp> Inherits from llvm::PassInfoMixin< TargetQisMappingPass > Public Types Name using ReplacementRule::Replacements Replacements using llvm::Instruction Instruction using std::vector< ReplacementRule > Rules using llvm::Value Value using ReplacementRule::Builder Builder using IAllocationManager::AllocationManagerPtr AllocationManagerPtr using RuleSet::Captures Captures using std::unordered_map< std::string, llvm::ConstantInt * > ConstantArguments using ILogger::ILoggerPtr ILoggerPtr using std::vector< llvm::Instruction * > DeletableInstructions using std::function< llvm::Value (llvm::Value , DeletableInstructions &)> InstructionModifier Public Functions Name TargetQisMappingPass ( RuleSet && rule_set, TargetQisMappingPassConfiguration const & config) Custom default constructor. TargetQisMappingPass ( TargetQisMappingPass const & ) Copy construction is banned. TargetQisMappingPass ( TargetQisMappingPass && ) =default We allow move semantics. ~TargetQisMappingPass () =default Default destruction. TargetQisMappingPass & operator= ( TargetQisMappingPass const & ) Copy assignment is banned. TargetQisMappingPass & operator= ( TargetQisMappingPass && ) =default Move assignment is permitted. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool runOnFunction (llvm::Function & function, InstructionModifier const & modifier) void processReplacements () Applies each of the replacements in the replacements_ variable. void setupCopyAndExpand () Configuration function for copy and expand to setup the necessary rules. void runCopyAndExpand (llvm::Module & module, llvm::ModuleAnalysisManager & mam) llvm::Value * copyAndExpand (llvm::Value * input, DeletableInstructions & schedule_instruction_deletion) llvm::Function * expandFunctionCall (llvm::Function & callee, ConstantArguments const & const_args ={}) Copies the function body and replace function arguments whenever arguments are constant. void constantFoldFunction (llvm::Function & callee) Folds all constant expression in function. void addConstExprRule ( ReplacementRule && rule) Helper function to create replacements for constant expressions. void runDetectActiveCode (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runDeleteDeadCode (llvm::Module & module, llvm::ModuleAnalysisManager & mam) llvm::Value * detectActiveCode (llvm::Value * input, DeletableInstructions & ) llvm::Value * deleteDeadCode (llvm::Value * input, DeletableInstructions & ) bool isActive (llvm::Value * value) const void followUsers (llvm::Value * value) void runReplacePhi (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runApplyRules (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool onQubitRelease (llvm::Instruction * instruction, Captures & captures) bool onQubitAllocate (llvm::Instruction * instruction, Captures & captures) void setLogger (ILoggerPtr logger) bool isRequired () Whether or not this pass is required to run. Detailed Description class microsoft::quantum::TargetQisMappingPass; This class applies a set of transformation rules to the IR to transform it into a new IR. The rules are added using the RuleSet class which allows the developer to create one or more rules on how to transform the IR. The module executes the following steps: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Apply adaptor \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Copy and expand functions \u2502\u2500\u2500\u2510 \u2502 clone \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 functions? \u2502 delete dead \u2502 \u2502 \u25bc code? \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Determine active code \u2502 \u2502 \u2502 delete dead \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 code? \u2502 \u2502 leave dead \u2502 \u25bc \u2502 code? \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Simplify phi nodes \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Delete dead code \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 fallback \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Apply rules \u2502\u25c0\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Copying and expanding functions identifies function calls and identifies compile time constants passed to the function. It then copies the full implementation of the function, replacing all compile-time constants (and hence changing the function signature). That is, if a function call f(x, 9) is identified, it is replaced with f.1(x) where f.1 is a copy of f with second argument written into the function. Public Types Documentation using Replacements using microsoft::quantum::TargetQisMappingPass::Replacements = ReplacementRule::Replacements; using Instruction using microsoft::quantum::TargetQisMappingPass::Instruction = llvm::Instruction; using Rules using microsoft::quantum::TargetQisMappingPass::Rules = std::vector<ReplacementRule>; using Value using microsoft::quantum::TargetQisMappingPass::Value = llvm::Value; using Builder using microsoft::quantum::TargetQisMappingPass::Builder = ReplacementRule::Builder; using AllocationManagerPtr using microsoft::quantum::TargetQisMappingPass::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; using Captures using microsoft::quantum::TargetQisMappingPass::Captures = RuleSet::Captures; using ConstantArguments using microsoft::quantum::TargetQisMappingPass::ConstantArguments = std::unordered_map<std::string, llvm::ConstantInt*>; using ILoggerPtr using microsoft::quantum::TargetQisMappingPass::ILoggerPtr = ILogger::ILoggerPtr; using DeletableInstructions using microsoft::quantum::TargetQisMappingPass::DeletableInstructions = std::vector<llvm::Instruction*>; using InstructionModifier using microsoft::quantum::TargetQisMappingPass::InstructionModifier = std::function<llvm::Value*(llvm::Value*, DeletableInstructions&)>; Public Functions Documentation function TargetQisMappingPass TargetQisMappingPass( RuleSet && rule_set, TargetQisMappingPassConfiguration const & config ) Custom default constructor. function TargetQisMappingPass TargetQisMappingPass( TargetQisMappingPass const & ) Copy construction is banned. function TargetQisMappingPass TargetQisMappingPass( TargetQisMappingPass && ) =default We allow move semantics. function ~TargetQisMappingPass ~TargetQisMappingPass() =default Default destruction. function operator= TargetQisMappingPass & operator=( TargetQisMappingPass const & ) Copy assignment is banned. function operator= TargetQisMappingPass & operator=( TargetQisMappingPass && ) =default Move assignment is permitted. function run llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) Implements the transformation analysis which uses the supplied ruleset to make substitutions in each function. function runOnFunction bool runOnFunction( llvm::Function & function, InstructionModifier const & modifier ) Generic function to apply a instructionModifier (lambda function) to every instruction in the function function . This method follows the execution path to the extend possible and deals with branching if the branch statement can be evaluated at compile time. function processReplacements void processReplacements() Applies each of the replacements in the replacements_ variable. function setupCopyAndExpand void setupCopyAndExpand() Configuration function for copy and expand to setup the necessary rules. function runCopyAndExpand void runCopyAndExpand( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) Main function for running the copy and expand functionality. This function first identifies the entry point and then follows every execution path to copy the callee function for every call instruction encountered. This makes that every call in the code has its own unique callee function which ensures that when allocating qubits or results, the assigned registers are not accidentally reused. function copyAndExpand llvm::Value * copyAndExpand( llvm::Value * input, DeletableInstructions & schedule_instruction_deletion ) Test whether the instruction is a call instruction and copy the callee in case it is. This function collects instructions which are scheduled for deletion at a later point. function expandFunctionCall llvm::Function * expandFunctionCall( llvm::Function & callee, ConstantArguments const & const_args ={} ) Copies the function body and replace function arguments whenever arguments are constant. function constantFoldFunction void constantFoldFunction( llvm::Function & callee ) Folds all constant expression in function. function addConstExprRule void addConstExprRule( ReplacementRule && rule ) Helper function to create replacements for constant expressions. function runDetectActiveCode void runDetectActiveCode( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function runDeleteDeadCode void runDeleteDeadCode( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function detectActiveCode llvm::Value * detectActiveCode( llvm::Value * input, DeletableInstructions & ) function deleteDeadCode llvm::Value * deleteDeadCode( llvm::Value * input, DeletableInstructions & ) function isActive bool isActive( llvm::Value * value ) const function followUsers void followUsers( llvm::Value * value ) function runReplacePhi void runReplacePhi( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) Function which replaces phi nodes which refer to inactive blocks. That is, in cases where branch statement evaluates at compile time, only one block will be marked as active. For those case we can eliminate the phi nodes. In the case where branch statements cannot be evaluated all are marked as active. In this case, phi nodes are left unchanged. function runApplyRules void runApplyRules( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function onQubitRelease bool onQubitRelease( llvm::Instruction * instruction, Captures & captures ) function onQubitAllocate bool onQubitAllocate( llvm::Instruction * instruction, Captures & captures ) function setLogger void setLogger( ILoggerPtr logger ) function isRequired static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::TargetQisMappingPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#microsoftquantumtargetqismappingpass","text":"More... #include <Passes/TargetQisMappingPass/TargetQisMappingPass.hpp> Inherits from llvm::PassInfoMixin< TargetQisMappingPass >","title":"microsoft::quantum::TargetQisMappingPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#public-types","text":"Name using ReplacementRule::Replacements Replacements using llvm::Instruction Instruction using std::vector< ReplacementRule > Rules using llvm::Value Value using ReplacementRule::Builder Builder using IAllocationManager::AllocationManagerPtr AllocationManagerPtr using RuleSet::Captures Captures using std::unordered_map< std::string, llvm::ConstantInt * > ConstantArguments using ILogger::ILoggerPtr ILoggerPtr using std::vector< llvm::Instruction * > DeletableInstructions using std::function< llvm::Value (llvm::Value , DeletableInstructions &)> InstructionModifier","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#public-functions","text":"Name TargetQisMappingPass ( RuleSet && rule_set, TargetQisMappingPassConfiguration const & config) Custom default constructor. TargetQisMappingPass ( TargetQisMappingPass const & ) Copy construction is banned. TargetQisMappingPass ( TargetQisMappingPass && ) =default We allow move semantics. ~TargetQisMappingPass () =default Default destruction. TargetQisMappingPass & operator= ( TargetQisMappingPass const & ) Copy assignment is banned. TargetQisMappingPass & operator= ( TargetQisMappingPass && ) =default Move assignment is permitted. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool runOnFunction (llvm::Function & function, InstructionModifier const & modifier) void processReplacements () Applies each of the replacements in the replacements_ variable. void setupCopyAndExpand () Configuration function for copy and expand to setup the necessary rules. void runCopyAndExpand (llvm::Module & module, llvm::ModuleAnalysisManager & mam) llvm::Value * copyAndExpand (llvm::Value * input, DeletableInstructions & schedule_instruction_deletion) llvm::Function * expandFunctionCall (llvm::Function & callee, ConstantArguments const & const_args ={}) Copies the function body and replace function arguments whenever arguments are constant. void constantFoldFunction (llvm::Function & callee) Folds all constant expression in function. void addConstExprRule ( ReplacementRule && rule) Helper function to create replacements for constant expressions. void runDetectActiveCode (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runDeleteDeadCode (llvm::Module & module, llvm::ModuleAnalysisManager & mam) llvm::Value * detectActiveCode (llvm::Value * input, DeletableInstructions & ) llvm::Value * deleteDeadCode (llvm::Value * input, DeletableInstructions & ) bool isActive (llvm::Value * value) const void followUsers (llvm::Value * value) void runReplacePhi (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runApplyRules (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool onQubitRelease (llvm::Instruction * instruction, Captures & captures) bool onQubitAllocate (llvm::Instruction * instruction, Captures & captures) void setLogger (ILoggerPtr logger) bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#detailed-description","text":"class microsoft::quantum::TargetQisMappingPass; This class applies a set of transformation rules to the IR to transform it into a new IR. The rules are added using the RuleSet class which allows the developer to create one or more rules on how to transform the IR. The module executes the following steps: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Apply adaptor \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Copy and expand functions \u2502\u2500\u2500\u2510 \u2502 clone \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 functions? \u2502 delete dead \u2502 \u2502 \u25bc code? \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Determine active code \u2502 \u2502 \u2502 delete dead \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 code? \u2502 \u2502 leave dead \u2502 \u25bc \u2502 code? \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Simplify phi nodes \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Delete dead code \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 fallback \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Apply rules \u2502\u25c0\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Copying and expanding functions identifies function calls and identifies compile time constants passed to the function. It then copies the full implementation of the function, replacing all compile-time constants (and hence changing the function signature). That is, if a function call f(x, 9) is identified, it is replaced with f.1(x) where f.1 is a copy of f with second argument written into the function.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#using-replacements","text":"using microsoft::quantum::TargetQisMappingPass::Replacements = ReplacementRule::Replacements;","title":"using Replacements"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#using-instruction","text":"using microsoft::quantum::TargetQisMappingPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#using-rules","text":"using microsoft::quantum::TargetQisMappingPass::Rules = std::vector<ReplacementRule>;","title":"using Rules"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#using-value","text":"using microsoft::quantum::TargetQisMappingPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#using-builder","text":"using microsoft::quantum::TargetQisMappingPass::Builder = ReplacementRule::Builder;","title":"using Builder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#using-allocationmanagerptr","text":"using microsoft::quantum::TargetQisMappingPass::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr;","title":"using AllocationManagerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#using-captures","text":"using microsoft::quantum::TargetQisMappingPass::Captures = RuleSet::Captures;","title":"using Captures"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#using-constantarguments","text":"using microsoft::quantum::TargetQisMappingPass::ConstantArguments = std::unordered_map<std::string, llvm::ConstantInt*>;","title":"using ConstantArguments"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#using-iloggerptr","text":"using microsoft::quantum::TargetQisMappingPass::ILoggerPtr = ILogger::ILoggerPtr;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#using-deletableinstructions","text":"using microsoft::quantum::TargetQisMappingPass::DeletableInstructions = std::vector<llvm::Instruction*>;","title":"using DeletableInstructions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#using-instructionmodifier","text":"using microsoft::quantum::TargetQisMappingPass::InstructionModifier = std::function<llvm::Value*(llvm::Value*, DeletableInstructions&)>;","title":"using InstructionModifier"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-targetqismappingpass","text":"TargetQisMappingPass( RuleSet && rule_set, TargetQisMappingPassConfiguration const & config ) Custom default constructor.","title":"function TargetQisMappingPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-targetqismappingpass_1","text":"TargetQisMappingPass( TargetQisMappingPass const & ) Copy construction is banned.","title":"function TargetQisMappingPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-targetqismappingpass_2","text":"TargetQisMappingPass( TargetQisMappingPass && ) =default We allow move semantics.","title":"function TargetQisMappingPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-targetqismappingpass_3","text":"~TargetQisMappingPass() =default Default destruction.","title":"function ~TargetQisMappingPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-operator","text":"TargetQisMappingPass & operator=( TargetQisMappingPass const & ) Copy assignment is banned.","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-operator_1","text":"TargetQisMappingPass & operator=( TargetQisMappingPass && ) =default Move assignment is permitted.","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-run","text":"llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) Implements the transformation analysis which uses the supplied ruleset to make substitutions in each function.","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-runonfunction","text":"bool runOnFunction( llvm::Function & function, InstructionModifier const & modifier ) Generic function to apply a instructionModifier (lambda function) to every instruction in the function function . This method follows the execution path to the extend possible and deals with branching if the branch statement can be evaluated at compile time.","title":"function runOnFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-processreplacements","text":"void processReplacements() Applies each of the replacements in the replacements_ variable.","title":"function processReplacements"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-setupcopyandexpand","text":"void setupCopyAndExpand() Configuration function for copy and expand to setup the necessary rules.","title":"function setupCopyAndExpand"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-runcopyandexpand","text":"void runCopyAndExpand( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) Main function for running the copy and expand functionality. This function first identifies the entry point and then follows every execution path to copy the callee function for every call instruction encountered. This makes that every call in the code has its own unique callee function which ensures that when allocating qubits or results, the assigned registers are not accidentally reused.","title":"function runCopyAndExpand"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-copyandexpand","text":"llvm::Value * copyAndExpand( llvm::Value * input, DeletableInstructions & schedule_instruction_deletion ) Test whether the instruction is a call instruction and copy the callee in case it is. This function collects instructions which are scheduled for deletion at a later point.","title":"function copyAndExpand"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-expandfunctioncall","text":"llvm::Function * expandFunctionCall( llvm::Function & callee, ConstantArguments const & const_args ={} ) Copies the function body and replace function arguments whenever arguments are constant.","title":"function expandFunctionCall"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-constantfoldfunction","text":"void constantFoldFunction( llvm::Function & callee ) Folds all constant expression in function.","title":"function constantFoldFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-addconstexprrule","text":"void addConstExprRule( ReplacementRule && rule ) Helper function to create replacements for constant expressions.","title":"function addConstExprRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-rundetectactivecode","text":"void runDetectActiveCode( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function runDetectActiveCode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-rundeletedeadcode","text":"void runDeleteDeadCode( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function runDeleteDeadCode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-detectactivecode","text":"llvm::Value * detectActiveCode( llvm::Value * input, DeletableInstructions & )","title":"function detectActiveCode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-deletedeadcode","text":"llvm::Value * deleteDeadCode( llvm::Value * input, DeletableInstructions & )","title":"function deleteDeadCode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-isactive","text":"bool isActive( llvm::Value * value ) const","title":"function isActive"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-followusers","text":"void followUsers( llvm::Value * value )","title":"function followUsers"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-runreplacephi","text":"void runReplacePhi( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) Function which replaces phi nodes which refer to inactive blocks. That is, in cases where branch statement evaluates at compile time, only one block will be marked as active. For those case we can eliminate the phi nodes. In the case where branch statements cannot be evaluated all are marked as active. In this case, phi nodes are left unchanged.","title":"function runReplacePhi"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-runapplyrules","text":"void runApplyRules( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function runApplyRules"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-onqubitrelease","text":"bool onQubitRelease( llvm::Instruction * instruction, Captures & captures )","title":"function onQubitRelease"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-onqubitallocate","text":"bool onQubitAllocate( llvm::Instruction * instruction, Captures & captures )","title":"function onQubitAllocate"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-setlogger","text":"void setLogger( ILoggerPtr logger )","title":"function setLogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/","text":"microsoft::quantum::TargetQisMappingPassConfiguration Configuration class for the RuleTransformation pass. #include <Passes/TargetQisMappingPass/TargetQisMappingPassConfiguration.hpp> Public Types Name using DeferredValue::DeferredValuePtr DeferredValuePtr Public Functions Name void setup ( ConfigurationManager & config) Setup function that attached the configuration to the ConfigurationManager . bool isDisabled () const Tests whether all functionality is disabled for this component. bool isDefault () const Tests whether this is an instance of default configuration. bool operator== ( TargetQisMappingPassConfiguration const & ref) const Testing equality of two configurations. bool shouldDeleteDeadCode () const Whether or not the component should delete dead code. bool shouldCloneFunctions () const bool assumeNoExceptions () const Whether or not we assume that the code does not throw at runtime. bool shouldTransformExecutionPathOnly () const uint64_t maxRecursion () const The maximum recursion acceptable when unrolling the execution path. bool shouldReuseQubits () const Whether or not to reuse qubits. bool shouldAnnotateQubitUse () const Whether or not to annotate entry point with the number of qubits they use. bool shouldReuseResults () const Whether or not to reuse result registers. bool shouldAnnotateResultUse () const Whether or not to annotate entry point with the number of results they use. bool shouldGroupMeasurements () const Whether or not the component should attempt to group measurements. bool oneShotMeasurement () const std::string entryPointAttr () const Attribute which indicate that a function is the entry point. bool disableReferenceCounting () const bool disableAliasCounting () const bool disableStringSupport () const bool disableRecordOutputSupport () const bool optimizeResultOne () const bool optimizeResultZero () const bool optimizeQuantumConstants () const bool optimizeResultComparison () const bool removeGetZeroOrOne () const bool useStaticQubitArrayAllocation () const bool useStaticQubitAllocation () const bool useStaticResultAllocation () const uint32_t defaultIntegerWidth () const TargetQisMappingPassConfiguration createDisabled () Creates a configuration where all functionality is disabled. TargetQisMappingPassConfiguration createReuseQubitsOnly () Creates a configuration where only reuse qubits is enabled. Public Types Documentation using DeferredValuePtr using microsoft::quantum::TargetQisMappingPassConfiguration::DeferredValuePtr = DeferredValue::DeferredValuePtr; Public Functions Documentation function setup void setup( ConfigurationManager & config ) Setup function that attached the configuration to the ConfigurationManager . function isDisabled bool isDisabled() const Tests whether all functionality is disabled for this component. function isDefault bool isDefault() const Tests whether this is an instance of default configuration. function operator== bool operator==( TargetQisMappingPassConfiguration const & ref ) const Testing equality of two configurations. function shouldDeleteDeadCode bool shouldDeleteDeadCode() const Whether or not the component should delete dead code. function shouldCloneFunctions bool shouldCloneFunctions() const Whether or not the component should clone functions. This is relevant in relation to qubit allocation if execution paths are expanded. function assumeNoExceptions bool assumeNoExceptions() const Whether or not we assume that the code does not throw at runtime. function shouldTransformExecutionPathOnly bool shouldTransformExecutionPathOnly() const Whether or not the component should follow the execution path only or it should be applied to all parts of the code. For statically allocated qubits one generally wants to follow the execution path whereas it makes more sense to apply to all parts of the code for dynamic qubit allocation. function maxRecursion uint64_t maxRecursion() const The maximum recursion acceptable when unrolling the execution path. function shouldReuseQubits bool shouldReuseQubits() const Whether or not to reuse qubits. function shouldAnnotateQubitUse bool shouldAnnotateQubitUse() const Whether or not to annotate entry point with the number of qubits they use. function shouldReuseResults bool shouldReuseResults() const Whether or not to reuse result registers. function shouldAnnotateResultUse bool shouldAnnotateResultUse() const Whether or not to annotate entry point with the number of results they use. function shouldGroupMeasurements bool shouldGroupMeasurements() const Whether or not the component should attempt to group measurements. function oneShotMeasurement bool oneShotMeasurement() const Whether or not the target supports measurement (and result interpretation) during the circuit execution. function entryPointAttr std::string entryPointAttr() const Attribute which indicate that a function is the entry point. function disableReferenceCounting bool disableReferenceCounting() const function disableAliasCounting bool disableAliasCounting() const function disableStringSupport bool disableStringSupport() const function disableRecordOutputSupport bool disableRecordOutputSupport() const function optimizeResultOne bool optimizeResultOne() const function optimizeResultZero bool optimizeResultZero() const function optimizeQuantumConstants bool optimizeQuantumConstants() const function optimizeResultComparison bool optimizeResultComparison() const function removeGetZeroOrOne bool removeGetZeroOrOne() const function useStaticQubitArrayAllocation bool useStaticQubitArrayAllocation() const function useStaticQubitAllocation bool useStaticQubitAllocation() const function useStaticResultAllocation bool useStaticResultAllocation() const function defaultIntegerWidth uint32_t defaultIntegerWidth() const function createDisabled static TargetQisMappingPassConfiguration createDisabled() Creates a configuration where all functionality is disabled. function createReuseQubitsOnly static TargetQisMappingPassConfiguration createReuseQubitsOnly() Creates a configuration where only reuse qubits is enabled. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::TargetQisMappingPassConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#microsoftquantumtargetqismappingpassconfiguration","text":"Configuration class for the RuleTransformation pass. #include <Passes/TargetQisMappingPass/TargetQisMappingPassConfiguration.hpp>","title":"microsoft::quantum::TargetQisMappingPassConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#public-types","text":"Name using DeferredValue::DeferredValuePtr DeferredValuePtr","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#public-functions","text":"Name void setup ( ConfigurationManager & config) Setup function that attached the configuration to the ConfigurationManager . bool isDisabled () const Tests whether all functionality is disabled for this component. bool isDefault () const Tests whether this is an instance of default configuration. bool operator== ( TargetQisMappingPassConfiguration const & ref) const Testing equality of two configurations. bool shouldDeleteDeadCode () const Whether or not the component should delete dead code. bool shouldCloneFunctions () const bool assumeNoExceptions () const Whether or not we assume that the code does not throw at runtime. bool shouldTransformExecutionPathOnly () const uint64_t maxRecursion () const The maximum recursion acceptable when unrolling the execution path. bool shouldReuseQubits () const Whether or not to reuse qubits. bool shouldAnnotateQubitUse () const Whether or not to annotate entry point with the number of qubits they use. bool shouldReuseResults () const Whether or not to reuse result registers. bool shouldAnnotateResultUse () const Whether or not to annotate entry point with the number of results they use. bool shouldGroupMeasurements () const Whether or not the component should attempt to group measurements. bool oneShotMeasurement () const std::string entryPointAttr () const Attribute which indicate that a function is the entry point. bool disableReferenceCounting () const bool disableAliasCounting () const bool disableStringSupport () const bool disableRecordOutputSupport () const bool optimizeResultOne () const bool optimizeResultZero () const bool optimizeQuantumConstants () const bool optimizeResultComparison () const bool removeGetZeroOrOne () const bool useStaticQubitArrayAllocation () const bool useStaticQubitAllocation () const bool useStaticResultAllocation () const uint32_t defaultIntegerWidth () const TargetQisMappingPassConfiguration createDisabled () Creates a configuration where all functionality is disabled. TargetQisMappingPassConfiguration createReuseQubitsOnly () Creates a configuration where only reuse qubits is enabled.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#using-deferredvalueptr","text":"using microsoft::quantum::TargetQisMappingPassConfiguration::DeferredValuePtr = DeferredValue::DeferredValuePtr;","title":"using DeferredValuePtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-setup","text":"void setup( ConfigurationManager & config ) Setup function that attached the configuration to the ConfigurationManager .","title":"function setup"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-isdisabled","text":"bool isDisabled() const Tests whether all functionality is disabled for this component.","title":"function isDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-isdefault","text":"bool isDefault() const Tests whether this is an instance of default configuration.","title":"function isDefault"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-operator","text":"bool operator==( TargetQisMappingPassConfiguration const & ref ) const Testing equality of two configurations.","title":"function operator=="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-shoulddeletedeadcode","text":"bool shouldDeleteDeadCode() const Whether or not the component should delete dead code.","title":"function shouldDeleteDeadCode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-shouldclonefunctions","text":"bool shouldCloneFunctions() const Whether or not the component should clone functions. This is relevant in relation to qubit allocation if execution paths are expanded.","title":"function shouldCloneFunctions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-assumenoexceptions","text":"bool assumeNoExceptions() const Whether or not we assume that the code does not throw at runtime.","title":"function assumeNoExceptions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-shouldtransformexecutionpathonly","text":"bool shouldTransformExecutionPathOnly() const Whether or not the component should follow the execution path only or it should be applied to all parts of the code. For statically allocated qubits one generally wants to follow the execution path whereas it makes more sense to apply to all parts of the code for dynamic qubit allocation.","title":"function shouldTransformExecutionPathOnly"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-maxrecursion","text":"uint64_t maxRecursion() const The maximum recursion acceptable when unrolling the execution path.","title":"function maxRecursion"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-shouldreusequbits","text":"bool shouldReuseQubits() const Whether or not to reuse qubits.","title":"function shouldReuseQubits"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-shouldannotatequbituse","text":"bool shouldAnnotateQubitUse() const Whether or not to annotate entry point with the number of qubits they use.","title":"function shouldAnnotateQubitUse"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-shouldreuseresults","text":"bool shouldReuseResults() const Whether or not to reuse result registers.","title":"function shouldReuseResults"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-shouldannotateresultuse","text":"bool shouldAnnotateResultUse() const Whether or not to annotate entry point with the number of results they use.","title":"function shouldAnnotateResultUse"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-shouldgroupmeasurements","text":"bool shouldGroupMeasurements() const Whether or not the component should attempt to group measurements.","title":"function shouldGroupMeasurements"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-oneshotmeasurement","text":"bool oneShotMeasurement() const Whether or not the target supports measurement (and result interpretation) during the circuit execution.","title":"function oneShotMeasurement"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-entrypointattr","text":"std::string entryPointAttr() const Attribute which indicate that a function is the entry point.","title":"function entryPointAttr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-disablereferencecounting","text":"bool disableReferenceCounting() const","title":"function disableReferenceCounting"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-disablealiascounting","text":"bool disableAliasCounting() const","title":"function disableAliasCounting"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-disablestringsupport","text":"bool disableStringSupport() const","title":"function disableStringSupport"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-disablerecordoutputsupport","text":"bool disableRecordOutputSupport() const","title":"function disableRecordOutputSupport"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-optimizeresultone","text":"bool optimizeResultOne() const","title":"function optimizeResultOne"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-optimizeresultzero","text":"bool optimizeResultZero() const","title":"function optimizeResultZero"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-optimizequantumconstants","text":"bool optimizeQuantumConstants() const","title":"function optimizeQuantumConstants"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-optimizeresultcomparison","text":"bool optimizeResultComparison() const","title":"function optimizeResultComparison"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-removegetzeroorone","text":"bool removeGetZeroOrOne() const","title":"function removeGetZeroOrOne"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-usestaticqubitarrayallocation","text":"bool useStaticQubitArrayAllocation() const","title":"function useStaticQubitArrayAllocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-usestaticqubitallocation","text":"bool useStaticQubitAllocation() const","title":"function useStaticQubitAllocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-usestaticresultallocation","text":"bool useStaticResultAllocation() const","title":"function useStaticResultAllocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-defaultintegerwidth","text":"uint32_t defaultIntegerWidth() const","title":"function defaultIntegerWidth"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-createdisabled","text":"static TargetQisMappingPassConfiguration createDisabled() Creates a configuration where all functionality is disabled.","title":"function createDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_target_qis_mapping_pass_configuration/#function-createreusequbitsonly","text":"static TargetQisMappingPassConfiguration createReuseQubitsOnly() Creates a configuration where only reuse qubits is enabled. Updated on 28 October 2022 at 19:30:15 UTC","title":"function createReuseQubitsOnly"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_program/","text":"microsoft::quantum::TestProgram Public Functions Name TestProgram () =default TestProgram (std::unique_ptr< llvm::Module > && module, std::unique_ptr< llvm::LLVMContext > && context) TestProgram ( TestProgram && ) =default TestProgram ( TestProgram const & ) ~TestProgram () =default void parseFromScript (String const & name, String const & script) llvm::Module & module () Friends Name class TestVM Public Functions Documentation function TestProgram TestProgram() =default function TestProgram inline TestProgram( std::unique_ptr< llvm::Module > && module, std::unique_ptr< llvm::LLVMContext > && context ) function TestProgram TestProgram( TestProgram && ) =default function TestProgram TestProgram( TestProgram const & ) function ~TestProgram ~TestProgram() =default function parseFromScript inline void parseFromScript( String const & name, String const & script ) function module inline llvm::Module & module() Friends friend TestVM friend class TestVM; Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::TestProgram"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_program/#microsoftquantumtestprogram","text":"","title":"microsoft::quantum::TestProgram"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_program/#public-functions","text":"Name TestProgram () =default TestProgram (std::unique_ptr< llvm::Module > && module, std::unique_ptr< llvm::LLVMContext > && context) TestProgram ( TestProgram && ) =default TestProgram ( TestProgram const & ) ~TestProgram () =default void parseFromScript (String const & name, String const & script) llvm::Module & module ()","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_program/#friends","text":"Name class TestVM","title":"Friends"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_program/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_program/#function-testprogram","text":"TestProgram() =default","title":"function TestProgram"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_program/#function-testprogram_1","text":"inline TestProgram( std::unique_ptr< llvm::Module > && module, std::unique_ptr< llvm::LLVMContext > && context )","title":"function TestProgram"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_program/#function-testprogram_2","text":"TestProgram( TestProgram && ) =default","title":"function TestProgram"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_program/#function-testprogram_3","text":"TestProgram( TestProgram const & )","title":"function TestProgram"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_program/#function-testprogram_4","text":"~TestProgram() =default","title":"function ~TestProgram"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_program/#function-parsefromscript","text":"inline void parseFromScript( String const & name, String const & script )","title":"function parseFromScript"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_program/#function-module","text":"inline llvm::Module & module()","title":"function module"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_program/#friends_1","text":"","title":"Friends"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_program/#friend-testvm","text":"friend class TestVM; Updated on 28 October 2022 at 19:30:15 UTC","title":"friend TestVM"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_v_m/","text":"microsoft::quantum::TestVM Public Functions Name TestVM ( TestProgram & program) template <typename T > void attachGlobalExternalVariable (String const & name, T * pointer) template <typename R ,typename X > void attachRuntimeFunction (String const & name, R(*)(X) pointer) template <typename R ,typename... Args> void attachRuntimeFunction (String const & name, R(*)(Args...) pointer) template <typename R > void attachRuntimeFunction (String const & name, R(*)() pointer) template <typename R ,typename... Args> R run (String const & name, Args &&... args) template <typename R > R run (String const & name) Public Functions Documentation function TestVM inline explicit TestVM( TestProgram & program ) function attachGlobalExternalVariable template <typename T > void attachGlobalExternalVariable( String const & name, T * pointer ) function attachRuntimeFunction template <typename R , typename X > void attachRuntimeFunction( String const & name, R(*)(X) pointer ) function attachRuntimeFunction template <typename R , typename... Args> void attachRuntimeFunction( String const & name, R(*)(Args...) pointer ) function attachRuntimeFunction template <typename R > void attachRuntimeFunction( String const & name, R(*)() pointer ) function run template <typename R , typename... Args> R run( String const & name, Args &&... args ) function run template <typename R > R run( String const & name ) Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::TestVM"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_v_m/#microsoftquantumtestvm","text":"","title":"microsoft::quantum::TestVM"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_v_m/#public-functions","text":"Name TestVM ( TestProgram & program) template <typename T > void attachGlobalExternalVariable (String const & name, T * pointer) template <typename R ,typename X > void attachRuntimeFunction (String const & name, R(*)(X) pointer) template <typename R ,typename... Args> void attachRuntimeFunction (String const & name, R(*)(Args...) pointer) template <typename R > void attachRuntimeFunction (String const & name, R(*)() pointer) template <typename R ,typename... Args> R run (String const & name, Args &&... args) template <typename R > R run (String const & name)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_v_m/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_v_m/#function-testvm","text":"inline explicit TestVM( TestProgram & program )","title":"function TestVM"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_v_m/#function-attachglobalexternalvariable","text":"template <typename T > void attachGlobalExternalVariable( String const & name, T * pointer )","title":"function attachGlobalExternalVariable"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_v_m/#function-attachruntimefunction","text":"template <typename R , typename X > void attachRuntimeFunction( String const & name, R(*)(X) pointer )","title":"function attachRuntimeFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_v_m/#function-attachruntimefunction_1","text":"template <typename R , typename... Args> void attachRuntimeFunction( String const & name, R(*)(Args...) pointer )","title":"function attachRuntimeFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_v_m/#function-attachruntimefunction_2","text":"template <typename R > void attachRuntimeFunction( String const & name, R(*)() pointer )","title":"function attachRuntimeFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_v_m/#function-run","text":"template <typename R , typename... Args> R run( String const & name, Args &&... args )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_test_v_m/#function-run_1","text":"template <typename R > R run( String const & name ) Updated on 28 October 2022 at 19:30:15 UTC","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/","text":"microsoft::quantum::UnnamedInvokePattern Inherits from microsoft::quantum::IOperandPrototype Public Types Name using std::string String Public Functions Name UnnamedInvokePattern () =default UnnamedInvokePattern ( UnnamedInvokePattern const & other) Copy construction prohibited. UnnamedInvokePattern ( UnnamedInvokePattern && other) =default Move construction allowed. ~UnnamedInvokePattern () override Destructor implementation. virtual bool match (Value * instr, Captures & captures) const override Matches the callee by name. virtual Child copy () const override Creates a copy of itself. Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Types Documentation using String using microsoft::quantum::UnnamedInvokePattern::String = std::string; Public Functions Documentation function UnnamedInvokePattern UnnamedInvokePattern() =default function UnnamedInvokePattern UnnamedInvokePattern( UnnamedInvokePattern const & other ) Copy construction prohibited. function UnnamedInvokePattern UnnamedInvokePattern( UnnamedInvokePattern && other ) =default Move construction allowed. function ~UnnamedInvokePattern ~UnnamedInvokePattern() override Destructor implementation. function match virtual bool match( Value * instr, Captures & captures ) const override Matches the callee by name. Reimplements : microsoft::quantum::IOperandPrototype::match function copy virtual Child copy() const override Creates a copy of itself. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::UnnamedInvokePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#microsoftquantumunnamedinvokepattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::UnnamedInvokePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#public-types","text":"Name using std::string String","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#public-functions","text":"Name UnnamedInvokePattern () =default UnnamedInvokePattern ( UnnamedInvokePattern const & other) Copy construction prohibited. UnnamedInvokePattern ( UnnamedInvokePattern && other) =default Move construction allowed. ~UnnamedInvokePattern () override Destructor implementation. virtual bool match (Value * instr, Captures & captures) const override Matches the callee by name. virtual Child copy () const override Creates a copy of itself.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#using-string","text":"using microsoft::quantum::UnnamedInvokePattern::String = std::string;","title":"using String"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#function-unnamedinvokepattern","text":"UnnamedInvokePattern() =default","title":"function UnnamedInvokePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#function-unnamedinvokepattern_1","text":"UnnamedInvokePattern( UnnamedInvokePattern const & other ) Copy construction prohibited.","title":"function UnnamedInvokePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#function-unnamedinvokepattern_2","text":"UnnamedInvokePattern( UnnamedInvokePattern && other ) =default Move construction allowed.","title":"function UnnamedInvokePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#function-unnamedinvokepattern_3","text":"~UnnamedInvokePattern() override Destructor implementation.","title":"function ~UnnamedInvokePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#function-match","text":"virtual bool match( Value * instr, Captures & captures ) const override Matches the callee by name. Reimplements : microsoft::quantum::IOperandPrototype::match","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#function-copy","text":"virtual Child copy() const override Creates a copy of itself. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 28 October 2022 at 19:30:15 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/","text":"microsoft::quantum::ValidationPass Inherits from llvm::PassInfoMixin< ValidationPass > Public Types Name using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using ILogger::Location Location using llvm::StringRef StringRef Public Functions Name ValidationPass ( TargetProfileConfiguration const & profile, TargetQisConfiguration const & qis, ILoggerPtr const & logger =nullptr) ValidationPass ( ValidationPass const & ) Copy construction is banned. ValidationPass ( ValidationPass && ) =default We allow move semantics. ~ValidationPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool isRequired () Whether or not this pass is required to run. Public Types Documentation using Instruction using microsoft::quantum::ValidationPass::Instruction = llvm::Instruction; using Value using microsoft::quantum::ValidationPass::Value = llvm::Value; using ILoggerPtr using microsoft::quantum::ValidationPass::ILoggerPtr = ILogger::ILoggerPtr; using Location using microsoft::quantum::ValidationPass::Location = ILogger::Location; using StringRef using microsoft::quantum::ValidationPass::StringRef = llvm::StringRef; Public Functions Documentation function ValidationPass explicit ValidationPass( TargetProfileConfiguration const & profile, TargetQisConfiguration const & qis, ILoggerPtr const & logger =nullptr ) function ValidationPass ValidationPass( ValidationPass const & ) Copy construction is banned. function ValidationPass ValidationPass( ValidationPass && ) =default We allow move semantics. function ~ValidationPass ~ValidationPass() =default Default destruction. function run llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function isRequired static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::ValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#microsoftquantumvalidationpass","text":"Inherits from llvm::PassInfoMixin< ValidationPass >","title":"microsoft::quantum::ValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#public-types","text":"Name using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using ILogger::Location Location using llvm::StringRef StringRef","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#public-functions","text":"Name ValidationPass ( TargetProfileConfiguration const & profile, TargetQisConfiguration const & qis, ILoggerPtr const & logger =nullptr) ValidationPass ( ValidationPass const & ) Copy construction is banned. ValidationPass ( ValidationPass && ) =default We allow move semantics. ~ValidationPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#using-instruction","text":"using microsoft::quantum::ValidationPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#using-value","text":"using microsoft::quantum::ValidationPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#using-iloggerptr","text":"using microsoft::quantum::ValidationPass::ILoggerPtr = ILogger::ILoggerPtr;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#using-location","text":"using microsoft::quantum::ValidationPass::Location = ILogger::Location;","title":"using Location"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#using-stringref","text":"using microsoft::quantum::ValidationPass::StringRef = llvm::StringRef;","title":"using StringRef"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#function-validationpass","text":"explicit ValidationPass( TargetProfileConfiguration const & profile, TargetQisConfiguration const & qis, ILoggerPtr const & logger =nullptr )","title":"function ValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#function-validationpass_1","text":"ValidationPass( ValidationPass const & ) Copy construction is banned.","title":"function ValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#function-validationpass_2","text":"ValidationPass( ValidationPass && ) =default We allow move semantics.","title":"function ValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#function-validationpass_3","text":"~ValidationPass() =default Default destruction.","title":"function ~ValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#function-run","text":"llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/","text":"microsoft::quantum::Validator More... #include <Validator/Validator.hpp> Public Types Name using std::unique_ptr< Validator > ValidatorPtr using ILogger::ILoggerPtr ILoggerPtr Protected Types Name using std::unique_ptr< llvm::PassBuilder > PassBuilderPtr Public Functions Name Validator ( TargetProfileConfiguration const & profile, TargetQisConfiguration const & qis, ILoggerPtr const & logger, bool debug, llvm::TargetMachine * target_machine =nullptr) Validator () Validator ( Validator const & ) Validator ( Validator && ) Validator & operator= ( Validator const & ) Validator & operator= ( Validator && ) ~Validator () =default bool validate (llvm::Module & module) ILoggerPtr logger () const Returns the logger. This value may be null if no logger was set. Protected Functions Name llvm::PassBuilder & passBuilder () Returns a reference to the pass builder. llvm::LoopAnalysisManager & loopAnalysisManager () Returns a reference to the loop analysis manager. llvm::FunctionAnalysisManager & functionAnalysisManager () Returns a reference to the function analysis manager. llvm::CGSCCAnalysisManager & gsccAnalysisManager () Returns a reference to the GSCC analysis manager. llvm::ModuleAnalysisManager & moduleAnalysisManager () Returns a reference to the module analysis manager. Detailed Description class microsoft::quantum::Validator; Validator class that defines a set of rules which constitutes the adaptor definition. Each of the rules can be used to transform a generic QIR and/or validate that the QIR is compliant with said rule. Public Types Documentation using ValidatorPtr using microsoft::quantum::Validator::ValidatorPtr = std::unique_ptr<Validator>; using ILoggerPtr using microsoft::quantum::Validator::ILoggerPtr = ILogger::ILoggerPtr; Protected Types Documentation using PassBuilderPtr using microsoft::quantum::Validator::PassBuilderPtr = std::unique_ptr<llvm::PassBuilder>; Public Functions Documentation function Validator explicit Validator( TargetProfileConfiguration const & profile, TargetQisConfiguration const & qis, ILoggerPtr const & logger, bool debug, llvm::TargetMachine * target_machine =nullptr ) function Validator Validator() function Validator Validator( Validator const & ) function Validator Validator( Validator && ) function operator= Validator & operator=( Validator const & ) function operator= Validator & operator=( Validator && ) function ~Validator ~Validator() =default function validate bool validate( llvm::Module & module ) Validates that a module complies with the specified QIR adaptor. Returns true if the module is valid and false otherwise. function logger ILoggerPtr logger() const Returns the logger. This value may be null if no logger was set. Protected Functions Documentation function passBuilder llvm::PassBuilder & passBuilder() Returns a reference to the pass builder. function loopAnalysisManager llvm::LoopAnalysisManager & loopAnalysisManager() Returns a reference to the loop analysis manager. function functionAnalysisManager llvm::FunctionAnalysisManager & functionAnalysisManager() Returns a reference to the function analysis manager. function gsccAnalysisManager llvm::CGSCCAnalysisManager & gsccAnalysisManager() Returns a reference to the GSCC analysis manager. function moduleAnalysisManager llvm::ModuleAnalysisManager & moduleAnalysisManager() Returns a reference to the module analysis manager. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::Validator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#microsoftquantumvalidator","text":"More... #include <Validator/Validator.hpp>","title":"microsoft::quantum::Validator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#public-types","text":"Name using std::unique_ptr< Validator > ValidatorPtr using ILogger::ILoggerPtr ILoggerPtr","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#protected-types","text":"Name using std::unique_ptr< llvm::PassBuilder > PassBuilderPtr","title":"Protected Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#public-functions","text":"Name Validator ( TargetProfileConfiguration const & profile, TargetQisConfiguration const & qis, ILoggerPtr const & logger, bool debug, llvm::TargetMachine * target_machine =nullptr) Validator () Validator ( Validator const & ) Validator ( Validator && ) Validator & operator= ( Validator const & ) Validator & operator= ( Validator && ) ~Validator () =default bool validate (llvm::Module & module) ILoggerPtr logger () const Returns the logger. This value may be null if no logger was set.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#protected-functions","text":"Name llvm::PassBuilder & passBuilder () Returns a reference to the pass builder. llvm::LoopAnalysisManager & loopAnalysisManager () Returns a reference to the loop analysis manager. llvm::FunctionAnalysisManager & functionAnalysisManager () Returns a reference to the function analysis manager. llvm::CGSCCAnalysisManager & gsccAnalysisManager () Returns a reference to the GSCC analysis manager. llvm::ModuleAnalysisManager & moduleAnalysisManager () Returns a reference to the module analysis manager.","title":"Protected Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#detailed-description","text":"class microsoft::quantum::Validator; Validator class that defines a set of rules which constitutes the adaptor definition. Each of the rules can be used to transform a generic QIR and/or validate that the QIR is compliant with said rule.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#using-validatorptr","text":"using microsoft::quantum::Validator::ValidatorPtr = std::unique_ptr<Validator>;","title":"using ValidatorPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#using-iloggerptr","text":"using microsoft::quantum::Validator::ILoggerPtr = ILogger::ILoggerPtr;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#protected-types-documentation","text":"","title":"Protected Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#using-passbuilderptr","text":"using microsoft::quantum::Validator::PassBuilderPtr = std::unique_ptr<llvm::PassBuilder>;","title":"using PassBuilderPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-validator","text":"explicit Validator( TargetProfileConfiguration const & profile, TargetQisConfiguration const & qis, ILoggerPtr const & logger, bool debug, llvm::TargetMachine * target_machine =nullptr )","title":"function Validator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-validator_1","text":"Validator()","title":"function Validator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-validator_2","text":"Validator( Validator const & )","title":"function Validator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-validator_3","text":"Validator( Validator && )","title":"function Validator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-operator","text":"Validator & operator=( Validator const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-operator_1","text":"Validator & operator=( Validator && )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-validator_4","text":"~Validator() =default","title":"function ~Validator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-validate","text":"bool validate( llvm::Module & module ) Validates that a module complies with the specified QIR adaptor. Returns true if the module is valid and false otherwise.","title":"function validate"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-logger","text":"ILoggerPtr logger() const Returns the logger. This value may be null if no logger was set.","title":"function logger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-passbuilder","text":"llvm::PassBuilder & passBuilder() Returns a reference to the pass builder.","title":"function passBuilder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-loopanalysismanager","text":"llvm::LoopAnalysisManager & loopAnalysisManager() Returns a reference to the loop analysis manager.","title":"function loopAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-functionanalysismanager","text":"llvm::FunctionAnalysisManager & functionAnalysisManager() Returns a reference to the function analysis manager.","title":"function functionAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-gsccanalysismanager","text":"llvm::CGSCCAnalysisManager & gsccAnalysisManager() Returns a reference to the GSCC analysis manager.","title":"function gsccAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-moduleanalysismanager","text":"llvm::ModuleAnalysisManager & moduleAnalysisManager() Returns a reference to the module analysis manager. Updated on 28 October 2022 at 19:30:15 UTC","title":"function moduleAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_pattern/","text":"microsoft::quantum::ZExtPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::ZExtPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_pattern/#microsoftquantumzextpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::ZExtPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 28 October 2022 at 19:30:15 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_transform_pass/","text":"microsoft::quantum::ZExtTransformPass Inherits from llvm::PassInfoMixin< ZExtTransformPass > Public Types Name using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using ILogger::Location Location using llvm::StringRef StringRef Public Functions Name ZExtTransformPass () =default ZExtTransformPass ( ZExtTransformPass const & ) Copy construction is banned. ZExtTransformPass ( ZExtTransformPass && ) =default We allow move semantics. ~ZExtTransformPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Function & function, llvm::FunctionAnalysisManager & fam) bool isRequired () Whether or not this pass is required to run. Public Types Documentation using Instruction using microsoft::quantum::ZExtTransformPass::Instruction = llvm::Instruction; using Value using microsoft::quantum::ZExtTransformPass::Value = llvm::Value; using ILoggerPtr using microsoft::quantum::ZExtTransformPass::ILoggerPtr = ILogger::ILoggerPtr; using Location using microsoft::quantum::ZExtTransformPass::Location = ILogger::Location; using StringRef using microsoft::quantum::ZExtTransformPass::StringRef = llvm::StringRef; Public Functions Documentation function ZExtTransformPass ZExtTransformPass() =default function ZExtTransformPass ZExtTransformPass( ZExtTransformPass const & ) Copy construction is banned. function ZExtTransformPass ZExtTransformPass( ZExtTransformPass && ) =default We allow move semantics. function ~ZExtTransformPass ~ZExtTransformPass() =default Default destruction. function run llvm::PreservedAnalyses run( llvm::Function & function, llvm::FunctionAnalysisManager & fam ) function isRequired static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::ZExtTransformPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_transform_pass/#microsoftquantumzexttransformpass","text":"Inherits from llvm::PassInfoMixin< ZExtTransformPass >","title":"microsoft::quantum::ZExtTransformPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_transform_pass/#public-types","text":"Name using llvm::Instruction Instruction using llvm::Value Value using ILogger::ILoggerPtr ILoggerPtr using ILogger::Location Location using llvm::StringRef StringRef","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_transform_pass/#public-functions","text":"Name ZExtTransformPass () =default ZExtTransformPass ( ZExtTransformPass const & ) Copy construction is banned. ZExtTransformPass ( ZExtTransformPass && ) =default We allow move semantics. ~ZExtTransformPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Function & function, llvm::FunctionAnalysisManager & fam) bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_transform_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_transform_pass/#using-instruction","text":"using microsoft::quantum::ZExtTransformPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_transform_pass/#using-value","text":"using microsoft::quantum::ZExtTransformPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_transform_pass/#using-iloggerptr","text":"using microsoft::quantum::ZExtTransformPass::ILoggerPtr = ILogger::ILoggerPtr;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_transform_pass/#using-location","text":"using microsoft::quantum::ZExtTransformPass::Location = ILogger::Location;","title":"using Location"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_transform_pass/#using-stringref","text":"using microsoft::quantum::ZExtTransformPass::StringRef = llvm::StringRef;","title":"using StringRef"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_transform_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_transform_pass/#function-zexttransformpass","text":"ZExtTransformPass() =default","title":"function ZExtTransformPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_transform_pass/#function-zexttransformpass_1","text":"ZExtTransformPass( ZExtTransformPass const & ) Copy construction is banned.","title":"function ZExtTransformPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_transform_pass/#function-zexttransformpass_2","text":"ZExtTransformPass( ZExtTransformPass && ) =default We allow move semantics.","title":"function ZExtTransformPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_transform_pass/#function-zexttransformpass_3","text":"~ZExtTransformPass() =default Default destruction.","title":"function ~ZExtTransformPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_transform_pass/#function-run","text":"llvm::PreservedAnalyses run( llvm::Function & function, llvm::FunctionAnalysisManager & fam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_z_ext_transform_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run. Updated on 28 October 2022 at 19:30:15 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture/","text":"microsoft::quantum::notation::Capture More... #include <Rules/Notation/Notation.hpp> Public Functions Name Capture (std::string const & name) Explicit creation using string name constructor. IOperandPrototypePtr operator= (IOperandPrototypePtr const & other) Detailed Description class microsoft::quantum::notation::Capture; Helper class to enable literals for IR patterns. The main purpose of this class is to enable notation that allows one write \"name\"_cap = operandGenerator() where the operand generator is a function which creates a IOperandPrototypePtr. This notation means that whenever a operand is matched, the matched value is stored under \"name\". Public Functions Documentation function Capture explicit Capture( std::string const & name ) Explicit creation using string name constructor. function operator= IOperandPrototypePtr operator=( IOperandPrototypePtr const & other ) Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::notation::Capture"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture/#microsoftquantumnotationcapture","text":"More... #include <Rules/Notation/Notation.hpp>","title":"microsoft::quantum::notation::Capture"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture/#public-functions","text":"Name Capture (std::string const & name) Explicit creation using string name constructor. IOperandPrototypePtr operator= (IOperandPrototypePtr const & other)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture/#detailed-description","text":"class microsoft::quantum::notation::Capture; Helper class to enable literals for IR patterns. The main purpose of this class is to enable notation that allows one write \"name\"_cap = operandGenerator() where the operand generator is a function which creates a IOperandPrototypePtr. This notation means that whenever a operand is matched, the matched value is stored under \"name\".","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture/#function-capture","text":"explicit Capture( std::string const & name ) Explicit creation using string name constructor.","title":"function Capture"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture/#function-operator","text":"IOperandPrototypePtr operator=( IOperandPrototypePtr const & other ) Updated on 28 October 2022 at 19:30:15 UTC","title":"function operator="},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis/","text":"microsoft::quantum::AllocationAnalysis Public Classes Name struct ResourceAccessLocation Public Types Name enum ResourceType { NotResource, QubitResource, ResultResource} using std::unordered_map< llvm::Value *, ResourceAccessLocation > ResourceValueToId using std::vector< ResourceAccessLocation > ResourceAccessList Public Attributes Name uint64_t largest_qubit_index uint64_t largest_result_index uint64_t usage_qubit_counts uint64_t usage_result_counts ResourceValueToId access_map ResourceAccessList resource_access Public Types Documentation enum ResourceType Enumerator Value Description NotResource QubitResource ResultResource using ResourceValueToId using microsoft::quantum::AllocationAnalysis::ResourceValueToId = std::unordered_map<llvm::Value*, ResourceAccessLocation>; using ResourceAccessList using microsoft::quantum::AllocationAnalysis::ResourceAccessList = std::vector<ResourceAccessLocation>; Public Attributes Documentation variable largest_qubit_index uint64_t largest_qubit_index {0}; variable largest_result_index uint64_t largest_result_index {0}; variable usage_qubit_counts uint64_t usage_qubit_counts {0}; variable usage_result_counts uint64_t usage_result_counts {0}; variable access_map ResourceValueToId access_map {}; variable resource_access ResourceAccessList resource_access {}; Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::AllocationAnalysis"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis/#microsoftquantumallocationanalysis","text":"","title":"microsoft::quantum::AllocationAnalysis"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis/#public-classes","text":"Name struct ResourceAccessLocation","title":"Public Classes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis/#public-types","text":"Name enum ResourceType { NotResource, QubitResource, ResultResource} using std::unordered_map< llvm::Value *, ResourceAccessLocation > ResourceValueToId using std::vector< ResourceAccessLocation > ResourceAccessList","title":"Public Types"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis/#public-attributes","text":"Name uint64_t largest_qubit_index uint64_t largest_result_index uint64_t usage_qubit_counts uint64_t usage_result_counts ResourceValueToId access_map ResourceAccessList resource_access","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis/#enum-resourcetype","text":"Enumerator Value Description NotResource QubitResource ResultResource","title":"enum ResourceType"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis/#using-resourcevaluetoid","text":"using microsoft::quantum::AllocationAnalysis::ResourceValueToId = std::unordered_map<llvm::Value*, ResourceAccessLocation>;","title":"using ResourceValueToId"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis/#using-resourceaccesslist","text":"using microsoft::quantum::AllocationAnalysis::ResourceAccessList = std::vector<ResourceAccessLocation>;","title":"using ResourceAccessList"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis/#variable-largest_qubit_index","text":"uint64_t largest_qubit_index {0};","title":"variable largest_qubit_index"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis/#variable-largest_result_index","text":"uint64_t largest_result_index {0};","title":"variable largest_result_index"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis/#variable-usage_qubit_counts","text":"uint64_t usage_qubit_counts {0};","title":"variable usage_qubit_counts"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis/#variable-usage_result_counts","text":"uint64_t usage_result_counts {0};","title":"variable usage_result_counts"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis/#variable-access_map","text":"ResourceValueToId access_map {};","title":"variable access_map"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis/#variable-resource_access","text":"ResourceAccessList resource_access {}; Updated on 28 October 2022 at 19:30:15 UTC","title":"variable resource_access"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis_1_1_resource_access_location/","text":"microsoft::quantum::AllocationAnalysis::ResourceAccessLocation Public Attributes Name llvm::Value * operand ResourceType type uint64_t index llvm::Instruction * used_by uint64_t operand_id Public Attributes Documentation variable operand llvm::Value * operand {nullptr}; variable type ResourceType type {ResourceType::NotResource}; variable index uint64_t index {static_cast<uint64_t>(-1)}; variable used_by llvm::Instruction * used_by {nullptr}; variable operand_id uint64_t operand_id {0}; Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::AllocationAnalysis::ResourceAccessLocation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis_1_1_resource_access_location/#microsoftquantumallocationanalysisresourceaccesslocation","text":"","title":"microsoft::quantum::AllocationAnalysis::ResourceAccessLocation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis_1_1_resource_access_location/#public-attributes","text":"Name llvm::Value * operand ResourceType type uint64_t index llvm::Instruction * used_by uint64_t operand_id","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis_1_1_resource_access_location/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis_1_1_resource_access_location/#variable-operand","text":"llvm::Value * operand {nullptr};","title":"variable operand"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis_1_1_resource_access_location/#variable-type","text":"ResourceType type {ResourceType::NotResource};","title":"variable type"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis_1_1_resource_access_location/#variable-index","text":"uint64_t index {static_cast<uint64_t>(-1)};","title":"variable index"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis_1_1_resource_access_location/#variable-used_by","text":"llvm::Instruction * used_by {nullptr};","title":"variable used_by"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_allocation_analysis_1_1_resource_access_location/#variable-operand_id","text":"uint64_t operand_id {0}; Updated on 28 October 2022 at 19:30:15 UTC","title":"variable operand_id"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/","text":"microsoft::quantum::BasicAllocationManager::AllocatedMemoryBlock More... #include <AllocationManager/AllocationManager.hpp> Public Attributes Name String name Name of the segment, if any given. Index count Number of elements contained within memory address segment. Address start Start address of memory address segment. Address end End address (not included in memory address segment) Detailed Description struct microsoft::quantum::BasicAllocationManager::AllocatedMemoryBlock; Defines a named register/memory address segment with start position, end position and count. We think of the address space as a continuous sequence of spaces that can store values and we refer to a bounded continuous sequence memory addresses as a segment (or memory address segment): start end \u2502 \u2502 \u25bc \u25bc \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u250c \u2500 \u2500 \u252c \u2500 \u2500 \u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u253c \u2500 \u2500 \u252c \u2500 \u2500 \u2510 0 1 \u2502 2 \u2502 3 \u2502... \u2502 N+1 \u2502 N+2 N+3 \u2514 \u2500 \u2500 \u2534 \u2500 \u2500 \u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2534 \u2500 \u2500 \u2534 \u2500 \u2500 \u2518 Address \u2502 space \u2502 Memory address segment of N elements \u2502 \u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 Public Attributes Documentation variable name String name {\"\"}; Name of the segment, if any given. variable count Index count {0}; Number of elements contained within memory address segment. variable start Address start {0}; Start address of memory address segment. variable end Address end {0}; End address (not included in memory address segment) Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::BasicAllocationManager::AllocatedMemoryBlock"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#microsoftquantumbasicallocationmanagerallocatedmemoryblock","text":"More... #include <AllocationManager/AllocationManager.hpp>","title":"microsoft::quantum::BasicAllocationManager::AllocatedMemoryBlock"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#public-attributes","text":"Name String name Name of the segment, if any given. Index count Number of elements contained within memory address segment. Address start Start address of memory address segment. Address end End address (not included in memory address segment)","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#detailed-description","text":"struct microsoft::quantum::BasicAllocationManager::AllocatedMemoryBlock; Defines a named register/memory address segment with start position, end position and count. We think of the address space as a continuous sequence of spaces that can store values and we refer to a bounded continuous sequence memory addresses as a segment (or memory address segment): start end \u2502 \u2502 \u25bc \u25bc \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u250c \u2500 \u2500 \u252c \u2500 \u2500 \u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u253c \u2500 \u2500 \u252c \u2500 \u2500 \u2510 0 1 \u2502 2 \u2502 3 \u2502... \u2502 N+1 \u2502 N+2 N+3 \u2514 \u2500 \u2500 \u2534 \u2500 \u2500 \u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2534 \u2500 \u2500 \u2534 \u2500 \u2500 \u2518 Address \u2502 space \u2502 Memory address segment of N elements \u2502 \u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500","title":"Detailed Description"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#variable-name","text":"String name {\"\"}; Name of the segment, if any given.","title":"variable name"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#variable-count","text":"Index count {0}; Number of elements contained within memory address segment.","title":"variable count"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#variable-start","text":"Address start {0}; Start address of memory address segment.","title":"variable start"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#variable-end","text":"Address end {0}; End address (not included in memory address segment) Updated on 28 October 2022 at 19:30:15 UTC","title":"variable end"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/","text":"microsoft::quantum::ConfigurationManager::Section More... #include <Commandline/ConfigurationManager.hpp> Public Attributes Name TypeId type Type of the configuration. String name Name of the section. String description Description of the section. bool can_disable Whether or not this section can be disabled. bool enabled_by_default Whether or not this section is enabled by default. VoidPtr configuration Configuration class instance. ConfigList settings List of parameter bindings. BoolPtr active Whether or not this component is active;. String id Id referring to this component. Detailed Description struct microsoft::quantum::ConfigurationManager::Section; Section defines a section in the configuration. It holds the type of the configuration class, the name of the section a description, the instance of the configuration class itself and list of parameter bindings. Public Attributes Documentation variable type TypeId type {[TypeId](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-typeid)(typeid(std::nullptr_t))}; Type of the configuration. variable name String name {}; Name of the section. variable description String description {}; Description of the section. variable can_disable bool can_disable {false}; Whether or not this section can be disabled. variable enabled_by_default bool enabled_by_default {true}; Whether or not this section is enabled by default. variable configuration VoidPtr configuration {}; Configuration class instance. variable settings ConfigList settings {}; List of parameter bindings. variable active BoolPtr active {nullptr}; Whether or not this component is active;. variable id String id {}; Id referring to this component. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::ConfigurationManager::Section"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#microsoftquantumconfigurationmanagersection","text":"More... #include <Commandline/ConfigurationManager.hpp>","title":"microsoft::quantum::ConfigurationManager::Section"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#public-attributes","text":"Name TypeId type Type of the configuration. String name Name of the section. String description Description of the section. bool can_disable Whether or not this section can be disabled. bool enabled_by_default Whether or not this section is enabled by default. VoidPtr configuration Configuration class instance. ConfigList settings List of parameter bindings. BoolPtr active Whether or not this component is active;. String id Id referring to this component.","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#detailed-description","text":"struct microsoft::quantum::ConfigurationManager::Section; Section defines a section in the configuration. It holds the type of the configuration class, the name of the section a description, the instance of the configuration class itself and list of parameter bindings.","title":"Detailed Description"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-type","text":"TypeId type {[TypeId](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-typeid)(typeid(std::nullptr_t))}; Type of the configuration.","title":"variable type"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-name","text":"String name {}; Name of the section.","title":"variable name"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-description","text":"String description {}; Description of the section.","title":"variable description"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-can_disable","text":"bool can_disable {false}; Whether or not this section can be disabled.","title":"variable can_disable"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-enabled_by_default","text":"bool enabled_by_default {true}; Whether or not this section is enabled by default.","title":"variable enabled_by_default"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-configuration","text":"VoidPtr configuration {}; Configuration class instance.","title":"variable configuration"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-settings","text":"ConfigList settings {}; List of parameter bindings.","title":"variable settings"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-active","text":"BoolPtr active {nullptr}; Whether or not this component is active;.","title":"variable active"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-id","text":"String id {}; Id referring to this component. Updated on 28 October 2022 at 19:30:15 UTC","title":"variable id"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_function_register/","text":"microsoft::quantum::FunctionRegister Public Types Name using std::unordered_map< String, llvm::Function * > FunctionMap using std::unordered_map< llvm::Function *, llvm::Function * > ReplacementMap using std::vector< llvm::CallInst * > CallList Public Attributes Name FunctionMap name_to_function_pointer ReplacementMap functions_to_replace CallList calls_to_replace Public Types Documentation using FunctionMap using microsoft::quantum::FunctionRegister::FunctionMap = std::unordered_map<String, llvm::Function*>; using ReplacementMap using microsoft::quantum::FunctionRegister::ReplacementMap = std::unordered_map<llvm::Function*, llvm::Function*>; using CallList using microsoft::quantum::FunctionRegister::CallList = std::vector<llvm::CallInst*>; Public Attributes Documentation variable name_to_function_pointer FunctionMap name_to_function_pointer {}; variable functions_to_replace ReplacementMap functions_to_replace {}; variable calls_to_replace CallList calls_to_replace {}; Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::FunctionRegister"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_function_register/#microsoftquantumfunctionregister","text":"","title":"microsoft::quantum::FunctionRegister"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_function_register/#public-types","text":"Name using std::unordered_map< String, llvm::Function * > FunctionMap using std::unordered_map< llvm::Function *, llvm::Function * > ReplacementMap using std::vector< llvm::CallInst * > CallList","title":"Public Types"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_function_register/#public-attributes","text":"Name FunctionMap name_to_function_pointer ReplacementMap functions_to_replace CallList calls_to_replace","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_function_register/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_function_register/#using-functionmap","text":"using microsoft::quantum::FunctionRegister::FunctionMap = std::unordered_map<String, llvm::Function*>;","title":"using FunctionMap"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_function_register/#using-replacementmap","text":"using microsoft::quantum::FunctionRegister::ReplacementMap = std::unordered_map<llvm::Function*, llvm::Function*>;","title":"using ReplacementMap"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_function_register/#using-calllist","text":"using microsoft::quantum::FunctionRegister::CallList = std::vector<llvm::CallInst*>;","title":"using CallList"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_function_register/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_function_register/#variable-name_to_function_pointer","text":"FunctionMap name_to_function_pointer {};","title":"variable name_to_function_pointer"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_function_register/#variable-functions_to_replace","text":"ReplacementMap functions_to_replace {};","title":"variable functions_to_replace"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_function_register/#variable-calls_to_replace","text":"CallList calls_to_replace {}; Updated on 28 October 2022 at 19:30:15 UTC","title":"variable calls_to_replace"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_group_analysis/","text":"microsoft::quantum::GroupAnalysis Public Types Name using std::vector< llvm::BasicBlock * > BlockList Public Attributes Name BlockList qc_cc_blocks BlockList qc_mc_cc_blocks Public Types Documentation using BlockList using microsoft::quantum::GroupAnalysis::BlockList = std::vector<llvm::BasicBlock*>; Public Attributes Documentation variable qc_cc_blocks BlockList qc_cc_blocks {}; variable qc_mc_cc_blocks BlockList qc_mc_cc_blocks {}; Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::GroupAnalysis"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_group_analysis/#microsoftquantumgroupanalysis","text":"","title":"microsoft::quantum::GroupAnalysis"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_group_analysis/#public-types","text":"Name using std::vector< llvm::BasicBlock * > BlockList","title":"Public Types"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_group_analysis/#public-attributes","text":"Name BlockList qc_cc_blocks BlockList qc_mc_cc_blocks","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_group_analysis/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_group_analysis/#using-blocklist","text":"using microsoft::quantum::GroupAnalysis::BlockList = std::vector<llvm::BasicBlock*>;","title":"using BlockList"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_group_analysis/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_group_analysis/#variable-qc_cc_blocks","text":"BlockList qc_cc_blocks {};","title":"variable qc_cc_blocks"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_group_analysis/#variable-qc_mc_cc_blocks","text":"BlockList qc_mc_cc_blocks {}; Updated on 28 October 2022 at 19:30:15 UTC","title":"variable qc_mc_cc_blocks"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_grouping_pass_1_1_resource_analysis/","text":"microsoft::quantum::GroupingPass::ResourceAnalysis Public Attributes Name bool is_const uint64_t id ResourceType type Public Attributes Documentation variable is_const bool is_const {false}; variable id uint64_t id {0}; variable type ResourceType type {ResourceType::UNDEFINED}; Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::GroupingPass::ResourceAnalysis"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_grouping_pass_1_1_resource_analysis/#microsoftquantumgroupingpassresourceanalysis","text":"","title":"microsoft::quantum::GroupingPass::ResourceAnalysis"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_grouping_pass_1_1_resource_analysis/#public-attributes","text":"Name bool is_const uint64_t id ResourceType type","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_grouping_pass_1_1_resource_analysis/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_grouping_pass_1_1_resource_analysis/#variable-is_const","text":"bool is_const {false};","title":"variable is_const"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_grouping_pass_1_1_resource_analysis/#variable-id","text":"uint64_t id {0};","title":"variable id"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_grouping_pass_1_1_resource_analysis/#variable-type","text":"ResourceType type {ResourceType::UNDEFINED}; Updated on 28 October 2022 at 19:30:15 UTC","title":"variable type"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_has_qat_serializers/","text":"microsoft::quantum::HasQatSerializers More... Public Attributes Name constexpr bool VALUE Detailed Description template <typename C > struct microsoft::quantum::HasQatSerializers; Public Attributes Documentation variable VALUE static constexpr bool VALUE = CheckToYaml::value && CheckFromYaml::value && CheckToString::value && CheckFromString::value; Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::HasQatSerializers"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_has_qat_serializers/#microsoftquantumhasqatserializers","text":"More...","title":"microsoft::quantum::HasQatSerializers"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_has_qat_serializers/#public-attributes","text":"Name constexpr bool VALUE","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_has_qat_serializers/#detailed-description","text":"template <typename C > struct microsoft::quantum::HasQatSerializers;","title":"Detailed Description"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_has_qat_serializers/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_has_qat_serializers/#variable-value","text":"static constexpr bool VALUE = CheckToYaml::value && CheckFromYaml::value && CheckToString::value && CheckFromString::value; Updated on 28 October 2022 at 19:30:15 UTC","title":"variable VALUE"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_location/","text":"microsoft::quantum::ILogger::Location Class that holds the location of where the incident happened. #include <Logging/ILogger.hpp> Inherits from microsoft::quantum::SourceLocation Public Functions Name Location () =default Location ( SourceLocation const & source) Location (String v_name, int64_t v_line, int64_t v_column, String llvm_hint =\"\", String frontend_hint =\"\") Location ( Location const & source) =default Location & operator= ( Location const & source) =default String & llvmHint () String const & llvmHint () const void setLlvmHint (String const & v) String & frontendHint () String const & frontendHint () const void setFrontendHint (String const & v) Additional inherited members Public Types inherited from microsoft::quantum::SourceLocation Name enum @0 { InvalidPosition} using llvm::StringRef StringRef Public Functions inherited from microsoft::quantum::SourceLocation Name SourceLocation () =default SourceLocation (String v_name, int64_t v_line, int64_t v_column) operator bool () const String & name () String const & name () const void setName (String const & name) int64_t & line () int64_t const & line () const void setLine (int64_t line) int64_t & column () int64_t const & column () const void setColumn (int64_t column) SourceLocation invalidPosition () Public Functions Documentation function Location Location() =default function Location inline explicit Location( SourceLocation const & source ) function Location inline Location( String v_name, int64_t v_line, int64_t v_column, String llvm_hint =\"\", String frontend_hint =\"\" ) function Location Location( Location const & source ) =default function operator= Location & operator=( Location const & source ) =default function llvmHint inline String & llvmHint() function llvmHint inline String const & llvmHint() const function setLlvmHint inline void setLlvmHint( String const & v ) function frontendHint inline String & frontendHint() function frontendHint inline String const & frontendHint() const function setFrontendHint inline void setFrontendHint( String const & v ) Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::ILogger::Location"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_location/#microsoftquantumiloggerlocation","text":"Class that holds the location of where the incident happened. #include <Logging/ILogger.hpp> Inherits from microsoft::quantum::SourceLocation","title":"microsoft::quantum::ILogger::Location"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_location/#public-functions","text":"Name Location () =default Location ( SourceLocation const & source) Location (String v_name, int64_t v_line, int64_t v_column, String llvm_hint =\"\", String frontend_hint =\"\") Location ( Location const & source) =default Location & operator= ( Location const & source) =default String & llvmHint () String const & llvmHint () const void setLlvmHint (String const & v) String & frontendHint () String const & frontendHint () const void setFrontendHint (String const & v)","title":"Public Functions"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_location/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::SourceLocation Name enum @0 { InvalidPosition} using llvm::StringRef StringRef Public Functions inherited from microsoft::quantum::SourceLocation Name SourceLocation () =default SourceLocation (String v_name, int64_t v_line, int64_t v_column) operator bool () const String & name () String const & name () const void setName (String const & name) int64_t & line () int64_t const & line () const void setLine (int64_t line) int64_t & column () int64_t const & column () const void setColumn (int64_t column) SourceLocation invalidPosition ()","title":"Additional inherited members"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_location/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_location/#function-location","text":"Location() =default","title":"function Location"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_location/#function-location_1","text":"inline explicit Location( SourceLocation const & source )","title":"function Location"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_location/#function-location_2","text":"inline Location( String v_name, int64_t v_line, int64_t v_column, String llvm_hint =\"\", String frontend_hint =\"\" )","title":"function Location"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_location/#function-location_3","text":"Location( Location const & source ) =default","title":"function Location"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_location/#function-operator","text":"Location & operator=( Location const & source ) =default","title":"function operator="},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_location/#function-llvmhint","text":"inline String & llvmHint()","title":"function llvmHint"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_location/#function-llvmhint_1","text":"inline String const & llvmHint() const","title":"function llvmHint"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_location/#function-setllvmhint","text":"inline void setLlvmHint( String const & v )","title":"function setLlvmHint"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_location/#function-frontendhint","text":"inline String & frontendHint()","title":"function frontendHint"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_location/#function-frontendhint_1","text":"inline String const & frontendHint() const","title":"function frontendHint"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_location/#function-setfrontendhint","text":"inline void setFrontendHint( String const & v ) Updated on 28 October 2022 at 19:30:15 UTC","title":"function setFrontendHint"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_message/","text":"microsoft::quantum::ILogger::Message Struct to hold a message together with its type and location. #include <Logging/ILogger.hpp> Public Attributes Name Type type Location location String message Public Attributes Documentation variable type Type type; variable location Location location; variable message String message; Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::ILogger::Message"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_message/#microsoftquantumiloggermessage","text":"Struct to hold a message together with its type and location. #include <Logging/ILogger.hpp>","title":"microsoft::quantum::ILogger::Message"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_message/#public-attributes","text":"Name Type type Location location String message","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_message/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_message/#variable-type","text":"Type type;","title":"variable type"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_message/#variable-location","text":"Location location;","title":"variable location"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_i_logger_1_1_message/#variable-message","text":"String message; Updated on 28 October 2022 at 19:30:15 UTC","title":"variable message"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_parameter_parser_1_1_parsed_value/","text":"microsoft::quantum::ParameterParser::ParsedValue Struct that contains parsed and interpreted values of command line arguments. Public Attributes Name bool is_key Whether or not a parsed value should be considered a key. String value Value after parsing. Public Attributes Documentation variable is_key bool is_key {false}; Whether or not a parsed value should be considered a key. variable value String value; Value after parsing. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::ParameterParser::ParsedValue"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_parameter_parser_1_1_parsed_value/#microsoftquantumparameterparserparsedvalue","text":"Struct that contains parsed and interpreted values of command line arguments.","title":"microsoft::quantum::ParameterParser::ParsedValue"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_parameter_parser_1_1_parsed_value/#public-attributes","text":"Name bool is_key Whether or not a parsed value should be considered a key. String value Value after parsing.","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_parameter_parser_1_1_parsed_value/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_parameter_parser_1_1_parsed_value/#variable-is_key","text":"bool is_key {false}; Whether or not a parsed value should be considered a key.","title":"variable is_key"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_parameter_parser_1_1_parsed_value/#variable-value","text":"String value; Value after parsing. Updated on 28 October 2022 at 19:30:15 UTC","title":"variable value"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_target_profile_mapping_configuration/","text":"microsoft::quantum::TargetProfileMappingConfiguration Public Functions Name void setup ( ConfigurationManager & config) bool shouldAddInstCombinePass () const bool shouldAddAggressiveInstCombinePass () const bool shouldAddSccpPass () const bool shouldAddSimplifyCfgPass () const bool shouldLowerSwitch () const bool shouldEliminateZExtI1 () const bool shouldDeferMeasurements () const void setUseDeferMeasurements (bool const & v) TargetProfileMappingConfiguration createDisabled () Public Functions Documentation function setup inline void setup( ConfigurationManager & config ) function shouldAddInstCombinePass inline bool shouldAddInstCombinePass() const function shouldAddAggressiveInstCombinePass inline bool shouldAddAggressiveInstCombinePass() const function shouldAddSccpPass inline bool shouldAddSccpPass() const function shouldAddSimplifyCfgPass inline bool shouldAddSimplifyCfgPass() const function shouldLowerSwitch inline bool shouldLowerSwitch() const function shouldEliminateZExtI1 inline bool shouldEliminateZExtI1() const function shouldDeferMeasurements inline bool shouldDeferMeasurements() const function setUseDeferMeasurements inline void setUseDeferMeasurements( bool const & v ) function createDisabled static inline TargetProfileMappingConfiguration createDisabled() Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::TargetProfileMappingConfiguration"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_target_profile_mapping_configuration/#microsoftquantumtargetprofilemappingconfiguration","text":"","title":"microsoft::quantum::TargetProfileMappingConfiguration"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_target_profile_mapping_configuration/#public-functions","text":"Name void setup ( ConfigurationManager & config) bool shouldAddInstCombinePass () const bool shouldAddAggressiveInstCombinePass () const bool shouldAddSccpPass () const bool shouldAddSimplifyCfgPass () const bool shouldLowerSwitch () const bool shouldEliminateZExtI1 () const bool shouldDeferMeasurements () const void setUseDeferMeasurements (bool const & v) TargetProfileMappingConfiguration createDisabled ()","title":"Public Functions"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_target_profile_mapping_configuration/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_target_profile_mapping_configuration/#function-setup","text":"inline void setup( ConfigurationManager & config )","title":"function setup"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_target_profile_mapping_configuration/#function-shouldaddinstcombinepass","text":"inline bool shouldAddInstCombinePass() const","title":"function shouldAddInstCombinePass"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_target_profile_mapping_configuration/#function-shouldaddaggressiveinstcombinepass","text":"inline bool shouldAddAggressiveInstCombinePass() const","title":"function shouldAddAggressiveInstCombinePass"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_target_profile_mapping_configuration/#function-shouldaddsccppass","text":"inline bool shouldAddSccpPass() const","title":"function shouldAddSccpPass"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_target_profile_mapping_configuration/#function-shouldaddsimplifycfgpass","text":"inline bool shouldAddSimplifyCfgPass() const","title":"function shouldAddSimplifyCfgPass"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_target_profile_mapping_configuration/#function-shouldlowerswitch","text":"inline bool shouldLowerSwitch() const","title":"function shouldLowerSwitch"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_target_profile_mapping_configuration/#function-shouldeliminatezexti1","text":"inline bool shouldEliminateZExtI1() const","title":"function shouldEliminateZExtI1"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_target_profile_mapping_configuration/#function-shoulddefermeasurements","text":"inline bool shouldDeferMeasurements() const","title":"function shouldDeferMeasurements"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_target_profile_mapping_configuration/#function-setusedefermeasurements","text":"inline void setUseDeferMeasurements( bool const & v )","title":"function setUseDeferMeasurements"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_target_profile_mapping_configuration/#function-createdisabled","text":"static inline TargetProfileMappingConfiguration createDisabled() Updated on 28 October 2022 at 19:30:15 UTC","title":"function createDisabled"},{"location":"Api/Classes/structstd_1_1hash_3_01microsoft_1_1quantum_1_1_opcode_value_01_4/","text":"std::hash< microsoft::quantum::OpcodeValue > Public Functions Name size_t operator() ( microsoft::quantum::OpcodeValue const & x) const Public Functions Documentation function operator() inline size_t operator()( microsoft::quantum::OpcodeValue const & x ) const Updated on 28 October 2022 at 19:30:15 UTC","title":"std::hash< microsoft::quantum::OpcodeValue >"},{"location":"Api/Classes/structstd_1_1hash_3_01microsoft_1_1quantum_1_1_opcode_value_01_4/#stdhash-microsoftquantumopcodevalue","text":"","title":"std::hash&lt; microsoft::quantum::OpcodeValue &gt;"},{"location":"Api/Classes/structstd_1_1hash_3_01microsoft_1_1quantum_1_1_opcode_value_01_4/#public-functions","text":"Name size_t operator() ( microsoft::quantum::OpcodeValue const & x) const","title":"Public Functions"},{"location":"Api/Classes/structstd_1_1hash_3_01microsoft_1_1quantum_1_1_opcode_value_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/structstd_1_1hash_3_01microsoft_1_1quantum_1_1_opcode_value_01_4/#function-operator","text":"inline size_t operator()( microsoft::quantum::OpcodeValue const & x ) const Updated on 28 October 2022 at 19:30:15 UTC","title":"function operator()"},{"location":"Api/Examples/","text":"Examples Updated on 28 October 2022 at 19:30:16 UTC","title":"Examples"},{"location":"Api/Examples/#examples","text":"Updated on 28 October 2022 at 19:30:16 UTC","title":"Examples"},{"location":"Api/Files/","text":"Files dir AdaptorFactory file AdaptorFactory/ConfigurableQirAdaptorFactory.cpp file AdaptorFactory/ConfigurableQirAdaptorFactory.hpp file AdaptorFactory/LlvmPassesConfiguration.cpp file AdaptorFactory/LlvmPassesConfiguration.hpp file AdaptorFactory/QirAdaptorFactory.cpp file AdaptorFactory/QirAdaptorFactory.hpp file AdaptorFactory/TargetProfileMappingConfiguration.hpp dir AllocationManager file AllocationManager/AllocationManager.cpp file AllocationManager/AllocationManager.hpp file AllocationManager/IAllocationManager.cpp file AllocationManager/IAllocationManager.hpp dir Commandline file Commandline/ConfigBind.hpp file Commandline/ConfigurationManager.cpp file Commandline/ConfigurationManager.hpp file Commandline/IConfigBind.cpp file Commandline/IConfigBind.hpp file Commandline/ParameterParser.cpp file Commandline/ParameterParser.hpp file Commandline/SerializationTraits.hpp file Commandline/SpecConfiguration.hpp dir Logging file Logging/CommentLogger.cpp file Logging/CommentLogger.hpp file Logging/ILogger.cpp file Logging/ILogger.hpp file Logging/LogCollection.cpp file Logging/LogCollection.hpp file Logging/SourceLocation.hpp dir ModuleLoader file ModuleLoader/DebugInfoUpdater.cpp file ModuleLoader/DebugInfoUpdater.hpp file ModuleLoader/InstructionLocationTable.cpp file ModuleLoader/InstructionLocationTable.hpp file ModuleLoader/ModuleLoader.hpp dir Passes dir Passes/DeferMeasurementPass file Passes/DeferMeasurementPass/DeferMeasurementPass.cpp file Passes/DeferMeasurementPass/DeferMeasurementPass.hpp dir Passes/DivisionByZeroPass file Passes/DivisionByZeroPass/DivisionByZeroPass.cpp file Passes/DivisionByZeroPass/DivisionByZeroPass.hpp dir Passes/FunctionReplacementPass file Passes/FunctionReplacementPass/FunctionAnnotatorPass.cpp file Passes/FunctionReplacementPass/FunctionAnnotatorPass.hpp file Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.cpp file Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.hpp file Passes/FunctionReplacementPass/FunctionReplacementConfiguration.hpp file Passes/FunctionReplacementPass/FunctionReplacementPass.cpp file Passes/FunctionReplacementPass/FunctionReplacementPass.hpp dir Passes/GroupingPass file Passes/GroupingPass/GroupingAnalysisPass.cpp file Passes/GroupingPass/GroupingAnalysisPass.hpp file Passes/GroupingPass/GroupingPass.cpp file Passes/GroupingPass/GroupingPass.hpp file Passes/GroupingPass/GroupingPassConfiguration.hpp dir Passes/PostTransformValidation file Passes/PostTransformValidation/PostTransformValidationPass.cpp file Passes/PostTransformValidation/PostTransformValidationPass.hpp file Passes/PostTransformValidation/PostTransformValidationPassConfiguration.hpp dir Passes/RemoveDisallowedAttributesPass file Passes/RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp dir Passes/RemoveNonEntrypointFunctions file Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPass.cpp file Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPass.hpp file Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPassConfiguration.hpp dir Passes/StaticResourceComponent file Passes/StaticResourceComponent/AllocationAnalysisPass.cpp file Passes/StaticResourceComponent/AllocationAnalysisPass.hpp file Passes/StaticResourceComponent/QubitRemapPass.cpp file Passes/StaticResourceComponent/QubitRemapPass.hpp file Passes/StaticResourceComponent/ReplaceQubitOnResetPass.cpp file Passes/StaticResourceComponent/ReplaceQubitOnResetPass.hpp file Passes/StaticResourceComponent/ResourceAnnotationPass.cpp file Passes/StaticResourceComponent/ResourceAnnotationPass.hpp file Passes/StaticResourceComponent/StaticResourceComponentConfiguration.cpp file Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp dir Passes/TargetQisMappingPass file Passes/TargetQisMappingPass/Factory.cpp file Passes/TargetQisMappingPass/Factory.hpp file Passes/TargetQisMappingPass/TargetQisMappingPass.cpp file Passes/TargetQisMappingPass/TargetQisMappingPass.hpp file Passes/TargetQisMappingPass/TargetQisMappingPassConfiguration.hpp file Passes/TargetQisMappingPass/TransformationRulesPassConfiguration.cpp dir Passes/ValidationPass file Passes/ValidationPass/FunctionValidationPass.cpp file Passes/ValidationPass/FunctionValidationPass.hpp file Passes/ValidationPass/TargetProfileConfiguration.cpp file Passes/ValidationPass/TargetProfileConfiguration.hpp file Passes/ValidationPass/TargetQisConfiguration.cpp file Passes/ValidationPass/TargetQisConfiguration.hpp file Passes/ValidationPass/ValidationPass.cpp file Passes/ValidationPass/ValidationPass.hpp dir Passes/ZExtTransformPass file Passes/ZExtTransformPass/ZExtTransformPass.cpp file Passes/ZExtTransformPass/ZExtTransformPass.hpp dir QatTypes file QatTypes/QatTypes.hpp dir QirAdaptor file QirAdaptor/QirAdaptor.cpp file QirAdaptor/QirAdaptor.hpp dir Rules file Rules/IOperandPrototype.cpp file Rules/IOperandPrototype.hpp file Rules/ReplacementRule.cpp file Rules/ReplacementRule.hpp file Rules/RuleSet.cpp file Rules/RuleSet.hpp dir Rules/Notation file Rules/Notation/BasicBlock.cpp file Rules/Notation/BitCast.cpp file Rules/Notation/Branch.cpp file Rules/Notation/Call.hpp file Rules/Notation/Call.ipp file Rules/Notation/CallByNameOnly.cpp file Rules/Notation/Capture.cpp file Rules/Notation/ConstInt.cpp file Rules/Notation/IntToPtr.cpp file Rules/Notation/Load.cpp file Rules/Notation/Notation.cpp file Rules/Notation/Notation.hpp file Rules/Notation/Phi.ipp file Rules/Notation/Select.cpp file Rules/Notation/Store.cpp file Rules/Notation/Switch.cpp file Rules/Notation/UnnamedInvoke.cpp file Rules/Notation/ZExt.cpp dir Rules/Patterns file Rules/Patterns/AnyPattern.cpp file Rules/Patterns/AnyPattern.hpp file Rules/Patterns/CallPattern.cpp file Rules/Patterns/CallPattern.hpp file Rules/Patterns/Instruction.cpp file Rules/Patterns/Instruction.hpp file Rules/Patterns/PhiPattern.cpp file Rules/Patterns/PhiPattern.hpp file Rules/Patterns/UnnamedInvokePattern.cpp file Rules/Patterns/UnnamedInvokePattern.hpp dir TestTools file TestTools/IrManipulationTestHelper.cpp file TestTools/IrManipulationTestHelper.hpp file TestTools/TestVm.hpp dir Utils file Utils/FunctionToModule.hpp file Utils/Trim.hpp dir Validator file Validator/Validator.cpp file Validator/Validator.hpp dir Version file Version/Version.cpp file Version/Version.tpl.hpp file Version/version_builder.py Updated on 28 October 2022 at 19:30:16 UTC","title":"Files"},{"location":"Api/Files/#files","text":"dir AdaptorFactory file AdaptorFactory/ConfigurableQirAdaptorFactory.cpp file AdaptorFactory/ConfigurableQirAdaptorFactory.hpp file AdaptorFactory/LlvmPassesConfiguration.cpp file AdaptorFactory/LlvmPassesConfiguration.hpp file AdaptorFactory/QirAdaptorFactory.cpp file AdaptorFactory/QirAdaptorFactory.hpp file AdaptorFactory/TargetProfileMappingConfiguration.hpp dir AllocationManager file AllocationManager/AllocationManager.cpp file AllocationManager/AllocationManager.hpp file AllocationManager/IAllocationManager.cpp file AllocationManager/IAllocationManager.hpp dir Commandline file Commandline/ConfigBind.hpp file Commandline/ConfigurationManager.cpp file Commandline/ConfigurationManager.hpp file Commandline/IConfigBind.cpp file Commandline/IConfigBind.hpp file Commandline/ParameterParser.cpp file Commandline/ParameterParser.hpp file Commandline/SerializationTraits.hpp file Commandline/SpecConfiguration.hpp dir Logging file Logging/CommentLogger.cpp file Logging/CommentLogger.hpp file Logging/ILogger.cpp file Logging/ILogger.hpp file Logging/LogCollection.cpp file Logging/LogCollection.hpp file Logging/SourceLocation.hpp dir ModuleLoader file ModuleLoader/DebugInfoUpdater.cpp file ModuleLoader/DebugInfoUpdater.hpp file ModuleLoader/InstructionLocationTable.cpp file ModuleLoader/InstructionLocationTable.hpp file ModuleLoader/ModuleLoader.hpp dir Passes dir Passes/DeferMeasurementPass file Passes/DeferMeasurementPass/DeferMeasurementPass.cpp file Passes/DeferMeasurementPass/DeferMeasurementPass.hpp dir Passes/DivisionByZeroPass file Passes/DivisionByZeroPass/DivisionByZeroPass.cpp file Passes/DivisionByZeroPass/DivisionByZeroPass.hpp dir Passes/FunctionReplacementPass file Passes/FunctionReplacementPass/FunctionAnnotatorPass.cpp file Passes/FunctionReplacementPass/FunctionAnnotatorPass.hpp file Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.cpp file Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.hpp file Passes/FunctionReplacementPass/FunctionReplacementConfiguration.hpp file Passes/FunctionReplacementPass/FunctionReplacementPass.cpp file Passes/FunctionReplacementPass/FunctionReplacementPass.hpp dir Passes/GroupingPass file Passes/GroupingPass/GroupingAnalysisPass.cpp file Passes/GroupingPass/GroupingAnalysisPass.hpp file Passes/GroupingPass/GroupingPass.cpp file Passes/GroupingPass/GroupingPass.hpp file Passes/GroupingPass/GroupingPassConfiguration.hpp dir Passes/PostTransformValidation file Passes/PostTransformValidation/PostTransformValidationPass.cpp file Passes/PostTransformValidation/PostTransformValidationPass.hpp file Passes/PostTransformValidation/PostTransformValidationPassConfiguration.hpp dir Passes/RemoveDisallowedAttributesPass file Passes/RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp dir Passes/RemoveNonEntrypointFunctions file Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPass.cpp file Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPass.hpp file Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPassConfiguration.hpp dir Passes/StaticResourceComponent file Passes/StaticResourceComponent/AllocationAnalysisPass.cpp file Passes/StaticResourceComponent/AllocationAnalysisPass.hpp file Passes/StaticResourceComponent/QubitRemapPass.cpp file Passes/StaticResourceComponent/QubitRemapPass.hpp file Passes/StaticResourceComponent/ReplaceQubitOnResetPass.cpp file Passes/StaticResourceComponent/ReplaceQubitOnResetPass.hpp file Passes/StaticResourceComponent/ResourceAnnotationPass.cpp file Passes/StaticResourceComponent/ResourceAnnotationPass.hpp file Passes/StaticResourceComponent/StaticResourceComponentConfiguration.cpp file Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp dir Passes/TargetQisMappingPass file Passes/TargetQisMappingPass/Factory.cpp file Passes/TargetQisMappingPass/Factory.hpp file Passes/TargetQisMappingPass/TargetQisMappingPass.cpp file Passes/TargetQisMappingPass/TargetQisMappingPass.hpp file Passes/TargetQisMappingPass/TargetQisMappingPassConfiguration.hpp file Passes/TargetQisMappingPass/TransformationRulesPassConfiguration.cpp dir Passes/ValidationPass file Passes/ValidationPass/FunctionValidationPass.cpp file Passes/ValidationPass/FunctionValidationPass.hpp file Passes/ValidationPass/TargetProfileConfiguration.cpp file Passes/ValidationPass/TargetProfileConfiguration.hpp file Passes/ValidationPass/TargetQisConfiguration.cpp file Passes/ValidationPass/TargetQisConfiguration.hpp file Passes/ValidationPass/ValidationPass.cpp file Passes/ValidationPass/ValidationPass.hpp dir Passes/ZExtTransformPass file Passes/ZExtTransformPass/ZExtTransformPass.cpp file Passes/ZExtTransformPass/ZExtTransformPass.hpp dir QatTypes file QatTypes/QatTypes.hpp dir QirAdaptor file QirAdaptor/QirAdaptor.cpp file QirAdaptor/QirAdaptor.hpp dir Rules file Rules/IOperandPrototype.cpp file Rules/IOperandPrototype.hpp file Rules/ReplacementRule.cpp file Rules/ReplacementRule.hpp file Rules/RuleSet.cpp file Rules/RuleSet.hpp dir Rules/Notation file Rules/Notation/BasicBlock.cpp file Rules/Notation/BitCast.cpp file Rules/Notation/Branch.cpp file Rules/Notation/Call.hpp file Rules/Notation/Call.ipp file Rules/Notation/CallByNameOnly.cpp file Rules/Notation/Capture.cpp file Rules/Notation/ConstInt.cpp file Rules/Notation/IntToPtr.cpp file Rules/Notation/Load.cpp file Rules/Notation/Notation.cpp file Rules/Notation/Notation.hpp file Rules/Notation/Phi.ipp file Rules/Notation/Select.cpp file Rules/Notation/Store.cpp file Rules/Notation/Switch.cpp file Rules/Notation/UnnamedInvoke.cpp file Rules/Notation/ZExt.cpp dir Rules/Patterns file Rules/Patterns/AnyPattern.cpp file Rules/Patterns/AnyPattern.hpp file Rules/Patterns/CallPattern.cpp file Rules/Patterns/CallPattern.hpp file Rules/Patterns/Instruction.cpp file Rules/Patterns/Instruction.hpp file Rules/Patterns/PhiPattern.cpp file Rules/Patterns/PhiPattern.hpp file Rules/Patterns/UnnamedInvokePattern.cpp file Rules/Patterns/UnnamedInvokePattern.hpp dir TestTools file TestTools/IrManipulationTestHelper.cpp file TestTools/IrManipulationTestHelper.hpp file TestTools/TestVm.hpp dir Utils file Utils/FunctionToModule.hpp file Utils/Trim.hpp dir Validator file Validator/Validator.cpp file Validator/Validator.hpp dir Version file Version/Version.cpp file Version/Version.tpl.hpp file Version/version_builder.py Updated on 28 October 2022 at 19:30:16 UTC","title":"Files"},{"location":"Api/Files/_allocation_analysis_pass_8cpp/","text":"Passes/StaticResourceComponent/AllocationAnalysisPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/StaticResourceComponent/AllocationAnalysisPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { llvm::AnalysisKey AllocationAnalysisPass::Key; bool AllocationAnalysisPass::extractResourceId(llvm::Value* value, uint64_t& return_value, ResourceType& type) const { auto* instruction_ptr = llvm::dyn_cast<llvm::IntToPtrInst>(value); auto* operator_ptr = llvm::dyn_cast<llvm::ConcreteOperator<llvm::Operator, llvm::Instruction::IntToPtr>>(value); auto* nullptr_cast = llvm::dyn_cast<llvm::ConstantPointerNull>(value); if (instruction_ptr || operator_ptr || nullptr_cast) { auto pointer_type = llvm::dyn_cast<llvm::PointerType>(value->getType()); if (!pointer_type) { return false; } llvm::Type* element_type = pointer_type->getElementType(); if (!element_type->isStructTy()) { return false; } type = ResourceType::NotResource; auto type_name = static_cast<String>(element_type->getStructName()); if (type_name == \"Qubit\") { type = ResourceType::QubitResource; } if (type_name == \"Result\") { type = ResourceType::ResultResource; } if (type == ResourceType::NotResource) { return false; } bool is_constant_int = nullptr_cast != nullptr; uint64_t n = 0; auto user = llvm::dyn_cast<llvm::User>(value); // In case there exists a user, it must have exactly one argument // which should be an integer. In case of deferred integers, the mapping // will not work if (user && user->getNumOperands() == 1) { auto cst = llvm::dyn_cast<llvm::ConstantInt>(user->getOperand(0)); if (cst) { is_constant_int = true; n = cst->getValue().getZExtValue(); } } if (is_constant_int) { return_value = n; return true; } } return false; } AllocationAnalysisPass::Result AllocationAnalysisPass::run( llvm::Function& function, llvm::FunctionAnalysisManager& /*fam*/) { AllocationAnalysis ret; std::unordered_set<uint64_t> qubits_used{}; std::unordered_set<uint64_t> results_used{}; for (auto& block : function) { for (auto& instr : block) { for (uint64_t i = 0; i < instr.getNumOperands(); ++i) { auto op = instr.getOperand(static_cast<uint32_t>(i)); ResourceType type = ResourceType::NotResource; uint64_t n = 0; // Checking if it is a qubit resource reference and extracting the corresponding // id and type. Otherwise, we skip to the next operand. if (!extractResourceId(op, n, type)) { continue; } ResourceAccessLocation value{op, type, n, &instr, i}; ret.access_map[op] = value; ret.resource_access.push_back(value); switch (type) { case ResourceType::QubitResource: qubits_used.insert(n); ret.largest_qubit_index = ret.largest_qubit_index < n ? n : ret.largest_qubit_index; break; case ResourceType::ResultResource: results_used.insert(n); ret.largest_result_index = ret.largest_result_index < n ? n : ret.largest_result_index; break; case ResourceType::NotResource: break; } } } } ret.usage_qubit_counts = qubits_used.size(); ret.usage_result_counts = results_used.size(); return ret; } bool AllocationAnalysisPass::isRequired() { return true; } llvm::PreservedAnalyses AllocationAnalysisPassPrinter::run( llvm::Function& /*module*/, llvm::FunctionAnalysisManager& /*fam*/) { return llvm::PreservedAnalyses::all(); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/StaticResourceComponent/AllocationAnalysisPass.cpp"},{"location":"Api/Files/_allocation_analysis_pass_8cpp/#passesstaticresourcecomponentallocationanalysispasscpp","text":"","title":"Passes/StaticResourceComponent/AllocationAnalysisPass.cpp"},{"location":"Api/Files/_allocation_analysis_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_allocation_analysis_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/StaticResourceComponent/AllocationAnalysisPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { llvm::AnalysisKey AllocationAnalysisPass::Key; bool AllocationAnalysisPass::extractResourceId(llvm::Value* value, uint64_t& return_value, ResourceType& type) const { auto* instruction_ptr = llvm::dyn_cast<llvm::IntToPtrInst>(value); auto* operator_ptr = llvm::dyn_cast<llvm::ConcreteOperator<llvm::Operator, llvm::Instruction::IntToPtr>>(value); auto* nullptr_cast = llvm::dyn_cast<llvm::ConstantPointerNull>(value); if (instruction_ptr || operator_ptr || nullptr_cast) { auto pointer_type = llvm::dyn_cast<llvm::PointerType>(value->getType()); if (!pointer_type) { return false; } llvm::Type* element_type = pointer_type->getElementType(); if (!element_type->isStructTy()) { return false; } type = ResourceType::NotResource; auto type_name = static_cast<String>(element_type->getStructName()); if (type_name == \"Qubit\") { type = ResourceType::QubitResource; } if (type_name == \"Result\") { type = ResourceType::ResultResource; } if (type == ResourceType::NotResource) { return false; } bool is_constant_int = nullptr_cast != nullptr; uint64_t n = 0; auto user = llvm::dyn_cast<llvm::User>(value); // In case there exists a user, it must have exactly one argument // which should be an integer. In case of deferred integers, the mapping // will not work if (user && user->getNumOperands() == 1) { auto cst = llvm::dyn_cast<llvm::ConstantInt>(user->getOperand(0)); if (cst) { is_constant_int = true; n = cst->getValue().getZExtValue(); } } if (is_constant_int) { return_value = n; return true; } } return false; } AllocationAnalysisPass::Result AllocationAnalysisPass::run( llvm::Function& function, llvm::FunctionAnalysisManager& /*fam*/) { AllocationAnalysis ret; std::unordered_set<uint64_t> qubits_used{}; std::unordered_set<uint64_t> results_used{}; for (auto& block : function) { for (auto& instr : block) { for (uint64_t i = 0; i < instr.getNumOperands(); ++i) { auto op = instr.getOperand(static_cast<uint32_t>(i)); ResourceType type = ResourceType::NotResource; uint64_t n = 0; // Checking if it is a qubit resource reference and extracting the corresponding // id and type. Otherwise, we skip to the next operand. if (!extractResourceId(op, n, type)) { continue; } ResourceAccessLocation value{op, type, n, &instr, i}; ret.access_map[op] = value; ret.resource_access.push_back(value); switch (type) { case ResourceType::QubitResource: qubits_used.insert(n); ret.largest_qubit_index = ret.largest_qubit_index < n ? n : ret.largest_qubit_index; break; case ResourceType::ResultResource: results_used.insert(n); ret.largest_result_index = ret.largest_result_index < n ? n : ret.largest_result_index; break; case ResourceType::NotResource: break; } } } } ret.usage_qubit_counts = qubits_used.size(); ret.usage_result_counts = results_used.size(); return ret; } bool AllocationAnalysisPass::isRequired() { return true; } llvm::PreservedAnalyses AllocationAnalysisPassPrinter::run( llvm::Function& /*module*/, llvm::FunctionAnalysisManager& /*fam*/) { return llvm::PreservedAnalyses::all(); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_allocation_analysis_pass_8hpp/","text":"Passes/StaticResourceComponent/AllocationAnalysisPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name struct microsoft::quantum::AllocationAnalysis struct microsoft::quantum::AllocationAnalysis::ResourceAccessLocation class microsoft::quantum::AllocationAnalysisPass class microsoft::quantum::AllocationAnalysisPassPrinter Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft::quantum { struct AllocationAnalysis { enum ResourceType { NotResource, QubitResource, ResultResource }; struct ResourceAccessLocation { llvm::Value* operand{nullptr}; ResourceType type{ResourceType::NotResource}; uint64_t index{static_cast<uint64_t>(-1)}; llvm::Instruction* used_by{nullptr}; uint64_t operand_id{0}; }; using ResourceValueToId = std::unordered_map<llvm::Value*, ResourceAccessLocation>; using ResourceAccessList = std::vector<ResourceAccessLocation>; uint64_t largest_qubit_index{0}; uint64_t largest_result_index{0}; uint64_t usage_qubit_counts{0}; uint64_t usage_result_counts{0}; ResourceValueToId access_map{}; ResourceAccessList resource_access{}; }; class AllocationAnalysisPass : public llvm::AnalysisInfoMixin<AllocationAnalysisPass> { public: using Result = AllocationAnalysis; using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using BlockSet = std::unordered_set<llvm::BasicBlock*>; using ResourceType = AllocationAnalysis::ResourceType; using ResourceAccessLocation = AllocationAnalysis::ResourceAccessLocation; // Construction and destruction configuration. // explicit AllocationAnalysisPass(ILoggerPtr const& logger) : logger_{logger} { } AllocationAnalysisPass(AllocationAnalysisPass const&) = delete; AllocationAnalysisPass(AllocationAnalysisPass&&) = default; ~AllocationAnalysisPass() = default; Result run(llvm::Function& function, llvm::FunctionAnalysisManager& fam); static bool isRequired(); private: bool extractResourceId(llvm::Value* value, uint64_t& return_value, ResourceType& type) const; ILoggerPtr logger_{nullptr}; static llvm::AnalysisKey Key; // NOLINT friend struct llvm::AnalysisInfoMixin<AllocationAnalysisPass>; }; class AllocationAnalysisPassPrinter : public llvm::PassInfoMixin<AllocationAnalysisPassPrinter> { public: llvm::PreservedAnalyses run(llvm::Function& module, llvm::FunctionAnalysisManager& mam); static bool isRequired() { return true; } }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/StaticResourceComponent/AllocationAnalysisPass.hpp"},{"location":"Api/Files/_allocation_analysis_pass_8hpp/#passesstaticresourcecomponentallocationanalysispasshpp","text":"","title":"Passes/StaticResourceComponent/AllocationAnalysisPass.hpp"},{"location":"Api/Files/_allocation_analysis_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_allocation_analysis_pass_8hpp/#classes","text":"Name struct microsoft::quantum::AllocationAnalysis struct microsoft::quantum::AllocationAnalysis::ResourceAccessLocation class microsoft::quantum::AllocationAnalysisPass class microsoft::quantum::AllocationAnalysisPassPrinter","title":"Classes"},{"location":"Api/Files/_allocation_analysis_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft::quantum { struct AllocationAnalysis { enum ResourceType { NotResource, QubitResource, ResultResource }; struct ResourceAccessLocation { llvm::Value* operand{nullptr}; ResourceType type{ResourceType::NotResource}; uint64_t index{static_cast<uint64_t>(-1)}; llvm::Instruction* used_by{nullptr}; uint64_t operand_id{0}; }; using ResourceValueToId = std::unordered_map<llvm::Value*, ResourceAccessLocation>; using ResourceAccessList = std::vector<ResourceAccessLocation>; uint64_t largest_qubit_index{0}; uint64_t largest_result_index{0}; uint64_t usage_qubit_counts{0}; uint64_t usage_result_counts{0}; ResourceValueToId access_map{}; ResourceAccessList resource_access{}; }; class AllocationAnalysisPass : public llvm::AnalysisInfoMixin<AllocationAnalysisPass> { public: using Result = AllocationAnalysis; using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using BlockSet = std::unordered_set<llvm::BasicBlock*>; using ResourceType = AllocationAnalysis::ResourceType; using ResourceAccessLocation = AllocationAnalysis::ResourceAccessLocation; // Construction and destruction configuration. // explicit AllocationAnalysisPass(ILoggerPtr const& logger) : logger_{logger} { } AllocationAnalysisPass(AllocationAnalysisPass const&) = delete; AllocationAnalysisPass(AllocationAnalysisPass&&) = default; ~AllocationAnalysisPass() = default; Result run(llvm::Function& function, llvm::FunctionAnalysisManager& fam); static bool isRequired(); private: bool extractResourceId(llvm::Value* value, uint64_t& return_value, ResourceType& type) const; ILoggerPtr logger_{nullptr}; static llvm::AnalysisKey Key; // NOLINT friend struct llvm::AnalysisInfoMixin<AllocationAnalysisPass>; }; class AllocationAnalysisPassPrinter : public llvm::PassInfoMixin<AllocationAnalysisPassPrinter> { public: llvm::PreservedAnalyses run(llvm::Function& module, llvm::FunctionAnalysisManager& mam); static bool isRequired() { return true; } }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_allocation_manager_8cpp/","text":"AllocationManager/AllocationManager.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AllocationManager/AllocationManager.hpp\" #include <memory> #include <unordered_map> #include <vector> namespace microsoft::quantum { BasicAllocationManager::BasicAllocationManagerPtr BasicAllocationManager::createNew() { BasicAllocationManagerPtr ret; ret.reset(new BasicAllocationManager()); return ret; } BasicAllocationManager::Index BasicAllocationManager::allocate(String const& name, Index const& count) { auto ret = next_qubit_index_; // Creating a memory segment mapping in case we are dealing with qubits AllocatedMemoryBlock map; map.name = name; map.count = count; map.start = next_qubit_index_; // Advancing start next_qubit_index_ += count; map.end = map.start + count; mappings_.emplace_back(std::move(map)); // Advancing the allocation index ++allocation_index_; updateRegistersInUse(allocationsInUse() + count); return ret; } void BasicAllocationManager::release(Address const& address) { --allocation_index_; auto it = mappings_.begin(); // Finding the element. Note that we could implement binary // search but assume that we are dealing with few allocations while (it != mappings_.end() && it->start != address) { ++it; } if (it == mappings_.end()) { throw std::runtime_error(\"Qubit segment not found.\"); } if (!reuse_qubits_) { mappings_.erase(it); } else { if (it->count > allocationsInUse()) { throw std::runtime_error(\"Attempting to release more qubits than what is currently allocated.\"); } // In case we are reusing registers, we update how many we are currently using updateRegistersInUse(allocationsInUse() - it->count); mappings_.erase(it); // Updating the next qubit index with naive algorithm that guarantees // 1. Continuous allocation // 2. No overlap in address if (mappings_.empty()) { next_qubit_index_ = 0; } else { auto& b = mappings_.back(); next_qubit_index_ = b.end; } } } void BasicAllocationManager::setReuseRegisters(bool val) { reuse_qubits_ = val; } void BasicAllocationManager::reset() { updateRegistersInUse(0); mappings_.clear(); allocation_index_ = 0; next_qubit_index_ = 0; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"AllocationManager/AllocationManager.cpp"},{"location":"Api/Files/_allocation_manager_8cpp/#allocationmanagerallocationmanagercpp","text":"","title":"AllocationManager/AllocationManager.cpp"},{"location":"Api/Files/_allocation_manager_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_allocation_manager_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AllocationManager/AllocationManager.hpp\" #include <memory> #include <unordered_map> #include <vector> namespace microsoft::quantum { BasicAllocationManager::BasicAllocationManagerPtr BasicAllocationManager::createNew() { BasicAllocationManagerPtr ret; ret.reset(new BasicAllocationManager()); return ret; } BasicAllocationManager::Index BasicAllocationManager::allocate(String const& name, Index const& count) { auto ret = next_qubit_index_; // Creating a memory segment mapping in case we are dealing with qubits AllocatedMemoryBlock map; map.name = name; map.count = count; map.start = next_qubit_index_; // Advancing start next_qubit_index_ += count; map.end = map.start + count; mappings_.emplace_back(std::move(map)); // Advancing the allocation index ++allocation_index_; updateRegistersInUse(allocationsInUse() + count); return ret; } void BasicAllocationManager::release(Address const& address) { --allocation_index_; auto it = mappings_.begin(); // Finding the element. Note that we could implement binary // search but assume that we are dealing with few allocations while (it != mappings_.end() && it->start != address) { ++it; } if (it == mappings_.end()) { throw std::runtime_error(\"Qubit segment not found.\"); } if (!reuse_qubits_) { mappings_.erase(it); } else { if (it->count > allocationsInUse()) { throw std::runtime_error(\"Attempting to release more qubits than what is currently allocated.\"); } // In case we are reusing registers, we update how many we are currently using updateRegistersInUse(allocationsInUse() - it->count); mappings_.erase(it); // Updating the next qubit index with naive algorithm that guarantees // 1. Continuous allocation // 2. No overlap in address if (mappings_.empty()) { next_qubit_index_ = 0; } else { auto& b = mappings_.back(); next_qubit_index_ = b.end; } } } void BasicAllocationManager::setReuseRegisters(bool val) { reuse_qubits_ = val; } void BasicAllocationManager::reset() { updateRegistersInUse(0); mappings_.clear(); allocation_index_ = 0; next_qubit_index_ = 0; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_allocation_manager_8hpp/","text":"AllocationManager/AllocationManager.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::BasicAllocationManager struct microsoft::quantum::BasicAllocationManager::AllocatedMemoryBlock Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AllocationManager/IAllocationManager.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include <memory> #include <string> #include <unordered_map> #include <vector> namespace microsoft::quantum { class BasicAllocationManager : public IAllocationManager { public: struct AllocatedMemoryBlock { String name{\"\"}; Index count{0}; Address start{0}; Address end{0}; }; using Mappings = std::vector<AllocatedMemoryBlock>; using BasicAllocationManagerPtr = std::shared_ptr<BasicAllocationManager>; // Construction only allowed using smart pointer allocation through static functions. // Constructors are private to prevent // static BasicAllocationManagerPtr createNew(); // Allocation and release functions // Address allocate(String const& name = \"\", Index const& count = 1) override; void release(Address const& address) override; void reset() override; void setReuseRegisters(bool val); private: // Private constructors // BasicAllocationManager() = default; Index next_qubit_index_{0}; // Memory mapping // Mappings mappings_{}; Index allocation_index_{0}; // Configuration // bool reuse_qubits_{true}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"AllocationManager/AllocationManager.hpp"},{"location":"Api/Files/_allocation_manager_8hpp/#allocationmanagerallocationmanagerhpp","text":"","title":"AllocationManager/AllocationManager.hpp"},{"location":"Api/Files/_allocation_manager_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_allocation_manager_8hpp/#classes","text":"Name class microsoft::quantum::BasicAllocationManager struct microsoft::quantum::BasicAllocationManager::AllocatedMemoryBlock","title":"Classes"},{"location":"Api/Files/_allocation_manager_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AllocationManager/IAllocationManager.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include <memory> #include <string> #include <unordered_map> #include <vector> namespace microsoft::quantum { class BasicAllocationManager : public IAllocationManager { public: struct AllocatedMemoryBlock { String name{\"\"}; Index count{0}; Address start{0}; Address end{0}; }; using Mappings = std::vector<AllocatedMemoryBlock>; using BasicAllocationManagerPtr = std::shared_ptr<BasicAllocationManager>; // Construction only allowed using smart pointer allocation through static functions. // Constructors are private to prevent // static BasicAllocationManagerPtr createNew(); // Allocation and release functions // Address allocate(String const& name = \"\", Index const& count = 1) override; void release(Address const& address) override; void reset() override; void setReuseRegisters(bool val); private: // Private constructors // BasicAllocationManager() = default; Index next_qubit_index_{0}; // Memory mapping // Mappings mappings_{}; Index allocation_index_{0}; // Configuration // bool reuse_qubits_{true}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_any_pattern_8cpp/","text":"Rules/Patterns/AnyPattern.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" namespace microsoft::quantum { AnyPattern::AnyPattern() = default; AnyPattern::~AnyPattern() = default; bool AnyPattern::match(Value* instr, Captures& captures) const { return success(instr, captures); } AnyPattern::Child AnyPattern::copy() const { return std::make_shared<AnyPattern>(); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Patterns/AnyPattern.cpp"},{"location":"Api/Files/_any_pattern_8cpp/#rulespatternsanypatterncpp","text":"","title":"Rules/Patterns/AnyPattern.cpp"},{"location":"Api/Files/_any_pattern_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_any_pattern_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" namespace microsoft::quantum { AnyPattern::AnyPattern() = default; AnyPattern::~AnyPattern() = default; bool AnyPattern::match(Value* instr, Captures& captures) const { return success(instr, captures); } AnyPattern::Child AnyPattern::copy() const { return std::make_shared<AnyPattern>(); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_any_pattern_8hpp/","text":"Rules/Patterns/AnyPattern.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::AnyPattern Pattern that matches any operand. Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { class AnyPattern : public IOperandPrototype { public: // Constructors. // AnyPattern(); ~AnyPattern() override; // \"Any\" implementation of the member functions in IOperandPrototype. bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Patterns/AnyPattern.hpp"},{"location":"Api/Files/_any_pattern_8hpp/#rulespatternsanypatternhpp","text":"","title":"Rules/Patterns/AnyPattern.hpp"},{"location":"Api/Files/_any_pattern_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_any_pattern_8hpp/#classes","text":"Name class microsoft::quantum::AnyPattern Pattern that matches any operand.","title":"Classes"},{"location":"Api/Files/_any_pattern_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { class AnyPattern : public IOperandPrototype { public: // Constructors. // AnyPattern(); ~AnyPattern() override; // \"Any\" implementation of the member functions in IOperandPrototype. bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_basic_block_8cpp/","text":"Rules/Notation/BasicBlock.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr basicBlock() { auto ret = std::make_shared<BasicBlockPattern>(); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Notation/BasicBlock.cpp"},{"location":"Api/Files/_basic_block_8cpp/#rulesnotationbasicblockcpp","text":"","title":"Rules/Notation/BasicBlock.cpp"},{"location":"Api/Files/_basic_block_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_basic_block_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr basicBlock() { auto ret = std::make_shared<BasicBlockPattern>(); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_bit_cast_8cpp/","text":"Rules/Notation/BitCast.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr bitCast(IOperandPrototypePtr const& arg) { auto cast_pattern = std::make_shared<BitCastPattern>(); cast_pattern->addChild(arg); return static_cast<IOperandPrototypePtr>(cast_pattern); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Notation/BitCast.cpp"},{"location":"Api/Files/_bit_cast_8cpp/#rulesnotationbitcastcpp","text":"","title":"Rules/Notation/BitCast.cpp"},{"location":"Api/Files/_bit_cast_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_bit_cast_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr bitCast(IOperandPrototypePtr const& arg) { auto cast_pattern = std::make_shared<BitCastPattern>(); cast_pattern->addChild(arg); return static_cast<IOperandPrototypePtr>(cast_pattern); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_branch_8cpp/","text":"Rules/Notation/Branch.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr branch( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2) { auto branch_pattern = std::make_shared<BranchPattern>(); branch_pattern->addChild(cond); branch_pattern->addChild(arg1); branch_pattern->addChild(arg2); return static_cast<IOperandPrototypePtr>(branch_pattern); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Notation/Branch.cpp"},{"location":"Api/Files/_branch_8cpp/#rulesnotationbranchcpp","text":"","title":"Rules/Notation/Branch.cpp"},{"location":"Api/Files/_branch_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_branch_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr branch( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2) { auto branch_pattern = std::make_shared<BranchPattern>(); branch_pattern->addChild(cond); branch_pattern->addChild(arg1); branch_pattern->addChild(arg2); return static_cast<IOperandPrototypePtr>(branch_pattern); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_call_8hpp/","text":"Rules/Notation/Call.hpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; template <typename... Args> IOperandPrototypePtr call(std::string const& name, Args... args); } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Notation/Call.hpp"},{"location":"Api/Files/_call_8hpp/#rulesnotationcallhpp","text":"","title":"Rules/Notation/Call.hpp"},{"location":"Api/Files/_call_8hpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_call_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; template <typename... Args> IOperandPrototypePtr call(std::string const& name, Args... args); } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_call_8ipp/","text":"Rules/Notation/Call.ipp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; template <typename... Args> IOperandPrototypePtr call(std::string const &name, Args... args) { IOperandPrototypePtr ret = std::make_shared<CallPattern>(name); std::vector<IOperandPrototypePtr> arguments{args...}; // Adding arguments to matching for (auto &a : arguments) { ret->addChild(a); } // Function name is kept in the last operand ret->addChild(std::make_shared<AnyPattern>()); return ret; } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Notation/Call.ipp"},{"location":"Api/Files/_call_8ipp/#rulesnotationcallipp","text":"","title":"Rules/Notation/Call.ipp"},{"location":"Api/Files/_call_8ipp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_call_8ipp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; template <typename... Args> IOperandPrototypePtr call(std::string const &name, Args... args) { IOperandPrototypePtr ret = std::make_shared<CallPattern>(name); std::vector<IOperandPrototypePtr> arguments{args...}; // Adding arguments to matching for (auto &a : arguments) { ret->addChild(a); } // Function name is kept in the last operand ret->addChild(std::make_shared<AnyPattern>()); return ret; } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_call_by_name_only_8cpp/","text":"Rules/Notation/CallByNameOnly.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr callByNameOnly(std::string const& name) { IOperandPrototypePtr ret = std::make_shared<CallPattern>(name); return ret; } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Notation/CallByNameOnly.cpp"},{"location":"Api/Files/_call_by_name_only_8cpp/#rulesnotationcallbynameonlycpp","text":"","title":"Rules/Notation/CallByNameOnly.cpp"},{"location":"Api/Files/_call_by_name_only_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_call_by_name_only_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr callByNameOnly(std::string const& name) { IOperandPrototypePtr ret = std::make_shared<CallPattern>(name); return ret; } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_call_pattern_8cpp/","text":"Rules/Patterns/CallPattern.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" namespace microsoft::quantum { CallPattern::CallPattern(String const& name) : name_{name} { } CallPattern::~CallPattern() = default; bool CallPattern::match(Value* instr, Captures& captures) const { auto* call_instr = llvm::dyn_cast<llvm::CallBase>(instr); if (call_instr == nullptr) { return fail(instr, captures); } auto target_function = call_instr->getCalledFunction(); if (target_function == nullptr) { return fail(instr, captures); } auto name = target_function->getName(); if (name != name_) { return fail(instr, captures); } auto ret = success(instr, captures); return ret; } CallPattern::Child CallPattern::copy() const { auto ret = std::make_shared<CallPattern>(name_); ret->copyPropertiesFrom(*this); return ret; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Patterns/CallPattern.cpp"},{"location":"Api/Files/_call_pattern_8cpp/#rulespatternscallpatterncpp","text":"","title":"Rules/Patterns/CallPattern.cpp"},{"location":"Api/Files/_call_pattern_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_call_pattern_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" namespace microsoft::quantum { CallPattern::CallPattern(String const& name) : name_{name} { } CallPattern::~CallPattern() = default; bool CallPattern::match(Value* instr, Captures& captures) const { auto* call_instr = llvm::dyn_cast<llvm::CallBase>(instr); if (call_instr == nullptr) { return fail(instr, captures); } auto target_function = call_instr->getCalledFunction(); if (target_function == nullptr) { return fail(instr, captures); } auto name = target_function->getName(); if (name != name_) { return fail(instr, captures); } auto ret = success(instr, captures); return ret; } CallPattern::Child CallPattern::copy() const { auto ret = std::make_shared<CallPattern>(name_); ret->copyPropertiesFrom(*this); return ret; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_call_pattern_8hpp/","text":"Rules/Patterns/CallPattern.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::CallPattern Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { class CallPattern : public IOperandPrototype { public: using String = std::string; // Construction of the call pattern by name or move only. // explicit CallPattern(String const& name); CallPattern(CallPattern const& other) = delete; CallPattern(CallPattern&& other) = default; ~CallPattern() override; // Call implmenetation of the member functions in IOperandPrototype. // bool match(Value* instr, Captures& captures) const override; Child copy() const override; private: String name_{}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Patterns/CallPattern.hpp"},{"location":"Api/Files/_call_pattern_8hpp/#rulespatternscallpatternhpp","text":"","title":"Rules/Patterns/CallPattern.hpp"},{"location":"Api/Files/_call_pattern_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_call_pattern_8hpp/#classes","text":"Name class microsoft::quantum::CallPattern","title":"Classes"},{"location":"Api/Files/_call_pattern_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { class CallPattern : public IOperandPrototype { public: using String = std::string; // Construction of the call pattern by name or move only. // explicit CallPattern(String const& name); CallPattern(CallPattern const& other) = delete; CallPattern(CallPattern&& other) = default; ~CallPattern() override; // Call implmenetation of the member functions in IOperandPrototype. // bool match(Value* instr, Captures& captures) const override; Child copy() const override; private: String name_{}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_capture_8cpp/","text":"Rules/Notation/Capture.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; Capture::Capture(std::string const& name) : name_{name} { } IOperandPrototypePtr Capture::operator=(IOperandPrototypePtr const& other) // NOLINT { auto ret = other->copy(); ret->captureAs(name_); return ret; } Capture operator\"\"_cap(char const* name, std::size_t) { return Capture(name); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Notation/Capture.cpp"},{"location":"Api/Files/_capture_8cpp/#rulesnotationcapturecpp","text":"","title":"Rules/Notation/Capture.cpp"},{"location":"Api/Files/_capture_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_capture_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; Capture::Capture(std::string const& name) : name_{name} { } IOperandPrototypePtr Capture::operator=(IOperandPrototypePtr const& other) // NOLINT { auto ret = other->copy(); ret->captureAs(name_); return ret; } Capture operator\"\"_cap(char const* name, std::size_t) { return Capture(name); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_comment_logger_8cpp/","text":"Logging/CommentLogger.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Logging/CommentLogger.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include <vector> namespace microsoft::quantum { void CommentLogger::debug(String const& message) { llvm::errs() << \"debug - \" << location_.name() << \":\" << location_.line() << \",\" << location_.column() << \" - \" << message << \"\\n\"; } void CommentLogger::info(String const& message) { llvm::errs() << \"info - \" << location_.name() << \":\" << location_.line() << \",\" << location_.column() << \" - \" << message << \"\\n\"; } void CommentLogger::warning(String const& message) { setHasWarnings(true); llvm::errs() << \"warning - \" << location_.name() << \":\" << location_.line() << \",\" << location_.column() << \" - \" << message << \"\\n\"; } void CommentLogger::error(String const& message) { setHasErrors(true); llvm::errs() << \"error - \" << location_.name() << \":\" << location_.line() << \",\" << location_.column() << \" - \" << message << \"\\n\"; } void CommentLogger::internalError(String const& message) { setHasErrors(true); llvm::errs() << \"internal error - \" << location_.name() << \":\" << location_.line() << \",\" << location_.column() << \" - \" << message << \"\\n\"; } void CommentLogger::setLocation(SourceLocation const& loc) { location_ = loc; } void CommentLogger::setLlvmHint(String const&) {} void CommentLogger::setFrontendHint(String const&) {} } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Logging/CommentLogger.cpp"},{"location":"Api/Files/_comment_logger_8cpp/#loggingcommentloggercpp","text":"","title":"Logging/CommentLogger.cpp"},{"location":"Api/Files/_comment_logger_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_comment_logger_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Logging/CommentLogger.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include <vector> namespace microsoft::quantum { void CommentLogger::debug(String const& message) { llvm::errs() << \"debug - \" << location_.name() << \":\" << location_.line() << \",\" << location_.column() << \" - \" << message << \"\\n\"; } void CommentLogger::info(String const& message) { llvm::errs() << \"info - \" << location_.name() << \":\" << location_.line() << \",\" << location_.column() << \" - \" << message << \"\\n\"; } void CommentLogger::warning(String const& message) { setHasWarnings(true); llvm::errs() << \"warning - \" << location_.name() << \":\" << location_.line() << \",\" << location_.column() << \" - \" << message << \"\\n\"; } void CommentLogger::error(String const& message) { setHasErrors(true); llvm::errs() << \"error - \" << location_.name() << \":\" << location_.line() << \",\" << location_.column() << \" - \" << message << \"\\n\"; } void CommentLogger::internalError(String const& message) { setHasErrors(true); llvm::errs() << \"internal error - \" << location_.name() << \":\" << location_.line() << \",\" << location_.column() << \" - \" << message << \"\\n\"; } void CommentLogger::setLocation(SourceLocation const& loc) { location_ = loc; } void CommentLogger::setLlvmHint(String const&) {} void CommentLogger::setFrontendHint(String const&) {} } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_comment_logger_8hpp/","text":"Logging/CommentLogger.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::CommentLogger Concrete ILogger implementation that prints all messages as IR comments to llvm::errs(). Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Logging/SourceLocation.hpp\" #include <vector> namespace microsoft::quantum { class CommentLogger : public ILogger { public: // Interface implementation // void debug(String const& message) override; void info(String const& message) override; void warning(String const& message) override; void error(String const& message) override; void internalError(String const& message) override; void setLocation(SourceLocation const& loc) override; void setLlvmHint(String const& value) override; void setFrontendHint(String const& value) override; private: SourceLocation location_; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Logging/CommentLogger.hpp"},{"location":"Api/Files/_comment_logger_8hpp/#loggingcommentloggerhpp","text":"","title":"Logging/CommentLogger.hpp"},{"location":"Api/Files/_comment_logger_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_comment_logger_8hpp/#classes","text":"Name class microsoft::quantum::CommentLogger Concrete ILogger implementation that prints all messages as IR comments to llvm::errs().","title":"Classes"},{"location":"Api/Files/_comment_logger_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Logging/SourceLocation.hpp\" #include <vector> namespace microsoft::quantum { class CommentLogger : public ILogger { public: // Interface implementation // void debug(String const& message) override; void info(String const& message) override; void warning(String const& message) override; void error(String const& message) override; void internalError(String const& message) override; void setLocation(SourceLocation const& loc) override; void setLlvmHint(String const& value) override; void setFrontendHint(String const& value) override; private: SourceLocation location_; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_config_bind_8hpp/","text":"Commandline/ConfigBind.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ConfigBind Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/IConfigBind.hpp\" #include \"qir/qat/Commandline/ParameterParser.hpp\" #include \"qir/qat/Commandline/SerializationTraits.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include <iomanip> #include <iostream> #include <sstream> #include <stack> #include <type_traits> #include <typeindex> #include <vector> namespace microsoft::quantum { class OpcodeSet; template <typename T> class ConfigBind : public IConfigBind { public: using Type = typename std::decay<T>::type; using StringSet = std::unordered_set<std::string>; using StringList = std::vector<std::string>; template <typename A, typename B, typename R> using EnableIf = typename std::enable_if<std::is_same<A, B>::value, R>::type; // Constructors, operators and destructor // ConfigBind() = delete; ConfigBind(ConfigBind const&) = delete; ConfigBind(ConfigBind&&) = delete; ConfigBind& operator=(ConfigBind const&) = delete; ConfigBind& operator=(ConfigBind&&) = delete; ~ConfigBind() override = default; ConfigBind( Type& bind, T default_value, String const& name, String const& description, ParameterVisibility visibility = ParameterVisibility::CliAndConfig); // Marks the configuration as being experimental. void markAsExperimental(Type const& off_value); // Interface implementation // bool setupArguments(ParameterParser& parser) override; bool configure(ParameterParser& parser, bool experimental_mode) override; void reset() override; String value() override; void* pointer() const override; void* pointerDefaultValue() override; std::type_index valueType() const override; void setValueFromYamlNode(YAML::Node const& node) override; void updateValueInYamlNode(YAML::Node& node) override; private: template <typename A, typename R = A> using EnableIfSerializable = typename std::enable_if<HasQatSerializers<A>::VALUE, R>::type; template <typename A, typename R = A> using EnableIfNotSerializable = typename std::enable_if<!HasQatSerializers<A>::VALUE, R>::type; template <typename R> EnableIfNotSerializable<R, void> loadYaml(YAML::Node const& node, R& value); template <typename R> EnableIfNotSerializable<R, void> saveYaml(YAML::Node& node, R const& value); // Yaml serialization for data types with custom serializers template <typename R> EnableIfSerializable<R, void> loadYaml(YAML::Node const& node, R& value); template <typename R> EnableIfSerializable<R, void> saveYaml(YAML::Node& node, R const& value); // Yaml serialization for string sets void loadYaml(YAML::Node const& node, StringSet& value); void saveYaml(YAML::Node& node, StringSet const& value); // Yaml serialization for string lists void loadYaml(YAML::Node const& node, StringList& value); void saveYaml(YAML::Node& node, StringList const& value); // Yaml serialization for string maps void loadYaml(YAML::Node const& node, StringMap& value); void saveYaml(YAML::Node& node, StringMap const& value); template <typename R> bool setupArguments(ParameterParser&, R const&); bool setupArguments(ParameterParser& parser, bool const&); template <typename R> EnableIfNotSerializable<R, void> alterNameBasedOnType(R const& default_value); template <typename R> EnableIfSerializable<R, void> alterNameBasedOnType(R const& default_value); template <typename R> void nonSerializableTypeAlterName(R const& default_value); void nonSerializableTypeAlterName(bool const& default_value); void nonSerializableTypeAlterName(StringSet const& default_value); void nonSerializableTypeAlterName(StringList const& default_value); template <typename A> EnableIfNotSerializable<A, String> valueAsString(A const& val); // String serialization for data types with custom serializers template <typename A> EnableIfSerializable<A, String> valueAsString(A const&); void alterNameBasedOnType(StringMap const& default_value); template <typename A> String nonSerializableValueAsString(A const&); template <typename A> String nonSerializableValueAsString(EnableIf<A, bool, A> const&); template <typename A> String nonSerializableValueAsString(EnableIf<A, StringSet, A> const&); template <typename A> String nonSerializableValueAsString(EnableIf<A, StringList, A> const&); template <typename A> String valueAsString(EnableIf<A, StringMap, A> const&); template <typename A> EnableIfNotSerializable<A, void> loadValue(ParameterParser& parser, A const& default_value); template <typename A> EnableIfSerializable<A, void> loadValue(ParameterParser& parser, A const& default_value); template <typename A> void loadValue(ParameterParser& parser, EnableIf<A, bool, A> const& default_value); template <typename A> void loadValue(ParameterParser& parser, EnableIf<A, String, A> const& default_value); template <typename A> void loadValue(ParameterParser& parser, EnableIf<A, StringMap, A> const& default_value); void insertKeyValueInStringMap(StringMap& map, String const& part); template <typename A> void loadValue(ParameterParser& parser, EnableIf<A, StringSet, A> const& default_value); template <typename A> void loadValue(ParameterParser& parser, EnableIf<A, StringList, A> const& default_value); Type& bind_; Type default_value_; Type experimental_off_value_; }; template <typename T> ConfigBind<T>::ConfigBind( Type& bind, T default_value, String const& name, String const& description, ParameterVisibility visibility) : IConfigBind(name, description, visibility) , bind_{bind} , default_value_{std::move(default_value)} { alterNameBasedOnType(default_value_); } template <typename T> template <typename R> void ConfigBind<T>::nonSerializableTypeAlterName(R const& default_value) { std::stringstream ss{\"\"}; ss << default_value; setDefault(static_cast<String>(ss.str())); } template <typename T> void ConfigBind<T>::nonSerializableTypeAlterName(bool const& default_value) { markAsFlag(); if (default_value) { setDefault(\"true\"); } else { setDefault(\"false\"); } } template <typename T> void ConfigBind<T>::alterNameBasedOnType(StringMap const& /*default_value*/) { std::stringstream ss{\"\"}; bool not_first = true; for (auto const& p : bind_) { if (not_first) { ss << \",\"; } ss << p.first << \"=\" << p.second; } setDefault(static_cast<String>(ss.str())); } template <typename T> void ConfigBind<T>::nonSerializableTypeAlterName(StringSet const& /*default_value*/) { std::stringstream ss{\"\"}; bool not_first = false; for (auto const& p : bind_) { if (not_first) { ss << \",\"; } ss << p; not_first = true; } setDefault(static_cast<String>(ss.str())); } template <typename T> void ConfigBind<T>::nonSerializableTypeAlterName(StringList const& /*default_value*/) { std::stringstream ss{\"\"}; bool not_first = false; for (auto const& p : bind_) { if (not_first) { ss << \",\"; } ss << p; not_first = true; } setDefault(static_cast<String>(ss.str())); } template <typename T> bool ConfigBind<T>::setupArguments(ParameterParser& parser) { auto sn = shorthandNotation(); if (!sn.empty()) { parser.addShorthandNotation(name(), sn); } return setupArguments(parser, default_value_); } template <typename T> template <typename R> bool ConfigBind<T>::setupArguments(ParameterParser&, R const&) { return true; } template <typename T> bool ConfigBind<T>::setupArguments(ParameterParser& parser, bool const&) { parser.addFlag(name()); return true; } template <typename T> template <typename R> typename ConfigBind<T>::template EnableIfNotSerializable<R, void> ConfigBind<T>::alterNameBasedOnType( R const& default_value) { nonSerializableTypeAlterName(default_value); } template <typename T> template <typename R> typename ConfigBind<T>::template EnableIfSerializable<R, void> ConfigBind<T>::alterNameBasedOnType( R const& /*default_value*/) { String ret; bind_.toString(ret); setDefault(static_cast<String>(ret)); } template <typename T> void ConfigBind<T>::reset() { if (isExperimental()) { bind_ = experimental_off_value_; } else { bind_ = default_value_; } } template <typename T> bool ConfigBind<T>::configure(ParameterParser& parser, bool experimental_mode) { if (!isAvailableToCli()) { return false; } if (!isExperimental()) { // For non-experimental parameters we load the default value loadValue<Type>(parser, default_value_); } else { // If the parameter is experimental and we are in experimental mode if (experimental_mode) { // ... we load the default value loadValue<Type>(parser, default_value_); } else { // ... and else we load the experimental off value bind_ = experimental_off_value_; } } return true; } template <typename T> void ConfigBind<T>::markAsExperimental(Type const& off_value) { experimental_off_value_ = off_value; makeSettingExperimental(); } template <typename T> String ConfigBind<T>::value() { return valueAsString<Type>(default_value_); } template <typename T> template <typename A> typename ConfigBind<T>::template EnableIfNotSerializable<A, String> ConfigBind<T>::valueAsString(A const& val) { return nonSerializableValueAsString<A>(val); } template <typename T> template <typename A> typename ConfigBind<T>::template EnableIfSerializable<A, String> ConfigBind<T>::valueAsString(A const&) { String ret; bind_.toString(ret); return ret; } template <typename T> template <typename A> String ConfigBind<T>::nonSerializableValueAsString(A const&) { std::stringstream ss{\"\"}; ss << bind_; return static_cast<String>(ss.str()); } template <typename T> template <typename A> String ConfigBind<T>::nonSerializableValueAsString(EnableIf<A, bool, A> const&) { std::stringstream ss{\"\"}; ss << (bind_ ? \"true\" : \"false\"); return static_cast<String>(ss.str()); } template <typename T> template <typename A> String ConfigBind<T>::valueAsString(EnableIf<A, StringMap, A> const&) { std::stringstream ss{\"\"}; bool not_first = true; for (auto const& p : bind_) { if (not_first) { ss << \",\"; } ss << p.first << \"=\" << p.second; } return static_cast<String>(ss.str()); } template <typename T> template <typename A> String ConfigBind<T>::nonSerializableValueAsString(EnableIf<A, StringSet, A> const&) { std::stringstream ss{\"\"}; bool not_first = false; for (auto const& p : bind_) { if (not_first) { ss << \",\"; } ss << p; not_first = true; } return static_cast<String>(ss.str()); } template <typename T> template <typename A> String ConfigBind<T>::nonSerializableValueAsString(EnableIf<A, StringList, A> const&) { std::stringstream ss{\"\"}; bool not_first = false; for (auto const& p : bind_) { if (not_first) { ss << \",\"; } ss << p; not_first = true; } return static_cast<String>(ss.str()); } template <typename T> template <typename A> typename ConfigBind<T>::template EnableIfNotSerializable<A, void> ConfigBind<T>::loadValue( ParameterParser& parser, A const& /*default_value*/) { static_assert(!std::is_same<A, bool>::value, \"Expected bool to be specialised\"); static_assert(!std::is_same<A, StringSet>::value, \"Expected StringSet to be specialised\"); static_assert(!std::is_same<A, StringList>::value, \"Expected StringList to be specialised\"); static_assert(!std::is_same<A, String>::value, \"Expected String to be specialised\"); if (parser.has(name())) { std::stringstream ss{parser.get(name())}; ss >> bind_; } } template <typename T> template <typename A> void ConfigBind<T>::loadValue(ParameterParser& parser, EnableIf<A, bool, A> const& /*default_value*/) { if (parser.has(name())) { parser.markAsUsed(name()); bind_ = true; } else if (parser.has(\"no-\" + name())) { parser.markAsUsed(\"no-\" + name()); bind_ = false; } } template <typename T> template <typename A> void ConfigBind<T>::loadValue(ParameterParser& parser, EnableIf<A, String, A> const& /*default_value*/) { if (parser.has(name())) { bind_ = parser.get(name()); } } template <typename T> void ConfigBind<T>::insertKeyValueInStringMap(StringMap& map, String const& part) { auto q = part.find('='); String key{}; String value{}; if (q == String::npos) { llvm::errs() << \"= not found.\\n\"; key = part; } else { key = part.substr(0, q); value = part.substr(q + 1, part.size() - q - 1); } map[key] = value; } template <typename T> template <typename A> void ConfigBind<T>::loadValue(ParameterParser& parser, EnableIf<A, StringSet, A> const& /*default_value*/) { if (!parser.has(name())) { return; } auto value = parser.get(name()); bind_.clear(); std::size_t last_p = 0; auto p = value.find(',', last_p); while (p != String::npos) { auto part = value.substr(last_p, p - last_p); bind_.insert(part); last_p = p + 1; p = value.find(',', last_p); } if (last_p < value.size()) { auto part = value.substr(last_p, p - last_p); bind_.insert(part); } } template <typename T> template <typename A> void ConfigBind<T>::loadValue(ParameterParser& parser, EnableIf<A, StringList, A> const& /*default_value*/) { if (!parser.has(name())) { return; } auto value = parser.get(name()); bind_.clear(); std::size_t last_p = 0; auto p = value.find(',', last_p); while (p != String::npos) { auto part = value.substr(last_p, p - last_p); bind_.push_back(part); last_p = p + 1; p = value.find(',', last_p); } if (last_p < value.size()) { auto part = value.substr(last_p, p - last_p); bind_.push_back(part); } } template <typename T> template <typename A> void ConfigBind<T>::loadValue(ParameterParser& parser, EnableIf<A, StringMap, A> const& /*default_value*/) { if (!parser.has(name())) { return; } auto value = parser.get(name()); bind_.clear(); std::size_t last_p = 0; auto p = value.find(',', last_p); while (p != String::npos) { auto part = value.substr(last_p, p - last_p); insertKeyValueInStringMap(bind_, part); last_p = p + 1; p = value.find(',', last_p); } if (last_p < value.size()) { auto part = value.substr(last_p, p - last_p); insertKeyValueInStringMap(bind_, part); } } template <typename T> template <typename A> typename ConfigBind<T>::template EnableIfSerializable<A, void> ConfigBind<T>::loadValue( ParameterParser& parser, A const& /*default_value*/) { if (!parser.has(name())) { return; } auto value = parser.get(name()); bind_.fromString(value); } template <typename T> void* ConfigBind<T>::pointer() const { return static_cast<void*>(&bind_); } template <typename T> void* ConfigBind<T>::pointerDefaultValue() { return static_cast<void*>(&default_value_); } template <typename T> std::type_index ConfigBind<T>::valueType() const { return std::type_index(typeid(T)); } template <typename T> void ConfigBind<T>::setValueFromYamlNode(YAML::Node const& node) { if (isLoadAndSavable() && node && node[name()]) { loadYaml(node, bind_); } } template <typename T> void ConfigBind<T>::updateValueInYamlNode(YAML::Node& node) { if (isLoadAndSavable()) { saveYaml(node, bind_); } } template <typename T> template <typename R> typename ConfigBind<T>::template EnableIfNotSerializable<R, void> ConfigBind<T>::loadYaml( YAML::Node const& node, R& value) { value = node[name()].template as<T>(); } template <typename T> template <typename R> typename ConfigBind<T>::template EnableIfNotSerializable<R, void> ConfigBind<T>::saveYaml( YAML::Node& node, R const& value) { node[name()] = value; } template <typename T> void ConfigBind<T>::loadYaml(YAML::Node const& node, StringSet& value) { for (auto& v : node[name()]) { value.insert(v.template as<String>()); } } template <typename T> void ConfigBind<T>::loadYaml(YAML::Node const& node, StringList& value) { for (auto& v : node[name()]) { value.push_back(v.template as<String>()); } } template <typename T> void ConfigBind<T>::saveYaml(YAML::Node& node, StringSet const& value) { YAML::Node list; for (auto& v : value) { list.push_back(v); } node[name()] = list; } template <typename T> void ConfigBind<T>::saveYaml(YAML::Node& node, StringList const& value) { YAML::Node list; for (auto& v : value) { list.push_back(v); } node[name()] = list; } template <typename T> void ConfigBind<T>::loadYaml(YAML::Node const& node, StringMap& value) { for (auto& v : node[name()]) { value[v.first.template as<String>()] = v.second.template as<String>(); } } template <typename T> void ConfigBind<T>::saveYaml(YAML::Node& node, StringMap const& value) { YAML::Node ret; for (auto& v : value) { ret[v.first] = v.second; } node[name()] = ret; } template <typename T> template <typename R> typename ConfigBind<T>::template EnableIfSerializable<R, void> ConfigBind<T>::loadYaml(YAML::Node const& node, R& value) { value.fromYaml(node[name()]); } template <typename T> template <typename R> typename ConfigBind<T>::template EnableIfSerializable<R, void> ConfigBind<T>::saveYaml(YAML::Node& node, R const& value) { YAML::Node val; value.toYaml(val); node[name()] = val; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Commandline/ConfigBind.hpp"},{"location":"Api/Files/_config_bind_8hpp/#commandlineconfigbindhpp","text":"","title":"Commandline/ConfigBind.hpp"},{"location":"Api/Files/_config_bind_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_config_bind_8hpp/#classes","text":"Name class microsoft::quantum::ConfigBind","title":"Classes"},{"location":"Api/Files/_config_bind_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/IConfigBind.hpp\" #include \"qir/qat/Commandline/ParameterParser.hpp\" #include \"qir/qat/Commandline/SerializationTraits.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include <iomanip> #include <iostream> #include <sstream> #include <stack> #include <type_traits> #include <typeindex> #include <vector> namespace microsoft::quantum { class OpcodeSet; template <typename T> class ConfigBind : public IConfigBind { public: using Type = typename std::decay<T>::type; using StringSet = std::unordered_set<std::string>; using StringList = std::vector<std::string>; template <typename A, typename B, typename R> using EnableIf = typename std::enable_if<std::is_same<A, B>::value, R>::type; // Constructors, operators and destructor // ConfigBind() = delete; ConfigBind(ConfigBind const&) = delete; ConfigBind(ConfigBind&&) = delete; ConfigBind& operator=(ConfigBind const&) = delete; ConfigBind& operator=(ConfigBind&&) = delete; ~ConfigBind() override = default; ConfigBind( Type& bind, T default_value, String const& name, String const& description, ParameterVisibility visibility = ParameterVisibility::CliAndConfig); // Marks the configuration as being experimental. void markAsExperimental(Type const& off_value); // Interface implementation // bool setupArguments(ParameterParser& parser) override; bool configure(ParameterParser& parser, bool experimental_mode) override; void reset() override; String value() override; void* pointer() const override; void* pointerDefaultValue() override; std::type_index valueType() const override; void setValueFromYamlNode(YAML::Node const& node) override; void updateValueInYamlNode(YAML::Node& node) override; private: template <typename A, typename R = A> using EnableIfSerializable = typename std::enable_if<HasQatSerializers<A>::VALUE, R>::type; template <typename A, typename R = A> using EnableIfNotSerializable = typename std::enable_if<!HasQatSerializers<A>::VALUE, R>::type; template <typename R> EnableIfNotSerializable<R, void> loadYaml(YAML::Node const& node, R& value); template <typename R> EnableIfNotSerializable<R, void> saveYaml(YAML::Node& node, R const& value); // Yaml serialization for data types with custom serializers template <typename R> EnableIfSerializable<R, void> loadYaml(YAML::Node const& node, R& value); template <typename R> EnableIfSerializable<R, void> saveYaml(YAML::Node& node, R const& value); // Yaml serialization for string sets void loadYaml(YAML::Node const& node, StringSet& value); void saveYaml(YAML::Node& node, StringSet const& value); // Yaml serialization for string lists void loadYaml(YAML::Node const& node, StringList& value); void saveYaml(YAML::Node& node, StringList const& value); // Yaml serialization for string maps void loadYaml(YAML::Node const& node, StringMap& value); void saveYaml(YAML::Node& node, StringMap const& value); template <typename R> bool setupArguments(ParameterParser&, R const&); bool setupArguments(ParameterParser& parser, bool const&); template <typename R> EnableIfNotSerializable<R, void> alterNameBasedOnType(R const& default_value); template <typename R> EnableIfSerializable<R, void> alterNameBasedOnType(R const& default_value); template <typename R> void nonSerializableTypeAlterName(R const& default_value); void nonSerializableTypeAlterName(bool const& default_value); void nonSerializableTypeAlterName(StringSet const& default_value); void nonSerializableTypeAlterName(StringList const& default_value); template <typename A> EnableIfNotSerializable<A, String> valueAsString(A const& val); // String serialization for data types with custom serializers template <typename A> EnableIfSerializable<A, String> valueAsString(A const&); void alterNameBasedOnType(StringMap const& default_value); template <typename A> String nonSerializableValueAsString(A const&); template <typename A> String nonSerializableValueAsString(EnableIf<A, bool, A> const&); template <typename A> String nonSerializableValueAsString(EnableIf<A, StringSet, A> const&); template <typename A> String nonSerializableValueAsString(EnableIf<A, StringList, A> const&); template <typename A> String valueAsString(EnableIf<A, StringMap, A> const&); template <typename A> EnableIfNotSerializable<A, void> loadValue(ParameterParser& parser, A const& default_value); template <typename A> EnableIfSerializable<A, void> loadValue(ParameterParser& parser, A const& default_value); template <typename A> void loadValue(ParameterParser& parser, EnableIf<A, bool, A> const& default_value); template <typename A> void loadValue(ParameterParser& parser, EnableIf<A, String, A> const& default_value); template <typename A> void loadValue(ParameterParser& parser, EnableIf<A, StringMap, A> const& default_value); void insertKeyValueInStringMap(StringMap& map, String const& part); template <typename A> void loadValue(ParameterParser& parser, EnableIf<A, StringSet, A> const& default_value); template <typename A> void loadValue(ParameterParser& parser, EnableIf<A, StringList, A> const& default_value); Type& bind_; Type default_value_; Type experimental_off_value_; }; template <typename T> ConfigBind<T>::ConfigBind( Type& bind, T default_value, String const& name, String const& description, ParameterVisibility visibility) : IConfigBind(name, description, visibility) , bind_{bind} , default_value_{std::move(default_value)} { alterNameBasedOnType(default_value_); } template <typename T> template <typename R> void ConfigBind<T>::nonSerializableTypeAlterName(R const& default_value) { std::stringstream ss{\"\"}; ss << default_value; setDefault(static_cast<String>(ss.str())); } template <typename T> void ConfigBind<T>::nonSerializableTypeAlterName(bool const& default_value) { markAsFlag(); if (default_value) { setDefault(\"true\"); } else { setDefault(\"false\"); } } template <typename T> void ConfigBind<T>::alterNameBasedOnType(StringMap const& /*default_value*/) { std::stringstream ss{\"\"}; bool not_first = true; for (auto const& p : bind_) { if (not_first) { ss << \",\"; } ss << p.first << \"=\" << p.second; } setDefault(static_cast<String>(ss.str())); } template <typename T> void ConfigBind<T>::nonSerializableTypeAlterName(StringSet const& /*default_value*/) { std::stringstream ss{\"\"}; bool not_first = false; for (auto const& p : bind_) { if (not_first) { ss << \",\"; } ss << p; not_first = true; } setDefault(static_cast<String>(ss.str())); } template <typename T> void ConfigBind<T>::nonSerializableTypeAlterName(StringList const& /*default_value*/) { std::stringstream ss{\"\"}; bool not_first = false; for (auto const& p : bind_) { if (not_first) { ss << \",\"; } ss << p; not_first = true; } setDefault(static_cast<String>(ss.str())); } template <typename T> bool ConfigBind<T>::setupArguments(ParameterParser& parser) { auto sn = shorthandNotation(); if (!sn.empty()) { parser.addShorthandNotation(name(), sn); } return setupArguments(parser, default_value_); } template <typename T> template <typename R> bool ConfigBind<T>::setupArguments(ParameterParser&, R const&) { return true; } template <typename T> bool ConfigBind<T>::setupArguments(ParameterParser& parser, bool const&) { parser.addFlag(name()); return true; } template <typename T> template <typename R> typename ConfigBind<T>::template EnableIfNotSerializable<R, void> ConfigBind<T>::alterNameBasedOnType( R const& default_value) { nonSerializableTypeAlterName(default_value); } template <typename T> template <typename R> typename ConfigBind<T>::template EnableIfSerializable<R, void> ConfigBind<T>::alterNameBasedOnType( R const& /*default_value*/) { String ret; bind_.toString(ret); setDefault(static_cast<String>(ret)); } template <typename T> void ConfigBind<T>::reset() { if (isExperimental()) { bind_ = experimental_off_value_; } else { bind_ = default_value_; } } template <typename T> bool ConfigBind<T>::configure(ParameterParser& parser, bool experimental_mode) { if (!isAvailableToCli()) { return false; } if (!isExperimental()) { // For non-experimental parameters we load the default value loadValue<Type>(parser, default_value_); } else { // If the parameter is experimental and we are in experimental mode if (experimental_mode) { // ... we load the default value loadValue<Type>(parser, default_value_); } else { // ... and else we load the experimental off value bind_ = experimental_off_value_; } } return true; } template <typename T> void ConfigBind<T>::markAsExperimental(Type const& off_value) { experimental_off_value_ = off_value; makeSettingExperimental(); } template <typename T> String ConfigBind<T>::value() { return valueAsString<Type>(default_value_); } template <typename T> template <typename A> typename ConfigBind<T>::template EnableIfNotSerializable<A, String> ConfigBind<T>::valueAsString(A const& val) { return nonSerializableValueAsString<A>(val); } template <typename T> template <typename A> typename ConfigBind<T>::template EnableIfSerializable<A, String> ConfigBind<T>::valueAsString(A const&) { String ret; bind_.toString(ret); return ret; } template <typename T> template <typename A> String ConfigBind<T>::nonSerializableValueAsString(A const&) { std::stringstream ss{\"\"}; ss << bind_; return static_cast<String>(ss.str()); } template <typename T> template <typename A> String ConfigBind<T>::nonSerializableValueAsString(EnableIf<A, bool, A> const&) { std::stringstream ss{\"\"}; ss << (bind_ ? \"true\" : \"false\"); return static_cast<String>(ss.str()); } template <typename T> template <typename A> String ConfigBind<T>::valueAsString(EnableIf<A, StringMap, A> const&) { std::stringstream ss{\"\"}; bool not_first = true; for (auto const& p : bind_) { if (not_first) { ss << \",\"; } ss << p.first << \"=\" << p.second; } return static_cast<String>(ss.str()); } template <typename T> template <typename A> String ConfigBind<T>::nonSerializableValueAsString(EnableIf<A, StringSet, A> const&) { std::stringstream ss{\"\"}; bool not_first = false; for (auto const& p : bind_) { if (not_first) { ss << \",\"; } ss << p; not_first = true; } return static_cast<String>(ss.str()); } template <typename T> template <typename A> String ConfigBind<T>::nonSerializableValueAsString(EnableIf<A, StringList, A> const&) { std::stringstream ss{\"\"}; bool not_first = false; for (auto const& p : bind_) { if (not_first) { ss << \",\"; } ss << p; not_first = true; } return static_cast<String>(ss.str()); } template <typename T> template <typename A> typename ConfigBind<T>::template EnableIfNotSerializable<A, void> ConfigBind<T>::loadValue( ParameterParser& parser, A const& /*default_value*/) { static_assert(!std::is_same<A, bool>::value, \"Expected bool to be specialised\"); static_assert(!std::is_same<A, StringSet>::value, \"Expected StringSet to be specialised\"); static_assert(!std::is_same<A, StringList>::value, \"Expected StringList to be specialised\"); static_assert(!std::is_same<A, String>::value, \"Expected String to be specialised\"); if (parser.has(name())) { std::stringstream ss{parser.get(name())}; ss >> bind_; } } template <typename T> template <typename A> void ConfigBind<T>::loadValue(ParameterParser& parser, EnableIf<A, bool, A> const& /*default_value*/) { if (parser.has(name())) { parser.markAsUsed(name()); bind_ = true; } else if (parser.has(\"no-\" + name())) { parser.markAsUsed(\"no-\" + name()); bind_ = false; } } template <typename T> template <typename A> void ConfigBind<T>::loadValue(ParameterParser& parser, EnableIf<A, String, A> const& /*default_value*/) { if (parser.has(name())) { bind_ = parser.get(name()); } } template <typename T> void ConfigBind<T>::insertKeyValueInStringMap(StringMap& map, String const& part) { auto q = part.find('='); String key{}; String value{}; if (q == String::npos) { llvm::errs() << \"= not found.\\n\"; key = part; } else { key = part.substr(0, q); value = part.substr(q + 1, part.size() - q - 1); } map[key] = value; } template <typename T> template <typename A> void ConfigBind<T>::loadValue(ParameterParser& parser, EnableIf<A, StringSet, A> const& /*default_value*/) { if (!parser.has(name())) { return; } auto value = parser.get(name()); bind_.clear(); std::size_t last_p = 0; auto p = value.find(',', last_p); while (p != String::npos) { auto part = value.substr(last_p, p - last_p); bind_.insert(part); last_p = p + 1; p = value.find(',', last_p); } if (last_p < value.size()) { auto part = value.substr(last_p, p - last_p); bind_.insert(part); } } template <typename T> template <typename A> void ConfigBind<T>::loadValue(ParameterParser& parser, EnableIf<A, StringList, A> const& /*default_value*/) { if (!parser.has(name())) { return; } auto value = parser.get(name()); bind_.clear(); std::size_t last_p = 0; auto p = value.find(',', last_p); while (p != String::npos) { auto part = value.substr(last_p, p - last_p); bind_.push_back(part); last_p = p + 1; p = value.find(',', last_p); } if (last_p < value.size()) { auto part = value.substr(last_p, p - last_p); bind_.push_back(part); } } template <typename T> template <typename A> void ConfigBind<T>::loadValue(ParameterParser& parser, EnableIf<A, StringMap, A> const& /*default_value*/) { if (!parser.has(name())) { return; } auto value = parser.get(name()); bind_.clear(); std::size_t last_p = 0; auto p = value.find(',', last_p); while (p != String::npos) { auto part = value.substr(last_p, p - last_p); insertKeyValueInStringMap(bind_, part); last_p = p + 1; p = value.find(',', last_p); } if (last_p < value.size()) { auto part = value.substr(last_p, p - last_p); insertKeyValueInStringMap(bind_, part); } } template <typename T> template <typename A> typename ConfigBind<T>::template EnableIfSerializable<A, void> ConfigBind<T>::loadValue( ParameterParser& parser, A const& /*default_value*/) { if (!parser.has(name())) { return; } auto value = parser.get(name()); bind_.fromString(value); } template <typename T> void* ConfigBind<T>::pointer() const { return static_cast<void*>(&bind_); } template <typename T> void* ConfigBind<T>::pointerDefaultValue() { return static_cast<void*>(&default_value_); } template <typename T> std::type_index ConfigBind<T>::valueType() const { return std::type_index(typeid(T)); } template <typename T> void ConfigBind<T>::setValueFromYamlNode(YAML::Node const& node) { if (isLoadAndSavable() && node && node[name()]) { loadYaml(node, bind_); } } template <typename T> void ConfigBind<T>::updateValueInYamlNode(YAML::Node& node) { if (isLoadAndSavable()) { saveYaml(node, bind_); } } template <typename T> template <typename R> typename ConfigBind<T>::template EnableIfNotSerializable<R, void> ConfigBind<T>::loadYaml( YAML::Node const& node, R& value) { value = node[name()].template as<T>(); } template <typename T> template <typename R> typename ConfigBind<T>::template EnableIfNotSerializable<R, void> ConfigBind<T>::saveYaml( YAML::Node& node, R const& value) { node[name()] = value; } template <typename T> void ConfigBind<T>::loadYaml(YAML::Node const& node, StringSet& value) { for (auto& v : node[name()]) { value.insert(v.template as<String>()); } } template <typename T> void ConfigBind<T>::loadYaml(YAML::Node const& node, StringList& value) { for (auto& v : node[name()]) { value.push_back(v.template as<String>()); } } template <typename T> void ConfigBind<T>::saveYaml(YAML::Node& node, StringSet const& value) { YAML::Node list; for (auto& v : value) { list.push_back(v); } node[name()] = list; } template <typename T> void ConfigBind<T>::saveYaml(YAML::Node& node, StringList const& value) { YAML::Node list; for (auto& v : value) { list.push_back(v); } node[name()] = list; } template <typename T> void ConfigBind<T>::loadYaml(YAML::Node const& node, StringMap& value) { for (auto& v : node[name()]) { value[v.first.template as<String>()] = v.second.template as<String>(); } } template <typename T> void ConfigBind<T>::saveYaml(YAML::Node& node, StringMap const& value) { YAML::Node ret; for (auto& v : value) { ret[v.first] = v.second; } node[name()] = ret; } template <typename T> template <typename R> typename ConfigBind<T>::template EnableIfSerializable<R, void> ConfigBind<T>::loadYaml(YAML::Node const& node, R& value) { value.fromYaml(node[name()]); } template <typename T> template <typename R> typename ConfigBind<T>::template EnableIfSerializable<R, void> ConfigBind<T>::saveYaml(YAML::Node& node, R const& value) { YAML::Node val; value.toYaml(val); node[name()] = val; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_configurable_qir_adaptor_factory_8cpp/","text":"AdaptorFactory/ConfigurableQirAdaptorFactory.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AdaptorFactory/ConfigurableQirAdaptorFactory.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/Factory.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/TargetQisMappingPass.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/TargetQisMappingPassConfiguration.hpp\" #include \"qir/qat/Rules/RuleSet.hpp\" #include <iostream> namespace microsoft::quantum { ConfigurableQirAdaptorFactory::ConfigurableQirAdaptorFactory( ConfigurationManager& configuration_manager, SetupMode const& mode) : QirAdaptorFactory(configuration_manager) { configurationManager().addConfig<TargetProfileConfiguration>(\"target.profile\"); configurationManager().addConfig<TargetQisConfiguration>(\"target.qis\"); if (mode == SetupMode::SetupPipeline) { setupDefaultComponentPipeline(); } } ConfigurableQirAdaptorFactory::ConfigurableQirAdaptorFactory( ConfigurationManager& configuration_manager, ConfigureFunction const& configure, TargetQisMappingPassConfiguration const& adaptor_pass_config, LlvmPassesConfiguration const& llvm_config) : QirAdaptorFactory(configuration_manager) { configurationManager().addConfig<TargetProfileConfiguration>(\"target.profile\"); configurationManager().addConfig<TargetQisConfiguration>(\"target.qis\"); setupDefaultComponentPipeline(); replaceAdaptorComponent<TargetQisMappingPassConfiguration>( \"adaptor.target-qis-mapping\", [configure](TargetQisMappingPassConfiguration const& config, QirAdaptor& adaptor) { auto& ret = adaptor.modulePassManager(); // Defining the mapping RuleSet rule_set; auto factory = RuleFactory( rule_set, adaptor.getQubitAllocationManager(), adaptor.getResultAllocationManager(), nullptr); configure(rule_set); // Creating adaptor pass ret.addPass(TargetQisMappingPass(std::move(rule_set), config)); }); configurationManager().setConfig(adaptor_pass_config); configurationManager().setConfig(llvm_config); } TargetQisMappingPassConfiguration const& ConfigurableQirAdaptorFactory::ruleTransformationConfig() const { return configurationManager().get<TargetQisMappingPassConfiguration>(); } LlvmPassesConfiguration const& ConfigurableQirAdaptorFactory::llvmPassesConfig() const { return configurationManager().get<LlvmPassesConfiguration>(); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"AdaptorFactory/ConfigurableQirAdaptorFactory.cpp"},{"location":"Api/Files/_configurable_qir_adaptor_factory_8cpp/#adaptorfactoryconfigurableqiradaptorfactorycpp","text":"","title":"AdaptorFactory/ConfigurableQirAdaptorFactory.cpp"},{"location":"Api/Files/_configurable_qir_adaptor_factory_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_configurable_qir_adaptor_factory_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AdaptorFactory/ConfigurableQirAdaptorFactory.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/Factory.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/TargetQisMappingPass.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/TargetQisMappingPassConfiguration.hpp\" #include \"qir/qat/Rules/RuleSet.hpp\" #include <iostream> namespace microsoft::quantum { ConfigurableQirAdaptorFactory::ConfigurableQirAdaptorFactory( ConfigurationManager& configuration_manager, SetupMode const& mode) : QirAdaptorFactory(configuration_manager) { configurationManager().addConfig<TargetProfileConfiguration>(\"target.profile\"); configurationManager().addConfig<TargetQisConfiguration>(\"target.qis\"); if (mode == SetupMode::SetupPipeline) { setupDefaultComponentPipeline(); } } ConfigurableQirAdaptorFactory::ConfigurableQirAdaptorFactory( ConfigurationManager& configuration_manager, ConfigureFunction const& configure, TargetQisMappingPassConfiguration const& adaptor_pass_config, LlvmPassesConfiguration const& llvm_config) : QirAdaptorFactory(configuration_manager) { configurationManager().addConfig<TargetProfileConfiguration>(\"target.profile\"); configurationManager().addConfig<TargetQisConfiguration>(\"target.qis\"); setupDefaultComponentPipeline(); replaceAdaptorComponent<TargetQisMappingPassConfiguration>( \"adaptor.target-qis-mapping\", [configure](TargetQisMappingPassConfiguration const& config, QirAdaptor& adaptor) { auto& ret = adaptor.modulePassManager(); // Defining the mapping RuleSet rule_set; auto factory = RuleFactory( rule_set, adaptor.getQubitAllocationManager(), adaptor.getResultAllocationManager(), nullptr); configure(rule_set); // Creating adaptor pass ret.addPass(TargetQisMappingPass(std::move(rule_set), config)); }); configurationManager().setConfig(adaptor_pass_config); configurationManager().setConfig(llvm_config); } TargetQisMappingPassConfiguration const& ConfigurableQirAdaptorFactory::ruleTransformationConfig() const { return configurationManager().get<TargetQisMappingPassConfiguration>(); } LlvmPassesConfiguration const& ConfigurableQirAdaptorFactory::llvmPassesConfig() const { return configurationManager().get<LlvmPassesConfiguration>(); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_configurable_qir_adaptor_factory_8hpp/","text":"AdaptorFactory/ConfigurableQirAdaptorFactory.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ConfigurableQirAdaptorFactory Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AdaptorFactory/LlvmPassesConfiguration.hpp\" #include \"qir/qat/AdaptorFactory/QirAdaptorFactory.hpp\" #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/TargetQisMappingPassConfiguration.hpp\" #include \"qir/qat/Rules/RuleSet.hpp\" namespace microsoft::quantum { class ConfigurableQirAdaptorFactory : public QirAdaptorFactory { public: using ConfigureFunction = std::function<void(RuleSet&)>; enum class SetupMode { DoNothing, SetupPipeline }; explicit ConfigurableQirAdaptorFactory( ConfigurationManager& configuration_manager, SetupMode const& mode = SetupMode::SetupPipeline); explicit ConfigurableQirAdaptorFactory( ConfigurationManager& configuration_manager, ConfigureFunction const& configure, TargetQisMappingPassConfiguration const& adaptor_pass_config = TargetQisMappingPassConfiguration::createDisabled(), LlvmPassesConfiguration const& llvm_config = LlvmPassesConfiguration::createDisabled()); // Shorthand notation to access configurations // TargetQisMappingPassConfiguration const& ruleTransformationConfig() const; LlvmPassesConfiguration const& llvmPassesConfig() const; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"AdaptorFactory/ConfigurableQirAdaptorFactory.hpp"},{"location":"Api/Files/_configurable_qir_adaptor_factory_8hpp/#adaptorfactoryconfigurableqiradaptorfactoryhpp","text":"","title":"AdaptorFactory/ConfigurableQirAdaptorFactory.hpp"},{"location":"Api/Files/_configurable_qir_adaptor_factory_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_configurable_qir_adaptor_factory_8hpp/#classes","text":"Name class microsoft::quantum::ConfigurableQirAdaptorFactory","title":"Classes"},{"location":"Api/Files/_configurable_qir_adaptor_factory_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AdaptorFactory/LlvmPassesConfiguration.hpp\" #include \"qir/qat/AdaptorFactory/QirAdaptorFactory.hpp\" #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/TargetQisMappingPassConfiguration.hpp\" #include \"qir/qat/Rules/RuleSet.hpp\" namespace microsoft::quantum { class ConfigurableQirAdaptorFactory : public QirAdaptorFactory { public: using ConfigureFunction = std::function<void(RuleSet&)>; enum class SetupMode { DoNothing, SetupPipeline }; explicit ConfigurableQirAdaptorFactory( ConfigurationManager& configuration_manager, SetupMode const& mode = SetupMode::SetupPipeline); explicit ConfigurableQirAdaptorFactory( ConfigurationManager& configuration_manager, ConfigureFunction const& configure, TargetQisMappingPassConfiguration const& adaptor_pass_config = TargetQisMappingPassConfiguration::createDisabled(), LlvmPassesConfiguration const& llvm_config = LlvmPassesConfiguration::createDisabled()); // Shorthand notation to access configurations // TargetQisMappingPassConfiguration const& ruleTransformationConfig() const; LlvmPassesConfiguration const& llvmPassesConfig() const; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_configuration_manager_8cpp/","text":"Commandline/ConfigurationManager.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/Commandline/SpecConfiguration.hpp\" #include \"yaml-cpp/yaml.h\" #include <fstream> using namespace microsoft::quantum; namespace microsoft::quantum { ConfigurationManager::ConfigurationManager() { addConfig<SpecConfiguration>(\"spec\"); } void ConfigurationManager::setupArguments(ParameterParser& parser) { for (auto& section : config_sections_) { // Skipping sections that are not meant to be disablable if (!section.can_disable) { continue; } // Ensuring that we are only using the last of the section id. // This means 'adaptor.grouping' becomes 'grouping' String id = section.id; auto p = id.find('.'); if (p != String::npos) { id = id.substr(p + 1, id.size() - p - 1); } // Adding enable or disable parameters for sections if (section.enabled_by_default) { parser.addFlag(\"disable-\" + id); } else { parser.addFlag(\"enable-\" + id); } } // Adding parameters for each section for (auto& section : config_sections_) { for (auto& c : section.settings) { // Resets the value to the default value c->reset(); // Setting arguments up if (!c->setupArguments(parser)) { throw std::runtime_error(\"Failed to set parser arguments up.\"); } } } } void ConfigurationManager::configure(ParameterParser& parser, bool experimental_mode) { for (auto& section : config_sections_) { // Skipping sections that are not meant to be disabled if (!section.can_disable) { *section.active = true; continue; } // Ensuring that we are only using the last of the section id. // This means 'adaptor.grouping' becomes 'grouping' String id = section.id; auto p = id.find('.'); if (p != String::npos) { id = id.substr(p + 1, id.size() - p - 1); } // Teesting if the section should be enabled or disabled if (section.enabled_by_default || parser.has(\"disable-\" + id)) { *section.active = (parser.get(\"disable-\" + id, \"false\") != \"true\"); } else { *section.active = (parser.get(\"enable-\" + id, \"false\") == \"true\"); } } for (auto& section : config_sections_) { for (auto& c : section.settings) { // Skipping those parameters which are not available to the // commandline interface for configuration if (!c->isAvailableToCli()) { continue; } // Configuring the paramter if (!c->configure(parser, experimental_mode)) { throw std::runtime_error(\"Failed configure the section.\"); } } } } void ConfigurationManager::printHelp(bool experimental_mode) const { std::cout << std::setfill(' '); // Enable or disable components std::cout << std::endl; std::cout << \"Component configuration\" << \" - \"; std::cout << \"Used to disable or enable components\" << std::endl; std::cout << std::endl; for (auto& section : config_sections_) { // Skipping sections that are not meant to be disabled if (!section.can_disable) { *section.active = true; continue; } // Ensuring that we are only using the last of the section id. // This means 'adaptor.grouping' becomes 'grouping' String id = section.id; auto p = id.find('.'); if (p != String::npos) { id = id.substr(p + 1, id.size() - p - 1); } // Creating sections for non-empty section ids if (!id.empty()) { if (section.enabled_by_default) { std::cout << std::setw(50) << std::left << (\"--disable-\" + id) << \"Disables \" << section.name << \". \"; std::cout << \"Default: false\" << std::endl; } else { std::cout << std::setw(50) << std::left << (\"--enable-\" + id) << \"Enables \" << section.name << \". \"; std::cout << \"Default: false\" << std::endl; } } } // Component configuration for (auto& section : config_sections_) { bool ignore = true; // Checking if this section has any CLI available configurations for (auto& c : section.settings) { if (!c->isAvailableToCli()) { continue; } if (c->isExperimental() && !experimental_mode) { continue; } ignore = false; break; } // Skipping to next section if there is nothing to show if (ignore) { continue; } std::cout << std::endl; std::cout << section.name; if (!section.description.empty()) { std::cout << \" - \" << section.description; } std::cout << std::endl << std::endl; for (auto& c : section.settings) { // Skipping those parameters which are not available to the // commandline interface for configuration if (!c->isAvailableToCli()) { continue; } // Skipping experimental parameters unless if we are in experimental // mode. if (c->isExperimental() && !experimental_mode) { continue; } String sn{\"\"}; if (!c->shorthandNotation().empty()) { sn = static_cast<String>(\", -\") + c->shorthandNotation(); } if (c->isFlag()) { if (c->defaultValue() == \"false\") { std::cout << std::setw(50) << std::left << (\"--\" + c->name() + sn); } else { std::cout << std::setw(50) << std::left << (\"--[no-]\" + c->name()); } } else { std::cout << std::setw(50) << std::left << (\"--\" + c->name() + sn); } if (c->isExperimental()) { std::cout << \"EXPERIMENTAL. \"; } std::cout << c->description() << \" \"; std::cout << \"Default: \" << c->defaultValue() << std::endl; } } } void ConfigurationManager::printConfiguration() const { std::cout << std::setfill('.'); std::cout << \"; # \" << \"Components\" << \"\\n\"; for (auto& section : config_sections_) { if (!section.id.empty()) { std::cout << \"; \" << std::setw(50) << std::left << (\"disable-\" + section.id) << \": \" << (*section.active ? \"false\" : \"true\") << \"\\n\"; } } std::cout << \"; \\n\"; for (auto& section : config_sections_) { std::cout << \"; # \" << section.name << \"\\n\"; for (auto& c : section.settings) { std::cout << \"; \" << std::setw(50) << std::left << c->name() << \": \" << c->value() << \"\\n\"; } std::cout << \"; \\n\"; } std::cout << std::flush; } void ConfigurationManager::addShorthandNotation(String const& parameter, String const& shorthand) { auto it = parameters_.find(parameter); if (it == parameters_.end()) { throw std::runtime_error(\"Parameter '\" + parameter + \"' not found.\"); } it->second->setShorthandNotation(shorthand); } void ConfigurationManager::setSectionName(String const& name, String const& description) { if (config_sections_.empty()) { throw std::runtime_error(\"No section created yet.\"); } config_sections_.back().name = name; config_sections_.back().description = description; } void ConfigurationManager::disableSectionByDefault() { if (config_sections_.empty()) { throw std::runtime_error(\"No section created yet.\"); } config_sections_.back().enabled_by_default = false; } void ConfigurationManager::disableSectionById(String const& id) { for (auto& section : config_sections_) { if (section.id == id) { section.enabled_by_default = false; return; } } throw std::runtime_error(\"Section '\" + id + \"' not found\"); } void ConfigurationManager::enableSectionById(String const& id) { for (auto& section : config_sections_) { if (section.id == id) { section.enabled_by_default = true; return; } } throw std::runtime_error(\"Section '\" + id + \"' not found\"); } void ConfigurationManager::allowDisableSectionById(String const& id) { for (auto& section : config_sections_) { if (section.id == id) { section.can_disable = true; return; } } throw std::runtime_error(\"Section '\" + id + \"' not found\"); } DeferredValue::DeferredValuePtr ConfigurationManager::getParameter(String const& name) { auto it = deferred_refs_.find(name); if (it != deferred_refs_.end()) { return it->second; } auto ret = DeferredValue::create(); deferred_refs_[name] = ret; auto it2 = parameters_.find(name); if (it2 != parameters_.end()) { ret->setReference(it2->second); } return ret; } void ConfigurationManager::loadConfig(String const& filename) { YAML::Node config = YAML::LoadFile(filename); for (auto& section : config_sections_) { auto node = getNodeFromPath(config, section.id); if (node) { for (auto& c : section.settings) { c->setValueFromYamlNode(node); } } } } void ConfigurationManager::saveConfig(String const& filename) { YAML::Node ret; for (auto& section : config_sections_) { if (section.id.empty()) { continue; } YAML::Node config; for (auto& c : section.settings) { c->updateValueInYamlNode(config); } setNodeFromPath(ret, section.id, config); } std::ofstream fout(filename); fout << ret; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Commandline/ConfigurationManager.cpp"},{"location":"Api/Files/_configuration_manager_8cpp/#commandlineconfigurationmanagercpp","text":"","title":"Commandline/ConfigurationManager.cpp"},{"location":"Api/Files/_configuration_manager_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_configuration_manager_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/Commandline/SpecConfiguration.hpp\" #include \"yaml-cpp/yaml.h\" #include <fstream> using namespace microsoft::quantum; namespace microsoft::quantum { ConfigurationManager::ConfigurationManager() { addConfig<SpecConfiguration>(\"spec\"); } void ConfigurationManager::setupArguments(ParameterParser& parser) { for (auto& section : config_sections_) { // Skipping sections that are not meant to be disablable if (!section.can_disable) { continue; } // Ensuring that we are only using the last of the section id. // This means 'adaptor.grouping' becomes 'grouping' String id = section.id; auto p = id.find('.'); if (p != String::npos) { id = id.substr(p + 1, id.size() - p - 1); } // Adding enable or disable parameters for sections if (section.enabled_by_default) { parser.addFlag(\"disable-\" + id); } else { parser.addFlag(\"enable-\" + id); } } // Adding parameters for each section for (auto& section : config_sections_) { for (auto& c : section.settings) { // Resets the value to the default value c->reset(); // Setting arguments up if (!c->setupArguments(parser)) { throw std::runtime_error(\"Failed to set parser arguments up.\"); } } } } void ConfigurationManager::configure(ParameterParser& parser, bool experimental_mode) { for (auto& section : config_sections_) { // Skipping sections that are not meant to be disabled if (!section.can_disable) { *section.active = true; continue; } // Ensuring that we are only using the last of the section id. // This means 'adaptor.grouping' becomes 'grouping' String id = section.id; auto p = id.find('.'); if (p != String::npos) { id = id.substr(p + 1, id.size() - p - 1); } // Teesting if the section should be enabled or disabled if (section.enabled_by_default || parser.has(\"disable-\" + id)) { *section.active = (parser.get(\"disable-\" + id, \"false\") != \"true\"); } else { *section.active = (parser.get(\"enable-\" + id, \"false\") == \"true\"); } } for (auto& section : config_sections_) { for (auto& c : section.settings) { // Skipping those parameters which are not available to the // commandline interface for configuration if (!c->isAvailableToCli()) { continue; } // Configuring the paramter if (!c->configure(parser, experimental_mode)) { throw std::runtime_error(\"Failed configure the section.\"); } } } } void ConfigurationManager::printHelp(bool experimental_mode) const { std::cout << std::setfill(' '); // Enable or disable components std::cout << std::endl; std::cout << \"Component configuration\" << \" - \"; std::cout << \"Used to disable or enable components\" << std::endl; std::cout << std::endl; for (auto& section : config_sections_) { // Skipping sections that are not meant to be disabled if (!section.can_disable) { *section.active = true; continue; } // Ensuring that we are only using the last of the section id. // This means 'adaptor.grouping' becomes 'grouping' String id = section.id; auto p = id.find('.'); if (p != String::npos) { id = id.substr(p + 1, id.size() - p - 1); } // Creating sections for non-empty section ids if (!id.empty()) { if (section.enabled_by_default) { std::cout << std::setw(50) << std::left << (\"--disable-\" + id) << \"Disables \" << section.name << \". \"; std::cout << \"Default: false\" << std::endl; } else { std::cout << std::setw(50) << std::left << (\"--enable-\" + id) << \"Enables \" << section.name << \". \"; std::cout << \"Default: false\" << std::endl; } } } // Component configuration for (auto& section : config_sections_) { bool ignore = true; // Checking if this section has any CLI available configurations for (auto& c : section.settings) { if (!c->isAvailableToCli()) { continue; } if (c->isExperimental() && !experimental_mode) { continue; } ignore = false; break; } // Skipping to next section if there is nothing to show if (ignore) { continue; } std::cout << std::endl; std::cout << section.name; if (!section.description.empty()) { std::cout << \" - \" << section.description; } std::cout << std::endl << std::endl; for (auto& c : section.settings) { // Skipping those parameters which are not available to the // commandline interface for configuration if (!c->isAvailableToCli()) { continue; } // Skipping experimental parameters unless if we are in experimental // mode. if (c->isExperimental() && !experimental_mode) { continue; } String sn{\"\"}; if (!c->shorthandNotation().empty()) { sn = static_cast<String>(\", -\") + c->shorthandNotation(); } if (c->isFlag()) { if (c->defaultValue() == \"false\") { std::cout << std::setw(50) << std::left << (\"--\" + c->name() + sn); } else { std::cout << std::setw(50) << std::left << (\"--[no-]\" + c->name()); } } else { std::cout << std::setw(50) << std::left << (\"--\" + c->name() + sn); } if (c->isExperimental()) { std::cout << \"EXPERIMENTAL. \"; } std::cout << c->description() << \" \"; std::cout << \"Default: \" << c->defaultValue() << std::endl; } } } void ConfigurationManager::printConfiguration() const { std::cout << std::setfill('.'); std::cout << \"; # \" << \"Components\" << \"\\n\"; for (auto& section : config_sections_) { if (!section.id.empty()) { std::cout << \"; \" << std::setw(50) << std::left << (\"disable-\" + section.id) << \": \" << (*section.active ? \"false\" : \"true\") << \"\\n\"; } } std::cout << \"; \\n\"; for (auto& section : config_sections_) { std::cout << \"; # \" << section.name << \"\\n\"; for (auto& c : section.settings) { std::cout << \"; \" << std::setw(50) << std::left << c->name() << \": \" << c->value() << \"\\n\"; } std::cout << \"; \\n\"; } std::cout << std::flush; } void ConfigurationManager::addShorthandNotation(String const& parameter, String const& shorthand) { auto it = parameters_.find(parameter); if (it == parameters_.end()) { throw std::runtime_error(\"Parameter '\" + parameter + \"' not found.\"); } it->second->setShorthandNotation(shorthand); } void ConfigurationManager::setSectionName(String const& name, String const& description) { if (config_sections_.empty()) { throw std::runtime_error(\"No section created yet.\"); } config_sections_.back().name = name; config_sections_.back().description = description; } void ConfigurationManager::disableSectionByDefault() { if (config_sections_.empty()) { throw std::runtime_error(\"No section created yet.\"); } config_sections_.back().enabled_by_default = false; } void ConfigurationManager::disableSectionById(String const& id) { for (auto& section : config_sections_) { if (section.id == id) { section.enabled_by_default = false; return; } } throw std::runtime_error(\"Section '\" + id + \"' not found\"); } void ConfigurationManager::enableSectionById(String const& id) { for (auto& section : config_sections_) { if (section.id == id) { section.enabled_by_default = true; return; } } throw std::runtime_error(\"Section '\" + id + \"' not found\"); } void ConfigurationManager::allowDisableSectionById(String const& id) { for (auto& section : config_sections_) { if (section.id == id) { section.can_disable = true; return; } } throw std::runtime_error(\"Section '\" + id + \"' not found\"); } DeferredValue::DeferredValuePtr ConfigurationManager::getParameter(String const& name) { auto it = deferred_refs_.find(name); if (it != deferred_refs_.end()) { return it->second; } auto ret = DeferredValue::create(); deferred_refs_[name] = ret; auto it2 = parameters_.find(name); if (it2 != parameters_.end()) { ret->setReference(it2->second); } return ret; } void ConfigurationManager::loadConfig(String const& filename) { YAML::Node config = YAML::LoadFile(filename); for (auto& section : config_sections_) { auto node = getNodeFromPath(config, section.id); if (node) { for (auto& c : section.settings) { c->setValueFromYamlNode(node); } } } } void ConfigurationManager::saveConfig(String const& filename) { YAML::Node ret; for (auto& section : config_sections_) { if (section.id.empty()) { continue; } YAML::Node config; for (auto& c : section.settings) { c->updateValueInYamlNode(config); } setNodeFromPath(ret, section.id, config); } std::ofstream fout(filename); fout << ret; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_configuration_manager_8hpp/","text":"Commandline/ConfigurationManager.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::DeferredValue class microsoft::quantum::ConfigurationManager struct microsoft::quantum::ConfigurationManager::Section Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigBind.hpp\" #include \"qir/qat/Commandline/IConfigBind.hpp\" #include \"qir/qat/Commandline/ParameterParser.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <cstddef> #include <deque> #include <iomanip> #include <iostream> #include <sstream> #include <stdexcept> #include <type_traits> #include <typeindex> #include <typeinfo> namespace microsoft::quantum { class ConfigurationManager; class DeferredValue { public: using DeferredValuePtr = std::shared_ptr<DeferredValue>; using IConfigBindPtr = std::shared_ptr<IConfigBind>; static DeferredValuePtr create() { DeferredValuePtr ret; ret.reset(new DeferredValue()); return ret; } void setReference(IConfigBindPtr const& value) { value_ref_ = value; } bool isDereferenceable() const { return value_ref_ != nullptr; } template <typename T> T value() const { if (!isDereferenceable()) { throw std::runtime_error(\"Deferred command line parameter is not dereferenceable.\"); } if (value_ref_->valueType() != std::type_index(typeid(T))) { throw std::runtime_error(\"Type mismatch for deferred command line parameter.\"); } auto ptr = static_cast<T*>(value_ref_->pointer()); return *ptr; } private: DeferredValue() = default; IConfigBindPtr value_ref_{nullptr}; }; class ConfigurationManager { public: using IConfigBindPtr = std::shared_ptr<IConfigBind>; using ConfigList = std::vector<IConfigBindPtr>; using VoidPtr = std::shared_ptr<void>; using TypeId = std::type_index; using BoolPtr = std::shared_ptr<bool>; using Parameters = std::unordered_map<String, IConfigBindPtr>; using DeferredValuePtr = DeferredValue::DeferredValuePtr; using DeferredRefs = std::unordered_map<String, DeferredValuePtr>; using ParameterVisibility = IConfigBind::ParameterVisibility; struct Section { TypeId type{TypeId(typeid(std::nullptr_t))}; String name{}; String description{}; bool can_disable{false}; bool enabled_by_default{true}; VoidPtr configuration{}; ConfigList settings{}; BoolPtr active{nullptr}; String id{}; }; using Sections = std::vector<Section>; // Constructors, copy and move operators, destructor // ConfigurationManager(); ConfigurationManager(ConfigurationManager const&) = delete; ConfigurationManager(ConfigurationManager&&) = delete; ConfigurationManager& operator=(ConfigurationManager const&) = delete; ConfigurationManager& operator=(ConfigurationManager&&) = delete; ~ConfigurationManager() { for (auto& s : config_sections_) { s.configuration.reset(); } } // Configuration setup // void setupArguments(ParameterParser& parser); void configure(ParameterParser& parser, bool experimental_mode = false); // Managing configuration // template <typename T> inline void setConfig(T const& value); template <typename T> inline T const& get() const; // Support functions // void printHelp(bool experimental_mode) const; void printConfiguration() const; // Configuration functions // template <typename T> inline void addConfig(String const& id = \"\", T const& default_value = T()); template <typename T> inline bool configWasRegistered(); template <typename T> inline bool isActive(); void setSectionName(String const& name, String const& description); void disableSectionByDefault(); void disableSectionById(String const& id); void enableSectionById(String const& id); void allowDisableSectionById(String const& id); template <typename T> inline void addParameter( T& bind, T default_value, String const& name, String const& description, ParameterVisibility visibility = ParameterVisibility::CliAndConfig); void addShorthandNotation(String const& parameter, String const& shorthand); template <typename T> inline void addParameter( T& bind, String const& name, String const& description, ParameterVisibility visibility = ParameterVisibility::CliAndConfig); template <typename T> inline void addExperimentalParameter( T& bind, T default_value, T off_value, String const& name, String const& description, ParameterVisibility visibility = ParameterVisibility::CliAndConfig); template <typename T> inline void addExperimentalParameter( T& bind, T default_value, String const& name, String const& description, ParameterVisibility visibility = ParameterVisibility::CliAndConfig); template <typename T> inline void addExperimentalParameter( T& bind, String const& name, String const& description, ParameterVisibility visibility = ParameterVisibility::CliAndConfig); DeferredValuePtr getParameter(String const& name); template <typename T> inline bool has() const; template <typename T> inline void updateParameter(String const& name, T const& value); void loadConfig(String const& filename); void saveConfig(String const& filename); private: template <typename T> inline T& getInternal() const; template <typename T> std::shared_ptr<ConfigBind<T>> newParameter( T& bind, T default_value, String const& name, String const& description, ParameterVisibility visibility = ParameterVisibility::CliAndConfig); YAML::Node getNodeFromPath(YAML::Node const& root, String const& path) { if (!root) { return YAML::Node(); } YAML::Node ret = root; std::size_t last_p = 0; std::size_t p = path.find('.', last_p); while (p != std::string::npos) { auto key = path.substr(last_p, p - last_p); last_p = p + 1; ret.reset(ret[key]); if (!ret) { return YAML::Node(); } p = path.find('.', last_p); } auto key = path.substr(last_p, path.size() - last_p); ret.reset(ret[key]); return ret; } void setNodeFromPath(YAML::Node& root, String const& path, YAML::Node const& value) { std::size_t p = path.find('.'); if (p == std::string::npos) { root[path] = value; return; } auto next_node = root[path.substr(0, p)]; setNodeFromPath(next_node, path.substr(p + 1, path.size() - p - 1), value); } Sections config_sections_{}; Parameters parameters_{}; DeferredRefs deferred_refs_{}; }; template <typename T> inline void ConfigurationManager::addConfig(String const& id, T const& default_value) { Section new_section{std::type_index(typeid(T))}; // Checking whether the section exists auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { throw std::runtime_error( \"Configuration section for type '\" + static_cast<std::string>(typeid(T).name()) + \"' already exists\"); } } // If not we create it. auto ptr = std::make_shared<T>(default_value); new_section.configuration = ptr; new_section.active = std::make_shared<bool>(true); new_section.id = id; config_sections_.emplace_back(std::move(new_section)); ptr->setup(*this); } template <typename T> inline bool ConfigurationManager::configWasRegistered() { auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { return true; } } return false; } template <typename T> inline bool ConfigurationManager::has() const { auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { return true; } } return false; } template <typename T> inline T& ConfigurationManager::getInternal() const { VoidPtr ptr{nullptr}; auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { ptr = section.configuration; break; } } if (ptr == nullptr) { throw std::runtime_error( \"(getInternal) Could not find configuration class '\" + static_cast<std::string>(typeid(T).name()) + \"'.\"); } return *static_cast<T*>(ptr.get()); } template <typename T> inline void ConfigurationManager::setConfig(T const& value) { auto& config = getInternal<T>(); config = value; } template <typename T> inline T const& ConfigurationManager::get() const { return getInternal<T>(); } template <typename T> inline bool ConfigurationManager::isActive() { BoolPtr ptr{nullptr}; auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { ptr = section.active; break; } } if (ptr == nullptr) { throw std::runtime_error( \"(isActive) Could not find configuration class '\" + static_cast<std::string>(typeid(T).name()) + \"'.\"); } return *ptr; } template <typename T> inline std::shared_ptr<ConfigBind<T>> ConfigurationManager::newParameter( T& bind, T default_value, String const& name, String const& description, ParameterVisibility visibility) { if (parameters_.find(name) != parameters_.end()) { throw std::runtime_error(\"Parameter '\" + name + \"' already exists.\"); } auto ret = std::make_shared<ConfigBind<T>>(bind, default_value, name, description, visibility); parameters_[name] = ret; auto it = deferred_refs_.find(name); if (it != deferred_refs_.end()) { it->second->setReference(ret); } return ret; } template <typename T> inline void ConfigurationManager::addParameter( T& bind, T default_value, String const& name, String const& description, ParameterVisibility visibility) { auto ptr = newParameter<T>(bind, default_value, name, description, visibility); config_sections_.back().settings.push_back(ptr); } template <typename T> inline void ConfigurationManager::addExperimentalParameter( T& bind, T default_value, T off_value, String const& name, String const& description, ParameterVisibility visibility) { auto ptr = newParameter<T>(bind, default_value, name, description, visibility); ptr->markAsExperimental(off_value); config_sections_.back().settings.push_back(ptr); } template <typename T> inline void ConfigurationManager::addParameter( T& bind, String const& name, String const& description, ParameterVisibility visibility) { auto ptr = newParameter<T>(bind, T(bind), name, description, visibility); config_sections_.back().settings.push_back(ptr); } template <typename T> inline void ConfigurationManager::addExperimentalParameter( T& bind, T default_value, String const& name, String const& description, ParameterVisibility visibility) { auto ptr = newParameter<T>(bind, T(default_value), name, description, visibility); ptr->markAsExperimental(T(bind)); config_sections_.back().settings.push_back(ptr); } template <typename T> inline void ConfigurationManager::addExperimentalParameter( T& bind, String const& name, String const& description, ParameterVisibility visibility) { auto ptr = newParameter<T>(bind, T(bind), name, description, visibility); ptr->markAsExperimental(T(bind)); config_sections_.back().settings.push_back(ptr); } template <typename T> inline void ConfigurationManager::updateParameter(String const& name, T const& value) { auto it = parameters_.find(name); if (it == parameters_.end()) { throw std::runtime_error(\"Parameter '\" + name + \"' does not exist.\"); } if (it->second == nullptr) { throw std::runtime_error(\"Configuration '\" + name + \"' binds to nullptr.\"); } auto param = it->second; if (param->valueType() != std::type_index(typeid(T))) { throw std::runtime_error(\"Parameter mismatch while attemting to update the parameter '\" + name + \"'\"); } auto& bind = *static_cast<T*>(param->pointerDefaultValue()); bind = value; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Commandline/ConfigurationManager.hpp"},{"location":"Api/Files/_configuration_manager_8hpp/#commandlineconfigurationmanagerhpp","text":"","title":"Commandline/ConfigurationManager.hpp"},{"location":"Api/Files/_configuration_manager_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_configuration_manager_8hpp/#classes","text":"Name class microsoft::quantum::DeferredValue class microsoft::quantum::ConfigurationManager struct microsoft::quantum::ConfigurationManager::Section","title":"Classes"},{"location":"Api/Files/_configuration_manager_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigBind.hpp\" #include \"qir/qat/Commandline/IConfigBind.hpp\" #include \"qir/qat/Commandline/ParameterParser.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <cstddef> #include <deque> #include <iomanip> #include <iostream> #include <sstream> #include <stdexcept> #include <type_traits> #include <typeindex> #include <typeinfo> namespace microsoft::quantum { class ConfigurationManager; class DeferredValue { public: using DeferredValuePtr = std::shared_ptr<DeferredValue>; using IConfigBindPtr = std::shared_ptr<IConfigBind>; static DeferredValuePtr create() { DeferredValuePtr ret; ret.reset(new DeferredValue()); return ret; } void setReference(IConfigBindPtr const& value) { value_ref_ = value; } bool isDereferenceable() const { return value_ref_ != nullptr; } template <typename T> T value() const { if (!isDereferenceable()) { throw std::runtime_error(\"Deferred command line parameter is not dereferenceable.\"); } if (value_ref_->valueType() != std::type_index(typeid(T))) { throw std::runtime_error(\"Type mismatch for deferred command line parameter.\"); } auto ptr = static_cast<T*>(value_ref_->pointer()); return *ptr; } private: DeferredValue() = default; IConfigBindPtr value_ref_{nullptr}; }; class ConfigurationManager { public: using IConfigBindPtr = std::shared_ptr<IConfigBind>; using ConfigList = std::vector<IConfigBindPtr>; using VoidPtr = std::shared_ptr<void>; using TypeId = std::type_index; using BoolPtr = std::shared_ptr<bool>; using Parameters = std::unordered_map<String, IConfigBindPtr>; using DeferredValuePtr = DeferredValue::DeferredValuePtr; using DeferredRefs = std::unordered_map<String, DeferredValuePtr>; using ParameterVisibility = IConfigBind::ParameterVisibility; struct Section { TypeId type{TypeId(typeid(std::nullptr_t))}; String name{}; String description{}; bool can_disable{false}; bool enabled_by_default{true}; VoidPtr configuration{}; ConfigList settings{}; BoolPtr active{nullptr}; String id{}; }; using Sections = std::vector<Section>; // Constructors, copy and move operators, destructor // ConfigurationManager(); ConfigurationManager(ConfigurationManager const&) = delete; ConfigurationManager(ConfigurationManager&&) = delete; ConfigurationManager& operator=(ConfigurationManager const&) = delete; ConfigurationManager& operator=(ConfigurationManager&&) = delete; ~ConfigurationManager() { for (auto& s : config_sections_) { s.configuration.reset(); } } // Configuration setup // void setupArguments(ParameterParser& parser); void configure(ParameterParser& parser, bool experimental_mode = false); // Managing configuration // template <typename T> inline void setConfig(T const& value); template <typename T> inline T const& get() const; // Support functions // void printHelp(bool experimental_mode) const; void printConfiguration() const; // Configuration functions // template <typename T> inline void addConfig(String const& id = \"\", T const& default_value = T()); template <typename T> inline bool configWasRegistered(); template <typename T> inline bool isActive(); void setSectionName(String const& name, String const& description); void disableSectionByDefault(); void disableSectionById(String const& id); void enableSectionById(String const& id); void allowDisableSectionById(String const& id); template <typename T> inline void addParameter( T& bind, T default_value, String const& name, String const& description, ParameterVisibility visibility = ParameterVisibility::CliAndConfig); void addShorthandNotation(String const& parameter, String const& shorthand); template <typename T> inline void addParameter( T& bind, String const& name, String const& description, ParameterVisibility visibility = ParameterVisibility::CliAndConfig); template <typename T> inline void addExperimentalParameter( T& bind, T default_value, T off_value, String const& name, String const& description, ParameterVisibility visibility = ParameterVisibility::CliAndConfig); template <typename T> inline void addExperimentalParameter( T& bind, T default_value, String const& name, String const& description, ParameterVisibility visibility = ParameterVisibility::CliAndConfig); template <typename T> inline void addExperimentalParameter( T& bind, String const& name, String const& description, ParameterVisibility visibility = ParameterVisibility::CliAndConfig); DeferredValuePtr getParameter(String const& name); template <typename T> inline bool has() const; template <typename T> inline void updateParameter(String const& name, T const& value); void loadConfig(String const& filename); void saveConfig(String const& filename); private: template <typename T> inline T& getInternal() const; template <typename T> std::shared_ptr<ConfigBind<T>> newParameter( T& bind, T default_value, String const& name, String const& description, ParameterVisibility visibility = ParameterVisibility::CliAndConfig); YAML::Node getNodeFromPath(YAML::Node const& root, String const& path) { if (!root) { return YAML::Node(); } YAML::Node ret = root; std::size_t last_p = 0; std::size_t p = path.find('.', last_p); while (p != std::string::npos) { auto key = path.substr(last_p, p - last_p); last_p = p + 1; ret.reset(ret[key]); if (!ret) { return YAML::Node(); } p = path.find('.', last_p); } auto key = path.substr(last_p, path.size() - last_p); ret.reset(ret[key]); return ret; } void setNodeFromPath(YAML::Node& root, String const& path, YAML::Node const& value) { std::size_t p = path.find('.'); if (p == std::string::npos) { root[path] = value; return; } auto next_node = root[path.substr(0, p)]; setNodeFromPath(next_node, path.substr(p + 1, path.size() - p - 1), value); } Sections config_sections_{}; Parameters parameters_{}; DeferredRefs deferred_refs_{}; }; template <typename T> inline void ConfigurationManager::addConfig(String const& id, T const& default_value) { Section new_section{std::type_index(typeid(T))}; // Checking whether the section exists auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { throw std::runtime_error( \"Configuration section for type '\" + static_cast<std::string>(typeid(T).name()) + \"' already exists\"); } } // If not we create it. auto ptr = std::make_shared<T>(default_value); new_section.configuration = ptr; new_section.active = std::make_shared<bool>(true); new_section.id = id; config_sections_.emplace_back(std::move(new_section)); ptr->setup(*this); } template <typename T> inline bool ConfigurationManager::configWasRegistered() { auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { return true; } } return false; } template <typename T> inline bool ConfigurationManager::has() const { auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { return true; } } return false; } template <typename T> inline T& ConfigurationManager::getInternal() const { VoidPtr ptr{nullptr}; auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { ptr = section.configuration; break; } } if (ptr == nullptr) { throw std::runtime_error( \"(getInternal) Could not find configuration class '\" + static_cast<std::string>(typeid(T).name()) + \"'.\"); } return *static_cast<T*>(ptr.get()); } template <typename T> inline void ConfigurationManager::setConfig(T const& value) { auto& config = getInternal<T>(); config = value; } template <typename T> inline T const& ConfigurationManager::get() const { return getInternal<T>(); } template <typename T> inline bool ConfigurationManager::isActive() { BoolPtr ptr{nullptr}; auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { ptr = section.active; break; } } if (ptr == nullptr) { throw std::runtime_error( \"(isActive) Could not find configuration class '\" + static_cast<std::string>(typeid(T).name()) + \"'.\"); } return *ptr; } template <typename T> inline std::shared_ptr<ConfigBind<T>> ConfigurationManager::newParameter( T& bind, T default_value, String const& name, String const& description, ParameterVisibility visibility) { if (parameters_.find(name) != parameters_.end()) { throw std::runtime_error(\"Parameter '\" + name + \"' already exists.\"); } auto ret = std::make_shared<ConfigBind<T>>(bind, default_value, name, description, visibility); parameters_[name] = ret; auto it = deferred_refs_.find(name); if (it != deferred_refs_.end()) { it->second->setReference(ret); } return ret; } template <typename T> inline void ConfigurationManager::addParameter( T& bind, T default_value, String const& name, String const& description, ParameterVisibility visibility) { auto ptr = newParameter<T>(bind, default_value, name, description, visibility); config_sections_.back().settings.push_back(ptr); } template <typename T> inline void ConfigurationManager::addExperimentalParameter( T& bind, T default_value, T off_value, String const& name, String const& description, ParameterVisibility visibility) { auto ptr = newParameter<T>(bind, default_value, name, description, visibility); ptr->markAsExperimental(off_value); config_sections_.back().settings.push_back(ptr); } template <typename T> inline void ConfigurationManager::addParameter( T& bind, String const& name, String const& description, ParameterVisibility visibility) { auto ptr = newParameter<T>(bind, T(bind), name, description, visibility); config_sections_.back().settings.push_back(ptr); } template <typename T> inline void ConfigurationManager::addExperimentalParameter( T& bind, T default_value, String const& name, String const& description, ParameterVisibility visibility) { auto ptr = newParameter<T>(bind, T(default_value), name, description, visibility); ptr->markAsExperimental(T(bind)); config_sections_.back().settings.push_back(ptr); } template <typename T> inline void ConfigurationManager::addExperimentalParameter( T& bind, String const& name, String const& description, ParameterVisibility visibility) { auto ptr = newParameter<T>(bind, T(bind), name, description, visibility); ptr->markAsExperimental(T(bind)); config_sections_.back().settings.push_back(ptr); } template <typename T> inline void ConfigurationManager::updateParameter(String const& name, T const& value) { auto it = parameters_.find(name); if (it == parameters_.end()) { throw std::runtime_error(\"Parameter '\" + name + \"' does not exist.\"); } if (it->second == nullptr) { throw std::runtime_error(\"Configuration '\" + name + \"' binds to nullptr.\"); } auto param = it->second; if (param->valueType() != std::type_index(typeid(T))) { throw std::runtime_error(\"Parameter mismatch while attemting to update the parameter '\" + name + \"'\"); } auto& bind = *static_cast<T*>(param->pointerDefaultValue()); bind = value; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_const_int_8cpp/","text":"Rules/Notation/ConstInt.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr constInt() { auto cast_pattern = std::make_shared<ConstIntPattern>(); return static_cast<IOperandPrototypePtr>(cast_pattern); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Notation/ConstInt.cpp"},{"location":"Api/Files/_const_int_8cpp/#rulesnotationconstintcpp","text":"","title":"Rules/Notation/ConstInt.cpp"},{"location":"Api/Files/_const_int_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_const_int_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr constInt() { auto cast_pattern = std::make_shared<ConstIntPattern>(); return static_cast<IOperandPrototypePtr>(cast_pattern); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_debug_info_updater_8cpp/","text":"ModuleLoader/DebugInfoUpdater.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/ModuleLoader/DebugInfoUpdater.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/ModuleLoader/InstructionLocationTable.hpp\" namespace microsoft::quantum { DebugInfoUpdater::DebugInfoUpdater( InstructionLocationTablePtr const& debug_info, Module& module, StringRef const& directory, StringRef const& filename) : debug_info_{debug_info} , module_{module} , builder_(module) { file_unit_ = builder_.createFile(filename, directory); compile_unit_ = builder_.createCompileUnit(llvm::dwarf::DW_LANG_C, file_unit_, \"qat\", false, \"\", 0); } void DebugInfoUpdater::update() { finder_.processModule(module_); visit(&module_); builder_.finalize(); } llvm::DISubroutineType* DebugInfoUpdater::createFunctionType(Function const* function) { llvm::SmallVector<llvm::Metadata*, 4> parameters; llvm::DIType* return_type = getOrCreateType(function->getReturnType()); parameters.push_back(return_type); for (auto const& arg : function->args()) { parameters.push_back(getOrCreateType(arg.getType())); } auto params_array = builder_.getOrCreateTypeArray(parameters); return builder_.createSubroutineType(params_array); } llvm::DIType* DebugInfoUpdater::getType(llvm::Type* type) { auto it = type_debug_info_.find(type); if (it != type_debug_info_.end()) { return it->second; } return nullptr; } llvm::DIType* DebugInfoUpdater::createVoidType(llvm::Type* type) { auto ret = builder_.createUnspecifiedType(\"void\"); type_debug_info_[type] = ret; return ret; } llvm::DIType* DebugInfoUpdater::createPointerType(llvm::Type* type) { auto pointee_type = type->getPointerElementType(); auto element_type = getOrCreateType(pointee_type); auto ret = builder_.createPointerType(element_type, 64); type_debug_info_[type] = ret; return ret; } llvm::DIType* DebugInfoUpdater::createOpaqueType(llvm::Type* type) { auto ret = builder_.createUnspecifiedType(\"opaque\"); type_debug_info_[type] = ret; return ret; } llvm::DIType* DebugInfoUpdater::getOrCreateType(llvm::Type* type) { DIType* di_type = getType(type); if (di_type != nullptr) { return di_type; } if (type->isVoidTy()) { return createVoidType(type); } if (type->isStructTy() || type->isArrayTy()) { // TODO(tfr): Consider more comprehensive support for structs and arrays return createOpaqueType(type); } if (type->isPointerTy()) { return createPointerType(type); } auto encoding = llvm::dwarf::DW_ATE_signed; if (type->isIntegerTy()) { encoding = llvm::dwarf::DW_ATE_unsigned; } else if (type->isFloatingPointTy()) { encoding = llvm::dwarf::DW_ATE_float; } auto ret = builder_.createBasicType(\"PrimitiveType\", type->getPrimitiveSizeInBits(), encoding); type_debug_info_[type] = ret; return ret; } void DebugInfoUpdater::visitFunction(Function& function) { // Skipping declarations and already annotated functions if (function.isDeclaration() || function_debug_info_.find(&function) != function_debug_info_.end()) { return; } // Preserving existing subprograms if (function.getSubprogram() != nullptr) { function_debug_info_[&function] = function.getSubprogram(); return; } // Creating new subprogram auto position = debug_info_->getPosition(&function); auto program_flags = llvm::DISubprogram::SPFlagDefinition; if (function.hasPrivateLinkage() || function.hasInternalLinkage()) { program_flags |= llvm::DISubprogram::SPFlagLocalToUnit; } auto subprogram = builder_.createFunction( file_unit_, function.getName(), StringRef(), file_unit_, static_cast<uint32_t>(position.line()), createFunctionType(&function), static_cast<uint32_t>(position.line()), llvm::DINode::FlagZero, program_flags); function.setSubprogram(subprogram); function_debug_info_[&function] = subprogram; } void DebugInfoUpdater::visitInstruction(Instruction& instr) { auto position = debug_info_->getPosition(&instr); if (position) { auto location = instr.getDebugLoc(); // Skipping instructions with existing debug locations if (location) { return; } // Copying scope and inlined at if possible llvm::DILocalScope* scope{nullptr}; llvm::DILocation* inlined_at{nullptr}; auto block = instr.getParent(); auto function = block->getParent(); auto it = function_debug_info_.find(function); // Sanity check if (it == function_debug_info_.end()) { throw std::runtime_error(\"Could not find parent function - this is not supposed to happen.\"); } auto subprogram = it->second; scope = subprogram; // Sanity check if (scope == nullptr) { throw std::runtime_error(\"Could not determine scope - this is not supposed to happen.\"); } // Updating the debug location auto new_debug_loc = llvm::DebugLoc(llvm::DILocation::get( module_.getContext(), static_cast<uint32_t>(position.line()), static_cast<uint32_t>(position.column()), scope, inlined_at)); instr.setDebugLoc(new_debug_loc); } } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"ModuleLoader/DebugInfoUpdater.cpp"},{"location":"Api/Files/_debug_info_updater_8cpp/#moduleloaderdebuginfoupdatercpp","text":"","title":"ModuleLoader/DebugInfoUpdater.cpp"},{"location":"Api/Files/_debug_info_updater_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_debug_info_updater_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/ModuleLoader/DebugInfoUpdater.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/ModuleLoader/InstructionLocationTable.hpp\" namespace microsoft::quantum { DebugInfoUpdater::DebugInfoUpdater( InstructionLocationTablePtr const& debug_info, Module& module, StringRef const& directory, StringRef const& filename) : debug_info_{debug_info} , module_{module} , builder_(module) { file_unit_ = builder_.createFile(filename, directory); compile_unit_ = builder_.createCompileUnit(llvm::dwarf::DW_LANG_C, file_unit_, \"qat\", false, \"\", 0); } void DebugInfoUpdater::update() { finder_.processModule(module_); visit(&module_); builder_.finalize(); } llvm::DISubroutineType* DebugInfoUpdater::createFunctionType(Function const* function) { llvm::SmallVector<llvm::Metadata*, 4> parameters; llvm::DIType* return_type = getOrCreateType(function->getReturnType()); parameters.push_back(return_type); for (auto const& arg : function->args()) { parameters.push_back(getOrCreateType(arg.getType())); } auto params_array = builder_.getOrCreateTypeArray(parameters); return builder_.createSubroutineType(params_array); } llvm::DIType* DebugInfoUpdater::getType(llvm::Type* type) { auto it = type_debug_info_.find(type); if (it != type_debug_info_.end()) { return it->second; } return nullptr; } llvm::DIType* DebugInfoUpdater::createVoidType(llvm::Type* type) { auto ret = builder_.createUnspecifiedType(\"void\"); type_debug_info_[type] = ret; return ret; } llvm::DIType* DebugInfoUpdater::createPointerType(llvm::Type* type) { auto pointee_type = type->getPointerElementType(); auto element_type = getOrCreateType(pointee_type); auto ret = builder_.createPointerType(element_type, 64); type_debug_info_[type] = ret; return ret; } llvm::DIType* DebugInfoUpdater::createOpaqueType(llvm::Type* type) { auto ret = builder_.createUnspecifiedType(\"opaque\"); type_debug_info_[type] = ret; return ret; } llvm::DIType* DebugInfoUpdater::getOrCreateType(llvm::Type* type) { DIType* di_type = getType(type); if (di_type != nullptr) { return di_type; } if (type->isVoidTy()) { return createVoidType(type); } if (type->isStructTy() || type->isArrayTy()) { // TODO(tfr): Consider more comprehensive support for structs and arrays return createOpaqueType(type); } if (type->isPointerTy()) { return createPointerType(type); } auto encoding = llvm::dwarf::DW_ATE_signed; if (type->isIntegerTy()) { encoding = llvm::dwarf::DW_ATE_unsigned; } else if (type->isFloatingPointTy()) { encoding = llvm::dwarf::DW_ATE_float; } auto ret = builder_.createBasicType(\"PrimitiveType\", type->getPrimitiveSizeInBits(), encoding); type_debug_info_[type] = ret; return ret; } void DebugInfoUpdater::visitFunction(Function& function) { // Skipping declarations and already annotated functions if (function.isDeclaration() || function_debug_info_.find(&function) != function_debug_info_.end()) { return; } // Preserving existing subprograms if (function.getSubprogram() != nullptr) { function_debug_info_[&function] = function.getSubprogram(); return; } // Creating new subprogram auto position = debug_info_->getPosition(&function); auto program_flags = llvm::DISubprogram::SPFlagDefinition; if (function.hasPrivateLinkage() || function.hasInternalLinkage()) { program_flags |= llvm::DISubprogram::SPFlagLocalToUnit; } auto subprogram = builder_.createFunction( file_unit_, function.getName(), StringRef(), file_unit_, static_cast<uint32_t>(position.line()), createFunctionType(&function), static_cast<uint32_t>(position.line()), llvm::DINode::FlagZero, program_flags); function.setSubprogram(subprogram); function_debug_info_[&function] = subprogram; } void DebugInfoUpdater::visitInstruction(Instruction& instr) { auto position = debug_info_->getPosition(&instr); if (position) { auto location = instr.getDebugLoc(); // Skipping instructions with existing debug locations if (location) { return; } // Copying scope and inlined at if possible llvm::DILocalScope* scope{nullptr}; llvm::DILocation* inlined_at{nullptr}; auto block = instr.getParent(); auto function = block->getParent(); auto it = function_debug_info_.find(function); // Sanity check if (it == function_debug_info_.end()) { throw std::runtime_error(\"Could not find parent function - this is not supposed to happen.\"); } auto subprogram = it->second; scope = subprogram; // Sanity check if (scope == nullptr) { throw std::runtime_error(\"Could not determine scope - this is not supposed to happen.\"); } // Updating the debug location auto new_debug_loc = llvm::DebugLoc(llvm::DILocation::get( module_.getContext(), static_cast<uint32_t>(position.line()), static_cast<uint32_t>(position.column()), scope, inlined_at)); instr.setDebugLoc(new_debug_loc); } } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_debug_info_updater_8hpp/","text":"ModuleLoader/DebugInfoUpdater.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::DebugInfoUpdater Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/ModuleLoader/InstructionLocationTable.hpp\" namespace microsoft::quantum { class DebugInfoUpdater : public llvm::InstVisitor<DebugInfoUpdater> { public: using DIBuilder = llvm::DIBuilder; using DataLayout = llvm::DataLayout; using Module = llvm::Module; using Function = llvm::Function; using Instruction = llvm::Instruction; using DIType = llvm::DIType; using StringRef = llvm::StringRef; DebugInfoUpdater( InstructionLocationTablePtr const& debug_info, Module& module, StringRef const& directory, StringRef const& filename); void update(); // Visitor implementation // void visitFunction(Function& function); void visitInstruction(Instruction& instr); protected: // Creating and getting types // llvm::DISubroutineType* createFunctionType(Function const* function); DIType* createVoidType(llvm::Type* type); DIType* createPointerType(llvm::Type* type); DIType* createOpaqueType(llvm::Type* type); DIType* getOrCreateType(llvm::Type* type); DIType* getType(llvm::Type* type); private: InstructionLocationTablePtr debug_info_{nullptr}; llvm::Module& module_; llvm::DIBuilder builder_; llvm::DebugInfoFinder finder_{}; llvm::DICompileUnit* compile_unit_; llvm::DIFile* file_unit_; llvm::ValueMap<llvm::Function const*, llvm::DISubprogram*> function_debug_info_{}; llvm::DenseMap<llvm::Type const*, llvm::DIType*> type_debug_info_{}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"ModuleLoader/DebugInfoUpdater.hpp"},{"location":"Api/Files/_debug_info_updater_8hpp/#moduleloaderdebuginfoupdaterhpp","text":"","title":"ModuleLoader/DebugInfoUpdater.hpp"},{"location":"Api/Files/_debug_info_updater_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_debug_info_updater_8hpp/#classes","text":"Name class microsoft::quantum::DebugInfoUpdater","title":"Classes"},{"location":"Api/Files/_debug_info_updater_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/ModuleLoader/InstructionLocationTable.hpp\" namespace microsoft::quantum { class DebugInfoUpdater : public llvm::InstVisitor<DebugInfoUpdater> { public: using DIBuilder = llvm::DIBuilder; using DataLayout = llvm::DataLayout; using Module = llvm::Module; using Function = llvm::Function; using Instruction = llvm::Instruction; using DIType = llvm::DIType; using StringRef = llvm::StringRef; DebugInfoUpdater( InstructionLocationTablePtr const& debug_info, Module& module, StringRef const& directory, StringRef const& filename); void update(); // Visitor implementation // void visitFunction(Function& function); void visitInstruction(Instruction& instr); protected: // Creating and getting types // llvm::DISubroutineType* createFunctionType(Function const* function); DIType* createVoidType(llvm::Type* type); DIType* createPointerType(llvm::Type* type); DIType* createOpaqueType(llvm::Type* type); DIType* getOrCreateType(llvm::Type* type); DIType* getType(llvm::Type* type); private: InstructionLocationTablePtr debug_info_{nullptr}; llvm::Module& module_; llvm::DIBuilder builder_; llvm::DebugInfoFinder finder_{}; llvm::DICompileUnit* compile_unit_; llvm::DIFile* file_unit_; llvm::ValueMap<llvm::Function const*, llvm::DISubprogram*> function_debug_info_{}; llvm::DenseMap<llvm::Type const*, llvm::DIType*> type_debug_info_{}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_defer_measurement_pass_8cpp/","text":"Passes/DeferMeasurementPass/DeferMeasurementPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/DeferMeasurementPass/DeferMeasurementPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <stdexcept> #include <unordered_map> #include <vector> namespace microsoft::quantum { std::string const DeferMeasurementPass::RECORD_INSTR_END = \"_record_output\"; DeferMeasurementPass::DeferMeasurementPass() noexcept : readout_names_{ {\"__quantum__qis__m__body\", \"__quantum__qis__mz__body\", \"__quantum__qis__reset__body\", \"__quantum__qis__read_result__body\"}} { } llvm::PreservedAnalyses DeferMeasurementPass::run(llvm::Function& function, llvm::FunctionAnalysisManager& /*mam*/) { for (auto& block : function) { // Identifying record functions std::vector<llvm::Instruction*> records; for (auto& instr : block) { auto call = llvm::dyn_cast<llvm::CallBase>(&instr); if (call != nullptr) { auto f = call->getCalledFunction(); if (f != nullptr) { auto name = static_cast<std::string>(f->getName()); bool is_readout = (name.size() >= RECORD_INSTR_END.size() && name.substr(name.size() - RECORD_INSTR_END.size(), RECORD_INSTR_END.size()) == RECORD_INSTR_END); if (is_readout || readout_names_.find(name) != readout_names_.end()) { records.push_back(&instr); } } } } // Moving function calls if (!records.empty()) { llvm::IRBuilder<> builder(function.getContext()); builder.SetInsertPoint(block.getTerminator()); for (auto instr : records) { auto new_instr = instr->clone(); new_instr->takeName(instr); builder.Insert(new_instr); instr->replaceAllUsesWith(new_instr); if (instr->use_empty()) { instr->eraseFromParent(); } else { throw std::runtime_error( \"Unexpected uses of instruction while moving records to the bottom of the block\"); } } } } return llvm::PreservedAnalyses::none(); } bool DeferMeasurementPass::isRequired() { return true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/DeferMeasurementPass/DeferMeasurementPass.cpp"},{"location":"Api/Files/_defer_measurement_pass_8cpp/#passesdefermeasurementpassdefermeasurementpasscpp","text":"","title":"Passes/DeferMeasurementPass/DeferMeasurementPass.cpp"},{"location":"Api/Files/_defer_measurement_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_defer_measurement_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/DeferMeasurementPass/DeferMeasurementPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <stdexcept> #include <unordered_map> #include <vector> namespace microsoft::quantum { std::string const DeferMeasurementPass::RECORD_INSTR_END = \"_record_output\"; DeferMeasurementPass::DeferMeasurementPass() noexcept : readout_names_{ {\"__quantum__qis__m__body\", \"__quantum__qis__mz__body\", \"__quantum__qis__reset__body\", \"__quantum__qis__read_result__body\"}} { } llvm::PreservedAnalyses DeferMeasurementPass::run(llvm::Function& function, llvm::FunctionAnalysisManager& /*mam*/) { for (auto& block : function) { // Identifying record functions std::vector<llvm::Instruction*> records; for (auto& instr : block) { auto call = llvm::dyn_cast<llvm::CallBase>(&instr); if (call != nullptr) { auto f = call->getCalledFunction(); if (f != nullptr) { auto name = static_cast<std::string>(f->getName()); bool is_readout = (name.size() >= RECORD_INSTR_END.size() && name.substr(name.size() - RECORD_INSTR_END.size(), RECORD_INSTR_END.size()) == RECORD_INSTR_END); if (is_readout || readout_names_.find(name) != readout_names_.end()) { records.push_back(&instr); } } } } // Moving function calls if (!records.empty()) { llvm::IRBuilder<> builder(function.getContext()); builder.SetInsertPoint(block.getTerminator()); for (auto instr : records) { auto new_instr = instr->clone(); new_instr->takeName(instr); builder.Insert(new_instr); instr->replaceAllUsesWith(new_instr); if (instr->use_empty()) { instr->eraseFromParent(); } else { throw std::runtime_error( \"Unexpected uses of instruction while moving records to the bottom of the block\"); } } } } return llvm::PreservedAnalyses::none(); } bool DeferMeasurementPass::isRequired() { return true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_defer_measurement_pass_8hpp/","text":"Passes/DeferMeasurementPass/DeferMeasurementPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::DeferMeasurementPass Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class DeferMeasurementPass : public llvm::PassInfoMixin<DeferMeasurementPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using Location = ILogger::Location; using StringRef = llvm::StringRef; static std::string const RECORD_INSTR_END; // Construction and destruction configuration. // DeferMeasurementPass() noexcept; DeferMeasurementPass(DeferMeasurementPass const&) = delete; DeferMeasurementPass(DeferMeasurementPass&&) = default; ~DeferMeasurementPass() = default; llvm::PreservedAnalyses run(llvm::Function& function, llvm::FunctionAnalysisManager& fam); static bool isRequired(); private: std::unordered_set<String> readout_names_{}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/DeferMeasurementPass/DeferMeasurementPass.hpp"},{"location":"Api/Files/_defer_measurement_pass_8hpp/#passesdefermeasurementpassdefermeasurementpasshpp","text":"","title":"Passes/DeferMeasurementPass/DeferMeasurementPass.hpp"},{"location":"Api/Files/_defer_measurement_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_defer_measurement_pass_8hpp/#classes","text":"Name class microsoft::quantum::DeferMeasurementPass","title":"Classes"},{"location":"Api/Files/_defer_measurement_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class DeferMeasurementPass : public llvm::PassInfoMixin<DeferMeasurementPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using Location = ILogger::Location; using StringRef = llvm::StringRef; static std::string const RECORD_INSTR_END; // Construction and destruction configuration. // DeferMeasurementPass() noexcept; DeferMeasurementPass(DeferMeasurementPass const&) = delete; DeferMeasurementPass(DeferMeasurementPass&&) = default; ~DeferMeasurementPass() = default; llvm::PreservedAnalyses run(llvm::Function& function, llvm::FunctionAnalysisManager& fam); static bool isRequired(); private: std::unordered_set<String> readout_names_{}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_division_by_zero_pass_8cpp/","text":"Passes/DivisionByZeroPass/DivisionByZeroPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/DivisionByZeroPass/DivisionByZeroPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { const char* const DivisionByZeroPass::EC_REPORT_FUNCTION = \"__qir__report_error_value\"; const char* const DivisionByZeroPass::EC_VARIABLE_NAME = \"__qir__error_code\"; int64_t const DivisionByZeroPass::EC_QIR_DIVISION_BY_ZERO = 1100; llvm::PreservedAnalyses DivisionByZeroPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { llvm::IRBuilder<> builder(module.getContext()); module.getOrInsertGlobal(EC_VARIABLE_NAME, builder.getInt64Ty()); error_variable_ = module.getNamedGlobal(EC_VARIABLE_NAME); error_variable_->setLinkage(llvm::GlobalValue::InternalLinkage); error_variable_->setInitializer(builder.getInt64(0)); error_variable_->setConstant(false); std::vector<llvm::Instruction*> instructions; for (auto& function : module) { for (auto& block : function) { for (auto& instr : block) { auto* udiv = llvm::dyn_cast<llvm::SDivOperator>(&instr); if (udiv) { instructions.push_back(&instr); } } } } // Injecting error code updates for (auto instr : instructions) { auto op2 = instr->getOperand(1); auto const& final_block = instr->getParent(); auto if_block = final_block->splitBasicBlock(instr, \"if_denominator_is_zero\", true); auto start_block = if_block->splitBasicBlock(if_block->getTerminator(), \"-INTERMEDIATE-\", true); start_block->takeName(final_block); final_block->setName(\"after_zero_check\"); builder.SetInsertPoint(start_block->getTerminator()); auto cmp = builder.CreateICmp(llvm::CmpInst::Predicate::ICMP_EQ, op2, builder.getInt64(0)); auto old_terminator = start_block->getTerminator(); llvm::BranchInst::Create(if_block, final_block, cmp, start_block); old_terminator->eraseFromParent(); raiseError(EC_QIR_DIVISION_BY_ZERO, module, if_block->getTerminator()); } // Checking error codes at end of llvm::Function* entry = nullptr; std::vector<llvm::BasicBlock*> exit_blocks; for (auto& function : module) { if (function.hasFnAttribute(\"EntryPoint\")) { entry = &function; for (auto& block : function) { auto last = block.getTerminator(); if (last && llvm::dyn_cast<llvm::ReturnInst>(last)) { exit_blocks.push_back(&block); } } break; } } if (entry) { for (auto start_block : exit_blocks) { auto if_block = start_block->splitBasicBlock(start_block->getTerminator(), \"if_error_occurred\", false); auto final_block = if_block->splitBasicBlock(if_block->getTerminator(), \"exit_block\", false); builder.SetInsertPoint(start_block->getTerminator()); llvm::LoadInst* load = builder.CreateLoad(builder.getInt64Ty(), error_variable_); auto cmp = builder.CreateICmp(llvm::CmpInst::Predicate::ICMP_NE, load, builder.getInt64(0)); auto old_terminator = start_block->getTerminator(); llvm::BranchInst::Create(if_block, final_block, cmp, start_block); old_terminator->eraseFromParent(); builder.SetInsertPoint(if_block->getTerminator()); auto fnc = module.getFunction(EC_REPORT_FUNCTION); std::vector<llvm::Value*> arguments; arguments.push_back(load); if (!fnc) { std::vector<llvm::Type*> types; types.resize(arguments.size()); for (uint64_t i = 0; i < types.size(); ++i) { types[i] = arguments[i]->getType(); } auto return_type = llvm::Type::getVoidTy(module.getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create(fnc_type, llvm::Function::ExternalLinkage, EC_REPORT_FUNCTION, module); } builder.CreateCall(fnc, arguments); } } return llvm::PreservedAnalyses::none(); } void DivisionByZeroPass::raiseError(int64_t error_code, llvm::Module& module, llvm::Instruction* instr) { llvm::IRBuilder<> builder(module.getContext()); auto const& final_block = instr->getParent(); auto if_block = final_block->splitBasicBlock(instr, \"if_ecc_not_set\", true); auto start_block = if_block->splitBasicBlock(if_block->getTerminator(), \"-INTERMEDIATE-\", true); start_block->takeName(final_block); final_block->setName(\"ecc_set_finally\"); builder.SetInsertPoint(start_block->getTerminator()); llvm::LoadInst* load = builder.CreateLoad(builder.getInt64Ty(), error_variable_); auto cmp = builder.CreateICmp(llvm::CmpInst::Predicate::ICMP_EQ, load, builder.getInt64(0)); auto old_terminator = start_block->getTerminator(); llvm::BranchInst::Create(if_block, final_block, cmp, start_block); old_terminator->eraseFromParent(); builder.SetInsertPoint(if_block->getTerminator()); builder.CreateStore(builder.getInt64(error_code), error_variable_); } bool DivisionByZeroPass::isRequired() { return true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/DivisionByZeroPass/DivisionByZeroPass.cpp"},{"location":"Api/Files/_division_by_zero_pass_8cpp/#passesdivisionbyzeropassdivisionbyzeropasscpp","text":"","title":"Passes/DivisionByZeroPass/DivisionByZeroPass.cpp"},{"location":"Api/Files/_division_by_zero_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_division_by_zero_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/DivisionByZeroPass/DivisionByZeroPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { const char* const DivisionByZeroPass::EC_REPORT_FUNCTION = \"__qir__report_error_value\"; const char* const DivisionByZeroPass::EC_VARIABLE_NAME = \"__qir__error_code\"; int64_t const DivisionByZeroPass::EC_QIR_DIVISION_BY_ZERO = 1100; llvm::PreservedAnalyses DivisionByZeroPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { llvm::IRBuilder<> builder(module.getContext()); module.getOrInsertGlobal(EC_VARIABLE_NAME, builder.getInt64Ty()); error_variable_ = module.getNamedGlobal(EC_VARIABLE_NAME); error_variable_->setLinkage(llvm::GlobalValue::InternalLinkage); error_variable_->setInitializer(builder.getInt64(0)); error_variable_->setConstant(false); std::vector<llvm::Instruction*> instructions; for (auto& function : module) { for (auto& block : function) { for (auto& instr : block) { auto* udiv = llvm::dyn_cast<llvm::SDivOperator>(&instr); if (udiv) { instructions.push_back(&instr); } } } } // Injecting error code updates for (auto instr : instructions) { auto op2 = instr->getOperand(1); auto const& final_block = instr->getParent(); auto if_block = final_block->splitBasicBlock(instr, \"if_denominator_is_zero\", true); auto start_block = if_block->splitBasicBlock(if_block->getTerminator(), \"-INTERMEDIATE-\", true); start_block->takeName(final_block); final_block->setName(\"after_zero_check\"); builder.SetInsertPoint(start_block->getTerminator()); auto cmp = builder.CreateICmp(llvm::CmpInst::Predicate::ICMP_EQ, op2, builder.getInt64(0)); auto old_terminator = start_block->getTerminator(); llvm::BranchInst::Create(if_block, final_block, cmp, start_block); old_terminator->eraseFromParent(); raiseError(EC_QIR_DIVISION_BY_ZERO, module, if_block->getTerminator()); } // Checking error codes at end of llvm::Function* entry = nullptr; std::vector<llvm::BasicBlock*> exit_blocks; for (auto& function : module) { if (function.hasFnAttribute(\"EntryPoint\")) { entry = &function; for (auto& block : function) { auto last = block.getTerminator(); if (last && llvm::dyn_cast<llvm::ReturnInst>(last)) { exit_blocks.push_back(&block); } } break; } } if (entry) { for (auto start_block : exit_blocks) { auto if_block = start_block->splitBasicBlock(start_block->getTerminator(), \"if_error_occurred\", false); auto final_block = if_block->splitBasicBlock(if_block->getTerminator(), \"exit_block\", false); builder.SetInsertPoint(start_block->getTerminator()); llvm::LoadInst* load = builder.CreateLoad(builder.getInt64Ty(), error_variable_); auto cmp = builder.CreateICmp(llvm::CmpInst::Predicate::ICMP_NE, load, builder.getInt64(0)); auto old_terminator = start_block->getTerminator(); llvm::BranchInst::Create(if_block, final_block, cmp, start_block); old_terminator->eraseFromParent(); builder.SetInsertPoint(if_block->getTerminator()); auto fnc = module.getFunction(EC_REPORT_FUNCTION); std::vector<llvm::Value*> arguments; arguments.push_back(load); if (!fnc) { std::vector<llvm::Type*> types; types.resize(arguments.size()); for (uint64_t i = 0; i < types.size(); ++i) { types[i] = arguments[i]->getType(); } auto return_type = llvm::Type::getVoidTy(module.getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create(fnc_type, llvm::Function::ExternalLinkage, EC_REPORT_FUNCTION, module); } builder.CreateCall(fnc, arguments); } } return llvm::PreservedAnalyses::none(); } void DivisionByZeroPass::raiseError(int64_t error_code, llvm::Module& module, llvm::Instruction* instr) { llvm::IRBuilder<> builder(module.getContext()); auto const& final_block = instr->getParent(); auto if_block = final_block->splitBasicBlock(instr, \"if_ecc_not_set\", true); auto start_block = if_block->splitBasicBlock(if_block->getTerminator(), \"-INTERMEDIATE-\", true); start_block->takeName(final_block); final_block->setName(\"ecc_set_finally\"); builder.SetInsertPoint(start_block->getTerminator()); llvm::LoadInst* load = builder.CreateLoad(builder.getInt64Ty(), error_variable_); auto cmp = builder.CreateICmp(llvm::CmpInst::Predicate::ICMP_EQ, load, builder.getInt64(0)); auto old_terminator = start_block->getTerminator(); llvm::BranchInst::Create(if_block, final_block, cmp, start_block); old_terminator->eraseFromParent(); builder.SetInsertPoint(if_block->getTerminator()); builder.CreateStore(builder.getInt64(error_code), error_variable_); } bool DivisionByZeroPass::isRequired() { return true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_division_by_zero_pass_8hpp/","text":"Passes/DivisionByZeroPass/DivisionByZeroPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::DivisionByZeroPass Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetProfileConfiguration.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetQisConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class DivisionByZeroPass : public llvm::PassInfoMixin<DivisionByZeroPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using Location = ILogger::Location; using StringRef = llvm::StringRef; static const char* const EC_VARIABLE_NAME; static const char* const EC_REPORT_FUNCTION; static int64_t const EC_QIR_DIVISION_BY_ZERO; // Construction and destruction configuration. // DivisionByZeroPass() = default; DivisionByZeroPass(DivisionByZeroPass const&) = delete; DivisionByZeroPass(DivisionByZeroPass&&) = default; ~DivisionByZeroPass() = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired(); void raiseError(int64_t error_code, llvm::Module& module, llvm::Instruction* instr); private: TargetProfileConfiguration config_{}; ILoggerPtr logger_{nullptr}; llvm::GlobalVariable* error_variable_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/DivisionByZeroPass/DivisionByZeroPass.hpp"},{"location":"Api/Files/_division_by_zero_pass_8hpp/#passesdivisionbyzeropassdivisionbyzeropasshpp","text":"","title":"Passes/DivisionByZeroPass/DivisionByZeroPass.hpp"},{"location":"Api/Files/_division_by_zero_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_division_by_zero_pass_8hpp/#classes","text":"Name class microsoft::quantum::DivisionByZeroPass","title":"Classes"},{"location":"Api/Files/_division_by_zero_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetProfileConfiguration.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetQisConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class DivisionByZeroPass : public llvm::PassInfoMixin<DivisionByZeroPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using Location = ILogger::Location; using StringRef = llvm::StringRef; static const char* const EC_VARIABLE_NAME; static const char* const EC_REPORT_FUNCTION; static int64_t const EC_QIR_DIVISION_BY_ZERO; // Construction and destruction configuration. // DivisionByZeroPass() = default; DivisionByZeroPass(DivisionByZeroPass const&) = delete; DivisionByZeroPass(DivisionByZeroPass&&) = default; ~DivisionByZeroPass() = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired(); void raiseError(int64_t error_code, llvm::Module& module, llvm::Instruction* instr); private: TargetProfileConfiguration config_{}; ILoggerPtr logger_{nullptr}; llvm::GlobalVariable* error_variable_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_factory_8cpp/","text":"Passes/TargetQisMappingPass/Factory.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/TargetQisMappingPass/Factory.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" namespace microsoft::quantum { namespace { using Instruction = llvm::Instruction; using Value = llvm::Value; using Builder = ReplacementRule::Builder; using Captures = ReplacementRule::Captures; using Replacements = ReplacementRule::Replacements; } // namespace using ReplacementRulePtr = RuleFactory::ReplacementRulePtr; using namespace microsoft::quantum::notation; RuleFactory::RuleFactory( RuleSet& rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager, ILoggerPtr logger) : rule_set_{rule_set} , qubit_alloc_manager_{std::move(qubit_alloc_manager)} , result_alloc_manager_{std::move(result_alloc_manager)} , logger_{std::move(logger)} { } void RuleFactory::usingConfiguration(TargetQisMappingPassConfiguration const& config) { default_integer_width_ = config.defaultIntegerWidth(); if (config.disableReferenceCounting()) { disableReferenceCounting(); } if (config.disableAliasCounting()) { disableAliasCounting(); } if (config.disableStringSupport()) { disableStringSupport(); } if (config.disableRecordOutputSupport()) { disableRecordOutputSupport(); } if (config.optimizeQuantumConstants()) { optimizeConstantResult(); } if (config.optimizeResultOne()) { optimizeResultOne(); } if (config.optimizeResultZero()) { optimizeResultZero(); } if (config.optimizeResultComparison()) { optimizeResultComparison(); } if (config.useStaticQubitArrayAllocation()) { useStaticQubitArrayAllocation(); } if (config.useStaticQubitAllocation()) { useStaticQubitAllocation(); } if (config.useStaticResultAllocation()) { useStaticResultAllocation(); } if (config.removeGetZeroOrOne()) { removeGetZeroOrOne(); } } void RuleFactory::removeFunctionCall(String const& name) { addRule({callByNameOnly(name), deleteInstruction()}); } void RuleFactory::removeGetZeroOrOne() { addRule( {callByNameOnly(\"__quantum__rt__result_get_zero\"), deleteUnusedInstruction()}, RuleSet::ReplaceDirection::ReplaceBackwards); addRule( {callByNameOnly(\"__quantum__rt__result_get_one\"), deleteUnusedInstruction()}, RuleSet::ReplaceDirection::ReplaceBackwards); } void RuleFactory::resolveConstantArraySizes() { // Array access replacement auto size_replacer = [](Builder&, Value* val, Captures& cap, Replacements& replacements) { // Get the index and testing that it is a constant int auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"size\"]); if (cst == nullptr) { // ... if not, we cannot perform the mapping. return false; } val->replaceAllUsesWith(cst); replacements.push_back({llvm::dyn_cast<Instruction>(val), nullptr}); return true; }; auto create_array = call(\"__quantum__rt__array_create_1d\", \"elementSize\"_cap = _, \"size\"_cap = _); auto get_size = call(\"__quantum__rt__array_get_size_1d\", create_array); addRule({std::move(get_size), size_replacer}); } void RuleFactory::inlineCallables() { auto logger = logger_; // Array access replacement auto callable_replacer = [logger](Builder&, Value* val, Captures&, Replacements&) { if (logger) { logger->setLocationFromValue(val); logger->internalError(\"Support for callable replacement is not implemented yet.\"); } else { throw std::runtime_error( \"No logger present - internal error: Support for callable replacement is not implemented \" \"yet.\\n\"); } return false; }; auto create_callable = call(\"__quantum__rt__callable_create\", \"function\"_cap = _, \"size\"_cap = _, _); auto invoke = call(\"__quantum__rt__callable_invoke\", create_callable, \"args\"_cap = _, \"ret\"_cap = _); addRule({std::move(invoke), callable_replacer}); } void RuleFactory::useStaticQubitArrayAllocation() { // TODO(issue-14): Use weak pointers to capture allocation managers auto qubit_alloc_manager = qubit_alloc_manager_; auto default_iw = default_integer_width_; auto allocation_replacer = [default_iw, qubit_alloc_manager](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"size\"]); if (cst == nullptr) { return false; } auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } if (cst == nullptr) { return false; } auto llvm_size = cst->getValue(); auto name = val->getName().str(); auto size = llvm_size.getZExtValue(); auto offset = qubit_alloc_manager->allocate(name, size); // Creating a new index APInt that is shifted by the offset of the allocation auto idx = llvm::APInt(default_iw, offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); // Replacing the instruction with new instruction auto old_instr = llvm::dyn_cast<Instruction>(val); // Safety precaution to ensure that we are dealing with a Instruction if (old_instr == nullptr) { return false; } auto instr = new llvm::IntToPtrInst(new_index, ptr_type); instr->takeName(old_instr); // Ensuring that we have replaced the instruction before // identifying release old_instr->replaceAllUsesWith(instr); replacements.push_back({old_instr, instr}); return true; }; addRule({call(\"__quantum__rt__qubit_allocate_array\", \"size\"_cap = _), allocation_replacer}); // Array access replacement auto access_replacer = [qubit_alloc_manager](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { // Getting the type pointer auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } // Get the index and testing that it is a constant int auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"index\"]); if (cst == nullptr) { // ... if not, we cannot perform the mapping. return false; } // Computing the index by getting the current index value and offsetting by // the offset at which the qubit array is allocated. auto offset_cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"arrayName\"]); if (offset_cst == nullptr) { return false; } auto llvm_offset = offset_cst->getValue(); auto offset = llvm_offset.getZExtValue(); // Creating a new index APInt that is shifted by the offset of the allocation auto llvm_size = cst->getValue(); auto idx = llvm::APInt(llvm_size.getBitWidth(), llvm_size.getZExtValue() + offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto old_instr = llvm::dyn_cast<Instruction>(val); if (old_instr == nullptr) { return false; } // Converting pointer builder.SetInsertPoint(old_instr->getNextNode()); auto instr = builder.CreateIntToPtr(new_index, ptr_type); instr->takeName(old_instr); old_instr->replaceAllUsesWith(instr); // Replacing the instruction with new instruction replacements.push_back({old_instr, nullptr}); // Deleting the getelement and cast operations replacements.push_back({llvm::dyn_cast<Instruction>(cap[\"getElement\"]), nullptr}); replacements.push_back({llvm::dyn_cast<Instruction>(cap[\"cast\"]), nullptr}); return true; }; auto get_element = call( \"__quantum__rt__array_get_element_ptr_1d\", intToPtr(\"arrayName\"_cap = constInt()), \"index\"_cap = constInt()); auto cast_pattern = bitCast(\"getElement\"_cap = get_element); auto load_pattern = load(\"cast\"_cap = cast_pattern); addRule({\"Array Load Pattern\", std::move(load_pattern), access_replacer}); auto deleter = deleteInstruction(); addRule( {call(\"__quantum__rt__qubit_release_array\", intToPtr(\"const\"_cap = constInt())), [qubit_alloc_manager, deleter](Builder& builder, Value* val, Captures& cap, Replacements& rep) { // Recovering the qubit id auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"const\"]); if (cst == nullptr) { return false; } auto address = cst->getValue().getZExtValue(); // Releasing qubit_alloc_manager->release(address); // Deleting instruction return deleter(builder, val, cap, rep); }}); } void RuleFactory::useStaticQubitAllocation() { auto logger = logger_; auto qubit_alloc_manager = qubit_alloc_manager_; auto default_iw = default_integer_width_; auto allocation_replacer = [default_iw, qubit_alloc_manager](Builder& builder, Value* val, Captures&, Replacements& replacements) { // Getting the type pointer auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } auto qubit_name = val->getName().str(); // Computing the index by getting the current index value and offseting by // the offset at which the qubit array is allocated. auto offset = qubit_alloc_manager->allocate(qubit_name); // Creating a new index APInt that is shifted by the offset of the allocation auto idx = llvm::APInt(default_iw, offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto instr = new llvm::IntToPtrInst(new_index, ptr_type); // Replacing the instruction with new instruction auto old_instr = llvm::dyn_cast<Instruction>(val); // Safety precaution to ensure that we are dealing with a Instruction if (old_instr == nullptr) { return false; } instr->takeName(old_instr); // Ensuring that we have replaced the instruction before // identifying release old_instr->replaceAllUsesWith(instr); replacements.push_back({old_instr, instr}); return true; }; // Dealing with qubit allocation addRule({call(\"__quantum__rt__qubit_allocate\"), allocation_replacer}); auto deleter = deleteInstruction(); // Handling the case where a constant integer is cast to a pointer and the pointer // is used in a call to qubit_release: // // %0 = inttoptr i64 0 to %Qubit* // call void @__quantum__rt__qubit_release(%Qubit* %0 // // The case of named addresses are also covered, by this pattern: // %leftMessage = inttoptr i64 0 to %Qubit* // call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) addRule( {call(\"__quantum__rt__qubit_release\", intToPtr(\"const\"_cap = constInt())), [qubit_alloc_manager, deleter](Builder& builder, Value* val, Captures& cap, Replacements& rep) { // Recovering the qubit id auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"const\"]); if (cst == nullptr) { return false; } auto address = cst->getValue().getZExtValue(); // Releasing qubit_alloc_manager->release(address); // Deleting instruction return deleter(builder, val, cap, rep); }}); // Handling where allocation is done by non-standard functions. In // this rule reports an error as we cannot reliably do a mapping. // // %leftMessage = call %Qubit* @__non_standard_allocator() // call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) addRule( {call(\"__quantum__rt__qubit_release\", \"name\"_cap = _), [qubit_alloc_manager, deleter, logger](Builder& builder, Value* val, Captures& cap, Replacements& rep) { // Getting the name auto name = cap[\"name\"]->getName().str(); auto* phi_node = llvm::dyn_cast<llvm::PHINode>(cap[\"name\"]); if (phi_node != nullptr) { if (logger) { logger->warningReleasePhiNodeQubit(val); } else { throw std::runtime_error( \"No logger present - Warning: Cannot release qubit arising from phi node.\\n\"); } return false; } if (logger) { logger->errorReleaseFailNonStandardAlloc(val); } else { throw std::runtime_error( \"No logger present - Error: Cannot release qubit from non-standard allocation.\\n\"); } return deleter(builder, val, cap, rep); } }); } void RuleFactory::useStaticResultAllocation() { auto result_alloc_manager = result_alloc_manager_; auto default_iw = default_integer_width_; auto replace_measurement = [default_iw, result_alloc_manager](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { // Getting the type pointer auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } // Computing the index by getting the current index value and offseting by // the offset at which the qubit array is allocated. auto offset = result_alloc_manager->allocate(); // Creating a new index APInt that is shifted by the offset of the allocation auto idx = llvm::APInt(default_iw, offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto instr = new llvm::IntToPtrInst(new_index, ptr_type); if (instr == nullptr) { return false; } instr->takeName(val); auto orig_instr = llvm::dyn_cast<llvm::Instruction>(val); if (orig_instr == nullptr) { return false; } auto module = orig_instr->getModule(); auto fnc = module->getFunction(\"__quantum__qis__mz__body\"); std::vector<llvm::Value*> arguments; arguments.push_back(cap[\"qubit\"]); arguments.push_back(instr); if (!fnc) { std::vector<llvm::Type*> types; types.resize(arguments.size()); for (uint64_t i = 0; i < types.size(); ++i) { types[i] = arguments[i]->getType(); } auto return_type = llvm::Type::getVoidTy(val->getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create(fnc_type, llvm::Function::ExternalLinkage, \"__quantum__qis__mz__body\", module); } // Ensuring we are inserting after the instruction being deleted builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(val)->getNextNode()); builder.CreateCall(fnc, arguments); // Replacing the instruction with new instruction replacements.push_back({llvm::dyn_cast<Instruction>(val), instr}); return true; }; // This rules identifies result allocations through the function \"__quantum__qis__m__body\". // As an example, the following // // %result1 = call %Result* @__quantum__qis__m__body(%Qubit* %0) // // translates into // // %result1 = inttoptr i64 0 to %Result* // call void @__quantum__qis__mz__body(%Qubit* %0, %Result* %result1) addRule({call(\"__quantum__qis__m__body\", \"qubit\"_cap = _), std::move(replace_measurement)}); } void RuleFactory::optimizeResultZero() { auto replace_branch_negative = [](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto cond = llvm::dyn_cast<llvm::Instruction>(val); if (cond == nullptr) { return false; } auto result = cap[\"result\"]; // Replacing result auto orig_instr = llvm::dyn_cast<llvm::Instruction>(val); if (orig_instr == nullptr) { return false; } auto module = orig_instr->getModule(); auto fnc = module->getFunction(\"__quantum__qis__read_result__body\"); std::vector<llvm::Value*> arguments; arguments.push_back(result); if (!fnc) { std::vector<llvm::Type*> types; types.resize(arguments.size()); for (uint64_t i = 0; i < types.size(); ++i) { types[i] = arguments[i]->getType(); } auto return_type = llvm::Type::getInt1Ty(val->getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create( fnc_type, llvm::Function::ExternalLinkage, \"__quantum__qis__read_result__body\", module); } builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(val)); auto new_call = builder.CreateCall(fnc, arguments); auto new_cond = builder.CreateNot(new_call); new_cond->takeName(cond); for (auto& use : cond->uses()) { llvm::User* user = use.getUser(); user->setOperand(use.getOperandNo(), new_cond); } cond->replaceAllUsesWith(new_cond); // Deleting the previous condition and function to fetch one replacements.push_back({cond, nullptr}); replacements.push_back({cap[\"zero\"], nullptr}); return true; }; /* Here is an example IR for which we want to make a match: %1 = call %Result* @__quantum__rt__result_get_zero() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 */ // Variations of get_one auto get_zero = call(\"__quantum__rt__result_get_zero\"); addRule({call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"zero\"_cap = get_zero), replace_branch_negative}); addRule({call(\"__quantum__rt__result_equal\", \"zero\"_cap = get_zero, \"result\"_cap = _), replace_branch_negative}); } void RuleFactory::optimizeResultOne() { auto replace_branch_positive = [](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto cond = llvm::dyn_cast<llvm::Instruction>(val); if (cond == nullptr) { return false; } auto result = cap[\"result\"]; // Replacing result auto orig_instr = llvm::dyn_cast<llvm::Instruction>(val); if (orig_instr == nullptr) { return false; } auto module = orig_instr->getModule(); auto fnc = module->getFunction(\"__quantum__qis__read_result__body\"); std::vector<llvm::Value*> arguments; arguments.push_back(result); if (!fnc) { std::vector<llvm::Type*> types; types.resize(arguments.size()); for (uint64_t i = 0; i < types.size(); ++i) { types[i] = arguments[i]->getType(); } auto return_type = llvm::Type::getInt1Ty(val->getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create( fnc_type, llvm::Function::ExternalLinkage, \"__quantum__qis__read_result__body\", module); } builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(val)); auto new_call = builder.CreateCall(fnc, arguments); new_call->takeName(cond); for (auto& use : cond->uses()) { llvm::User* user = use.getUser(); user->setOperand(use.getOperandNo(), new_call); } cond->replaceAllUsesWith(new_call); // Deleting the previous condition and function to fetch one replacements.push_back({cond, nullptr}); replacements.push_back({cap[\"one\"], nullptr}); return true; }; /* Here is an example IR for which we want to make a match: %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 */ // Variations of get_one auto get_one = call(\"__quantum__rt__result_get_one\"); addRule({call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), replace_branch_positive}); addRule({call(\"__quantum__rt__result_equal\", \"one\"_cap = get_one, \"result\"_cap = _), replace_branch_positive}); } void RuleFactory::optimizeConstantResult() { auto replace_constant_result = [](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto f1 = llvm::dyn_cast<llvm::CallInst>(cap[\"1\"]); auto f2 = llvm::dyn_cast<llvm::CallInst>(cap[\"2\"]); if (f1 == nullptr || f2 == nullptr) { return false; } auto n1 = f1->getCalledFunction()->getName(); auto n2 = f2->getCalledFunction()->getName(); bool value = n1 == n2; auto llvm_value = llvm::APInt(1, value); // Computing offset auto new_instr = llvm::ConstantInt::get(builder.getContext(), llvm_value); val->replaceAllUsesWith(new_instr); replacements.push_back({val, nullptr}); replacements.push_back({f1, nullptr}); replacements.push_back({f2, nullptr}); return true; }; auto get_zero = call(\"__quantum__rt__result_get_zero\"); auto get_one = call(\"__quantum__rt__result_get_one\"); addRule({call(\"__quantum__rt__result_equal\", \"1\"_cap = get_zero, \"2\"_cap = get_zero), replace_constant_result}); addRule({call(\"__quantum__rt__result_equal\", \"1\"_cap = get_zero, \"2\"_cap = get_one), replace_constant_result}); addRule({call(\"__quantum__rt__result_equal\", \"1\"_cap = get_one, \"2\"_cap = get_zero), replace_constant_result}); addRule({call(\"__quantum__rt__result_equal\", \"1\"_cap = get_one, \"2\"_cap = get_one), replace_constant_result}); } void RuleFactory::optimizeResultComparison() { auto replace_comparison = [](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto cond = llvm::dyn_cast<llvm::Instruction>(val); if (cond == nullptr) { return false; } auto m1 = cap[\"m1\"]; auto m2 = cap[\"m2\"]; if (m1 == nullptr || m2 == nullptr) { return false; } auto orig_instr = llvm::dyn_cast<llvm::Instruction>(val); if (orig_instr == nullptr) { return false; } auto module = orig_instr->getModule(); auto fnc = module->getFunction(\"__quantum__qis__read_result__body\"); if (!fnc) { std::vector<llvm::Type*> types; types.resize(1); types[0] = m1->getType(); auto return_type = llvm::Type::getInt1Ty(val->getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create( fnc_type, llvm::Function::ExternalLinkage, \"__quantum__qis__read_result__body\", module); } builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(val)); auto c1 = builder.CreateCall(fnc, {m1}); auto c2 = builder.CreateCall(fnc, {m2}); auto new_cond = builder.CreateICmpEQ(c1, c2); new_cond->takeName(cond); for (auto& use : cond->uses()) { llvm::User* user = use.getUser(); user->setOperand(use.getOperandNo(), new_cond); } cond->replaceAllUsesWith(new_cond); // Deleting the previous condition and function to fetch one replacements.push_back({cond, nullptr}); return true; }; /* Here is an example IR for which we want to make a match: %result1 = call %Result* @__quantum__qis__m__body(%Qubit* %q0) %result2 = call %Result* @__quantum__qis__m__body(%Qubit* %q1) %0 = call i1 @__quantum__rt__result_equal(%Result* %result1, %Result* %result2) */ auto m1 = call(\"__quantum__qis__m__body\", \"q1\"_cap = _); auto m2 = call(\"__quantum__qis__m__body\", \"q2\"_cap = _); addRule({call(\"__quantum__rt__result_equal\", \"m1\"_cap = m1, \"m2\"_cap = m2), replace_comparison}); } void RuleFactory::disableReferenceCounting() { removeFunctionCall(\"__quantum__rt__array_update_reference_count\"); removeFunctionCall(\"__quantum__rt__string_update_reference_count\"); removeFunctionCall(\"__quantum__rt__result_update_reference_count\"); } void RuleFactory::disableAliasCounting() { removeFunctionCall(\"__quantum__rt__array_update_alias_count\"); removeFunctionCall(\"__quantum__rt__string_update_alias_count\"); removeFunctionCall(\"__quantum__rt__result_update_alias_count\"); } void RuleFactory::disableStringSupport() { removeFunctionCall(\"__quantum__rt__fail\"); removeFunctionCall(\"__quantum__rt__message\"); removeFunctionCall(\"__quantum__rt__string_update_alias_count\"); removeFunctionCall(\"__quantum__rt__string_create\"); removeFunctionCall(\"__quantum__rt__string_get_data\"); removeFunctionCall(\"__quantum__rt__string_get_length\"); removeFunctionCall(\"__quantum__rt__string_update_reference_count\"); removeFunctionCall(\"__quantum__rt__string_concatenate\"); removeFunctionCall(\"__quantum__rt__string_equal\"); removeFunctionCall(\"__quantum__rt__int_to_string\"); removeFunctionCall(\"__quantum__rt__double_to_string\"); removeFunctionCall(\"__quantum__rt__bool_to_string\"); removeFunctionCall(\"__quantum__rt__result_to_string\"); removeFunctionCall(\"__quantum__rt__pauli_to_string\"); removeFunctionCall(\"__quantum__rt__qubit_to_string\"); removeFunctionCall(\"__quantum__rt__range_to_string\"); removeFunctionCall(\"__quantum__rt__bigint_to_string\"); } void RuleFactory::disableRecordOutputSupport() { removeFunctionCall(\"__quantum__rt__result_record_output\"); removeFunctionCall(\"__quantum__rt__bool_record_output\"); removeFunctionCall(\"__quantum__rt__integer_record_output\"); removeFunctionCall(\"__quantum__rt__double_record_output\"); removeFunctionCall(\"__quantum__rt__tuple_start_record_output\"); removeFunctionCall(\"__quantum__rt__tuple_end_record_output\"); removeFunctionCall(\"__quantum__rt__array_start_record_output\"); removeFunctionCall(\"__quantum__rt__array_end_record_output\"); } ReplacementRulePtr RuleFactory::addRule(ReplacementRule&& rule, RuleSet::ReplaceDirection const& dir) { auto ret = std::make_shared<ReplacementRule>(std::move(rule)); rule_set_.addRule(ret, dir); return ret; } void RuleFactory::setDefaultIntegerWidth(uint32_t v) { default_integer_width_ = v; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/TargetQisMappingPass/Factory.cpp"},{"location":"Api/Files/_factory_8cpp/#passestargetqismappingpassfactorycpp","text":"","title":"Passes/TargetQisMappingPass/Factory.cpp"},{"location":"Api/Files/_factory_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_factory_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/TargetQisMappingPass/Factory.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" namespace microsoft::quantum { namespace { using Instruction = llvm::Instruction; using Value = llvm::Value; using Builder = ReplacementRule::Builder; using Captures = ReplacementRule::Captures; using Replacements = ReplacementRule::Replacements; } // namespace using ReplacementRulePtr = RuleFactory::ReplacementRulePtr; using namespace microsoft::quantum::notation; RuleFactory::RuleFactory( RuleSet& rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager, ILoggerPtr logger) : rule_set_{rule_set} , qubit_alloc_manager_{std::move(qubit_alloc_manager)} , result_alloc_manager_{std::move(result_alloc_manager)} , logger_{std::move(logger)} { } void RuleFactory::usingConfiguration(TargetQisMappingPassConfiguration const& config) { default_integer_width_ = config.defaultIntegerWidth(); if (config.disableReferenceCounting()) { disableReferenceCounting(); } if (config.disableAliasCounting()) { disableAliasCounting(); } if (config.disableStringSupport()) { disableStringSupport(); } if (config.disableRecordOutputSupport()) { disableRecordOutputSupport(); } if (config.optimizeQuantumConstants()) { optimizeConstantResult(); } if (config.optimizeResultOne()) { optimizeResultOne(); } if (config.optimizeResultZero()) { optimizeResultZero(); } if (config.optimizeResultComparison()) { optimizeResultComparison(); } if (config.useStaticQubitArrayAllocation()) { useStaticQubitArrayAllocation(); } if (config.useStaticQubitAllocation()) { useStaticQubitAllocation(); } if (config.useStaticResultAllocation()) { useStaticResultAllocation(); } if (config.removeGetZeroOrOne()) { removeGetZeroOrOne(); } } void RuleFactory::removeFunctionCall(String const& name) { addRule({callByNameOnly(name), deleteInstruction()}); } void RuleFactory::removeGetZeroOrOne() { addRule( {callByNameOnly(\"__quantum__rt__result_get_zero\"), deleteUnusedInstruction()}, RuleSet::ReplaceDirection::ReplaceBackwards); addRule( {callByNameOnly(\"__quantum__rt__result_get_one\"), deleteUnusedInstruction()}, RuleSet::ReplaceDirection::ReplaceBackwards); } void RuleFactory::resolveConstantArraySizes() { // Array access replacement auto size_replacer = [](Builder&, Value* val, Captures& cap, Replacements& replacements) { // Get the index and testing that it is a constant int auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"size\"]); if (cst == nullptr) { // ... if not, we cannot perform the mapping. return false; } val->replaceAllUsesWith(cst); replacements.push_back({llvm::dyn_cast<Instruction>(val), nullptr}); return true; }; auto create_array = call(\"__quantum__rt__array_create_1d\", \"elementSize\"_cap = _, \"size\"_cap = _); auto get_size = call(\"__quantum__rt__array_get_size_1d\", create_array); addRule({std::move(get_size), size_replacer}); } void RuleFactory::inlineCallables() { auto logger = logger_; // Array access replacement auto callable_replacer = [logger](Builder&, Value* val, Captures&, Replacements&) { if (logger) { logger->setLocationFromValue(val); logger->internalError(\"Support for callable replacement is not implemented yet.\"); } else { throw std::runtime_error( \"No logger present - internal error: Support for callable replacement is not implemented \" \"yet.\\n\"); } return false; }; auto create_callable = call(\"__quantum__rt__callable_create\", \"function\"_cap = _, \"size\"_cap = _, _); auto invoke = call(\"__quantum__rt__callable_invoke\", create_callable, \"args\"_cap = _, \"ret\"_cap = _); addRule({std::move(invoke), callable_replacer}); } void RuleFactory::useStaticQubitArrayAllocation() { // TODO(issue-14): Use weak pointers to capture allocation managers auto qubit_alloc_manager = qubit_alloc_manager_; auto default_iw = default_integer_width_; auto allocation_replacer = [default_iw, qubit_alloc_manager](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"size\"]); if (cst == nullptr) { return false; } auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } if (cst == nullptr) { return false; } auto llvm_size = cst->getValue(); auto name = val->getName().str(); auto size = llvm_size.getZExtValue(); auto offset = qubit_alloc_manager->allocate(name, size); // Creating a new index APInt that is shifted by the offset of the allocation auto idx = llvm::APInt(default_iw, offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); // Replacing the instruction with new instruction auto old_instr = llvm::dyn_cast<Instruction>(val); // Safety precaution to ensure that we are dealing with a Instruction if (old_instr == nullptr) { return false; } auto instr = new llvm::IntToPtrInst(new_index, ptr_type); instr->takeName(old_instr); // Ensuring that we have replaced the instruction before // identifying release old_instr->replaceAllUsesWith(instr); replacements.push_back({old_instr, instr}); return true; }; addRule({call(\"__quantum__rt__qubit_allocate_array\", \"size\"_cap = _), allocation_replacer}); // Array access replacement auto access_replacer = [qubit_alloc_manager](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { // Getting the type pointer auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } // Get the index and testing that it is a constant int auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"index\"]); if (cst == nullptr) { // ... if not, we cannot perform the mapping. return false; } // Computing the index by getting the current index value and offsetting by // the offset at which the qubit array is allocated. auto offset_cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"arrayName\"]); if (offset_cst == nullptr) { return false; } auto llvm_offset = offset_cst->getValue(); auto offset = llvm_offset.getZExtValue(); // Creating a new index APInt that is shifted by the offset of the allocation auto llvm_size = cst->getValue(); auto idx = llvm::APInt(llvm_size.getBitWidth(), llvm_size.getZExtValue() + offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto old_instr = llvm::dyn_cast<Instruction>(val); if (old_instr == nullptr) { return false; } // Converting pointer builder.SetInsertPoint(old_instr->getNextNode()); auto instr = builder.CreateIntToPtr(new_index, ptr_type); instr->takeName(old_instr); old_instr->replaceAllUsesWith(instr); // Replacing the instruction with new instruction replacements.push_back({old_instr, nullptr}); // Deleting the getelement and cast operations replacements.push_back({llvm::dyn_cast<Instruction>(cap[\"getElement\"]), nullptr}); replacements.push_back({llvm::dyn_cast<Instruction>(cap[\"cast\"]), nullptr}); return true; }; auto get_element = call( \"__quantum__rt__array_get_element_ptr_1d\", intToPtr(\"arrayName\"_cap = constInt()), \"index\"_cap = constInt()); auto cast_pattern = bitCast(\"getElement\"_cap = get_element); auto load_pattern = load(\"cast\"_cap = cast_pattern); addRule({\"Array Load Pattern\", std::move(load_pattern), access_replacer}); auto deleter = deleteInstruction(); addRule( {call(\"__quantum__rt__qubit_release_array\", intToPtr(\"const\"_cap = constInt())), [qubit_alloc_manager, deleter](Builder& builder, Value* val, Captures& cap, Replacements& rep) { // Recovering the qubit id auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"const\"]); if (cst == nullptr) { return false; } auto address = cst->getValue().getZExtValue(); // Releasing qubit_alloc_manager->release(address); // Deleting instruction return deleter(builder, val, cap, rep); }}); } void RuleFactory::useStaticQubitAllocation() { auto logger = logger_; auto qubit_alloc_manager = qubit_alloc_manager_; auto default_iw = default_integer_width_; auto allocation_replacer = [default_iw, qubit_alloc_manager](Builder& builder, Value* val, Captures&, Replacements& replacements) { // Getting the type pointer auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } auto qubit_name = val->getName().str(); // Computing the index by getting the current index value and offseting by // the offset at which the qubit array is allocated. auto offset = qubit_alloc_manager->allocate(qubit_name); // Creating a new index APInt that is shifted by the offset of the allocation auto idx = llvm::APInt(default_iw, offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto instr = new llvm::IntToPtrInst(new_index, ptr_type); // Replacing the instruction with new instruction auto old_instr = llvm::dyn_cast<Instruction>(val); // Safety precaution to ensure that we are dealing with a Instruction if (old_instr == nullptr) { return false; } instr->takeName(old_instr); // Ensuring that we have replaced the instruction before // identifying release old_instr->replaceAllUsesWith(instr); replacements.push_back({old_instr, instr}); return true; }; // Dealing with qubit allocation addRule({call(\"__quantum__rt__qubit_allocate\"), allocation_replacer}); auto deleter = deleteInstruction(); // Handling the case where a constant integer is cast to a pointer and the pointer // is used in a call to qubit_release: // // %0 = inttoptr i64 0 to %Qubit* // call void @__quantum__rt__qubit_release(%Qubit* %0 // // The case of named addresses are also covered, by this pattern: // %leftMessage = inttoptr i64 0 to %Qubit* // call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) addRule( {call(\"__quantum__rt__qubit_release\", intToPtr(\"const\"_cap = constInt())), [qubit_alloc_manager, deleter](Builder& builder, Value* val, Captures& cap, Replacements& rep) { // Recovering the qubit id auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"const\"]); if (cst == nullptr) { return false; } auto address = cst->getValue().getZExtValue(); // Releasing qubit_alloc_manager->release(address); // Deleting instruction return deleter(builder, val, cap, rep); }}); // Handling where allocation is done by non-standard functions. In // this rule reports an error as we cannot reliably do a mapping. // // %leftMessage = call %Qubit* @__non_standard_allocator() // call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) addRule( {call(\"__quantum__rt__qubit_release\", \"name\"_cap = _), [qubit_alloc_manager, deleter, logger](Builder& builder, Value* val, Captures& cap, Replacements& rep) { // Getting the name auto name = cap[\"name\"]->getName().str(); auto* phi_node = llvm::dyn_cast<llvm::PHINode>(cap[\"name\"]); if (phi_node != nullptr) { if (logger) { logger->warningReleasePhiNodeQubit(val); } else { throw std::runtime_error( \"No logger present - Warning: Cannot release qubit arising from phi node.\\n\"); } return false; } if (logger) { logger->errorReleaseFailNonStandardAlloc(val); } else { throw std::runtime_error( \"No logger present - Error: Cannot release qubit from non-standard allocation.\\n\"); } return deleter(builder, val, cap, rep); } }); } void RuleFactory::useStaticResultAllocation() { auto result_alloc_manager = result_alloc_manager_; auto default_iw = default_integer_width_; auto replace_measurement = [default_iw, result_alloc_manager](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { // Getting the type pointer auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } // Computing the index by getting the current index value and offseting by // the offset at which the qubit array is allocated. auto offset = result_alloc_manager->allocate(); // Creating a new index APInt that is shifted by the offset of the allocation auto idx = llvm::APInt(default_iw, offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto instr = new llvm::IntToPtrInst(new_index, ptr_type); if (instr == nullptr) { return false; } instr->takeName(val); auto orig_instr = llvm::dyn_cast<llvm::Instruction>(val); if (orig_instr == nullptr) { return false; } auto module = orig_instr->getModule(); auto fnc = module->getFunction(\"__quantum__qis__mz__body\"); std::vector<llvm::Value*> arguments; arguments.push_back(cap[\"qubit\"]); arguments.push_back(instr); if (!fnc) { std::vector<llvm::Type*> types; types.resize(arguments.size()); for (uint64_t i = 0; i < types.size(); ++i) { types[i] = arguments[i]->getType(); } auto return_type = llvm::Type::getVoidTy(val->getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create(fnc_type, llvm::Function::ExternalLinkage, \"__quantum__qis__mz__body\", module); } // Ensuring we are inserting after the instruction being deleted builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(val)->getNextNode()); builder.CreateCall(fnc, arguments); // Replacing the instruction with new instruction replacements.push_back({llvm::dyn_cast<Instruction>(val), instr}); return true; }; // This rules identifies result allocations through the function \"__quantum__qis__m__body\". // As an example, the following // // %result1 = call %Result* @__quantum__qis__m__body(%Qubit* %0) // // translates into // // %result1 = inttoptr i64 0 to %Result* // call void @__quantum__qis__mz__body(%Qubit* %0, %Result* %result1) addRule({call(\"__quantum__qis__m__body\", \"qubit\"_cap = _), std::move(replace_measurement)}); } void RuleFactory::optimizeResultZero() { auto replace_branch_negative = [](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto cond = llvm::dyn_cast<llvm::Instruction>(val); if (cond == nullptr) { return false; } auto result = cap[\"result\"]; // Replacing result auto orig_instr = llvm::dyn_cast<llvm::Instruction>(val); if (orig_instr == nullptr) { return false; } auto module = orig_instr->getModule(); auto fnc = module->getFunction(\"__quantum__qis__read_result__body\"); std::vector<llvm::Value*> arguments; arguments.push_back(result); if (!fnc) { std::vector<llvm::Type*> types; types.resize(arguments.size()); for (uint64_t i = 0; i < types.size(); ++i) { types[i] = arguments[i]->getType(); } auto return_type = llvm::Type::getInt1Ty(val->getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create( fnc_type, llvm::Function::ExternalLinkage, \"__quantum__qis__read_result__body\", module); } builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(val)); auto new_call = builder.CreateCall(fnc, arguments); auto new_cond = builder.CreateNot(new_call); new_cond->takeName(cond); for (auto& use : cond->uses()) { llvm::User* user = use.getUser(); user->setOperand(use.getOperandNo(), new_cond); } cond->replaceAllUsesWith(new_cond); // Deleting the previous condition and function to fetch one replacements.push_back({cond, nullptr}); replacements.push_back({cap[\"zero\"], nullptr}); return true; }; /* Here is an example IR for which we want to make a match: %1 = call %Result* @__quantum__rt__result_get_zero() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 */ // Variations of get_one auto get_zero = call(\"__quantum__rt__result_get_zero\"); addRule({call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"zero\"_cap = get_zero), replace_branch_negative}); addRule({call(\"__quantum__rt__result_equal\", \"zero\"_cap = get_zero, \"result\"_cap = _), replace_branch_negative}); } void RuleFactory::optimizeResultOne() { auto replace_branch_positive = [](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto cond = llvm::dyn_cast<llvm::Instruction>(val); if (cond == nullptr) { return false; } auto result = cap[\"result\"]; // Replacing result auto orig_instr = llvm::dyn_cast<llvm::Instruction>(val); if (orig_instr == nullptr) { return false; } auto module = orig_instr->getModule(); auto fnc = module->getFunction(\"__quantum__qis__read_result__body\"); std::vector<llvm::Value*> arguments; arguments.push_back(result); if (!fnc) { std::vector<llvm::Type*> types; types.resize(arguments.size()); for (uint64_t i = 0; i < types.size(); ++i) { types[i] = arguments[i]->getType(); } auto return_type = llvm::Type::getInt1Ty(val->getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create( fnc_type, llvm::Function::ExternalLinkage, \"__quantum__qis__read_result__body\", module); } builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(val)); auto new_call = builder.CreateCall(fnc, arguments); new_call->takeName(cond); for (auto& use : cond->uses()) { llvm::User* user = use.getUser(); user->setOperand(use.getOperandNo(), new_call); } cond->replaceAllUsesWith(new_call); // Deleting the previous condition and function to fetch one replacements.push_back({cond, nullptr}); replacements.push_back({cap[\"one\"], nullptr}); return true; }; /* Here is an example IR for which we want to make a match: %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 */ // Variations of get_one auto get_one = call(\"__quantum__rt__result_get_one\"); addRule({call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), replace_branch_positive}); addRule({call(\"__quantum__rt__result_equal\", \"one\"_cap = get_one, \"result\"_cap = _), replace_branch_positive}); } void RuleFactory::optimizeConstantResult() { auto replace_constant_result = [](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto f1 = llvm::dyn_cast<llvm::CallInst>(cap[\"1\"]); auto f2 = llvm::dyn_cast<llvm::CallInst>(cap[\"2\"]); if (f1 == nullptr || f2 == nullptr) { return false; } auto n1 = f1->getCalledFunction()->getName(); auto n2 = f2->getCalledFunction()->getName(); bool value = n1 == n2; auto llvm_value = llvm::APInt(1, value); // Computing offset auto new_instr = llvm::ConstantInt::get(builder.getContext(), llvm_value); val->replaceAllUsesWith(new_instr); replacements.push_back({val, nullptr}); replacements.push_back({f1, nullptr}); replacements.push_back({f2, nullptr}); return true; }; auto get_zero = call(\"__quantum__rt__result_get_zero\"); auto get_one = call(\"__quantum__rt__result_get_one\"); addRule({call(\"__quantum__rt__result_equal\", \"1\"_cap = get_zero, \"2\"_cap = get_zero), replace_constant_result}); addRule({call(\"__quantum__rt__result_equal\", \"1\"_cap = get_zero, \"2\"_cap = get_one), replace_constant_result}); addRule({call(\"__quantum__rt__result_equal\", \"1\"_cap = get_one, \"2\"_cap = get_zero), replace_constant_result}); addRule({call(\"__quantum__rt__result_equal\", \"1\"_cap = get_one, \"2\"_cap = get_one), replace_constant_result}); } void RuleFactory::optimizeResultComparison() { auto replace_comparison = [](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto cond = llvm::dyn_cast<llvm::Instruction>(val); if (cond == nullptr) { return false; } auto m1 = cap[\"m1\"]; auto m2 = cap[\"m2\"]; if (m1 == nullptr || m2 == nullptr) { return false; } auto orig_instr = llvm::dyn_cast<llvm::Instruction>(val); if (orig_instr == nullptr) { return false; } auto module = orig_instr->getModule(); auto fnc = module->getFunction(\"__quantum__qis__read_result__body\"); if (!fnc) { std::vector<llvm::Type*> types; types.resize(1); types[0] = m1->getType(); auto return_type = llvm::Type::getInt1Ty(val->getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create( fnc_type, llvm::Function::ExternalLinkage, \"__quantum__qis__read_result__body\", module); } builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(val)); auto c1 = builder.CreateCall(fnc, {m1}); auto c2 = builder.CreateCall(fnc, {m2}); auto new_cond = builder.CreateICmpEQ(c1, c2); new_cond->takeName(cond); for (auto& use : cond->uses()) { llvm::User* user = use.getUser(); user->setOperand(use.getOperandNo(), new_cond); } cond->replaceAllUsesWith(new_cond); // Deleting the previous condition and function to fetch one replacements.push_back({cond, nullptr}); return true; }; /* Here is an example IR for which we want to make a match: %result1 = call %Result* @__quantum__qis__m__body(%Qubit* %q0) %result2 = call %Result* @__quantum__qis__m__body(%Qubit* %q1) %0 = call i1 @__quantum__rt__result_equal(%Result* %result1, %Result* %result2) */ auto m1 = call(\"__quantum__qis__m__body\", \"q1\"_cap = _); auto m2 = call(\"__quantum__qis__m__body\", \"q2\"_cap = _); addRule({call(\"__quantum__rt__result_equal\", \"m1\"_cap = m1, \"m2\"_cap = m2), replace_comparison}); } void RuleFactory::disableReferenceCounting() { removeFunctionCall(\"__quantum__rt__array_update_reference_count\"); removeFunctionCall(\"__quantum__rt__string_update_reference_count\"); removeFunctionCall(\"__quantum__rt__result_update_reference_count\"); } void RuleFactory::disableAliasCounting() { removeFunctionCall(\"__quantum__rt__array_update_alias_count\"); removeFunctionCall(\"__quantum__rt__string_update_alias_count\"); removeFunctionCall(\"__quantum__rt__result_update_alias_count\"); } void RuleFactory::disableStringSupport() { removeFunctionCall(\"__quantum__rt__fail\"); removeFunctionCall(\"__quantum__rt__message\"); removeFunctionCall(\"__quantum__rt__string_update_alias_count\"); removeFunctionCall(\"__quantum__rt__string_create\"); removeFunctionCall(\"__quantum__rt__string_get_data\"); removeFunctionCall(\"__quantum__rt__string_get_length\"); removeFunctionCall(\"__quantum__rt__string_update_reference_count\"); removeFunctionCall(\"__quantum__rt__string_concatenate\"); removeFunctionCall(\"__quantum__rt__string_equal\"); removeFunctionCall(\"__quantum__rt__int_to_string\"); removeFunctionCall(\"__quantum__rt__double_to_string\"); removeFunctionCall(\"__quantum__rt__bool_to_string\"); removeFunctionCall(\"__quantum__rt__result_to_string\"); removeFunctionCall(\"__quantum__rt__pauli_to_string\"); removeFunctionCall(\"__quantum__rt__qubit_to_string\"); removeFunctionCall(\"__quantum__rt__range_to_string\"); removeFunctionCall(\"__quantum__rt__bigint_to_string\"); } void RuleFactory::disableRecordOutputSupport() { removeFunctionCall(\"__quantum__rt__result_record_output\"); removeFunctionCall(\"__quantum__rt__bool_record_output\"); removeFunctionCall(\"__quantum__rt__integer_record_output\"); removeFunctionCall(\"__quantum__rt__double_record_output\"); removeFunctionCall(\"__quantum__rt__tuple_start_record_output\"); removeFunctionCall(\"__quantum__rt__tuple_end_record_output\"); removeFunctionCall(\"__quantum__rt__array_start_record_output\"); removeFunctionCall(\"__quantum__rt__array_end_record_output\"); } ReplacementRulePtr RuleFactory::addRule(ReplacementRule&& rule, RuleSet::ReplaceDirection const& dir) { auto ret = std::make_shared<ReplacementRule>(std::move(rule)); rule_set_.addRule(ret, dir); return ret; } void RuleFactory::setDefaultIntegerWidth(uint32_t v) { default_integer_width_ = v; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_factory_8hpp/","text":"Passes/TargetQisMappingPass/Factory.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::RuleFactory Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AllocationManager/AllocationManager.hpp\" #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/TargetQisMappingPassConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include \"qir/qat/Rules/ReplacementRule.hpp\" #include \"qir/qat/Rules/RuleSet.hpp\" #include <memory> namespace microsoft::quantum { class RuleFactory { public: using ReplacementRulePtr = std::shared_ptr<ReplacementRule>; using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; using ILoggerPtr = ILogger::ILoggerPtr; // Constructor configuration. Explicit construction with // rule set to be configured, which can be moved using move // semantics. No copy allowed. // RuleFactory( RuleSet& rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager, ILoggerPtr logger); RuleFactory() = delete; RuleFactory(RuleFactory const&) = delete; RuleFactory(RuleFactory&&) = default; ~RuleFactory() = default; // // void usingConfiguration(TargetQisMappingPassConfiguration const& config); // Generic rules // void removeFunctionCall(String const& name); // Conventions // void useStaticQubitArrayAllocation(); void useStaticQubitAllocation(); void useStaticResultAllocation(); void resolveConstantArraySizes(); void inlineCallables(); // Optimizations // void optimizeResultOne(); void optimizeResultZero(); void optimizeConstantResult(); void optimizeResultComparison(); void removeGetZeroOrOne(); // Disabling by feature // void disableReferenceCounting(); void disableAliasCounting(); void disableStringSupport(); void disableRecordOutputSupport(); // Configuration // void setDefaultIntegerWidth(uint32_t v); private: ReplacementRulePtr addRule( ReplacementRule&& rule, RuleSet::ReplaceDirection const& dir = RuleSet::ReplaceDirection::ReplaceForwards); // Affected artefacts // RuleSet& rule_set_; // Allocation managers. // AllocationManagerPtr qubit_alloc_manager_{nullptr}; AllocationManagerPtr result_alloc_manager_{nullptr}; ILoggerPtr logger_{nullptr}; // uint32_t default_integer_width_{64}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/TargetQisMappingPass/Factory.hpp"},{"location":"Api/Files/_factory_8hpp/#passestargetqismappingpassfactoryhpp","text":"","title":"Passes/TargetQisMappingPass/Factory.hpp"},{"location":"Api/Files/_factory_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_factory_8hpp/#classes","text":"Name class microsoft::quantum::RuleFactory","title":"Classes"},{"location":"Api/Files/_factory_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AllocationManager/AllocationManager.hpp\" #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/TargetQisMappingPassConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include \"qir/qat/Rules/ReplacementRule.hpp\" #include \"qir/qat/Rules/RuleSet.hpp\" #include <memory> namespace microsoft::quantum { class RuleFactory { public: using ReplacementRulePtr = std::shared_ptr<ReplacementRule>; using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; using ILoggerPtr = ILogger::ILoggerPtr; // Constructor configuration. Explicit construction with // rule set to be configured, which can be moved using move // semantics. No copy allowed. // RuleFactory( RuleSet& rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager, ILoggerPtr logger); RuleFactory() = delete; RuleFactory(RuleFactory const&) = delete; RuleFactory(RuleFactory&&) = default; ~RuleFactory() = default; // // void usingConfiguration(TargetQisMappingPassConfiguration const& config); // Generic rules // void removeFunctionCall(String const& name); // Conventions // void useStaticQubitArrayAllocation(); void useStaticQubitAllocation(); void useStaticResultAllocation(); void resolveConstantArraySizes(); void inlineCallables(); // Optimizations // void optimizeResultOne(); void optimizeResultZero(); void optimizeConstantResult(); void optimizeResultComparison(); void removeGetZeroOrOne(); // Disabling by feature // void disableReferenceCounting(); void disableAliasCounting(); void disableStringSupport(); void disableRecordOutputSupport(); // Configuration // void setDefaultIntegerWidth(uint32_t v); private: ReplacementRulePtr addRule( ReplacementRule&& rule, RuleSet::ReplaceDirection const& dir = RuleSet::ReplaceDirection::ReplaceForwards); // Affected artefacts // RuleSet& rule_set_; // Allocation managers. // AllocationManagerPtr qubit_alloc_manager_{nullptr}; AllocationManagerPtr result_alloc_manager_{nullptr}; ILoggerPtr logger_{nullptr}; // uint32_t default_integer_width_{64}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_function_annotator_pass_8cpp/","text":"Passes/FunctionReplacementPass/FunctionAnnotatorPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/FunctionReplacementPass/FunctionAnnotatorPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { bool FunctionAnnotatorPass::isRequired() { return true; } llvm::PreservedAnalyses FunctionAnnotatorPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { bool changed = false; auto annotations = config_.injectedAnnotations(); // Removing all function call attributes if (config_.shouldRemoveCallAttributes()) { for (auto& function : module) { for (auto& block : function) { for (auto& instr : block) { auto call_instr = llvm::dyn_cast<llvm::CallBase>(&instr); if (!call_instr) { continue; } call_instr->setAttributes({}); changed = true; } } } } // Adding replaceWith as requested for (auto& function : module) { auto name = static_cast<String>(function.getName()); // Adding annotation if requested auto it = annotations.find(name); if (it == annotations.end()) { continue; } function.addFnAttr(\"replaceWith\", it->second); changed = true; } if (changed) { return llvm::PreservedAnalyses::none(); } return llvm::PreservedAnalyses::all(); } void FunctionAnnotatorPass::setLogger(ILoggerPtr logger) { logger_ = std::move(logger); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/FunctionReplacementPass/FunctionAnnotatorPass.cpp"},{"location":"Api/Files/_function_annotator_pass_8cpp/#passesfunctionreplacementpassfunctionannotatorpasscpp","text":"","title":"Passes/FunctionReplacementPass/FunctionAnnotatorPass.cpp"},{"location":"Api/Files/_function_annotator_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_function_annotator_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/FunctionReplacementPass/FunctionAnnotatorPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { bool FunctionAnnotatorPass::isRequired() { return true; } llvm::PreservedAnalyses FunctionAnnotatorPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { bool changed = false; auto annotations = config_.injectedAnnotations(); // Removing all function call attributes if (config_.shouldRemoveCallAttributes()) { for (auto& function : module) { for (auto& block : function) { for (auto& instr : block) { auto call_instr = llvm::dyn_cast<llvm::CallBase>(&instr); if (!call_instr) { continue; } call_instr->setAttributes({}); changed = true; } } } } // Adding replaceWith as requested for (auto& function : module) { auto name = static_cast<String>(function.getName()); // Adding annotation if requested auto it = annotations.find(name); if (it == annotations.end()) { continue; } function.addFnAttr(\"replaceWith\", it->second); changed = true; } if (changed) { return llvm::PreservedAnalyses::none(); } return llvm::PreservedAnalyses::all(); } void FunctionAnnotatorPass::setLogger(ILoggerPtr logger) { logger_ = std::move(logger); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_function_annotator_pass_8hpp/","text":"Passes/FunctionReplacementPass/FunctionAnnotatorPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::FunctionAnnotatorPass Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/FunctionReplacementPass/FunctionReplacementConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft::quantum { class FunctionAnnotatorPass : public llvm::PassInfoMixin<FunctionAnnotatorPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using BlockSet = std::unordered_set<llvm::BasicBlock*>; using SharedBuilder = std::shared_ptr<llvm::IRBuilder<>>; // Construction and destruction configuration. // explicit FunctionAnnotatorPass(FunctionReplacementConfiguration const& cfg) : config_{cfg} { } FunctionAnnotatorPass(FunctionAnnotatorPass const&) = delete; FunctionAnnotatorPass(FunctionAnnotatorPass&&) = default; ~FunctionAnnotatorPass() = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired(); void setLogger(ILoggerPtr logger); private: FunctionReplacementConfiguration config_{}; ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/FunctionReplacementPass/FunctionAnnotatorPass.hpp"},{"location":"Api/Files/_function_annotator_pass_8hpp/#passesfunctionreplacementpassfunctionannotatorpasshpp","text":"","title":"Passes/FunctionReplacementPass/FunctionAnnotatorPass.hpp"},{"location":"Api/Files/_function_annotator_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_function_annotator_pass_8hpp/#classes","text":"Name class microsoft::quantum::FunctionAnnotatorPass","title":"Classes"},{"location":"Api/Files/_function_annotator_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/FunctionReplacementPass/FunctionReplacementConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft::quantum { class FunctionAnnotatorPass : public llvm::PassInfoMixin<FunctionAnnotatorPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using BlockSet = std::unordered_set<llvm::BasicBlock*>; using SharedBuilder = std::shared_ptr<llvm::IRBuilder<>>; // Construction and destruction configuration. // explicit FunctionAnnotatorPass(FunctionReplacementConfiguration const& cfg) : config_{cfg} { } FunctionAnnotatorPass(FunctionAnnotatorPass const&) = delete; FunctionAnnotatorPass(FunctionAnnotatorPass&&) = default; ~FunctionAnnotatorPass() = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired(); void setLogger(ILoggerPtr logger); private: FunctionReplacementConfiguration config_{}; ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_function_replacement_analysis_pass_8cpp/","text":"Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { llvm::AnalysisKey FunctionReplacementAnalysisPass::Key; FunctionReplacementAnalysisPass::Result FunctionReplacementAnalysisPass::run( llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { FunctionRegister ret; // Registering all functions for (auto& function : module) { ret.name_to_function_pointer[static_cast<String>(function.getName())] = &function; } // Registering replacements for (auto& function : module) { /* if (function.isDeclaration()) { continue; } */ if (function.hasFnAttribute(\"replaceWith\")) { auto attr = function.getFnAttribute(\"replaceWith\"); if (!attr.isStringAttribute()) { if (logger_) { logger_->errorExpectedStringValueForAttr( static_cast<String>(function.getName()), static_cast<String>(attr.getKindAsString())); } else { throw std::runtime_error(\"Expected string attribute for attribute 'replaceWith'\"); } } auto name = static_cast<String>(attr.getValueAsString()); auto it = ret.name_to_function_pointer.find(name); // Ignoring replacements that were not found if (it == ret.name_to_function_pointer.end()) { if (logger_) { logger_->warningWeakLinkReplacementNotPossible(static_cast<String>(function.getName()), name); } continue; } // Checking function signature String signature1; llvm::raw_string_ostream ostream1(signature1); ostream1 << *function.getFunctionType(); String signature2; llvm::raw_string_ostream ostream2(signature2); ostream2 << *it->second->getFunctionType(); if (signature1 != signature2) { if (logger_) { logger_->errorReplacementSignatureMismatch( static_cast<String>(function.getName()), signature1, signature2); } else { throw std::runtime_error(\"Expected string attribute for attribute 'replaceWith'\"); } } // Registering replacement ret.functions_to_replace[&function] = it->second; } } for (auto& function : module) { for (auto& block : function) { for (auto& instr : block) { auto call_instr = llvm::dyn_cast<llvm::CallInst>(&instr); if (call_instr == nullptr) { continue; } auto function_ptr = call_instr->getCalledFunction(); auto it = ret.functions_to_replace.find(function_ptr); if (function_ptr == nullptr || it == ret.functions_to_replace.end()) { continue; } ret.calls_to_replace.push_back(call_instr); } } } return ret; } bool FunctionReplacementAnalysisPass::isRequired() { return true; } llvm::PreservedAnalyses FunctionReplacementAnalysisPassPrinter::run( llvm::Module& module, llvm::ModuleAnalysisManager& mam) { auto& result = mam.getResult<FunctionReplacementAnalysisPass>(module); llvm::errs() << \"============================== REPORT ==============================\\n\"; llvm::errs() << \"Functions:\\n\"; for (auto& p : result.name_to_function_pointer) { llvm::errs() << \"Found function \" << p.first << \"\\n\"; } llvm::errs() << \"\\nFunctions to replace:\\n\"; for (auto& p : result.functions_to_replace) { llvm::errs() << p.first->getName() << \" -> \" << p.second->getName() << \"\\n\"; } llvm::errs() << \"\\nCalls to replacable functions:\\n\"; for (auto& p : result.calls_to_replace) { llvm::errs() << *p << \"\\n\"; } llvm::errs() << \"============================ END REPORT ============================\\n\"; return llvm::PreservedAnalyses::all(); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.cpp"},{"location":"Api/Files/_function_replacement_analysis_pass_8cpp/#passesfunctionreplacementpassfunctionreplacementanalysispasscpp","text":"","title":"Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.cpp"},{"location":"Api/Files/_function_replacement_analysis_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_function_replacement_analysis_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { llvm::AnalysisKey FunctionReplacementAnalysisPass::Key; FunctionReplacementAnalysisPass::Result FunctionReplacementAnalysisPass::run( llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { FunctionRegister ret; // Registering all functions for (auto& function : module) { ret.name_to_function_pointer[static_cast<String>(function.getName())] = &function; } // Registering replacements for (auto& function : module) { /* if (function.isDeclaration()) { continue; } */ if (function.hasFnAttribute(\"replaceWith\")) { auto attr = function.getFnAttribute(\"replaceWith\"); if (!attr.isStringAttribute()) { if (logger_) { logger_->errorExpectedStringValueForAttr( static_cast<String>(function.getName()), static_cast<String>(attr.getKindAsString())); } else { throw std::runtime_error(\"Expected string attribute for attribute 'replaceWith'\"); } } auto name = static_cast<String>(attr.getValueAsString()); auto it = ret.name_to_function_pointer.find(name); // Ignoring replacements that were not found if (it == ret.name_to_function_pointer.end()) { if (logger_) { logger_->warningWeakLinkReplacementNotPossible(static_cast<String>(function.getName()), name); } continue; } // Checking function signature String signature1; llvm::raw_string_ostream ostream1(signature1); ostream1 << *function.getFunctionType(); String signature2; llvm::raw_string_ostream ostream2(signature2); ostream2 << *it->second->getFunctionType(); if (signature1 != signature2) { if (logger_) { logger_->errorReplacementSignatureMismatch( static_cast<String>(function.getName()), signature1, signature2); } else { throw std::runtime_error(\"Expected string attribute for attribute 'replaceWith'\"); } } // Registering replacement ret.functions_to_replace[&function] = it->second; } } for (auto& function : module) { for (auto& block : function) { for (auto& instr : block) { auto call_instr = llvm::dyn_cast<llvm::CallInst>(&instr); if (call_instr == nullptr) { continue; } auto function_ptr = call_instr->getCalledFunction(); auto it = ret.functions_to_replace.find(function_ptr); if (function_ptr == nullptr || it == ret.functions_to_replace.end()) { continue; } ret.calls_to_replace.push_back(call_instr); } } } return ret; } bool FunctionReplacementAnalysisPass::isRequired() { return true; } llvm::PreservedAnalyses FunctionReplacementAnalysisPassPrinter::run( llvm::Module& module, llvm::ModuleAnalysisManager& mam) { auto& result = mam.getResult<FunctionReplacementAnalysisPass>(module); llvm::errs() << \"============================== REPORT ==============================\\n\"; llvm::errs() << \"Functions:\\n\"; for (auto& p : result.name_to_function_pointer) { llvm::errs() << \"Found function \" << p.first << \"\\n\"; } llvm::errs() << \"\\nFunctions to replace:\\n\"; for (auto& p : result.functions_to_replace) { llvm::errs() << p.first->getName() << \" -> \" << p.second->getName() << \"\\n\"; } llvm::errs() << \"\\nCalls to replacable functions:\\n\"; for (auto& p : result.calls_to_replace) { llvm::errs() << *p << \"\\n\"; } llvm::errs() << \"============================ END REPORT ============================\\n\"; return llvm::PreservedAnalyses::all(); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_function_replacement_analysis_pass_8hpp/","text":"Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name struct microsoft::quantum::FunctionRegister class microsoft::quantum::FunctionReplacementAnalysisPass class microsoft::quantum::FunctionReplacementAnalysisPassPrinter Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/FunctionReplacementPass/FunctionReplacementConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft::quantum { struct FunctionRegister { using FunctionMap = std::unordered_map<String, llvm::Function*>; using ReplacementMap = std::unordered_map<llvm::Function*, llvm::Function*>; using CallList = std::vector<llvm::CallInst*>; FunctionMap name_to_function_pointer{}; ReplacementMap functions_to_replace{}; CallList calls_to_replace{}; }; class FunctionReplacementAnalysisPass : public llvm::AnalysisInfoMixin<FunctionReplacementAnalysisPass> { public: using Result = FunctionRegister; using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using BlockSet = std::unordered_set<llvm::BasicBlock*>; // Construction and destruction configuration. // explicit FunctionReplacementAnalysisPass(FunctionReplacementConfiguration const& cfg, ILoggerPtr const& logger) : config_{cfg} , logger_{logger} { } FunctionReplacementAnalysisPass(FunctionReplacementAnalysisPass const&) = delete; FunctionReplacementAnalysisPass(FunctionReplacementAnalysisPass&&) = default; ~FunctionReplacementAnalysisPass() = default; Result run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); void runBlockAnalysis(llvm::Module& module); static bool isRequired(); private: FunctionReplacementConfiguration config_{}; ILoggerPtr logger_{nullptr}; static llvm::AnalysisKey Key; // NOLINT friend struct llvm::AnalysisInfoMixin<FunctionReplacementAnalysisPass>; }; class FunctionReplacementAnalysisPassPrinter : public llvm::PassInfoMixin<FunctionReplacementAnalysisPassPrinter> { public: llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired() { return true; } }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.hpp"},{"location":"Api/Files/_function_replacement_analysis_pass_8hpp/#passesfunctionreplacementpassfunctionreplacementanalysispasshpp","text":"","title":"Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.hpp"},{"location":"Api/Files/_function_replacement_analysis_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_function_replacement_analysis_pass_8hpp/#classes","text":"Name struct microsoft::quantum::FunctionRegister class microsoft::quantum::FunctionReplacementAnalysisPass class microsoft::quantum::FunctionReplacementAnalysisPassPrinter","title":"Classes"},{"location":"Api/Files/_function_replacement_analysis_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/FunctionReplacementPass/FunctionReplacementConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft::quantum { struct FunctionRegister { using FunctionMap = std::unordered_map<String, llvm::Function*>; using ReplacementMap = std::unordered_map<llvm::Function*, llvm::Function*>; using CallList = std::vector<llvm::CallInst*>; FunctionMap name_to_function_pointer{}; ReplacementMap functions_to_replace{}; CallList calls_to_replace{}; }; class FunctionReplacementAnalysisPass : public llvm::AnalysisInfoMixin<FunctionReplacementAnalysisPass> { public: using Result = FunctionRegister; using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using BlockSet = std::unordered_set<llvm::BasicBlock*>; // Construction and destruction configuration. // explicit FunctionReplacementAnalysisPass(FunctionReplacementConfiguration const& cfg, ILoggerPtr const& logger) : config_{cfg} , logger_{logger} { } FunctionReplacementAnalysisPass(FunctionReplacementAnalysisPass const&) = delete; FunctionReplacementAnalysisPass(FunctionReplacementAnalysisPass&&) = default; ~FunctionReplacementAnalysisPass() = default; Result run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); void runBlockAnalysis(llvm::Module& module); static bool isRequired(); private: FunctionReplacementConfiguration config_{}; ILoggerPtr logger_{nullptr}; static llvm::AnalysisKey Key; // NOLINT friend struct llvm::AnalysisInfoMixin<FunctionReplacementAnalysisPass>; }; class FunctionReplacementAnalysisPassPrinter : public llvm::PassInfoMixin<FunctionReplacementAnalysisPassPrinter> { public: llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired() { return true; } }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_function_replacement_configuration_8hpp/","text":"Passes/FunctionReplacementPass/FunctionReplacementConfiguration.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::FunctionReplacementConfiguration Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" namespace microsoft::quantum { class FunctionReplacementConfiguration { public: using Set = std::unordered_set<std::string>; // Setup and construction // void setup(ConfigurationManager& config) { config.setSectionName( \"Replacement linking\", \"Replaces function calls if the given function is present in the IR\"); config.addParameter(injected_annotations_, \"replace-functions\", \"Functions to be replaced.\"); config.addParameter(should_remove_call_attributes_, \"remove-call-attributes\", \"Discard all call attributes\"); } static FunctionReplacementConfiguration createDisabled() { FunctionReplacementConfiguration ret; return ret; } StringMap const& injectedAnnotations() const { return injected_annotations_; } bool shouldRemoveCallAttributes() const { return should_remove_call_attributes_; } private: StringMap injected_annotations_{}; bool should_remove_call_attributes_{false}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/FunctionReplacementPass/FunctionReplacementConfiguration.hpp"},{"location":"Api/Files/_function_replacement_configuration_8hpp/#passesfunctionreplacementpassfunctionreplacementconfigurationhpp","text":"","title":"Passes/FunctionReplacementPass/FunctionReplacementConfiguration.hpp"},{"location":"Api/Files/_function_replacement_configuration_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_function_replacement_configuration_8hpp/#classes","text":"Name class microsoft::quantum::FunctionReplacementConfiguration","title":"Classes"},{"location":"Api/Files/_function_replacement_configuration_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" namespace microsoft::quantum { class FunctionReplacementConfiguration { public: using Set = std::unordered_set<std::string>; // Setup and construction // void setup(ConfigurationManager& config) { config.setSectionName( \"Replacement linking\", \"Replaces function calls if the given function is present in the IR\"); config.addParameter(injected_annotations_, \"replace-functions\", \"Functions to be replaced.\"); config.addParameter(should_remove_call_attributes_, \"remove-call-attributes\", \"Discard all call attributes\"); } static FunctionReplacementConfiguration createDisabled() { FunctionReplacementConfiguration ret; return ret; } StringMap const& injectedAnnotations() const { return injected_annotations_; } bool shouldRemoveCallAttributes() const { return should_remove_call_attributes_; } private: StringMap injected_annotations_{}; bool should_remove_call_attributes_{false}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_function_replacement_pass_8cpp/","text":"Passes/FunctionReplacementPass/FunctionReplacementPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/FunctionReplacementPass/FunctionReplacementPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { bool FunctionReplacementPass::isRequired() { return true; } llvm::PreservedAnalyses FunctionReplacementPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& mam) { llvm::IRBuilder<> builder(module.getContext()); auto& result = mam.getResult<FunctionReplacementAnalysisPass>(module); for (auto& call_instr : result.calls_to_replace) { auto function = call_instr->getCalledFunction(); auto it = result.functions_to_replace.find(function); if (function == nullptr || it == result.functions_to_replace.end()) { continue; } std::vector<llvm::Value*> arguments; for (std::size_t i = 0; i < call_instr->arg_size(); ++i) { arguments.emplace_back(call_instr->getArgOperand(i)); } builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(call_instr)); auto new_call = builder.CreateCall(it->second, arguments); new_call->takeName(call_instr); call_instr->replaceAllUsesWith(new_call); call_instr->eraseFromParent(); } return llvm::PreservedAnalyses::none(); } void FunctionReplacementPass::setLogger(ILoggerPtr logger) { logger_ = std::move(logger); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/FunctionReplacementPass/FunctionReplacementPass.cpp"},{"location":"Api/Files/_function_replacement_pass_8cpp/#passesfunctionreplacementpassfunctionreplacementpasscpp","text":"","title":"Passes/FunctionReplacementPass/FunctionReplacementPass.cpp"},{"location":"Api/Files/_function_replacement_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_function_replacement_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/FunctionReplacementPass/FunctionReplacementPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { bool FunctionReplacementPass::isRequired() { return true; } llvm::PreservedAnalyses FunctionReplacementPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& mam) { llvm::IRBuilder<> builder(module.getContext()); auto& result = mam.getResult<FunctionReplacementAnalysisPass>(module); for (auto& call_instr : result.calls_to_replace) { auto function = call_instr->getCalledFunction(); auto it = result.functions_to_replace.find(function); if (function == nullptr || it == result.functions_to_replace.end()) { continue; } std::vector<llvm::Value*> arguments; for (std::size_t i = 0; i < call_instr->arg_size(); ++i) { arguments.emplace_back(call_instr->getArgOperand(i)); } builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(call_instr)); auto new_call = builder.CreateCall(it->second, arguments); new_call->takeName(call_instr); call_instr->replaceAllUsesWith(new_call); call_instr->eraseFromParent(); } return llvm::PreservedAnalyses::none(); } void FunctionReplacementPass::setLogger(ILoggerPtr logger) { logger_ = std::move(logger); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_function_replacement_pass_8hpp/","text":"Passes/FunctionReplacementPass/FunctionReplacementPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::FunctionReplacementPass Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/FunctionReplacementPass/FunctionReplacementConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft::quantum { class FunctionReplacementPass : public llvm::PassInfoMixin<FunctionReplacementPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using BlockSet = std::unordered_set<llvm::BasicBlock*>; using SharedBuilder = std::shared_ptr<llvm::IRBuilder<>>; // Construction and destruction configuration. // explicit FunctionReplacementPass(FunctionReplacementConfiguration const& cfg) : config_{cfg} { } FunctionReplacementPass(FunctionReplacementPass const&) = delete; FunctionReplacementPass(FunctionReplacementPass&&) = default; ~FunctionReplacementPass() = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired(); void setLogger(ILoggerPtr logger); private: FunctionReplacementConfiguration config_{}; ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/FunctionReplacementPass/FunctionReplacementPass.hpp"},{"location":"Api/Files/_function_replacement_pass_8hpp/#passesfunctionreplacementpassfunctionreplacementpasshpp","text":"","title":"Passes/FunctionReplacementPass/FunctionReplacementPass.hpp"},{"location":"Api/Files/_function_replacement_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_function_replacement_pass_8hpp/#classes","text":"Name class microsoft::quantum::FunctionReplacementPass","title":"Classes"},{"location":"Api/Files/_function_replacement_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/FunctionReplacementPass/FunctionReplacementConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft::quantum { class FunctionReplacementPass : public llvm::PassInfoMixin<FunctionReplacementPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using BlockSet = std::unordered_set<llvm::BasicBlock*>; using SharedBuilder = std::shared_ptr<llvm::IRBuilder<>>; // Construction and destruction configuration. // explicit FunctionReplacementPass(FunctionReplacementConfiguration const& cfg) : config_{cfg} { } FunctionReplacementPass(FunctionReplacementPass const&) = delete; FunctionReplacementPass(FunctionReplacementPass&&) = default; ~FunctionReplacementPass() = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired(); void setLogger(ILoggerPtr logger); private: FunctionReplacementConfiguration config_{}; ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_function_to_module_8hpp/","text":"Utils/FunctionToModule.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::FunctionToModule Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" namespace microsoft::quantum { class FunctionToModule : public llvm::PassInfoMixin<FunctionToModule> { public: // Construction and destruction configuration. // explicit FunctionToModule(llvm::FunctionPassManager&& manager) : manager_{std::move(manager)} { } FunctionToModule(FunctionToModule const&) = delete; FunctionToModule(FunctionToModule&&) = default; ~FunctionToModule() = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam) { llvm::FunctionAnalysisManager& fam = mam.getResult<llvm::FunctionAnalysisManagerModuleProxy>(module).getManager(); for (auto& f : module) { if (f.isDeclaration()) { continue; } auto ret = manager_.run(f, fam); fam.invalidate(f, ret); } return llvm::PreservedAnalyses::none(); } static bool isRequired() { return true; } private: llvm::FunctionPassManager manager_; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Utils/FunctionToModule.hpp"},{"location":"Api/Files/_function_to_module_8hpp/#utilsfunctiontomodulehpp","text":"","title":"Utils/FunctionToModule.hpp"},{"location":"Api/Files/_function_to_module_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_function_to_module_8hpp/#classes","text":"Name class microsoft::quantum::FunctionToModule","title":"Classes"},{"location":"Api/Files/_function_to_module_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" namespace microsoft::quantum { class FunctionToModule : public llvm::PassInfoMixin<FunctionToModule> { public: // Construction and destruction configuration. // explicit FunctionToModule(llvm::FunctionPassManager&& manager) : manager_{std::move(manager)} { } FunctionToModule(FunctionToModule const&) = delete; FunctionToModule(FunctionToModule&&) = default; ~FunctionToModule() = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam) { llvm::FunctionAnalysisManager& fam = mam.getResult<llvm::FunctionAnalysisManagerModuleProxy>(module).getManager(); for (auto& f : module) { if (f.isDeclaration()) { continue; } auto ret = manager_.run(f, fam); fam.invalidate(f, ret); } return llvm::PreservedAnalyses::none(); } static bool isRequired() { return true; } private: llvm::FunctionPassManager manager_; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_function_validation_pass_8cpp/","text":"Passes/ValidationPass/FunctionValidationPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/ValidationPass/FunctionValidationPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/AllocationAnalysisPass.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { FunctionValidationPass::FunctionValidationPass( TargetProfileConfiguration const& profile_config, TargetQisConfiguration const& qis_config, ILoggerPtr const& logger) : profile_config_{profile_config} , qis_config_{qis_config} , logger_{logger} { } llvm::PreservedAnalyses FunctionValidationPass::run(llvm::Function& function, llvm::FunctionAnalysisManager& fam) { auto& function_details = fam.getResult<AllocationAnalysisPass>(function); if (qis_config_.requiresQubits() && function_details.usage_qubit_counts == 0) { logger_->errorNoQubitsPresent(&function, profile_config_.targetName()); } if (qis_config_.requiresResults() && function_details.usage_result_counts == 0) { logger_->errorNoResultsPresent(&function, profile_config_.targetName()); } for (auto& block : function) { for (auto& instr : block) { for (auto& op : instr.operands()) { auto poison = llvm::dyn_cast<llvm::PoisonValue>(op); auto undef = llvm::dyn_cast<llvm::UndefValue>(op); if (poison && !profile_config_.allowPoison()) { logger_->errorPoisonNotAllowed(profile_config_.targetName(), &instr); } else if (undef && !profile_config_.allowUndef()) { logger_->errorUndefNotAllowed(profile_config_.targetName(), &instr); } } } } return llvm::PreservedAnalyses::all(); } bool FunctionValidationPass::isRequired() { return true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/ValidationPass/FunctionValidationPass.cpp"},{"location":"Api/Files/_function_validation_pass_8cpp/#passesvalidationpassfunctionvalidationpasscpp","text":"","title":"Passes/ValidationPass/FunctionValidationPass.cpp"},{"location":"Api/Files/_function_validation_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_function_validation_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/ValidationPass/FunctionValidationPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/AllocationAnalysisPass.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { FunctionValidationPass::FunctionValidationPass( TargetProfileConfiguration const& profile_config, TargetQisConfiguration const& qis_config, ILoggerPtr const& logger) : profile_config_{profile_config} , qis_config_{qis_config} , logger_{logger} { } llvm::PreservedAnalyses FunctionValidationPass::run(llvm::Function& function, llvm::FunctionAnalysisManager& fam) { auto& function_details = fam.getResult<AllocationAnalysisPass>(function); if (qis_config_.requiresQubits() && function_details.usage_qubit_counts == 0) { logger_->errorNoQubitsPresent(&function, profile_config_.targetName()); } if (qis_config_.requiresResults() && function_details.usage_result_counts == 0) { logger_->errorNoResultsPresent(&function, profile_config_.targetName()); } for (auto& block : function) { for (auto& instr : block) { for (auto& op : instr.operands()) { auto poison = llvm::dyn_cast<llvm::PoisonValue>(op); auto undef = llvm::dyn_cast<llvm::UndefValue>(op); if (poison && !profile_config_.allowPoison()) { logger_->errorPoisonNotAllowed(profile_config_.targetName(), &instr); } else if (undef && !profile_config_.allowUndef()) { logger_->errorUndefNotAllowed(profile_config_.targetName(), &instr); } } } } return llvm::PreservedAnalyses::all(); } bool FunctionValidationPass::isRequired() { return true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_function_validation_pass_8hpp/","text":"Passes/ValidationPass/FunctionValidationPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::FunctionValidationPass Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetProfileConfiguration.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetQisConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class FunctionValidationPass : public llvm::PassInfoMixin<FunctionValidationPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using Location = ILogger::Location; using StringRef = llvm::StringRef; // Construction and destruction configuration. // explicit FunctionValidationPass( TargetProfileConfiguration const& profile_config, TargetQisConfiguration const& qis_config, ILoggerPtr const& logger = nullptr); FunctionValidationPass(FunctionValidationPass const&) = delete; FunctionValidationPass(FunctionValidationPass&&) = default; ~FunctionValidationPass() = default; llvm::PreservedAnalyses run(llvm::Function& function, llvm::FunctionAnalysisManager& fam); static bool isRequired(); private: TargetProfileConfiguration profile_config_{}; TargetQisConfiguration qis_config_{}; ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/ValidationPass/FunctionValidationPass.hpp"},{"location":"Api/Files/_function_validation_pass_8hpp/#passesvalidationpassfunctionvalidationpasshpp","text":"","title":"Passes/ValidationPass/FunctionValidationPass.hpp"},{"location":"Api/Files/_function_validation_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_function_validation_pass_8hpp/#classes","text":"Name class microsoft::quantum::FunctionValidationPass","title":"Classes"},{"location":"Api/Files/_function_validation_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetProfileConfiguration.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetQisConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class FunctionValidationPass : public llvm::PassInfoMixin<FunctionValidationPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using Location = ILogger::Location; using StringRef = llvm::StringRef; // Construction and destruction configuration. // explicit FunctionValidationPass( TargetProfileConfiguration const& profile_config, TargetQisConfiguration const& qis_config, ILoggerPtr const& logger = nullptr); FunctionValidationPass(FunctionValidationPass const&) = delete; FunctionValidationPass(FunctionValidationPass&&) = default; ~FunctionValidationPass() = default; llvm::PreservedAnalyses run(llvm::Function& function, llvm::FunctionAnalysisManager& fam); static bool isRequired(); private: TargetProfileConfiguration profile_config_{}; TargetQisConfiguration qis_config_{}; ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_grouping_analysis_pass_8cpp/","text":"Passes/GroupingPass/GroupingAnalysisPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/GroupingPass/GroupingAnalysisPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { String const GroupingAnalysisPass::QIS_START = \"__quantum\" \"__qis_\"; String const GroupingAnalysisPass::READ_INSTR_START = \"__quantum\" \"__qis__read_\"; llvm::AnalysisKey GroupingAnalysisPass::Key; void GroupingAnalysisPass::runBlockAnalysis(llvm::Module& module) { for (auto& function : module) { for (auto& block : function) { bool pure_quantum = true; bool pure_measurement = true; // Classifying the blocks for (auto& instr : block) { auto call_instr = llvm::dyn_cast<llvm::CallBase>(&instr); if (call_instr != nullptr) { auto f = call_instr->getCalledFunction(); if (f == nullptr) { continue; } auto name = static_cast<std::string>(f->getName()); bool is_quantum = (name.size() >= QIS_START.size() && name.substr(0, QIS_START.size()) == QIS_START); bool is_measurement = (name.size() >= READ_INSTR_START.size() && name.substr(0, READ_INSTR_START.size()) == READ_INSTR_START); if (is_measurement) { contains_quantum_measurement_.insert(&block); } if (is_quantum) { contains_quantum_circuit_.insert(&block); } pure_measurement = pure_measurement && is_measurement; pure_quantum = pure_quantum && is_quantum && !is_measurement; } else { // Any other instruction is makes the block non-pure pure_quantum = false; pure_measurement = false; } } if (pure_quantum) { pure_quantum_instructions_.insert(&block); } if (pure_measurement) { pure_quantum_measurement_.insert(&block); } } } } GroupingAnalysisPass::Result GroupingAnalysisPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { // Preparing analysis contains_quantum_circuit_.clear(); contains_quantum_measurement_.clear(); pure_quantum_instructions_.clear(); pure_quantum_measurement_.clear(); // Classifying each of the blocks runBlockAnalysis(module); GroupAnalysis ret; for (auto& function : module) { for (auto& block : function) { bool is_pure_quantum = pure_quantum_instructions_.find(&block) != pure_quantum_instructions_.end(); bool is_pure_measurement = pure_quantum_measurement_.find(&block) != pure_quantum_measurement_.end(); // Pure blocks are ignored if (is_pure_quantum || is_pure_measurement) { continue; } bool has_quantum = contains_quantum_circuit_.find(&block) != contains_quantum_circuit_.end(); // Pure classical blocks are also ignored if (!has_quantum) { continue; } bool has_measurement = contains_quantum_measurement_.find(&block) != contains_quantum_measurement_.end(); // Differentiating between blocks that has measurements and those that has not if (!has_measurement) { ret.qc_cc_blocks.push_back(&block); } else { ret.qc_mc_cc_blocks.push_back(&block); } } } return ret; } bool GroupingAnalysisPass::isRequired() { return true; } llvm::PreservedAnalyses GroupingAnalysisPassPrinter::run(llvm::Module& module, llvm::ModuleAnalysisManager& mam) { auto& result = mam.getResult<GroupingAnalysisPass>(module); llvm::errs() << result.qc_cc_blocks.size() << \" qc cc blocks.\\n\"; llvm::errs() << result.qc_mc_cc_blocks.size() << \" qc mc cc blocks.\\n\"; return llvm::PreservedAnalyses::all(); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/GroupingPass/GroupingAnalysisPass.cpp"},{"location":"Api/Files/_grouping_analysis_pass_8cpp/#passesgroupingpassgroupinganalysispasscpp","text":"","title":"Passes/GroupingPass/GroupingAnalysisPass.cpp"},{"location":"Api/Files/_grouping_analysis_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_grouping_analysis_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/GroupingPass/GroupingAnalysisPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { String const GroupingAnalysisPass::QIS_START = \"__quantum\" \"__qis_\"; String const GroupingAnalysisPass::READ_INSTR_START = \"__quantum\" \"__qis__read_\"; llvm::AnalysisKey GroupingAnalysisPass::Key; void GroupingAnalysisPass::runBlockAnalysis(llvm::Module& module) { for (auto& function : module) { for (auto& block : function) { bool pure_quantum = true; bool pure_measurement = true; // Classifying the blocks for (auto& instr : block) { auto call_instr = llvm::dyn_cast<llvm::CallBase>(&instr); if (call_instr != nullptr) { auto f = call_instr->getCalledFunction(); if (f == nullptr) { continue; } auto name = static_cast<std::string>(f->getName()); bool is_quantum = (name.size() >= QIS_START.size() && name.substr(0, QIS_START.size()) == QIS_START); bool is_measurement = (name.size() >= READ_INSTR_START.size() && name.substr(0, READ_INSTR_START.size()) == READ_INSTR_START); if (is_measurement) { contains_quantum_measurement_.insert(&block); } if (is_quantum) { contains_quantum_circuit_.insert(&block); } pure_measurement = pure_measurement && is_measurement; pure_quantum = pure_quantum && is_quantum && !is_measurement; } else { // Any other instruction is makes the block non-pure pure_quantum = false; pure_measurement = false; } } if (pure_quantum) { pure_quantum_instructions_.insert(&block); } if (pure_measurement) { pure_quantum_measurement_.insert(&block); } } } } GroupingAnalysisPass::Result GroupingAnalysisPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { // Preparing analysis contains_quantum_circuit_.clear(); contains_quantum_measurement_.clear(); pure_quantum_instructions_.clear(); pure_quantum_measurement_.clear(); // Classifying each of the blocks runBlockAnalysis(module); GroupAnalysis ret; for (auto& function : module) { for (auto& block : function) { bool is_pure_quantum = pure_quantum_instructions_.find(&block) != pure_quantum_instructions_.end(); bool is_pure_measurement = pure_quantum_measurement_.find(&block) != pure_quantum_measurement_.end(); // Pure blocks are ignored if (is_pure_quantum || is_pure_measurement) { continue; } bool has_quantum = contains_quantum_circuit_.find(&block) != contains_quantum_circuit_.end(); // Pure classical blocks are also ignored if (!has_quantum) { continue; } bool has_measurement = contains_quantum_measurement_.find(&block) != contains_quantum_measurement_.end(); // Differentiating between blocks that has measurements and those that has not if (!has_measurement) { ret.qc_cc_blocks.push_back(&block); } else { ret.qc_mc_cc_blocks.push_back(&block); } } } return ret; } bool GroupingAnalysisPass::isRequired() { return true; } llvm::PreservedAnalyses GroupingAnalysisPassPrinter::run(llvm::Module& module, llvm::ModuleAnalysisManager& mam) { auto& result = mam.getResult<GroupingAnalysisPass>(module); llvm::errs() << result.qc_cc_blocks.size() << \" qc cc blocks.\\n\"; llvm::errs() << result.qc_mc_cc_blocks.size() << \" qc mc cc blocks.\\n\"; return llvm::PreservedAnalyses::all(); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_grouping_analysis_pass_8hpp/","text":"Passes/GroupingPass/GroupingAnalysisPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name struct microsoft::quantum::GroupAnalysis class microsoft::quantum::GroupingAnalysisPass class microsoft::quantum::GroupingAnalysisPassPrinter Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/GroupingPass/GroupingPassConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft::quantum { struct GroupAnalysis { using BlockList = std::vector<llvm::BasicBlock*>; BlockList qc_cc_blocks{}; BlockList qc_mc_cc_blocks{}; }; class GroupingAnalysisPass : public llvm::AnalysisInfoMixin<GroupingAnalysisPass> { public: using Result = GroupAnalysis; using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using BlockSet = std::unordered_set<llvm::BasicBlock*>; static String const QIS_START; static String const READ_INSTR_START; // Construction and destruction configuration. // explicit GroupingAnalysisPass(GroupingPassConfiguration const& cfg, ILoggerPtr const& logger) : config_{cfg} , logger_{logger} { } GroupingAnalysisPass(GroupingAnalysisPass const&) = delete; GroupingAnalysisPass(GroupingAnalysisPass&&) = default; ~GroupingAnalysisPass() = default; Result run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); void runBlockAnalysis(llvm::Module& module); static bool isRequired(); private: GroupingPassConfiguration config_{}; // Block classification // BlockSet contains_quantum_circuit_{}; BlockSet contains_quantum_measurement_{}; BlockSet pure_quantum_instructions_{}; BlockSet pure_quantum_measurement_{}; ILoggerPtr logger_{nullptr}; static llvm::AnalysisKey Key; // NOLINT friend struct llvm::AnalysisInfoMixin<GroupingAnalysisPass>; }; class GroupingAnalysisPassPrinter : public llvm::PassInfoMixin<GroupingAnalysisPassPrinter> { public: llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired() { return true; } }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/GroupingPass/GroupingAnalysisPass.hpp"},{"location":"Api/Files/_grouping_analysis_pass_8hpp/#passesgroupingpassgroupinganalysispasshpp","text":"","title":"Passes/GroupingPass/GroupingAnalysisPass.hpp"},{"location":"Api/Files/_grouping_analysis_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_grouping_analysis_pass_8hpp/#classes","text":"Name struct microsoft::quantum::GroupAnalysis class microsoft::quantum::GroupingAnalysisPass class microsoft::quantum::GroupingAnalysisPassPrinter","title":"Classes"},{"location":"Api/Files/_grouping_analysis_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/GroupingPass/GroupingPassConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft::quantum { struct GroupAnalysis { using BlockList = std::vector<llvm::BasicBlock*>; BlockList qc_cc_blocks{}; BlockList qc_mc_cc_blocks{}; }; class GroupingAnalysisPass : public llvm::AnalysisInfoMixin<GroupingAnalysisPass> { public: using Result = GroupAnalysis; using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using BlockSet = std::unordered_set<llvm::BasicBlock*>; static String const QIS_START; static String const READ_INSTR_START; // Construction and destruction configuration. // explicit GroupingAnalysisPass(GroupingPassConfiguration const& cfg, ILoggerPtr const& logger) : config_{cfg} , logger_{logger} { } GroupingAnalysisPass(GroupingAnalysisPass const&) = delete; GroupingAnalysisPass(GroupingAnalysisPass&&) = default; ~GroupingAnalysisPass() = default; Result run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); void runBlockAnalysis(llvm::Module& module); static bool isRequired(); private: GroupingPassConfiguration config_{}; // Block classification // BlockSet contains_quantum_circuit_{}; BlockSet contains_quantum_measurement_{}; BlockSet pure_quantum_instructions_{}; BlockSet pure_quantum_measurement_{}; ILoggerPtr logger_{nullptr}; static llvm::AnalysisKey Key; // NOLINT friend struct llvm::AnalysisInfoMixin<GroupingAnalysisPass>; }; class GroupingAnalysisPassPrinter : public llvm::PassInfoMixin<GroupingAnalysisPassPrinter> { public: llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired() { return true; } }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_grouping_pass_8cpp/","text":"Passes/GroupingPass/GroupingPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/GroupingPass/GroupingPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Passes/GroupingPass/GroupingAnalysisPass.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { bool GroupingPass::isRequired() { return true; } bool GroupingPass::isQuantumRegister(llvm::Type const* type) { if (type->isPointerTy()) { auto element_type = type->getPointerElementType(); if (element_type->isStructTy()) { auto type_name = static_cast<String const>(element_type->getStructName()); return quantum_register_types_.find(type_name) != quantum_register_types_.end(); } } return false; } int64_t GroupingPass::classifyInstruction(llvm::Instruction const* instr) { int64_t ret = PureClassical; auto irreversible_operations = config_.irreversibleOperations(); // Checking all operations bool any_quantum = false; bool any_classical = false; bool is_void = instr->getType()->isVoidTy(); bool returns_quantum = isQuantumRegister(instr->getType()); bool destructive_quantum = false; auto call = llvm::dyn_cast<llvm::CallBase>(instr); if (call != nullptr) { auto f = call->getCalledFunction(); if (f == nullptr) { throw std::runtime_error(\"Function pointer was null during logic separation analysis.\"); } // Checking if it is an irreversabile operation auto name = static_cast<std::string>(f->getName()); if (irreversible_operations.find(name) != irreversible_operations.end()) { destructive_quantum = true; } for (auto& arg : call->args()) { auto q = isQuantumRegister(arg->getType()); any_quantum |= q; any_classical |= !q; } if (returns_quantum || (is_void && !any_classical && any_quantum)) { ret |= DestQuantum; } } else { for (auto& op : instr->operands()) { auto q = isQuantumRegister(op->getType()); any_quantum |= q; any_classical |= !q; } // Setting the destination platform if (returns_quantum) { ret |= DestQuantum; // If no classical or quantum arguments present, then destination dictates // source if (!any_quantum && !any_classical) { ret |= SourceQuantum; } } } if (destructive_quantum) { return TransferQuantumToClassical; } if (any_quantum && any_classical) { if (ret != DestQuantum) { ret = InvalidMixedLocation; } } else if (any_quantum) { ret |= SourceQuantum; } return ret; } void GroupingPass::prepareSourceSeparation(llvm::Module& module, llvm::BasicBlock* tail_classical) { // Creating replacement blocks auto& context = module.getContext(); post_classical_block_ = llvm::BasicBlock::Create(context, \"post-classical\", tail_classical->getParent(), tail_classical); quantum_block_ = llvm::BasicBlock::Create(context, \"quantum\", tail_classical->getParent(), post_classical_block_); pre_classical_block_ = llvm::BasicBlock::Create(context, \"pre-classical\", tail_classical->getParent(), quantum_block_); // Storing the blocks for later processing quantum_blocks_.push_back(quantum_block_); classical_blocks_.push_back(pre_classical_block_); classical_blocks_.push_back(post_classical_block_); // Renaming the block pre_classical_block_->takeName(tail_classical); // Preparing builders post_classical_builder_->SetInsertPoint(post_classical_block_); quantum_builder_->SetInsertPoint(quantum_block_); pre_classical_builder_->SetInsertPoint(pre_classical_block_); // Replacing entry tail_classical->setName(\"exit_quantum_grouping\"); tail_classical->replaceUsesWithIf( pre_classical_block_, [](llvm::Use& use) { auto* phi_node = llvm::dyn_cast<llvm::PHINode>(use.getUser()); return (phi_node == nullptr); }); } void GroupingPass::nextQuantumCycle(llvm::Module& module, llvm::BasicBlock* tail_classical) { auto& context = module.getContext(); pre_classical_builder_->CreateBr(quantum_block_); quantum_builder_->CreateBr(post_classical_block_); // pre_classical_block_ = post_classical_block_; // Creating replacement blocks post_classical_block_ = llvm::BasicBlock::Create(context, \"post-classical\", tail_classical->getParent(), tail_classical); quantum_block_ = llvm::BasicBlock::Create(context, \"quantum\", tail_classical->getParent(), post_classical_block_); // Storing the blocks for later processing quantum_blocks_.push_back(quantum_block_); classical_blocks_.push_back(post_classical_block_); // Preparing builders post_classical_builder_->SetInsertPoint(post_classical_block_); quantum_builder_->SetInsertPoint(quantum_block_); pre_classical_builder_->SetInsertPoint(pre_classical_block_); } GroupingPass::ResourceAnalysis GroupingPass::operandAnalysis(llvm::Value* val) const { // Determining if this is a static resource auto* instruction_ptr = llvm::dyn_cast<llvm::IntToPtrInst>(val); auto* operator_ptr = llvm::dyn_cast<llvm::ConcreteOperator<llvm::Operator, llvm::Instruction::IntToPtr>>(val); auto* nullptr_cast = llvm::dyn_cast<llvm::ConstantPointerNull>(val); ResourceAnalysis ret{}; ret.is_const = (instruction_ptr != nullptr) || (operator_ptr != nullptr) || (nullptr_cast != nullptr); // Extracting the type and index auto pointer_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (!pointer_type) { return ret; } llvm::Type* element_type = pointer_type->getElementType(); if (!element_type->isStructTy()) { return ret; } if (ret.is_const) { auto type_name = static_cast<String>(element_type->getStructName()); if (type_name == \"Qubit\") { ret.type = ResourceType::QUBIT; } else if (type_name == \"Result\") { ret.type = ResourceType::RESULT; } if (ret.type != ResourceType::UNDEFINED) { auto user = llvm::dyn_cast<llvm::User>(val); ret.id = 0; if (user && user->getNumOperands() == 1) { auto cst = llvm::dyn_cast<llvm::ConstantInt>(user->getOperand(0)); if (cst) { ret.id = cst->getValue().getZExtValue(); } } } } return ret; } void GroupingPass::expandBasedOnSource(llvm::Module& module, llvm::BasicBlock* tail_classical) { prepareSourceSeparation(module, tail_classical); auto qir_rt_start = config_.qirRuntimePrefix(); // Variables used for the modifications to_delete_.clear(); std::unordered_set<llvm::Value*> depends_on_qc; bool destruction_sequence_begun = false; std::unordered_set<llvm::Value*> destroyed_resources{}; std::unordered_set<uint64_t> destroyed_qubits{}; std::unordered_set<uint64_t> destroyed_results{}; std::unordered_set<llvm::Value*> post_classical_instructions{}; for (auto& instr : *tail_classical) { // Ignoring terminators // Only the terminator survives in the tail block if (instr.isTerminator()) { continue; } auto instr_class = classifyInstruction(&instr); if ((instr_class & SourceQuantum) != 0) { // Checking if we are starting a new quantum program for (auto& op : instr.operands()) { if (post_classical_instructions.find(op) != post_classical_instructions.end()) { nextQuantumCycle(module, tail_classical); depends_on_qc.clear(); destroyed_resources.clear(); destroyed_qubits.clear(); destroyed_results.clear(); post_classical_instructions.clear(); destruction_sequence_begun = false; break; } } // Checking if the instruction is destructive if (instr_class == TransferQuantumToClassical) { for (auto& op : instr.operands()) { destroyed_resources.insert(op); auto analysis = operandAnalysis(op); // Taking note of destroyed statically allocated resources if (analysis.is_const) { switch (analysis.type) { case ResourceType::QUBIT: destroyed_qubits.insert(analysis.id); break; case ResourceType::RESULT: destroyed_results.insert(analysis.id); break; case ResourceType::UNDEFINED: break; } } } destruction_sequence_begun = true; } else { bool relies_on_destroyed_resource = false; for (auto& op : instr.operands()) { // Skipping function pointers if (llvm::dyn_cast<llvm::Function>(op)) { continue; } auto analysis = operandAnalysis(op); // Note that we are forced to create a new cycle if a destructive // instruction is encountered. The reason is that we cannot garantuee // whether a qubit reference is to a to destroyed resource or not. // Consider for instance, %a1.i.i = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) // which could refer to qubit 0 or qubit 1 depending on %0. If %0 is not known // at compile time, we will not be able to determine its value. if (!analysis.is_const && destruction_sequence_begun) { relies_on_destroyed_resource = true; break; } // If it was marked as destroyed, we break right away if (destroyed_resources.find(op) != destroyed_resources.end()) { relies_on_destroyed_resource = true; break; } // In case we are dealing with a constant (statically allocated) // we check if the resource was destroyed. if (analysis.is_const) { switch (analysis.type) { case ResourceType::QUBIT: if (destroyed_qubits.find(analysis.id) != destroyed_qubits.end()) { relies_on_destroyed_resource = true; } break; case ResourceType::RESULT: if (destroyed_results.find(analysis.id) != destroyed_results.end()) { relies_on_destroyed_resource = true; } break; case ResourceType::UNDEFINED: break; } if (relies_on_destroyed_resource) { break; } } } if (relies_on_destroyed_resource) { nextQuantumCycle(module, tail_classical); depends_on_qc.clear(); post_classical_instructions.clear(); destroyed_resources.clear(); destroyed_qubits.clear(); destroyed_results.clear(); destruction_sequence_begun = false; } } // Marking all instructions that depend on a a read out for (auto user : instr.users()) { depends_on_qc.insert(user); } // Moving the instruction to auto new_instr = instr.clone(); new_instr->takeName(&instr); quantum_builder_->Insert(new_instr); instr.replaceAllUsesWith(new_instr); to_delete_.push_back(&instr); } else if (instr_class != InvalidMixedLocation) { // Check if depends on readout bool is_post_quantum_instruction = depends_on_qc.find(&instr) != depends_on_qc.end(); // Calls which starts with __quantum__rt__ cannot be moved to // the pre-calculation section becuase they might have side effects // such as recording output helper functions. auto call_instr = llvm::dyn_cast<llvm::CallBase>(&instr); if (call_instr != nullptr) { auto f = call_instr->getCalledFunction(); if (f == nullptr) { continue; } auto name = static_cast<std::string>(f->getName()); is_post_quantum_instruction |= (name.size() >= qir_rt_start.size() && name.substr(0, qir_rt_start.size()) == qir_rt_start); } // Checking if we are inserting the instruction before or after // the quantum block if (is_post_quantum_instruction) { for (auto user : instr.users()) { depends_on_qc.insert(user); } // Inserting to post section auto new_instr = instr.clone(); new_instr->takeName(&instr); post_classical_builder_->Insert(new_instr); instr.replaceAllUsesWith(new_instr); to_delete_.push_back(&instr); post_classical_instructions.insert(new_instr); continue; } // Post quantum section // Moving remaining to pre-section auto new_instr = instr.clone(); new_instr->takeName(&instr); pre_classical_builder_->Insert(new_instr); instr.replaceAllUsesWith(new_instr); to_delete_.push_back(&instr); } else { throw std::runtime_error(\"Unsupported occurring while grouping instructions\"); } } pre_classical_builder_->CreateBr(quantum_block_); quantum_builder_->CreateBr(post_classical_block_); post_classical_builder_->CreateBr(tail_classical); deleteInstructions(); } void GroupingPass::expandBasedOnDest( llvm::Module& module, llvm::BasicBlock* block, bool move_quatum, String const& name) { auto& context = module.getContext(); to_delete_.clear(); auto extra_block = llvm::BasicBlock::Create(context, \"unnamed\", block->getParent(), block); extra_block->takeName(block); block->replaceUsesWithIf( extra_block, [](llvm::Use& use) { auto* phi_node = llvm::dyn_cast<llvm::PHINode>(use.getUser()); return (phi_node == nullptr); }); block->setName(name); llvm::IRBuilder<> first_builder{context}; first_builder.SetInsertPoint(extra_block); for (auto& instr : *block) { if (instr.isTerminator()) { continue; } auto instr_class = classifyInstruction(&instr); bool dest_is_quantum = (instr_class & DestQuantum) != 0; if (dest_is_quantum == move_quatum) { auto new_instr = instr.clone(); new_instr->takeName(&instr); first_builder.Insert(new_instr); instr.replaceAllUsesWith(new_instr); to_delete_.push_back(&instr); } } first_builder.CreateBr(block); deleteInstructions(); } void GroupingPass::deleteInstructions() { for (auto it = to_delete_.rbegin(); it != to_delete_.rend(); ++it) { auto ptr = *it; if (!ptr->use_empty()) { if (logger_) { logger_->errorCouldNotDeleteNode(ptr); } else { throw std::runtime_error(\"No logger present - Error: Unable to delete instruction.\\n\"); } } else { ptr->eraseFromParent(); } } } llvm::PreservedAnalyses GroupingPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& mam) { if (!config_.groupQis()) { return llvm::PreservedAnalyses::all(); } auto& result = mam.getResult<GroupingAnalysisPass>(module); // Preparing builders auto& context = module.getContext(); pre_classical_builder_ = std::make_shared<llvm::IRBuilder<>>(context); quantum_builder_ = std::make_shared<llvm::IRBuilder<>>(context); post_classical_builder_ = std::make_shared<llvm::IRBuilder<>>(context); for (auto* block : result.qc_cc_blocks) { quantum_blocks_.clear(); classical_blocks_.clear(); // First split expandBasedOnSource(module, block); // Second splits for (auto* readout_block : quantum_blocks_) { expandBasedOnDest(module, readout_block, true, \"readout\"); } // Last classical block does not contain any loads classical_blocks_.pop_back(); for (auto* load_block : classical_blocks_) { expandBasedOnDest(module, load_block, false, \"load\"); } } for (auto* block : result.qc_mc_cc_blocks) { quantum_blocks_.clear(); classical_blocks_.clear(); // First split expandBasedOnSource(module, block); // Second splits for (auto* readout_block : quantum_blocks_) { expandBasedOnDest(module, readout_block, true, \"readout\"); } // Last classical block does not contain any loads classical_blocks_.pop_back(); for (auto* load_block : classical_blocks_) { expandBasedOnDest(module, load_block, false, \"load\"); } } return llvm::PreservedAnalyses::none(); } void GroupingPass::setLogger(ILoggerPtr logger) { logger_ = std::move(logger); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/GroupingPass/GroupingPass.cpp"},{"location":"Api/Files/_grouping_pass_8cpp/#passesgroupingpassgroupingpasscpp","text":"","title":"Passes/GroupingPass/GroupingPass.cpp"},{"location":"Api/Files/_grouping_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_grouping_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/GroupingPass/GroupingPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Passes/GroupingPass/GroupingAnalysisPass.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { bool GroupingPass::isRequired() { return true; } bool GroupingPass::isQuantumRegister(llvm::Type const* type) { if (type->isPointerTy()) { auto element_type = type->getPointerElementType(); if (element_type->isStructTy()) { auto type_name = static_cast<String const>(element_type->getStructName()); return quantum_register_types_.find(type_name) != quantum_register_types_.end(); } } return false; } int64_t GroupingPass::classifyInstruction(llvm::Instruction const* instr) { int64_t ret = PureClassical; auto irreversible_operations = config_.irreversibleOperations(); // Checking all operations bool any_quantum = false; bool any_classical = false; bool is_void = instr->getType()->isVoidTy(); bool returns_quantum = isQuantumRegister(instr->getType()); bool destructive_quantum = false; auto call = llvm::dyn_cast<llvm::CallBase>(instr); if (call != nullptr) { auto f = call->getCalledFunction(); if (f == nullptr) { throw std::runtime_error(\"Function pointer was null during logic separation analysis.\"); } // Checking if it is an irreversabile operation auto name = static_cast<std::string>(f->getName()); if (irreversible_operations.find(name) != irreversible_operations.end()) { destructive_quantum = true; } for (auto& arg : call->args()) { auto q = isQuantumRegister(arg->getType()); any_quantum |= q; any_classical |= !q; } if (returns_quantum || (is_void && !any_classical && any_quantum)) { ret |= DestQuantum; } } else { for (auto& op : instr->operands()) { auto q = isQuantumRegister(op->getType()); any_quantum |= q; any_classical |= !q; } // Setting the destination platform if (returns_quantum) { ret |= DestQuantum; // If no classical or quantum arguments present, then destination dictates // source if (!any_quantum && !any_classical) { ret |= SourceQuantum; } } } if (destructive_quantum) { return TransferQuantumToClassical; } if (any_quantum && any_classical) { if (ret != DestQuantum) { ret = InvalidMixedLocation; } } else if (any_quantum) { ret |= SourceQuantum; } return ret; } void GroupingPass::prepareSourceSeparation(llvm::Module& module, llvm::BasicBlock* tail_classical) { // Creating replacement blocks auto& context = module.getContext(); post_classical_block_ = llvm::BasicBlock::Create(context, \"post-classical\", tail_classical->getParent(), tail_classical); quantum_block_ = llvm::BasicBlock::Create(context, \"quantum\", tail_classical->getParent(), post_classical_block_); pre_classical_block_ = llvm::BasicBlock::Create(context, \"pre-classical\", tail_classical->getParent(), quantum_block_); // Storing the blocks for later processing quantum_blocks_.push_back(quantum_block_); classical_blocks_.push_back(pre_classical_block_); classical_blocks_.push_back(post_classical_block_); // Renaming the block pre_classical_block_->takeName(tail_classical); // Preparing builders post_classical_builder_->SetInsertPoint(post_classical_block_); quantum_builder_->SetInsertPoint(quantum_block_); pre_classical_builder_->SetInsertPoint(pre_classical_block_); // Replacing entry tail_classical->setName(\"exit_quantum_grouping\"); tail_classical->replaceUsesWithIf( pre_classical_block_, [](llvm::Use& use) { auto* phi_node = llvm::dyn_cast<llvm::PHINode>(use.getUser()); return (phi_node == nullptr); }); } void GroupingPass::nextQuantumCycle(llvm::Module& module, llvm::BasicBlock* tail_classical) { auto& context = module.getContext(); pre_classical_builder_->CreateBr(quantum_block_); quantum_builder_->CreateBr(post_classical_block_); // pre_classical_block_ = post_classical_block_; // Creating replacement blocks post_classical_block_ = llvm::BasicBlock::Create(context, \"post-classical\", tail_classical->getParent(), tail_classical); quantum_block_ = llvm::BasicBlock::Create(context, \"quantum\", tail_classical->getParent(), post_classical_block_); // Storing the blocks for later processing quantum_blocks_.push_back(quantum_block_); classical_blocks_.push_back(post_classical_block_); // Preparing builders post_classical_builder_->SetInsertPoint(post_classical_block_); quantum_builder_->SetInsertPoint(quantum_block_); pre_classical_builder_->SetInsertPoint(pre_classical_block_); } GroupingPass::ResourceAnalysis GroupingPass::operandAnalysis(llvm::Value* val) const { // Determining if this is a static resource auto* instruction_ptr = llvm::dyn_cast<llvm::IntToPtrInst>(val); auto* operator_ptr = llvm::dyn_cast<llvm::ConcreteOperator<llvm::Operator, llvm::Instruction::IntToPtr>>(val); auto* nullptr_cast = llvm::dyn_cast<llvm::ConstantPointerNull>(val); ResourceAnalysis ret{}; ret.is_const = (instruction_ptr != nullptr) || (operator_ptr != nullptr) || (nullptr_cast != nullptr); // Extracting the type and index auto pointer_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (!pointer_type) { return ret; } llvm::Type* element_type = pointer_type->getElementType(); if (!element_type->isStructTy()) { return ret; } if (ret.is_const) { auto type_name = static_cast<String>(element_type->getStructName()); if (type_name == \"Qubit\") { ret.type = ResourceType::QUBIT; } else if (type_name == \"Result\") { ret.type = ResourceType::RESULT; } if (ret.type != ResourceType::UNDEFINED) { auto user = llvm::dyn_cast<llvm::User>(val); ret.id = 0; if (user && user->getNumOperands() == 1) { auto cst = llvm::dyn_cast<llvm::ConstantInt>(user->getOperand(0)); if (cst) { ret.id = cst->getValue().getZExtValue(); } } } } return ret; } void GroupingPass::expandBasedOnSource(llvm::Module& module, llvm::BasicBlock* tail_classical) { prepareSourceSeparation(module, tail_classical); auto qir_rt_start = config_.qirRuntimePrefix(); // Variables used for the modifications to_delete_.clear(); std::unordered_set<llvm::Value*> depends_on_qc; bool destruction_sequence_begun = false; std::unordered_set<llvm::Value*> destroyed_resources{}; std::unordered_set<uint64_t> destroyed_qubits{}; std::unordered_set<uint64_t> destroyed_results{}; std::unordered_set<llvm::Value*> post_classical_instructions{}; for (auto& instr : *tail_classical) { // Ignoring terminators // Only the terminator survives in the tail block if (instr.isTerminator()) { continue; } auto instr_class = classifyInstruction(&instr); if ((instr_class & SourceQuantum) != 0) { // Checking if we are starting a new quantum program for (auto& op : instr.operands()) { if (post_classical_instructions.find(op) != post_classical_instructions.end()) { nextQuantumCycle(module, tail_classical); depends_on_qc.clear(); destroyed_resources.clear(); destroyed_qubits.clear(); destroyed_results.clear(); post_classical_instructions.clear(); destruction_sequence_begun = false; break; } } // Checking if the instruction is destructive if (instr_class == TransferQuantumToClassical) { for (auto& op : instr.operands()) { destroyed_resources.insert(op); auto analysis = operandAnalysis(op); // Taking note of destroyed statically allocated resources if (analysis.is_const) { switch (analysis.type) { case ResourceType::QUBIT: destroyed_qubits.insert(analysis.id); break; case ResourceType::RESULT: destroyed_results.insert(analysis.id); break; case ResourceType::UNDEFINED: break; } } } destruction_sequence_begun = true; } else { bool relies_on_destroyed_resource = false; for (auto& op : instr.operands()) { // Skipping function pointers if (llvm::dyn_cast<llvm::Function>(op)) { continue; } auto analysis = operandAnalysis(op); // Note that we are forced to create a new cycle if a destructive // instruction is encountered. The reason is that we cannot garantuee // whether a qubit reference is to a to destroyed resource or not. // Consider for instance, %a1.i.i = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) // which could refer to qubit 0 or qubit 1 depending on %0. If %0 is not known // at compile time, we will not be able to determine its value. if (!analysis.is_const && destruction_sequence_begun) { relies_on_destroyed_resource = true; break; } // If it was marked as destroyed, we break right away if (destroyed_resources.find(op) != destroyed_resources.end()) { relies_on_destroyed_resource = true; break; } // In case we are dealing with a constant (statically allocated) // we check if the resource was destroyed. if (analysis.is_const) { switch (analysis.type) { case ResourceType::QUBIT: if (destroyed_qubits.find(analysis.id) != destroyed_qubits.end()) { relies_on_destroyed_resource = true; } break; case ResourceType::RESULT: if (destroyed_results.find(analysis.id) != destroyed_results.end()) { relies_on_destroyed_resource = true; } break; case ResourceType::UNDEFINED: break; } if (relies_on_destroyed_resource) { break; } } } if (relies_on_destroyed_resource) { nextQuantumCycle(module, tail_classical); depends_on_qc.clear(); post_classical_instructions.clear(); destroyed_resources.clear(); destroyed_qubits.clear(); destroyed_results.clear(); destruction_sequence_begun = false; } } // Marking all instructions that depend on a a read out for (auto user : instr.users()) { depends_on_qc.insert(user); } // Moving the instruction to auto new_instr = instr.clone(); new_instr->takeName(&instr); quantum_builder_->Insert(new_instr); instr.replaceAllUsesWith(new_instr); to_delete_.push_back(&instr); } else if (instr_class != InvalidMixedLocation) { // Check if depends on readout bool is_post_quantum_instruction = depends_on_qc.find(&instr) != depends_on_qc.end(); // Calls which starts with __quantum__rt__ cannot be moved to // the pre-calculation section becuase they might have side effects // such as recording output helper functions. auto call_instr = llvm::dyn_cast<llvm::CallBase>(&instr); if (call_instr != nullptr) { auto f = call_instr->getCalledFunction(); if (f == nullptr) { continue; } auto name = static_cast<std::string>(f->getName()); is_post_quantum_instruction |= (name.size() >= qir_rt_start.size() && name.substr(0, qir_rt_start.size()) == qir_rt_start); } // Checking if we are inserting the instruction before or after // the quantum block if (is_post_quantum_instruction) { for (auto user : instr.users()) { depends_on_qc.insert(user); } // Inserting to post section auto new_instr = instr.clone(); new_instr->takeName(&instr); post_classical_builder_->Insert(new_instr); instr.replaceAllUsesWith(new_instr); to_delete_.push_back(&instr); post_classical_instructions.insert(new_instr); continue; } // Post quantum section // Moving remaining to pre-section auto new_instr = instr.clone(); new_instr->takeName(&instr); pre_classical_builder_->Insert(new_instr); instr.replaceAllUsesWith(new_instr); to_delete_.push_back(&instr); } else { throw std::runtime_error(\"Unsupported occurring while grouping instructions\"); } } pre_classical_builder_->CreateBr(quantum_block_); quantum_builder_->CreateBr(post_classical_block_); post_classical_builder_->CreateBr(tail_classical); deleteInstructions(); } void GroupingPass::expandBasedOnDest( llvm::Module& module, llvm::BasicBlock* block, bool move_quatum, String const& name) { auto& context = module.getContext(); to_delete_.clear(); auto extra_block = llvm::BasicBlock::Create(context, \"unnamed\", block->getParent(), block); extra_block->takeName(block); block->replaceUsesWithIf( extra_block, [](llvm::Use& use) { auto* phi_node = llvm::dyn_cast<llvm::PHINode>(use.getUser()); return (phi_node == nullptr); }); block->setName(name); llvm::IRBuilder<> first_builder{context}; first_builder.SetInsertPoint(extra_block); for (auto& instr : *block) { if (instr.isTerminator()) { continue; } auto instr_class = classifyInstruction(&instr); bool dest_is_quantum = (instr_class & DestQuantum) != 0; if (dest_is_quantum == move_quatum) { auto new_instr = instr.clone(); new_instr->takeName(&instr); first_builder.Insert(new_instr); instr.replaceAllUsesWith(new_instr); to_delete_.push_back(&instr); } } first_builder.CreateBr(block); deleteInstructions(); } void GroupingPass::deleteInstructions() { for (auto it = to_delete_.rbegin(); it != to_delete_.rend(); ++it) { auto ptr = *it; if (!ptr->use_empty()) { if (logger_) { logger_->errorCouldNotDeleteNode(ptr); } else { throw std::runtime_error(\"No logger present - Error: Unable to delete instruction.\\n\"); } } else { ptr->eraseFromParent(); } } } llvm::PreservedAnalyses GroupingPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& mam) { if (!config_.groupQis()) { return llvm::PreservedAnalyses::all(); } auto& result = mam.getResult<GroupingAnalysisPass>(module); // Preparing builders auto& context = module.getContext(); pre_classical_builder_ = std::make_shared<llvm::IRBuilder<>>(context); quantum_builder_ = std::make_shared<llvm::IRBuilder<>>(context); post_classical_builder_ = std::make_shared<llvm::IRBuilder<>>(context); for (auto* block : result.qc_cc_blocks) { quantum_blocks_.clear(); classical_blocks_.clear(); // First split expandBasedOnSource(module, block); // Second splits for (auto* readout_block : quantum_blocks_) { expandBasedOnDest(module, readout_block, true, \"readout\"); } // Last classical block does not contain any loads classical_blocks_.pop_back(); for (auto* load_block : classical_blocks_) { expandBasedOnDest(module, load_block, false, \"load\"); } } for (auto* block : result.qc_mc_cc_blocks) { quantum_blocks_.clear(); classical_blocks_.clear(); // First split expandBasedOnSource(module, block); // Second splits for (auto* readout_block : quantum_blocks_) { expandBasedOnDest(module, readout_block, true, \"readout\"); } // Last classical block does not contain any loads classical_blocks_.pop_back(); for (auto* load_block : classical_blocks_) { expandBasedOnDest(module, load_block, false, \"load\"); } } return llvm::PreservedAnalyses::none(); } void GroupingPass::setLogger(ILoggerPtr logger) { logger_ = std::move(logger); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_grouping_pass_8hpp/","text":"Passes/GroupingPass/GroupingPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::GroupingPass struct microsoft::quantum::GroupingPass::ResourceAnalysis Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/GroupingPass/GroupingPassConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft::quantum { class GroupingPass : public llvm::PassInfoMixin<GroupingPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using BlockSet = std::unordered_set<llvm::BasicBlock*>; using SharedBuilder = std::shared_ptr<llvm::IRBuilder<>>; // Construction and destruction configuration. // enum class ResourceType { UNDEFINED, QUBIT, RESULT }; struct ResourceAnalysis { bool is_const{false}; uint64_t id{0}; ResourceType type{ResourceType::UNDEFINED}; }; enum { PureClassical = 0, SourceQuantum = 1, DestQuantum = 2, PureQuantum = SourceQuantum | DestQuantum, TransferClassicalToQuantum = DestQuantum, TransferQuantumToClassical = SourceQuantum, InvalidMixedLocation = -1 }; explicit GroupingPass(GroupingPassConfiguration const& cfg) : config_{cfg} { } GroupingPass(GroupingPass const&) = delete; GroupingPass(GroupingPass&&) = default; ~GroupingPass() = default; // void prepareSourceSeparation(llvm::Module& module, llvm::BasicBlock* block); void nextQuantumCycle(llvm::Module& module, llvm::BasicBlock* block); void expandBasedOnSource(llvm::Module& module, llvm::BasicBlock* block); void expandBasedOnDest(llvm::Module& module, llvm::BasicBlock* block, bool move_quatum, String const& name); // bool isQuantumRegister(llvm::Type const* type); int64_t classifyInstruction(llvm::Instruction const* instr); llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); void runBlockAnalysis(llvm::Module& module); static bool isRequired(); void setLogger(ILoggerPtr logger); private: void deleteInstructions(); ResourceAnalysis operandAnalysis(llvm::Value* val) const; GroupingPassConfiguration config_{}; // Basic blocks used to build llvm::BasicBlock* post_classical_block_{nullptr}; llvm::BasicBlock* quantum_block_{nullptr}; llvm::BasicBlock* pre_classical_block_{nullptr}; // Builders // SharedBuilder pre_classical_builder_{}; SharedBuilder quantum_builder_{}; SharedBuilder post_classical_builder_{}; std::vector<llvm::BasicBlock*> quantum_blocks_{}; std::vector<llvm::BasicBlock*> classical_blocks_{}; BlockSet visited_blocks_; ILoggerPtr logger_{nullptr}; std::unordered_set<String> quantum_register_types_ = {\"Qubit\", \"Result\"}; std::vector<llvm::Instruction*> to_delete_; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/GroupingPass/GroupingPass.hpp"},{"location":"Api/Files/_grouping_pass_8hpp/#passesgroupingpassgroupingpasshpp","text":"","title":"Passes/GroupingPass/GroupingPass.hpp"},{"location":"Api/Files/_grouping_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_grouping_pass_8hpp/#classes","text":"Name class microsoft::quantum::GroupingPass struct microsoft::quantum::GroupingPass::ResourceAnalysis","title":"Classes"},{"location":"Api/Files/_grouping_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/GroupingPass/GroupingPassConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft::quantum { class GroupingPass : public llvm::PassInfoMixin<GroupingPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using BlockSet = std::unordered_set<llvm::BasicBlock*>; using SharedBuilder = std::shared_ptr<llvm::IRBuilder<>>; // Construction and destruction configuration. // enum class ResourceType { UNDEFINED, QUBIT, RESULT }; struct ResourceAnalysis { bool is_const{false}; uint64_t id{0}; ResourceType type{ResourceType::UNDEFINED}; }; enum { PureClassical = 0, SourceQuantum = 1, DestQuantum = 2, PureQuantum = SourceQuantum | DestQuantum, TransferClassicalToQuantum = DestQuantum, TransferQuantumToClassical = SourceQuantum, InvalidMixedLocation = -1 }; explicit GroupingPass(GroupingPassConfiguration const& cfg) : config_{cfg} { } GroupingPass(GroupingPass const&) = delete; GroupingPass(GroupingPass&&) = default; ~GroupingPass() = default; // void prepareSourceSeparation(llvm::Module& module, llvm::BasicBlock* block); void nextQuantumCycle(llvm::Module& module, llvm::BasicBlock* block); void expandBasedOnSource(llvm::Module& module, llvm::BasicBlock* block); void expandBasedOnDest(llvm::Module& module, llvm::BasicBlock* block, bool move_quatum, String const& name); // bool isQuantumRegister(llvm::Type const* type); int64_t classifyInstruction(llvm::Instruction const* instr); llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); void runBlockAnalysis(llvm::Module& module); static bool isRequired(); void setLogger(ILoggerPtr logger); private: void deleteInstructions(); ResourceAnalysis operandAnalysis(llvm::Value* val) const; GroupingPassConfiguration config_{}; // Basic blocks used to build llvm::BasicBlock* post_classical_block_{nullptr}; llvm::BasicBlock* quantum_block_{nullptr}; llvm::BasicBlock* pre_classical_block_{nullptr}; // Builders // SharedBuilder pre_classical_builder_{}; SharedBuilder quantum_builder_{}; SharedBuilder post_classical_builder_{}; std::vector<llvm::BasicBlock*> quantum_blocks_{}; std::vector<llvm::BasicBlock*> classical_blocks_{}; BlockSet visited_blocks_; ILoggerPtr logger_{nullptr}; std::unordered_set<String> quantum_register_types_ = {\"Qubit\", \"Result\"}; std::vector<llvm::Instruction*> to_delete_; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_grouping_pass_configuration_8hpp/","text":"Passes/GroupingPass/GroupingPassConfiguration.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::GroupingPassConfiguration Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" namespace microsoft::quantum { class GroupingPassConfiguration { public: using Set = std::unordered_set<std::string>; using DeferredValuePtr = DeferredValue::DeferredValuePtr; // Setup and construction // void setup(ConfigurationManager& config) { config.setSectionName(\"Grouping quantum instructions\", \"Separation of quantum and classical operations\"); config.addExperimentalParameter( group_qis_, true, false, \"group-qis\", \"Whether or not to separate quantum and classical circuits\"); irreversible_operations_ = config.getParameter(\"irreversible-operations\"); qir_runtime_prefix_ = config.getParameter(\"qir-runtime-prefix\"); } static GroupingPassConfiguration createDisabled() { GroupingPassConfiguration ret; ret.group_qis_ = false; return ret; } bool groupQis() const { return group_qis_; } Set irreversibleOperations() const { assert(irreversible_operations_ != nullptr); if (irreversible_operations_ == nullptr) { throw std::runtime_error(\"Configuration 'GroupingPassConfiguration' was not initialized.\"); } if (!irreversible_operations_->isDereferenceable()) { throw std::runtime_error(\"Target QIS configuration was not loaded.\"); } return irreversible_operations_->value<Set>(); } String qirRuntimePrefix() const { return qir_runtime_prefix_->value<String>(); } private: bool group_qis_{true}; DeferredValuePtr irreversible_operations_{}; DeferredValuePtr qir_runtime_prefix_{}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/GroupingPass/GroupingPassConfiguration.hpp"},{"location":"Api/Files/_grouping_pass_configuration_8hpp/#passesgroupingpassgroupingpassconfigurationhpp","text":"","title":"Passes/GroupingPass/GroupingPassConfiguration.hpp"},{"location":"Api/Files/_grouping_pass_configuration_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_grouping_pass_configuration_8hpp/#classes","text":"Name class microsoft::quantum::GroupingPassConfiguration","title":"Classes"},{"location":"Api/Files/_grouping_pass_configuration_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" namespace microsoft::quantum { class GroupingPassConfiguration { public: using Set = std::unordered_set<std::string>; using DeferredValuePtr = DeferredValue::DeferredValuePtr; // Setup and construction // void setup(ConfigurationManager& config) { config.setSectionName(\"Grouping quantum instructions\", \"Separation of quantum and classical operations\"); config.addExperimentalParameter( group_qis_, true, false, \"group-qis\", \"Whether or not to separate quantum and classical circuits\"); irreversible_operations_ = config.getParameter(\"irreversible-operations\"); qir_runtime_prefix_ = config.getParameter(\"qir-runtime-prefix\"); } static GroupingPassConfiguration createDisabled() { GroupingPassConfiguration ret; ret.group_qis_ = false; return ret; } bool groupQis() const { return group_qis_; } Set irreversibleOperations() const { assert(irreversible_operations_ != nullptr); if (irreversible_operations_ == nullptr) { throw std::runtime_error(\"Configuration 'GroupingPassConfiguration' was not initialized.\"); } if (!irreversible_operations_->isDereferenceable()) { throw std::runtime_error(\"Target QIS configuration was not loaded.\"); } return irreversible_operations_->value<Set>(); } String qirRuntimePrefix() const { return qir_runtime_prefix_->value<String>(); } private: bool group_qis_{true}; DeferredValuePtr irreversible_operations_{}; DeferredValuePtr qir_runtime_prefix_{}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_i_allocation_manager_8cpp/","text":"AllocationManager/IAllocationManager.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AllocationManager/IAllocationManager.hpp\" namespace microsoft::quantum { IAllocationManager::~IAllocationManager() = default; uint64_t IAllocationManager::allocationsInUse() const { return registers_in_use_; } uint64_t IAllocationManager::maxAllocationsUsed() const { return max_registers_used_; } void IAllocationManager::updateRegistersInUse(uint64_t n) { registers_in_use_ = n; if (n > max_registers_used_) { max_registers_used_ = n; } } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"AllocationManager/IAllocationManager.cpp"},{"location":"Api/Files/_i_allocation_manager_8cpp/#allocationmanageriallocationmanagercpp","text":"","title":"AllocationManager/IAllocationManager.cpp"},{"location":"Api/Files/_i_allocation_manager_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_allocation_manager_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AllocationManager/IAllocationManager.hpp\" namespace microsoft::quantum { IAllocationManager::~IAllocationManager() = default; uint64_t IAllocationManager::allocationsInUse() const { return registers_in_use_; } uint64_t IAllocationManager::maxAllocationsUsed() const { return max_registers_used_; } void IAllocationManager::updateRegistersInUse(uint64_t n) { registers_in_use_ = n; if (n > max_registers_used_) { max_registers_used_ = n; } } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_i_allocation_manager_8hpp/","text":"AllocationManager/IAllocationManager.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::IAllocationManager Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <memory> #include <string> namespace microsoft::quantum { class IAllocationManager { public: using Address = uint64_t; using Index = uint64_t; using AllocationManagerPtr = std::shared_ptr<IAllocationManager>; // Construction, moves and copies // IAllocationManager(IAllocationManager const&) = delete; IAllocationManager(IAllocationManager&&) = delete; IAllocationManager& operator=(IAllocationManager const&) = delete; IAllocationManager& operator=(IAllocationManager&&) = delete; virtual ~IAllocationManager(); // Interface // virtual Address allocate(String const& name = \"\", Index const& count = 1) = 0; virtual void release(Address const& address) = 0; virtual void reset() = 0; // Statistics // uint64_t allocationsInUse() const; uint64_t maxAllocationsUsed() const; protected: IAllocationManager() = default; void updateRegistersInUse(uint64_t n); private: uint64_t registers_in_use_{0}; uint64_t max_registers_used_{0}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"AllocationManager/IAllocationManager.hpp"},{"location":"Api/Files/_i_allocation_manager_8hpp/#allocationmanageriallocationmanagerhpp","text":"","title":"AllocationManager/IAllocationManager.hpp"},{"location":"Api/Files/_i_allocation_manager_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_allocation_manager_8hpp/#classes","text":"Name class microsoft::quantum::IAllocationManager","title":"Classes"},{"location":"Api/Files/_i_allocation_manager_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <memory> #include <string> namespace microsoft::quantum { class IAllocationManager { public: using Address = uint64_t; using Index = uint64_t; using AllocationManagerPtr = std::shared_ptr<IAllocationManager>; // Construction, moves and copies // IAllocationManager(IAllocationManager const&) = delete; IAllocationManager(IAllocationManager&&) = delete; IAllocationManager& operator=(IAllocationManager const&) = delete; IAllocationManager& operator=(IAllocationManager&&) = delete; virtual ~IAllocationManager(); // Interface // virtual Address allocate(String const& name = \"\", Index const& count = 1) = 0; virtual void release(Address const& address) = 0; virtual void reset() = 0; // Statistics // uint64_t allocationsInUse() const; uint64_t maxAllocationsUsed() const; protected: IAllocationManager() = default; void updateRegistersInUse(uint64_t n); private: uint64_t registers_in_use_{0}; uint64_t max_registers_used_{0}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_i_config_bind_8cpp/","text":"Commandline/IConfigBind.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/IConfigBind.hpp\" #include \"qir/qat/Commandline/ConfigurationManager.hpp\" using namespace microsoft::quantum; namespace microsoft::quantum { IConfigBind::IConfigBind(String const& name, String const& description, ParameterVisibility visibility) : name_{name} , description_{description} , visibility_{visibility} { } IConfigBind::~IConfigBind() = default; String IConfigBind::name() const { return name_; } String IConfigBind::description() const { return description_; } void IConfigBind::setName(String const& name) { name_ = name; } bool IConfigBind::isFlag() const { return is_flag_; } String IConfigBind::defaultValue() const { return str_default_value_; } void IConfigBind::markAsFlag() { is_flag_ = true; } void IConfigBind::setDefault(String const& v) { str_default_value_ = v; } void IConfigBind::makeSettingExperimental() { is_experimental_ = true; } bool IConfigBind::isExperimental() const { return is_experimental_; } bool IConfigBind::isLoadAndSavable() const { return (visibility_ & ParameterVisibility::ConfigOnly) != ParameterVisibility::None; } bool IConfigBind::isAvailableToCli() const { return (visibility_ & ParameterVisibility::CliOnly) != ParameterVisibility::None; } void IConfigBind::setShorthandNotation(String const& name) { shorthand_notation_ = name; } String IConfigBind::shorthandNotation() const { return shorthand_notation_; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Commandline/IConfigBind.cpp"},{"location":"Api/Files/_i_config_bind_8cpp/#commandlineiconfigbindcpp","text":"","title":"Commandline/IConfigBind.cpp"},{"location":"Api/Files/_i_config_bind_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_config_bind_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/IConfigBind.hpp\" #include \"qir/qat/Commandline/ConfigurationManager.hpp\" using namespace microsoft::quantum; namespace microsoft::quantum { IConfigBind::IConfigBind(String const& name, String const& description, ParameterVisibility visibility) : name_{name} , description_{description} , visibility_{visibility} { } IConfigBind::~IConfigBind() = default; String IConfigBind::name() const { return name_; } String IConfigBind::description() const { return description_; } void IConfigBind::setName(String const& name) { name_ = name; } bool IConfigBind::isFlag() const { return is_flag_; } String IConfigBind::defaultValue() const { return str_default_value_; } void IConfigBind::markAsFlag() { is_flag_ = true; } void IConfigBind::setDefault(String const& v) { str_default_value_ = v; } void IConfigBind::makeSettingExperimental() { is_experimental_ = true; } bool IConfigBind::isExperimental() const { return is_experimental_; } bool IConfigBind::isLoadAndSavable() const { return (visibility_ & ParameterVisibility::ConfigOnly) != ParameterVisibility::None; } bool IConfigBind::isAvailableToCli() const { return (visibility_ & ParameterVisibility::CliOnly) != ParameterVisibility::None; } void IConfigBind::setShorthandNotation(String const& name) { shorthand_notation_ = name; } String IConfigBind::shorthandNotation() const { return shorthand_notation_; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_i_config_bind_8hpp/","text":"Commandline/IConfigBind.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::IConfigBind Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/external/yaml.hpp\" #include \"qir/qat/Commandline/ParameterParser.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <iomanip> #include <iostream> #include <sstream> #include <type_traits> #include <typeindex> namespace microsoft::quantum { class IConfigBind { public: enum ParameterVisibility { None = 0, CliOnly = 1, ConfigOnly = 2, CliAndConfig = CliOnly | ConfigOnly, }; // Deleted constructors and deleted operators // // Strictly speaking the code would remain correct if we allowed copy and/or move, but // we have chosen to ban them by choice as potential bugs arising from allowing copy and/or // move can be difficult to find. We consider this behaviour a part of the interface definition. IConfigBind(IConfigBind const&) = delete; IConfigBind(IConfigBind&&) = delete; IConfigBind& operator=(IConfigBind const&) = delete; IConfigBind& operator=(IConfigBind&&) = delete; // Virtual destructor // virtual ~IConfigBind(); // Interface // virtual bool setupArguments(ParameterParser& parser) = 0; virtual bool configure(ParameterParser& parser, bool experimental_mode) = 0; virtual void reset() = 0; virtual String value() = 0; virtual void* pointer() const = 0; virtual void* pointerDefaultValue() = 0; virtual std::type_index valueType() const = 0; virtual void setValueFromYamlNode(YAML::Node const& node) = 0; virtual void updateValueInYamlNode(YAML::Node& node) = 0; // Properties // String name() const; String description() const; bool isFlag() const; String defaultValue() const; bool isExperimental() const; bool isLoadAndSavable() const; bool isAvailableToCli() const; void setShorthandNotation(String const& name); String shorthandNotation() const; protected: // Constructor // IConfigBind( String const& name, String const& description, ParameterVisibility visibility = ParameterVisibility::CliAndConfig); // Configuration // void setName(String const& name); void markAsFlag(); void setDefault(String const& v); void makeSettingExperimental(); private: String name_{\"\"}; String shorthand_notation_{\"\"}; String description_{\"\"}; bool is_flag_{false}; String str_default_value_{\"\"}; bool is_experimental_{false}; ParameterVisibility visibility_{ParameterVisibility::CliAndConfig}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Commandline/IConfigBind.hpp"},{"location":"Api/Files/_i_config_bind_8hpp/#commandlineiconfigbindhpp","text":"","title":"Commandline/IConfigBind.hpp"},{"location":"Api/Files/_i_config_bind_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_config_bind_8hpp/#classes","text":"Name class microsoft::quantum::IConfigBind","title":"Classes"},{"location":"Api/Files/_i_config_bind_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/external/yaml.hpp\" #include \"qir/qat/Commandline/ParameterParser.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <iomanip> #include <iostream> #include <sstream> #include <type_traits> #include <typeindex> namespace microsoft::quantum { class IConfigBind { public: enum ParameterVisibility { None = 0, CliOnly = 1, ConfigOnly = 2, CliAndConfig = CliOnly | ConfigOnly, }; // Deleted constructors and deleted operators // // Strictly speaking the code would remain correct if we allowed copy and/or move, but // we have chosen to ban them by choice as potential bugs arising from allowing copy and/or // move can be difficult to find. We consider this behaviour a part of the interface definition. IConfigBind(IConfigBind const&) = delete; IConfigBind(IConfigBind&&) = delete; IConfigBind& operator=(IConfigBind const&) = delete; IConfigBind& operator=(IConfigBind&&) = delete; // Virtual destructor // virtual ~IConfigBind(); // Interface // virtual bool setupArguments(ParameterParser& parser) = 0; virtual bool configure(ParameterParser& parser, bool experimental_mode) = 0; virtual void reset() = 0; virtual String value() = 0; virtual void* pointer() const = 0; virtual void* pointerDefaultValue() = 0; virtual std::type_index valueType() const = 0; virtual void setValueFromYamlNode(YAML::Node const& node) = 0; virtual void updateValueInYamlNode(YAML::Node& node) = 0; // Properties // String name() const; String description() const; bool isFlag() const; String defaultValue() const; bool isExperimental() const; bool isLoadAndSavable() const; bool isAvailableToCli() const; void setShorthandNotation(String const& name); String shorthandNotation() const; protected: // Constructor // IConfigBind( String const& name, String const& description, ParameterVisibility visibility = ParameterVisibility::CliAndConfig); // Configuration // void setName(String const& name); void markAsFlag(); void setDefault(String const& v); void makeSettingExperimental(); private: String name_{\"\"}; String shorthand_notation_{\"\"}; String description_{\"\"}; bool is_flag_{false}; String str_default_value_{\"\"}; bool is_experimental_{false}; ParameterVisibility visibility_{ParameterVisibility::CliAndConfig}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_i_logger_8cpp/","text":"Logging/ILogger.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Logging/ILogger.hpp\" #include <cstdint> #include <fstream> #include <iostream> #include <string> namespace microsoft::quantum { ILogger::~ILogger() { // Ensuring that the captured function is deleted to release // shared memory. location_resolver_ = nullptr; } void ILogger::setLocationFromFunctionName(String const& name) { if (location_from_name_resolver_) { auto loc = location_from_name_resolver_(name); setLocation(loc); } } void ILogger::setLocationFromValue(llvm::Value const* value) { if (location_resolver_) { auto loc = location_resolver_(value); setLocation(loc); } } void ILogger::setLocationResolver(LocationResolver const& r) { location_resolver_ = r; } void ILogger::setLocationFromNameResolver(LocationFromNameResolver const& r) { location_from_name_resolver_ = r; } ILogger::Messages const& ILogger::messages() const { throw std::runtime_error(\"messages() is not supported by logger.\"); } void ILogger::dump(std::ostream& /*out*/) const { throw std::runtime_error(\"dump() is not supported by logger.\"); } SourceLocation ILogger::resolveLocation(llvm::Value const* value) { if (location_resolver_) { return location_resolver_(value); } return SourceLocation::invalidPosition(); } bool ILogger::hadErrors() const { return had_errors_; } bool ILogger::hadWarnings() const { return had_warnings_; } void ILogger::errorWithLocation(String const& message, llvm::Value* ptr) { if (ptr) { setLocationFromValue(ptr); } error(message); } void ILogger::warningWithLocation(String const& message, llvm::Value* ptr) { if (ptr) { setLocationFromValue(ptr); } warning(message); } void ILogger::errorCouldNotDeleteNode(llvm::Value* ptr) { errorWithLocation(\"Could not delete node.\", ptr); } void ILogger::errorExpectedStraightLineCodeMultipleFunctions(llvm::Value* ptr) { errorWithLocation(\"Expected straight line code, but multiple functions present.\", ptr); } void ILogger::errorExpectedStraightLineCodeMultipleBlocks(llvm::Value* ptr) { errorWithLocation(\"Expected straight line code, but multiple blocks present.\", ptr); } void ILogger::errorReleaseFailNonStandardAlloc(llvm::Value* ptr) { errorWithLocation(\"Cannot release qubit from non-standard allocation.\", ptr); } void ILogger::warningReleasePhiNodeQubit(llvm::Value* ptr) { if (ptr) { setLocationFromValue(ptr); } warning(\"Cannot release qubit arising from phi node.\"); } void ILogger::errorFunctionInliningMaxRecursion(uint64_t n, llvm::Value* ptr) { errorWithLocation(\"Function inlining exceeded maximum recursion depth of \" + std::to_string(n), ptr); } void ILogger::errorNoQubitsPresent(llvm::Value* ptr, String const& name) { errorWithLocation(\"No qubits present in function (required by adaptor '\" + name + \"').\", ptr); } void ILogger::errorNoResultsPresent(llvm::Value* ptr, String const& name) { errorWithLocation(\"No results present in function (required by adaptor '\" + name + \"').\", ptr); } void ILogger::errorOpcodeNotAllowed(String const& code, String const& target_name, llvm::Value* ptr) { if (ptr) { setLocationFromValue(ptr); } error(\"Opcode '\" + code + \"' is not allowed for this adaptor (\" + target_name + \").\"); } void ILogger::errorCustomFunctionsNotAllowed(llvm::Value* ptr) { errorWithLocation(\"Calls to custom defined functions not allowed.\", ptr); } void ILogger::errorExternalCallsNotAllowed(String const& function_name, String const& target_name, llvm::Value* ptr) { errorWithLocation( \"External call '\" + function_name + \"' is not allowed for this adaptor (\" + target_name + \").\", ptr); } void ILogger::errorTypeNotAllowed(String const& type_name, String const& target_name, llvm::Value* ptr) { errorWithLocation(\"Type '\" + type_name + \"' is not allowed for this adaptor (\" + target_name + \").\", ptr); } void ILogger::errorPoisonNotAllowed(String const& target_name, llvm::Value* ptr) { errorWithLocation(\"Poison value is not allowed for this adaptor (\" + target_name + \").\", ptr); } void ILogger::errorUndefNotAllowed(String const& target_name, llvm::Value* ptr) { errorWithLocation(\"Undef value is not allowed for this adaptor (\" + target_name + \").\", ptr); } void ILogger::errorExpectedStringValueForAttr(String const& function_name, String const& attr_name) { setLocationFromFunctionName(function_name); error(\"Expected string value for attribute '\" + attr_name + \"' for function \" + function_name); } void ILogger::warningWeakLinkReplacementNotPossible(String const& function_name, String const& replacement) { setLocationFromFunctionName(function_name); warning(\"Could not find replacement \" + replacement + \" for function \" + function_name); } void ILogger::errorReplacementSignatureMismatch( String const& function_name, String const& signature1, String const& signature2) { setLocationFromFunctionName(function_name); error(\"Replacement signature mismatch: \" + signature1 + \" differs from \" + signature2); } void ILogger::setHasErrors(bool value) { had_errors_ = value; } void ILogger::setHasWarnings(bool value) { had_warnings_ = value; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Logging/ILogger.cpp"},{"location":"Api/Files/_i_logger_8cpp/#loggingiloggercpp","text":"","title":"Logging/ILogger.cpp"},{"location":"Api/Files/_i_logger_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_logger_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Logging/ILogger.hpp\" #include <cstdint> #include <fstream> #include <iostream> #include <string> namespace microsoft::quantum { ILogger::~ILogger() { // Ensuring that the captured function is deleted to release // shared memory. location_resolver_ = nullptr; } void ILogger::setLocationFromFunctionName(String const& name) { if (location_from_name_resolver_) { auto loc = location_from_name_resolver_(name); setLocation(loc); } } void ILogger::setLocationFromValue(llvm::Value const* value) { if (location_resolver_) { auto loc = location_resolver_(value); setLocation(loc); } } void ILogger::setLocationResolver(LocationResolver const& r) { location_resolver_ = r; } void ILogger::setLocationFromNameResolver(LocationFromNameResolver const& r) { location_from_name_resolver_ = r; } ILogger::Messages const& ILogger::messages() const { throw std::runtime_error(\"messages() is not supported by logger.\"); } void ILogger::dump(std::ostream& /*out*/) const { throw std::runtime_error(\"dump() is not supported by logger.\"); } SourceLocation ILogger::resolveLocation(llvm::Value const* value) { if (location_resolver_) { return location_resolver_(value); } return SourceLocation::invalidPosition(); } bool ILogger::hadErrors() const { return had_errors_; } bool ILogger::hadWarnings() const { return had_warnings_; } void ILogger::errorWithLocation(String const& message, llvm::Value* ptr) { if (ptr) { setLocationFromValue(ptr); } error(message); } void ILogger::warningWithLocation(String const& message, llvm::Value* ptr) { if (ptr) { setLocationFromValue(ptr); } warning(message); } void ILogger::errorCouldNotDeleteNode(llvm::Value* ptr) { errorWithLocation(\"Could not delete node.\", ptr); } void ILogger::errorExpectedStraightLineCodeMultipleFunctions(llvm::Value* ptr) { errorWithLocation(\"Expected straight line code, but multiple functions present.\", ptr); } void ILogger::errorExpectedStraightLineCodeMultipleBlocks(llvm::Value* ptr) { errorWithLocation(\"Expected straight line code, but multiple blocks present.\", ptr); } void ILogger::errorReleaseFailNonStandardAlloc(llvm::Value* ptr) { errorWithLocation(\"Cannot release qubit from non-standard allocation.\", ptr); } void ILogger::warningReleasePhiNodeQubit(llvm::Value* ptr) { if (ptr) { setLocationFromValue(ptr); } warning(\"Cannot release qubit arising from phi node.\"); } void ILogger::errorFunctionInliningMaxRecursion(uint64_t n, llvm::Value* ptr) { errorWithLocation(\"Function inlining exceeded maximum recursion depth of \" + std::to_string(n), ptr); } void ILogger::errorNoQubitsPresent(llvm::Value* ptr, String const& name) { errorWithLocation(\"No qubits present in function (required by adaptor '\" + name + \"').\", ptr); } void ILogger::errorNoResultsPresent(llvm::Value* ptr, String const& name) { errorWithLocation(\"No results present in function (required by adaptor '\" + name + \"').\", ptr); } void ILogger::errorOpcodeNotAllowed(String const& code, String const& target_name, llvm::Value* ptr) { if (ptr) { setLocationFromValue(ptr); } error(\"Opcode '\" + code + \"' is not allowed for this adaptor (\" + target_name + \").\"); } void ILogger::errorCustomFunctionsNotAllowed(llvm::Value* ptr) { errorWithLocation(\"Calls to custom defined functions not allowed.\", ptr); } void ILogger::errorExternalCallsNotAllowed(String const& function_name, String const& target_name, llvm::Value* ptr) { errorWithLocation( \"External call '\" + function_name + \"' is not allowed for this adaptor (\" + target_name + \").\", ptr); } void ILogger::errorTypeNotAllowed(String const& type_name, String const& target_name, llvm::Value* ptr) { errorWithLocation(\"Type '\" + type_name + \"' is not allowed for this adaptor (\" + target_name + \").\", ptr); } void ILogger::errorPoisonNotAllowed(String const& target_name, llvm::Value* ptr) { errorWithLocation(\"Poison value is not allowed for this adaptor (\" + target_name + \").\", ptr); } void ILogger::errorUndefNotAllowed(String const& target_name, llvm::Value* ptr) { errorWithLocation(\"Undef value is not allowed for this adaptor (\" + target_name + \").\", ptr); } void ILogger::errorExpectedStringValueForAttr(String const& function_name, String const& attr_name) { setLocationFromFunctionName(function_name); error(\"Expected string value for attribute '\" + attr_name + \"' for function \" + function_name); } void ILogger::warningWeakLinkReplacementNotPossible(String const& function_name, String const& replacement) { setLocationFromFunctionName(function_name); warning(\"Could not find replacement \" + replacement + \" for function \" + function_name); } void ILogger::errorReplacementSignatureMismatch( String const& function_name, String const& signature1, String const& signature2) { setLocationFromFunctionName(function_name); error(\"Replacement signature mismatch: \" + signature1 + \" differs from \" + signature2); } void ILogger::setHasErrors(bool value) { had_errors_ = value; } void ILogger::setHasWarnings(bool value) { had_warnings_ = value; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_i_logger_8hpp/","text":"Logging/ILogger.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ILogger struct microsoft::quantum::ILogger::Location Class that holds the location of where the incident happened. struct microsoft::quantum::ILogger::Message Struct to hold a message together with its type and location. Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/SourceLocation.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <cstdint> #include <fstream> #include <memory> #include <string> #include <utility> namespace microsoft::quantum { class ILogger { public: using Value = llvm::Value; using LocationResolver = std::function<SourceLocation(Value const*)>; using LocationFromNameResolver = std::function<SourceLocation(String const&)>; using ILoggerPtr = std::shared_ptr<ILogger>; struct Location : public SourceLocation { Location() = default; explicit Location(SourceLocation const& source) : SourceLocation(source) { } Location(String v_name, int64_t v_line, int64_t v_column, String llvm_hint = \"\", String frontend_hint = \"\") : SourceLocation(std::move(v_name), v_line, v_column) , llvm_hint_{std::move(llvm_hint)} , frontend_hint_{std::move(frontend_hint)} { } Location(Location const& source) = default; Location& operator=(Location const& source) = default; String& llvmHint() { return llvm_hint_; } String const& llvmHint() const { return llvm_hint_; } void setLlvmHint(String const& v) { llvm_hint_ = v; } String& frontendHint() { return frontend_hint_; } String const& frontendHint() const { return frontend_hint_; } void setFrontendHint(String const& v) { frontend_hint_ = v; } private: String llvm_hint_{\"\"}; String frontend_hint_{\"\"}; }; enum class Type { Debug, Info, Warning, Error, InternalError }; struct Message { Type type; Location location; String message; }; using Messages = std::vector<Message>; // Constructors, copy and move operators and destructors // ILogger() = default; ILogger(ILogger const&) = delete; ILogger(ILogger&&) = delete; ILogger& operator=(ILogger const&) = delete; ILogger& operator=(ILogger&&) = delete; virtual ~ILogger(); // Abstract interface methods // virtual void debug(String const& message) = 0; virtual void info(String const& message) = 0; virtual void warning(String const& message) = 0; virtual void error(String const& message) = 0; virtual void internalError(String const& message) = 0; virtual void setLocation(SourceLocation const& location) = 0; virtual void setLlvmHint(String const& value) = 0; virtual void setFrontendHint(String const& value) = 0; virtual Messages const& messages() const; virtual void dump(std::ostream& out) const; // Location integration with LLVM // void setLocationFromValue(llvm::Value const* value); void setLocationFromFunctionName(String const& name); void setLocationResolver(LocationResolver const& r); void setLocationFromNameResolver(LocationFromNameResolver const& r); SourceLocation resolveLocation(llvm::Value const* value); bool hadErrors() const; bool hadWarnings() const; void errorWithLocation(String const& message, llvm::Value* ptr = nullptr); void warningWithLocation(String const& message, llvm::Value* ptr = nullptr); virtual void errorCouldNotDeleteNode(llvm::Value* ptr = nullptr); virtual void errorExpectedStraightLineCodeMultipleFunctions(llvm::Value* ptr = nullptr); virtual void errorExpectedStraightLineCodeMultipleBlocks(llvm::Value* ptr = nullptr); virtual void errorReleaseFailNonStandardAlloc(llvm::Value* ptr = nullptr); virtual void warningReleasePhiNodeQubit(llvm::Value* ptr = nullptr); virtual void errorFunctionInliningMaxRecursion(uint64_t n, llvm::Value* ptr = nullptr); virtual void errorNoQubitsPresent(llvm::Value* ptr = nullptr, String const& name = \"unnamed\"); virtual void errorNoResultsPresent(llvm::Value* ptr = nullptr, String const& name = \"unnamed\"); virtual void errorOpcodeNotAllowed(String const& code, String const& target_name, llvm::Value* ptr = nullptr); virtual void errorCustomFunctionsNotAllowed(llvm::Value* ptr = nullptr); virtual void errorExternalCallsNotAllowed( String const& function_name, String const& target_name, llvm::Value* ptr = nullptr); virtual void errorTypeNotAllowed(String const& type_name, String const& target_name, llvm::Value* ptr = nullptr); virtual void errorPoisonNotAllowed(String const& target_name, llvm::Value* ptr = nullptr); virtual void errorUndefNotAllowed(String const& target_name, llvm::Value* ptr = nullptr); virtual void errorExpectedStringValueForAttr(String const& function_name, String const& attr_name); virtual void warningWeakLinkReplacementNotPossible(String const& function_name, String const& replacement); virtual void errorReplacementSignatureMismatch( String const& function_name, String const& signature1, String const& signature2); protected: void setHasErrors(bool value); void setHasWarnings(bool value); private: bool had_errors_{false}; bool had_warnings_{false}; LocationResolver location_resolver_{nullptr}; LocationFromNameResolver location_from_name_resolver_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Logging/ILogger.hpp"},{"location":"Api/Files/_i_logger_8hpp/#loggingiloggerhpp","text":"","title":"Logging/ILogger.hpp"},{"location":"Api/Files/_i_logger_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_logger_8hpp/#classes","text":"Name class microsoft::quantum::ILogger struct microsoft::quantum::ILogger::Location Class that holds the location of where the incident happened. struct microsoft::quantum::ILogger::Message Struct to hold a message together with its type and location.","title":"Classes"},{"location":"Api/Files/_i_logger_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/SourceLocation.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <cstdint> #include <fstream> #include <memory> #include <string> #include <utility> namespace microsoft::quantum { class ILogger { public: using Value = llvm::Value; using LocationResolver = std::function<SourceLocation(Value const*)>; using LocationFromNameResolver = std::function<SourceLocation(String const&)>; using ILoggerPtr = std::shared_ptr<ILogger>; struct Location : public SourceLocation { Location() = default; explicit Location(SourceLocation const& source) : SourceLocation(source) { } Location(String v_name, int64_t v_line, int64_t v_column, String llvm_hint = \"\", String frontend_hint = \"\") : SourceLocation(std::move(v_name), v_line, v_column) , llvm_hint_{std::move(llvm_hint)} , frontend_hint_{std::move(frontend_hint)} { } Location(Location const& source) = default; Location& operator=(Location const& source) = default; String& llvmHint() { return llvm_hint_; } String const& llvmHint() const { return llvm_hint_; } void setLlvmHint(String const& v) { llvm_hint_ = v; } String& frontendHint() { return frontend_hint_; } String const& frontendHint() const { return frontend_hint_; } void setFrontendHint(String const& v) { frontend_hint_ = v; } private: String llvm_hint_{\"\"}; String frontend_hint_{\"\"}; }; enum class Type { Debug, Info, Warning, Error, InternalError }; struct Message { Type type; Location location; String message; }; using Messages = std::vector<Message>; // Constructors, copy and move operators and destructors // ILogger() = default; ILogger(ILogger const&) = delete; ILogger(ILogger&&) = delete; ILogger& operator=(ILogger const&) = delete; ILogger& operator=(ILogger&&) = delete; virtual ~ILogger(); // Abstract interface methods // virtual void debug(String const& message) = 0; virtual void info(String const& message) = 0; virtual void warning(String const& message) = 0; virtual void error(String const& message) = 0; virtual void internalError(String const& message) = 0; virtual void setLocation(SourceLocation const& location) = 0; virtual void setLlvmHint(String const& value) = 0; virtual void setFrontendHint(String const& value) = 0; virtual Messages const& messages() const; virtual void dump(std::ostream& out) const; // Location integration with LLVM // void setLocationFromValue(llvm::Value const* value); void setLocationFromFunctionName(String const& name); void setLocationResolver(LocationResolver const& r); void setLocationFromNameResolver(LocationFromNameResolver const& r); SourceLocation resolveLocation(llvm::Value const* value); bool hadErrors() const; bool hadWarnings() const; void errorWithLocation(String const& message, llvm::Value* ptr = nullptr); void warningWithLocation(String const& message, llvm::Value* ptr = nullptr); virtual void errorCouldNotDeleteNode(llvm::Value* ptr = nullptr); virtual void errorExpectedStraightLineCodeMultipleFunctions(llvm::Value* ptr = nullptr); virtual void errorExpectedStraightLineCodeMultipleBlocks(llvm::Value* ptr = nullptr); virtual void errorReleaseFailNonStandardAlloc(llvm::Value* ptr = nullptr); virtual void warningReleasePhiNodeQubit(llvm::Value* ptr = nullptr); virtual void errorFunctionInliningMaxRecursion(uint64_t n, llvm::Value* ptr = nullptr); virtual void errorNoQubitsPresent(llvm::Value* ptr = nullptr, String const& name = \"unnamed\"); virtual void errorNoResultsPresent(llvm::Value* ptr = nullptr, String const& name = \"unnamed\"); virtual void errorOpcodeNotAllowed(String const& code, String const& target_name, llvm::Value* ptr = nullptr); virtual void errorCustomFunctionsNotAllowed(llvm::Value* ptr = nullptr); virtual void errorExternalCallsNotAllowed( String const& function_name, String const& target_name, llvm::Value* ptr = nullptr); virtual void errorTypeNotAllowed(String const& type_name, String const& target_name, llvm::Value* ptr = nullptr); virtual void errorPoisonNotAllowed(String const& target_name, llvm::Value* ptr = nullptr); virtual void errorUndefNotAllowed(String const& target_name, llvm::Value* ptr = nullptr); virtual void errorExpectedStringValueForAttr(String const& function_name, String const& attr_name); virtual void warningWeakLinkReplacementNotPossible(String const& function_name, String const& replacement); virtual void errorReplacementSignatureMismatch( String const& function_name, String const& signature1, String const& signature2); protected: void setHasErrors(bool value); void setHasWarnings(bool value); private: bool had_errors_{false}; bool had_warnings_{false}; LocationResolver location_resolver_{nullptr}; LocationFromNameResolver location_from_name_resolver_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_i_operand_prototype_8cpp/","text":"Rules/IOperandPrototype.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Rules/IOperandPrototype.hpp\" namespace microsoft::quantum { IOperandPrototype::~IOperandPrototype() = default; bool IOperandPrototype::matchChildren(Value* value, Captures& captures) const { if (!children_.empty()) { auto user = llvm::dyn_cast<llvm::User>(value); if (user == nullptr) { return false; } if (user->getNumOperands() != children_.size()) { return false; } uint64_t i = 0; while (i < children_.size()) { auto v = user->getOperand(static_cast<uint32_t>(i)); if (!children_[i]->match(v, captures)) { return false; } ++i; } return true; } // TODO(issue-16): value may be other type than llvm::User. Check other relevant types // and deal with it. return true; } void IOperandPrototype::addChild(Child const& child) { children_.push_back(child); } void IOperandPrototype::captureAs(std::string capture_name) { capture_name_ = std::move(capture_name); } bool IOperandPrototype::fail(Value* /*value*/, Captures& /*captures*/) const { return false; } bool IOperandPrototype::success(Value* value, Captures& captures) const { capture(value, captures); auto ret = matchChildren(value, captures); if (!ret) { uncapture(value, captures); } return ret; } void IOperandPrototype::capture(Value* value, Captures& captures) const { if (!capture_name_.empty()) { captures[capture_name_] = value; } } void IOperandPrototype::uncapture(Value* /*value*/, Captures& captures) const { if (!capture_name_.empty()) { auto it = captures.find(capture_name_); if (it == captures.end()) { throw std::runtime_error(\"Previously captured name \" + capture_name_ + \" not found in capture list.\"); } captures.erase(it); } } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/IOperandPrototype.cpp"},{"location":"Api/Files/_i_operand_prototype_8cpp/#rulesioperandprototypecpp","text":"","title":"Rules/IOperandPrototype.cpp"},{"location":"Api/Files/_i_operand_prototype_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_operand_prototype_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Rules/IOperandPrototype.hpp\" namespace microsoft::quantum { IOperandPrototype::~IOperandPrototype() = default; bool IOperandPrototype::matchChildren(Value* value, Captures& captures) const { if (!children_.empty()) { auto user = llvm::dyn_cast<llvm::User>(value); if (user == nullptr) { return false; } if (user->getNumOperands() != children_.size()) { return false; } uint64_t i = 0; while (i < children_.size()) { auto v = user->getOperand(static_cast<uint32_t>(i)); if (!children_[i]->match(v, captures)) { return false; } ++i; } return true; } // TODO(issue-16): value may be other type than llvm::User. Check other relevant types // and deal with it. return true; } void IOperandPrototype::addChild(Child const& child) { children_.push_back(child); } void IOperandPrototype::captureAs(std::string capture_name) { capture_name_ = std::move(capture_name); } bool IOperandPrototype::fail(Value* /*value*/, Captures& /*captures*/) const { return false; } bool IOperandPrototype::success(Value* value, Captures& captures) const { capture(value, captures); auto ret = matchChildren(value, captures); if (!ret) { uncapture(value, captures); } return ret; } void IOperandPrototype::capture(Value* value, Captures& captures) const { if (!capture_name_.empty()) { captures[capture_name_] = value; } } void IOperandPrototype::uncapture(Value* /*value*/, Captures& captures) const { if (!capture_name_.empty()) { auto it = captures.find(capture_name_); if (it == captures.end()) { throw std::runtime_error(\"Previously captured name \" + capture_name_ + \" not found in capture list.\"); } captures.erase(it); } } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_i_operand_prototype_8hpp/","text":"Rules/IOperandPrototype.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::IOperandPrototype Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { class IOperandPrototype { public: using Instruction = llvm::Instruction; using String = std::string; using Value = llvm::Value; using Child = std::shared_ptr<IOperandPrototype>; using Children = std::vector<Child>; using Captures = std::unordered_map<std::string, Value*>; // Constructors and destructors // IOperandPrototype() = default; virtual ~IOperandPrototype(); // Interface functions // virtual bool match(Value* value, Captures& captures) const = 0; virtual Child copy() const = 0; // Shared functionality // void addChild(Child const& child); void captureAs(std::string capture_name); protected: // Function to indicate match success or failure. Either of these // must be called prior to return from an implementation of // IOperandPrototype::match. // bool fail(Value* value, Captures& captures) const; bool success(Value* value, Captures& captures) const; // Helper functions for the capture logic. // bool matchChildren(Value* value, Captures& captures) const; // Helper functions for operation // void copyPropertiesFrom(IOperandPrototype const& other) { capture_name_ = other.capture_name_; children_ = other.children_; } private: void capture(Value* value, Captures& captures) const; void uncapture(Value* value, Captures& captures) const; // Data variables for common matching functionality // std::string capture_name_{\"\"}; Children children_{}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/IOperandPrototype.hpp"},{"location":"Api/Files/_i_operand_prototype_8hpp/#rulesioperandprototypehpp","text":"","title":"Rules/IOperandPrototype.hpp"},{"location":"Api/Files/_i_operand_prototype_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_operand_prototype_8hpp/#classes","text":"Name class microsoft::quantum::IOperandPrototype","title":"Classes"},{"location":"Api/Files/_i_operand_prototype_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { class IOperandPrototype { public: using Instruction = llvm::Instruction; using String = std::string; using Value = llvm::Value; using Child = std::shared_ptr<IOperandPrototype>; using Children = std::vector<Child>; using Captures = std::unordered_map<std::string, Value*>; // Constructors and destructors // IOperandPrototype() = default; virtual ~IOperandPrototype(); // Interface functions // virtual bool match(Value* value, Captures& captures) const = 0; virtual Child copy() const = 0; // Shared functionality // void addChild(Child const& child); void captureAs(std::string capture_name); protected: // Function to indicate match success or failure. Either of these // must be called prior to return from an implementation of // IOperandPrototype::match. // bool fail(Value* value, Captures& captures) const; bool success(Value* value, Captures& captures) const; // Helper functions for the capture logic. // bool matchChildren(Value* value, Captures& captures) const; // Helper functions for operation // void copyPropertiesFrom(IOperandPrototype const& other) { capture_name_ = other.capture_name_; children_ = other.children_; } private: void capture(Value* value, Captures& captures) const; void uncapture(Value* value, Captures& captures) const; // Data variables for common matching functionality // std::string capture_name_{\"\"}; Children children_{}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_instruction_8cpp/","text":"Rules/Patterns/Instruction.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" namespace microsoft::quantum { bool StorePattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::StoreInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } StorePattern::Child StorePattern::copy() const { auto ret = std::make_shared<StorePattern>(); ret->copyPropertiesFrom(*this); return ret; } bool LoadPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::LoadInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } LoadPattern::Child LoadPattern::copy() const { auto ret = std::make_shared<LoadPattern>(); ret->copyPropertiesFrom(*this); return ret; } bool BitCastPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::BitCastInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } BitCastPattern::Child BitCastPattern::copy() const { auto ret = std::make_shared<BitCastPattern>(); ret->copyPropertiesFrom(*this); return ret; } bool IntToPtrPattern::match(Value* instr, Captures& captures) const { auto* a = llvm::dyn_cast<llvm::IntToPtrInst>(instr); auto* b = llvm::dyn_cast<llvm::ConcreteOperator<llvm::Operator, llvm::Instruction::IntToPtr>>(instr); if (a == nullptr && b == nullptr) { return fail(instr, captures); } auto ret = success(instr, captures); return ret; } IntToPtrPattern::Child IntToPtrPattern::copy() const { auto ret = std::make_shared<IntToPtrPattern>(); ret->copyPropertiesFrom(*this); return ret; } bool ConstIntPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::ConstantInt>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } ConstIntPattern::Child ConstIntPattern::copy() const { auto ret = std::make_shared<ConstIntPattern>(); ret->copyPropertiesFrom(*this); return ret; } bool BranchPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::BranchInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } BranchPattern::Child BranchPattern::copy() const { auto ret = std::make_shared<BranchPattern>(); ret->copyPropertiesFrom(*this); return ret; } bool SelectPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::SelectInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } SelectPattern::Child SelectPattern::copy() const { auto ret = std::make_shared<SelectPattern>(); ret->copyPropertiesFrom(*this); return ret; } bool BasicBlockPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::BasicBlock>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } BasicBlockPattern::Child BasicBlockPattern::copy() const { auto ret = std::make_shared<BasicBlockPattern>(); ret->copyPropertiesFrom(*this); return ret; } bool SwitchPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::SwitchInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } SwitchPattern::Child SwitchPattern::copy() const { auto ret = std::make_shared<SwitchPattern>(); ret->copyPropertiesFrom(*this); return ret; } bool ZExtPattern::match(Value* instr, Captures& captures) const { auto* cast_instr = llvm::dyn_cast<llvm::ZExtInst>(instr); if (cast_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } ZExtPattern::Child ZExtPattern::copy() const { auto ret = std::make_shared<ZExtPattern>(); ret->copyPropertiesFrom(*this); return ret; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Patterns/Instruction.cpp"},{"location":"Api/Files/_instruction_8cpp/#rulespatternsinstructioncpp","text":"","title":"Rules/Patterns/Instruction.cpp"},{"location":"Api/Files/_instruction_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_instruction_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" namespace microsoft::quantum { bool StorePattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::StoreInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } StorePattern::Child StorePattern::copy() const { auto ret = std::make_shared<StorePattern>(); ret->copyPropertiesFrom(*this); return ret; } bool LoadPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::LoadInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } LoadPattern::Child LoadPattern::copy() const { auto ret = std::make_shared<LoadPattern>(); ret->copyPropertiesFrom(*this); return ret; } bool BitCastPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::BitCastInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } BitCastPattern::Child BitCastPattern::copy() const { auto ret = std::make_shared<BitCastPattern>(); ret->copyPropertiesFrom(*this); return ret; } bool IntToPtrPattern::match(Value* instr, Captures& captures) const { auto* a = llvm::dyn_cast<llvm::IntToPtrInst>(instr); auto* b = llvm::dyn_cast<llvm::ConcreteOperator<llvm::Operator, llvm::Instruction::IntToPtr>>(instr); if (a == nullptr && b == nullptr) { return fail(instr, captures); } auto ret = success(instr, captures); return ret; } IntToPtrPattern::Child IntToPtrPattern::copy() const { auto ret = std::make_shared<IntToPtrPattern>(); ret->copyPropertiesFrom(*this); return ret; } bool ConstIntPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::ConstantInt>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } ConstIntPattern::Child ConstIntPattern::copy() const { auto ret = std::make_shared<ConstIntPattern>(); ret->copyPropertiesFrom(*this); return ret; } bool BranchPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::BranchInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } BranchPattern::Child BranchPattern::copy() const { auto ret = std::make_shared<BranchPattern>(); ret->copyPropertiesFrom(*this); return ret; } bool SelectPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::SelectInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } SelectPattern::Child SelectPattern::copy() const { auto ret = std::make_shared<SelectPattern>(); ret->copyPropertiesFrom(*this); return ret; } bool BasicBlockPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::BasicBlock>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } BasicBlockPattern::Child BasicBlockPattern::copy() const { auto ret = std::make_shared<BasicBlockPattern>(); ret->copyPropertiesFrom(*this); return ret; } bool SwitchPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::SwitchInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } SwitchPattern::Child SwitchPattern::copy() const { auto ret = std::make_shared<SwitchPattern>(); ret->copyPropertiesFrom(*this); return ret; } bool ZExtPattern::match(Value* instr, Captures& captures) const { auto* cast_instr = llvm::dyn_cast<llvm::ZExtInst>(instr); if (cast_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } ZExtPattern::Child ZExtPattern::copy() const { auto ret = std::make_shared<ZExtPattern>(); ret->copyPropertiesFrom(*this); return ret; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_instruction_8hpp/","text":"Rules/Patterns/Instruction.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::StorePattern class microsoft::quantum::LoadPattern class microsoft::quantum::BitCastPattern class microsoft::quantum::IntToPtrPattern class microsoft::quantum::ConstIntPattern class microsoft::quantum::BranchPattern class microsoft::quantum::SelectPattern class microsoft::quantum::BasicBlockPattern class microsoft::quantum::SwitchPattern class microsoft::quantum::ZExtPattern Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { class StorePattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class LoadPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class BitCastPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class IntToPtrPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class ConstIntPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class BranchPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class SelectPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class BasicBlockPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class SwitchPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class ZExtPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Patterns/Instruction.hpp"},{"location":"Api/Files/_instruction_8hpp/#rulespatternsinstructionhpp","text":"","title":"Rules/Patterns/Instruction.hpp"},{"location":"Api/Files/_instruction_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_instruction_8hpp/#classes","text":"Name class microsoft::quantum::StorePattern class microsoft::quantum::LoadPattern class microsoft::quantum::BitCastPattern class microsoft::quantum::IntToPtrPattern class microsoft::quantum::ConstIntPattern class microsoft::quantum::BranchPattern class microsoft::quantum::SelectPattern class microsoft::quantum::BasicBlockPattern class microsoft::quantum::SwitchPattern class microsoft::quantum::ZExtPattern","title":"Classes"},{"location":"Api/Files/_instruction_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { class StorePattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class LoadPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class BitCastPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class IntToPtrPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class ConstIntPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class BranchPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class SelectPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class BasicBlockPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class SwitchPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class ZExtPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_instruction_location_table_8cpp/","text":"ModuleLoader/InstructionLocationTable.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/ModuleLoader/InstructionLocationTable.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include <memory> namespace microsoft::quantum { InstructionLocationTable::InstructionLocationTablePtr InstructionLocationTable::create() { InstructionLocationTablePtr ret; ret.reset(new InstructionLocationTable()); return ret; } void InstructionLocationTable::printInfoComment(Value const& value, llvm::formatted_raw_ostream& outstream) { registerValuePosition(&value, outstream); } void InstructionLocationTable::emitBasicBlockStartAnnot(BasicBlock const* block, llvm::formatted_raw_ostream& outstream) { registerValuePosition(block, outstream); } void InstructionLocationTable::emitFunctionAnnot(Function const* function, llvm::formatted_raw_ostream& outstream) { outstream.flush(); Position pos; pos.setName(static_cast<String>(current_filename_)); pos.setLine(outstream.getLine() + 1); pos.setColumn(outstream.getColumn() + 1); positions_.insert(std::make_pair(function, pos)); function_positions_[static_cast<String>(function->getName())] = pos; } InstructionLocationTable::Position InstructionLocationTable::getPosition(Value const* value) const { auto it = positions_.find(value); if (it != positions_.end()) { return it->second; } return Position::invalidPosition(); } InstructionLocationTable::Position InstructionLocationTable::getPositionFromFunctionName(String const& name) const { auto it = function_positions_.find(name); if (it != function_positions_.end()) { return it->second; } return Position::invalidPosition(); } void InstructionLocationTable::registerModule(StringRef const& filename, Module const* module) { current_filename_ = filename; // Using a null output stream to traverse the DAG and keep track of the position of the cursor. // The cursor position is subsequently recorded as instructions are registered. llvm::raw_null_ostream dummy{}; module->print(dummy, this); } void InstructionLocationTable::registerValuePosition(Value const* value, llvm::formatted_raw_ostream& outstream) { outstream.flush(); Position pos; pos.setName(static_cast<String>(current_filename_)); pos.setLine(outstream.getLine() + 1); pos.setColumn(outstream.getColumn() + 1); positions_.insert(std::make_pair(value, pos)); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"ModuleLoader/InstructionLocationTable.cpp"},{"location":"Api/Files/_instruction_location_table_8cpp/#moduleloaderinstructionlocationtablecpp","text":"","title":"ModuleLoader/InstructionLocationTable.cpp"},{"location":"Api/Files/_instruction_location_table_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_instruction_location_table_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/ModuleLoader/InstructionLocationTable.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include <memory> namespace microsoft::quantum { InstructionLocationTable::InstructionLocationTablePtr InstructionLocationTable::create() { InstructionLocationTablePtr ret; ret.reset(new InstructionLocationTable()); return ret; } void InstructionLocationTable::printInfoComment(Value const& value, llvm::formatted_raw_ostream& outstream) { registerValuePosition(&value, outstream); } void InstructionLocationTable::emitBasicBlockStartAnnot(BasicBlock const* block, llvm::formatted_raw_ostream& outstream) { registerValuePosition(block, outstream); } void InstructionLocationTable::emitFunctionAnnot(Function const* function, llvm::formatted_raw_ostream& outstream) { outstream.flush(); Position pos; pos.setName(static_cast<String>(current_filename_)); pos.setLine(outstream.getLine() + 1); pos.setColumn(outstream.getColumn() + 1); positions_.insert(std::make_pair(function, pos)); function_positions_[static_cast<String>(function->getName())] = pos; } InstructionLocationTable::Position InstructionLocationTable::getPosition(Value const* value) const { auto it = positions_.find(value); if (it != positions_.end()) { return it->second; } return Position::invalidPosition(); } InstructionLocationTable::Position InstructionLocationTable::getPositionFromFunctionName(String const& name) const { auto it = function_positions_.find(name); if (it != function_positions_.end()) { return it->second; } return Position::invalidPosition(); } void InstructionLocationTable::registerModule(StringRef const& filename, Module const* module) { current_filename_ = filename; // Using a null output stream to traverse the DAG and keep track of the position of the cursor. // The cursor position is subsequently recorded as instructions are registered. llvm::raw_null_ostream dummy{}; module->print(dummy, this); } void InstructionLocationTable::registerValuePosition(Value const* value, llvm::formatted_raw_ostream& outstream) { outstream.flush(); Position pos; pos.setName(static_cast<String>(current_filename_)); pos.setLine(outstream.getLine() + 1); pos.setColumn(outstream.getColumn() + 1); positions_.insert(std::make_pair(value, pos)); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_instruction_location_table_8hpp/","text":"ModuleLoader/InstructionLocationTable.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::InstructionLocationTable Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/SourceLocation.hpp\" #include <memory> #include <unordered_map> namespace microsoft::quantum { class InstructionLocationTable : public llvm::AssemblyAnnotationWriter { public: using Position = SourceLocation; using StringRef = llvm::StringRef; using BasicBlock = llvm::BasicBlock; using Function = llvm::Function; using Value = llvm::Value; using Module = llvm::Module; using Positions = std::unordered_map<Value const*, Position>; using FunctionPositions = std::unordered_map<String, Position>; using InstructionLocationTablePtr = std::shared_ptr<InstructionLocationTable>; static InstructionLocationTablePtr create(); // Debug table interface // Position getPosition(Value const* value) const; Position getPositionFromFunctionName(String const& name) const; void registerModule(StringRef const& filename, Module const* module); protected: // AssemblyAnnotationWriter interface implementations // void printInfoComment(Value const& value, llvm::formatted_raw_ostream& outstream) override; void emitBasicBlockStartAnnot(BasicBlock const* block, llvm::formatted_raw_ostream& outstream) override; void emitFunctionAnnot(Function const* function, llvm::formatted_raw_ostream& outstream) override; private: Positions positions_; FunctionPositions function_positions_; StringRef current_filename_{}; InstructionLocationTable() = default; void registerValuePosition(Value const* value, llvm::formatted_raw_ostream& outstream); }; using InstructionLocationTablePtr = InstructionLocationTable::InstructionLocationTablePtr; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"ModuleLoader/InstructionLocationTable.hpp"},{"location":"Api/Files/_instruction_location_table_8hpp/#moduleloaderinstructionlocationtablehpp","text":"","title":"ModuleLoader/InstructionLocationTable.hpp"},{"location":"Api/Files/_instruction_location_table_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_instruction_location_table_8hpp/#classes","text":"Name class microsoft::quantum::InstructionLocationTable","title":"Classes"},{"location":"Api/Files/_instruction_location_table_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/SourceLocation.hpp\" #include <memory> #include <unordered_map> namespace microsoft::quantum { class InstructionLocationTable : public llvm::AssemblyAnnotationWriter { public: using Position = SourceLocation; using StringRef = llvm::StringRef; using BasicBlock = llvm::BasicBlock; using Function = llvm::Function; using Value = llvm::Value; using Module = llvm::Module; using Positions = std::unordered_map<Value const*, Position>; using FunctionPositions = std::unordered_map<String, Position>; using InstructionLocationTablePtr = std::shared_ptr<InstructionLocationTable>; static InstructionLocationTablePtr create(); // Debug table interface // Position getPosition(Value const* value) const; Position getPositionFromFunctionName(String const& name) const; void registerModule(StringRef const& filename, Module const* module); protected: // AssemblyAnnotationWriter interface implementations // void printInfoComment(Value const& value, llvm::formatted_raw_ostream& outstream) override; void emitBasicBlockStartAnnot(BasicBlock const* block, llvm::formatted_raw_ostream& outstream) override; void emitFunctionAnnot(Function const* function, llvm::formatted_raw_ostream& outstream) override; private: Positions positions_; FunctionPositions function_positions_; StringRef current_filename_{}; InstructionLocationTable() = default; void registerValuePosition(Value const* value, llvm::formatted_raw_ostream& outstream); }; using InstructionLocationTablePtr = InstructionLocationTable::InstructionLocationTablePtr; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_int_to_ptr_8cpp/","text":"Rules/Notation/IntToPtr.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr intToPtr(IOperandPrototypePtr const& arg) { auto cast_pattern = std::make_shared<IntToPtrPattern>(); cast_pattern->addChild(arg); return static_cast<IOperandPrototypePtr>(cast_pattern); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Notation/IntToPtr.cpp"},{"location":"Api/Files/_int_to_ptr_8cpp/#rulesnotationinttoptrcpp","text":"","title":"Rules/Notation/IntToPtr.cpp"},{"location":"Api/Files/_int_to_ptr_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_int_to_ptr_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr intToPtr(IOperandPrototypePtr const& arg) { auto cast_pattern = std::make_shared<IntToPtrPattern>(); cast_pattern->addChild(arg); return static_cast<IOperandPrototypePtr>(cast_pattern); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_ir_manipulation_test_helper_8cpp/","text":"TestTools/IrManipulationTestHelper.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/TestTools/IrManipulationTestHelper.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Utils/FunctionToModule.hpp\" #include \"qir/qat/Utils/Trim.hpp\" namespace microsoft::quantum { bool IrManipulationTestHelper::fromString(String const& data) { context_ = std::make_unique<llvm::LLVMContext>(); module_ = llvm::parseIR(llvm::MemoryBufferRef(data, \"IrManipulationTestHelper\"), error_, *context_.get()); compilation_failed_ = (module_ == nullptr); return !compilation_failed_; } String IrManipulationTestHelper::toString() const { String str; llvm::raw_string_ostream ostream(str); ostream << *module_; ostream.flush(); return str; } TestProgram IrManipulationTestHelper::toProgram() { TestProgram ret{std::move(module_), std::move(context_)}; return ret; } IrManipulationTestHelper::Strings IrManipulationTestHelper::toBodyInstructions(String const& block_name) { if (isModuleBroken()) { return {}; } String data = toString(); Strings ret; auto pos = data.find(\"define i8 @Main() local_unnamed_addr\"); if (pos == String::npos) { return {}; } // Skipping entry if (block_name.empty()) { pos = data.find(\"entry:\", pos); } else { pos = data.find(block_name + \":\", pos); } if (pos == String::npos) { return {}; } auto last_pos = data.find('\\n', pos); assert(last_pos != String::npos); auto next_pos = data.find('\\n', last_pos + 1); auto terminator = data.find('}', pos); while ((next_pos != String::npos) && (next_pos < terminator)) { auto val = data.substr(last_pos, next_pos - last_pos); // Removing comments auto comment_p = val.find(';'); if (comment_p != String::npos) { val = val.substr(0, comment_p); } trim(val); if (val != \"\") { // Breaking at the next block if we are only extracting a specified block if (!block_name.empty() && val[val.size() - 1] == ':') { break; } ret.emplace_back(std::move(val)); } last_pos = next_pos; next_pos = data.find('\\n', last_pos + 1); } return ret; } bool IrManipulationTestHelper::hasInstructionSequence(Strings const& instructions, String const& block_name) { auto body_instructions = toBodyInstructions(block_name); uint64_t i = 0; uint64_t j = 0; while (i < instructions.size() && j < body_instructions.size()) { auto& a = instructions[i]; auto& b = body_instructions[j]; if (a == b) { ++i; } ++j; } if (i < instructions.size()) { return false; } return true; } void IrManipulationTestHelper::applyQirAdaptor( GeneratorPtr const& generator, OptimizationLevel const& optimization_level, bool debug) { auto adaptor = generator->newQirAdaptor(\"generic\", optimization_level, debug); adaptor->apply(*module_); // Verifying that the module is valid if (isModuleBroken()) { throw std::runtime_error(\"Module was broken after applying result\"); } } bool IrManipulationTestHelper::validateQirAdaptor(GeneratorPtr const& generator, String const& target_name, bool debug) { auto adaptor = generator->newQirAdaptor(target_name, OptimizationLevel::O0, debug); return adaptor->validate(*module_); } bool IrManipulationTestHelper::containsValidationErrors( GeneratorPtr const& generator, String const& target_name, Strings const& errors, bool debug) const { auto adaptor = generator->newQirAdaptor(target_name, OptimizationLevel::O0, debug); auto& configuration_manager = generator->configurationManager(); auto logger = std::make_shared<LogCollection>(); auto validator = std::make_unique<Validator>( configuration_manager.get<TargetProfileConfiguration>(), configuration_manager.get<TargetQisConfiguration>(), logger, debug); validator->validate(*module_); if (!logger) { throw std::runtime_error(\"Logger not present. Cannot test the presence of errors without a logger.\"); } std::unordered_set<String> hints; for (auto& message : logger->messages()) { hints.insert(message.location.llvmHint()); } auto ret = true; for (auto const& error : errors) { if (hints.find(error) == hints.end()) { ret = false; if (debug) { llvm::errs() << \"Missing '\" << error << \"' in LLVM output.\\n\"; } } } if (!ret && debug) { llvm::errs() << \"\\nExpected errors: \\n\"; for (auto const& error : errors) { llvm::errs() << error << \"\\n\"; } llvm::errs() << \"\\nActual errors: \\n\"; for (auto const& message : logger->messages()) { llvm::errs() << message.location.llvmHint() << \"\\n\"; llvm::errs() << \" - \" << message.message << \"\\n\"; } llvm::errs() << \"\\n\"; } return ret; } bool IrManipulationTestHelper::containsExactValidationErrors( GeneratorPtr const& generator, String const& target_name, Strings const& errors, bool debug) const { auto adaptor = generator->newQirAdaptor(target_name, OptimizationLevel::O0, debug); auto& configuration_manager = generator->configurationManager(); auto logger = std::make_shared<LogCollection>(); auto validator = std::make_unique<Validator>( configuration_manager.get<TargetProfileConfiguration>(), configuration_manager.get<TargetQisConfiguration>(), logger, debug); validator->validate(*module_); if (!logger) { throw std::runtime_error(\"Logger not present. Cannot test the presence of errors without a logger.\"); } auto ret = true; std::unordered_set<String> hints; std::unordered_set<String> error_set{errors.begin(), errors.end()}; for (auto const& message : logger->messages()) { hints.insert(message.location.llvmHint()); if (error_set.find(message.location.llvmHint()) == error_set.end()) { ret = false; if (debug) { llvm::errs() << \"Missing '\" << message.location.llvmHint() << \"' in expected errors.\\n\"; } } } for (auto const& error : errors) { if (hints.find(error) == hints.end()) { ret = false; if (debug) { llvm::errs() << \"Missing '\" << error << \"' in LLVM output.\\n\"; } } } if (!ret && debug) { llvm::errs() << \"\\nExpected errors: \\n\"; for (auto const& error : errors) { llvm::errs() << error << \"\\n\"; } llvm::errs() << \"\\nActual errors: \\n\"; for (auto const& message : logger->messages()) { llvm::errs() << message.location.llvmHint() << \"\\n\"; llvm::errs() << \" - \" << message.message << \"\\n\"; } llvm::errs() << \"\\n\"; } return ret; } void IrManipulationTestHelper::declareOpaque(String const& name) { opaque_declarations_.insert(name); } void IrManipulationTestHelper::declareFunction(String const& declaration) { function_declarations_.insert(declaration); } String IrManipulationTestHelper::generateScript(String const& body, String const& args) const { String script = R\"script( ; ModuleID = 'IrManipulationTestHelper' source_filename = \"IrManipulationTestHelper.ll\" )script\"; // Adding opaque types for (auto const& op : opaque_declarations_) { script += \"%\" + op + \" = type opaque\\n\"; } script += \"define i8 @Main(\" + args + \") local_unnamed_addr #0 {\\nentry:\\n\"; script += body; script += \"\\n ret i8 0\\n\"; script += \"\\n}\\n\\n\"; for (auto const& op : function_declarations_) { script += \"declare \" + op + \"\\n\"; } script += \"\\nattributes #0 = { \\\"EntryPoint\\\" }\\n\"; return script; } String IrManipulationTestHelper::getErrorMessage() const { String str; llvm::raw_string_ostream ostream(str); switch (error_.getKind()) { case llvm::SourceMgr::DiagKind::DK_Error: ostream << \"Error at \"; break; case llvm::SourceMgr::DiagKind::DK_Warning: ostream << \"Warning at \"; break; case llvm::SourceMgr::DiagKind::DK_Remark: ostream << \"Remark at \"; break; case llvm::SourceMgr::DiagKind::DK_Note: ostream << \"Note at \"; break; } ostream << error_.getLineNo() << \":\" << error_.getColumnNo() << \": \"; ostream << error_.getMessage() << \"\\n\\n\"; ostream << error_.getLineContents(); ostream.flush(); return str; } bool IrManipulationTestHelper::fromBodyString(String const& body, String const& args) { auto script = generateScript(body, args); return fromString(script); } IrManipulationTestHelper::ModulePtr& IrManipulationTestHelper::module() { return module_; } bool IrManipulationTestHelper::isModuleBroken() { if (compilation_failed_) { return compilation_failed_; } llvm::LoopAnalysisManager loop_analysis_manager; llvm::FunctionAnalysisManager function_analysis_manager; llvm::CGSCCAnalysisManager gscc_analysis_manager; llvm::ModuleAnalysisManager module_analysis_manager; auto pass_builder = std::make_unique<llvm::PassBuilder>(); pass_builder->registerModuleAnalyses(module_analysis_manager); pass_builder->registerCGSCCAnalyses(gscc_analysis_manager); pass_builder->registerFunctionAnalyses(function_analysis_manager); pass_builder->registerLoopAnalyses(loop_analysis_manager); pass_builder->crossRegisterProxies( loop_analysis_manager, function_analysis_manager, gscc_analysis_manager, module_analysis_manager); llvm::VerifierAnalysis verifier; auto result = verifier.run(*module_, module_analysis_manager); return result.IRBroken; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"TestTools/IrManipulationTestHelper.cpp"},{"location":"Api/Files/_ir_manipulation_test_helper_8cpp/#testtoolsirmanipulationtesthelpercpp","text":"","title":"TestTools/IrManipulationTestHelper.cpp"},{"location":"Api/Files/_ir_manipulation_test_helper_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_ir_manipulation_test_helper_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/TestTools/IrManipulationTestHelper.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Utils/FunctionToModule.hpp\" #include \"qir/qat/Utils/Trim.hpp\" namespace microsoft::quantum { bool IrManipulationTestHelper::fromString(String const& data) { context_ = std::make_unique<llvm::LLVMContext>(); module_ = llvm::parseIR(llvm::MemoryBufferRef(data, \"IrManipulationTestHelper\"), error_, *context_.get()); compilation_failed_ = (module_ == nullptr); return !compilation_failed_; } String IrManipulationTestHelper::toString() const { String str; llvm::raw_string_ostream ostream(str); ostream << *module_; ostream.flush(); return str; } TestProgram IrManipulationTestHelper::toProgram() { TestProgram ret{std::move(module_), std::move(context_)}; return ret; } IrManipulationTestHelper::Strings IrManipulationTestHelper::toBodyInstructions(String const& block_name) { if (isModuleBroken()) { return {}; } String data = toString(); Strings ret; auto pos = data.find(\"define i8 @Main() local_unnamed_addr\"); if (pos == String::npos) { return {}; } // Skipping entry if (block_name.empty()) { pos = data.find(\"entry:\", pos); } else { pos = data.find(block_name + \":\", pos); } if (pos == String::npos) { return {}; } auto last_pos = data.find('\\n', pos); assert(last_pos != String::npos); auto next_pos = data.find('\\n', last_pos + 1); auto terminator = data.find('}', pos); while ((next_pos != String::npos) && (next_pos < terminator)) { auto val = data.substr(last_pos, next_pos - last_pos); // Removing comments auto comment_p = val.find(';'); if (comment_p != String::npos) { val = val.substr(0, comment_p); } trim(val); if (val != \"\") { // Breaking at the next block if we are only extracting a specified block if (!block_name.empty() && val[val.size() - 1] == ':') { break; } ret.emplace_back(std::move(val)); } last_pos = next_pos; next_pos = data.find('\\n', last_pos + 1); } return ret; } bool IrManipulationTestHelper::hasInstructionSequence(Strings const& instructions, String const& block_name) { auto body_instructions = toBodyInstructions(block_name); uint64_t i = 0; uint64_t j = 0; while (i < instructions.size() && j < body_instructions.size()) { auto& a = instructions[i]; auto& b = body_instructions[j]; if (a == b) { ++i; } ++j; } if (i < instructions.size()) { return false; } return true; } void IrManipulationTestHelper::applyQirAdaptor( GeneratorPtr const& generator, OptimizationLevel const& optimization_level, bool debug) { auto adaptor = generator->newQirAdaptor(\"generic\", optimization_level, debug); adaptor->apply(*module_); // Verifying that the module is valid if (isModuleBroken()) { throw std::runtime_error(\"Module was broken after applying result\"); } } bool IrManipulationTestHelper::validateQirAdaptor(GeneratorPtr const& generator, String const& target_name, bool debug) { auto adaptor = generator->newQirAdaptor(target_name, OptimizationLevel::O0, debug); return adaptor->validate(*module_); } bool IrManipulationTestHelper::containsValidationErrors( GeneratorPtr const& generator, String const& target_name, Strings const& errors, bool debug) const { auto adaptor = generator->newQirAdaptor(target_name, OptimizationLevel::O0, debug); auto& configuration_manager = generator->configurationManager(); auto logger = std::make_shared<LogCollection>(); auto validator = std::make_unique<Validator>( configuration_manager.get<TargetProfileConfiguration>(), configuration_manager.get<TargetQisConfiguration>(), logger, debug); validator->validate(*module_); if (!logger) { throw std::runtime_error(\"Logger not present. Cannot test the presence of errors without a logger.\"); } std::unordered_set<String> hints; for (auto& message : logger->messages()) { hints.insert(message.location.llvmHint()); } auto ret = true; for (auto const& error : errors) { if (hints.find(error) == hints.end()) { ret = false; if (debug) { llvm::errs() << \"Missing '\" << error << \"' in LLVM output.\\n\"; } } } if (!ret && debug) { llvm::errs() << \"\\nExpected errors: \\n\"; for (auto const& error : errors) { llvm::errs() << error << \"\\n\"; } llvm::errs() << \"\\nActual errors: \\n\"; for (auto const& message : logger->messages()) { llvm::errs() << message.location.llvmHint() << \"\\n\"; llvm::errs() << \" - \" << message.message << \"\\n\"; } llvm::errs() << \"\\n\"; } return ret; } bool IrManipulationTestHelper::containsExactValidationErrors( GeneratorPtr const& generator, String const& target_name, Strings const& errors, bool debug) const { auto adaptor = generator->newQirAdaptor(target_name, OptimizationLevel::O0, debug); auto& configuration_manager = generator->configurationManager(); auto logger = std::make_shared<LogCollection>(); auto validator = std::make_unique<Validator>( configuration_manager.get<TargetProfileConfiguration>(), configuration_manager.get<TargetQisConfiguration>(), logger, debug); validator->validate(*module_); if (!logger) { throw std::runtime_error(\"Logger not present. Cannot test the presence of errors without a logger.\"); } auto ret = true; std::unordered_set<String> hints; std::unordered_set<String> error_set{errors.begin(), errors.end()}; for (auto const& message : logger->messages()) { hints.insert(message.location.llvmHint()); if (error_set.find(message.location.llvmHint()) == error_set.end()) { ret = false; if (debug) { llvm::errs() << \"Missing '\" << message.location.llvmHint() << \"' in expected errors.\\n\"; } } } for (auto const& error : errors) { if (hints.find(error) == hints.end()) { ret = false; if (debug) { llvm::errs() << \"Missing '\" << error << \"' in LLVM output.\\n\"; } } } if (!ret && debug) { llvm::errs() << \"\\nExpected errors: \\n\"; for (auto const& error : errors) { llvm::errs() << error << \"\\n\"; } llvm::errs() << \"\\nActual errors: \\n\"; for (auto const& message : logger->messages()) { llvm::errs() << message.location.llvmHint() << \"\\n\"; llvm::errs() << \" - \" << message.message << \"\\n\"; } llvm::errs() << \"\\n\"; } return ret; } void IrManipulationTestHelper::declareOpaque(String const& name) { opaque_declarations_.insert(name); } void IrManipulationTestHelper::declareFunction(String const& declaration) { function_declarations_.insert(declaration); } String IrManipulationTestHelper::generateScript(String const& body, String const& args) const { String script = R\"script( ; ModuleID = 'IrManipulationTestHelper' source_filename = \"IrManipulationTestHelper.ll\" )script\"; // Adding opaque types for (auto const& op : opaque_declarations_) { script += \"%\" + op + \" = type opaque\\n\"; } script += \"define i8 @Main(\" + args + \") local_unnamed_addr #0 {\\nentry:\\n\"; script += body; script += \"\\n ret i8 0\\n\"; script += \"\\n}\\n\\n\"; for (auto const& op : function_declarations_) { script += \"declare \" + op + \"\\n\"; } script += \"\\nattributes #0 = { \\\"EntryPoint\\\" }\\n\"; return script; } String IrManipulationTestHelper::getErrorMessage() const { String str; llvm::raw_string_ostream ostream(str); switch (error_.getKind()) { case llvm::SourceMgr::DiagKind::DK_Error: ostream << \"Error at \"; break; case llvm::SourceMgr::DiagKind::DK_Warning: ostream << \"Warning at \"; break; case llvm::SourceMgr::DiagKind::DK_Remark: ostream << \"Remark at \"; break; case llvm::SourceMgr::DiagKind::DK_Note: ostream << \"Note at \"; break; } ostream << error_.getLineNo() << \":\" << error_.getColumnNo() << \": \"; ostream << error_.getMessage() << \"\\n\\n\"; ostream << error_.getLineContents(); ostream.flush(); return str; } bool IrManipulationTestHelper::fromBodyString(String const& body, String const& args) { auto script = generateScript(body, args); return fromString(script); } IrManipulationTestHelper::ModulePtr& IrManipulationTestHelper::module() { return module_; } bool IrManipulationTestHelper::isModuleBroken() { if (compilation_failed_) { return compilation_failed_; } llvm::LoopAnalysisManager loop_analysis_manager; llvm::FunctionAnalysisManager function_analysis_manager; llvm::CGSCCAnalysisManager gscc_analysis_manager; llvm::ModuleAnalysisManager module_analysis_manager; auto pass_builder = std::make_unique<llvm::PassBuilder>(); pass_builder->registerModuleAnalyses(module_analysis_manager); pass_builder->registerCGSCCAnalyses(gscc_analysis_manager); pass_builder->registerFunctionAnalyses(function_analysis_manager); pass_builder->registerLoopAnalyses(loop_analysis_manager); pass_builder->crossRegisterProxies( loop_analysis_manager, function_analysis_manager, gscc_analysis_manager, module_analysis_manager); llvm::VerifierAnalysis verifier; auto result = verifier.run(*module_, module_analysis_manager); return result.IRBroken; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_ir_manipulation_test_helper_8hpp/","text":"TestTools/IrManipulationTestHelper.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::IrManipulationTestHelper Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AdaptorFactory/QirAdaptorFactory.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/TestTools/TestVm.hpp\" #include <unordered_set> #include <vector> namespace microsoft::quantum { class IrManipulationTestHelper { public: using String = std::string; using Strings = std::vector<String>; using LLVMContext = llvm::LLVMContext; using SMDiagnostic = llvm::SMDiagnostic; using Module = llvm::Module; using ContextPtr = std::unique_ptr<LLVMContext>; using ModulePtr = std::unique_ptr<Module>; using OptimizationLevel = llvm::OptimizationLevel; using GeneratorPtr = std::shared_ptr<QirAdaptorFactory>; // IrManipulationTestHelper is default constructible with no ability to move // or copy. // IrManipulationTestHelper() = default; IrManipulationTestHelper(IrManipulationTestHelper const&) = delete; IrManipulationTestHelper& operator=(IrManipulationTestHelper const&) = delete; IrManipulationTestHelper(IrManipulationTestHelper&&) = delete; IrManipulationTestHelper& operator=(IrManipulationTestHelper&&) = delete; // Output functions // String toString() const; Strings toBodyInstructions(String const& block_name = \"\"); TestProgram toProgram(); // Test functions // bool hasInstructionSequence(Strings const& instructions, String const& block_name = \"\"); void applyQirAdaptor( GeneratorPtr const& generator, OptimizationLevel const& optimization_level = OptimizationLevel::O0, bool debug = false); bool validateQirAdaptor(GeneratorPtr const& generator, String const& target_name = \"generic\", bool debug = false); bool containsValidationErrors( GeneratorPtr const& generator, String const& target_name, Strings const& errors, bool debug = false) const; bool containsExactValidationErrors( GeneratorPtr const& generator, String const& target_name, Strings const& errors, bool debug = false) const; // Declaration of partial or full IR // void declareOpaque(String const& name); void declareFunction(String const& declaration); bool fromBodyString(String const& body, String const& args = \"\"); String generateScript(String const& body, String const& args = \"\") const; bool fromString(String const& data); String getErrorMessage() const; bool isModuleBroken(); // Acccess member functions // ModulePtr& module(); private: // Declarations // std::unordered_set<std::string> opaque_declarations_{}; std::unordered_set<std::string> function_declarations_{}; // Compilation state // bool compilation_failed_{false}; ContextPtr context_; ModulePtr module_; SMDiagnostic error_; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"TestTools/IrManipulationTestHelper.hpp"},{"location":"Api/Files/_ir_manipulation_test_helper_8hpp/#testtoolsirmanipulationtesthelperhpp","text":"","title":"TestTools/IrManipulationTestHelper.hpp"},{"location":"Api/Files/_ir_manipulation_test_helper_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_ir_manipulation_test_helper_8hpp/#classes","text":"Name class microsoft::quantum::IrManipulationTestHelper","title":"Classes"},{"location":"Api/Files/_ir_manipulation_test_helper_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AdaptorFactory/QirAdaptorFactory.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/TestTools/TestVm.hpp\" #include <unordered_set> #include <vector> namespace microsoft::quantum { class IrManipulationTestHelper { public: using String = std::string; using Strings = std::vector<String>; using LLVMContext = llvm::LLVMContext; using SMDiagnostic = llvm::SMDiagnostic; using Module = llvm::Module; using ContextPtr = std::unique_ptr<LLVMContext>; using ModulePtr = std::unique_ptr<Module>; using OptimizationLevel = llvm::OptimizationLevel; using GeneratorPtr = std::shared_ptr<QirAdaptorFactory>; // IrManipulationTestHelper is default constructible with no ability to move // or copy. // IrManipulationTestHelper() = default; IrManipulationTestHelper(IrManipulationTestHelper const&) = delete; IrManipulationTestHelper& operator=(IrManipulationTestHelper const&) = delete; IrManipulationTestHelper(IrManipulationTestHelper&&) = delete; IrManipulationTestHelper& operator=(IrManipulationTestHelper&&) = delete; // Output functions // String toString() const; Strings toBodyInstructions(String const& block_name = \"\"); TestProgram toProgram(); // Test functions // bool hasInstructionSequence(Strings const& instructions, String const& block_name = \"\"); void applyQirAdaptor( GeneratorPtr const& generator, OptimizationLevel const& optimization_level = OptimizationLevel::O0, bool debug = false); bool validateQirAdaptor(GeneratorPtr const& generator, String const& target_name = \"generic\", bool debug = false); bool containsValidationErrors( GeneratorPtr const& generator, String const& target_name, Strings const& errors, bool debug = false) const; bool containsExactValidationErrors( GeneratorPtr const& generator, String const& target_name, Strings const& errors, bool debug = false) const; // Declaration of partial or full IR // void declareOpaque(String const& name); void declareFunction(String const& declaration); bool fromBodyString(String const& body, String const& args = \"\"); String generateScript(String const& body, String const& args = \"\") const; bool fromString(String const& data); String getErrorMessage() const; bool isModuleBroken(); // Acccess member functions // ModulePtr& module(); private: // Declarations // std::unordered_set<std::string> opaque_declarations_{}; std::unordered_set<std::string> function_declarations_{}; // Compilation state // bool compilation_failed_{false}; ContextPtr context_; ModulePtr module_; SMDiagnostic error_; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_llvm_passes_configuration_8cpp/","text":"AdaptorFactory/LlvmPassesConfiguration.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AdaptorFactory/LlvmPassesConfiguration.hpp\" #include \"qir/qat/Commandline/ConfigurationManager.hpp\" namespace microsoft::quantum { void LlvmPassesConfiguration::setup(ConfigurationManager& config) { config.setSectionName(\"LLVM optimizations\", \"Enables specific LLVM optimizations before and after transformation.\"); // LLVM transformations config.addParameter(unroll_loops_, \"unroll-loops\", \"Aggressively unroll loops.\"); config.addParameter( unroll_allow_partial_, \"allow-partial\", \"Enables or disables partial unrolling. When disabled only full unrolling is allowed.\"); config.addParameter(unroll_allow_peeling_, \"allow-peeling\", \"Enables or disables loop peeling.\"); config.addParameter( unroll_allow_runtime_, \"allow-runtime\", \"Enables or disables unrolling of loops with runtime trip count.\"); config.addParameter( unroll_allow_upper_bound_, \"allow-upper-bound\", \"Enables or disables the use of trip count upper bound in loop unrolling.\"); config.addParameter( unroll_allow_profile_based_peeling_, \"allow-profile-based-peeling\", \"Enables or disables loop peeling basing on profile.\"); config.addParameter(unroll_full_unroll_count_, \"full-unroll-count\", \"Sets the max full unroll count.\"); config.addParameter(unroll_opt_level_, \"unroll-opt-level\", \"Sets the optimization level for loop unrolling.\"); config.addParameter( unroll_only_when_forced_, \"only-when-forced\", \"If true, only loops that explicitly request unrolling via metadata are considered.\"); config.addParameter( unroll_forget_scev_, \"forget-scev\", \"If true, forget all loops when unrolling. If false, forget top-most loop of \" \"the currently processed loops.\"); config.addParameter(always_inline_, \"always-inline\", \"Aggressively inline function calls.\"); config.addParameter(inline_parameter_, \"inlining-parameter\", \"Number of code lines acceptable when inlining.\"); config.addParameter(eliminate_constants_, \"eliminate-constants\", \"Uses LLVM pass to eliminate constants.\"); config.addParameter(eliminate_dead_code_, \"eliminate-dead-code\", \"Uses LLVMs aggressive dead code elimination.\"); config.addParameter(eliminate_memory_, \"eliminate-memory\", \"Maps memory into registers where feasible.\"); } bool LlvmPassesConfiguration::alwaysInline() const { return always_inline_; } bool LlvmPassesConfiguration::unrollLoops() const { return unroll_loops_; } int32_t LlvmPassesConfiguration::inlineParameter() const { return inline_parameter_; } bool LlvmPassesConfiguration::unrollAllowPartial() const { return unroll_allow_partial_; } bool LlvmPassesConfiguration::unrollAllowPeeling() const { return unroll_allow_peeling_; } bool LlvmPassesConfiguration::unrollAllowRuntime() const { return unroll_allow_runtime_; } bool LlvmPassesConfiguration::unrollAllowUpperBound() const { return unroll_allow_upper_bound_; } bool LlvmPassesConfiguration::unrollAllowProfilBasedPeeling() const { return unroll_allow_profile_based_peeling_; } uint64_t LlvmPassesConfiguration::unrolFullUnrollCount() const { return unroll_full_unroll_count_; } int32_t LlvmPassesConfiguration::unrollOptLevel() const { return unroll_opt_level_; } bool LlvmPassesConfiguration::unrollOnlyWhenForced() const { return unroll_only_when_forced_; } bool LlvmPassesConfiguration::unrollForgeScev() const { return unroll_forget_scev_; } bool LlvmPassesConfiguration::eliminateConstants() const { return eliminate_constants_; } bool LlvmPassesConfiguration::eliminateDeadCode() const { return eliminate_dead_code_; } bool LlvmPassesConfiguration::eliminateMemory() const { return eliminate_memory_; } LlvmPassesConfiguration LlvmPassesConfiguration::createDisabled() { LlvmPassesConfiguration ret; ret.always_inline_ = false; ret.inline_parameter_ = 0; ret.unroll_loops_ = false; ret.unroll_allow_partial_ = false; ret.unroll_allow_peeling_ = false; ret.unroll_allow_runtime_ = false; ret.unroll_allow_upper_bound_ = false; ret.unroll_allow_profile_based_peeling_ = false; ret.unroll_full_unroll_count_ = 0; ret.unroll_opt_level_ = 0; ret.unroll_only_when_forced_ = false; ret.unroll_forget_scev_ = false; ret.eliminate_constants_ = false; ret.eliminate_dead_code_ = false; ret.eliminate_memory_ = false; return ret; } LlvmPassesConfiguration LlvmPassesConfiguration::createUnrollInline() { LlvmPassesConfiguration ret; ret.always_inline_ = true; ret.inline_parameter_ = std::numeric_limits<int32_t>::max(); ret.unroll_loops_ = true; ret.unroll_allow_partial_ = true; ret.unroll_allow_peeling_ = true; ret.unroll_allow_runtime_ = true; ret.unroll_allow_upper_bound_ = true; ret.unroll_allow_profile_based_peeling_ = true; ret.unroll_full_unroll_count_ = 1024; ret.unroll_opt_level_ = 3; ret.unroll_only_when_forced_ = false; ret.unroll_forget_scev_ = false; ret.eliminate_constants_ = true; ret.eliminate_dead_code_ = true; ret.eliminate_memory_ = true; return ret; } bool LlvmPassesConfiguration::isDisabled() const { return always_inline_ == false && inline_parameter_ == 0 && unroll_loops_ == false && unroll_allow_partial_ == false && unroll_allow_peeling_ == false && unroll_allow_runtime_ == false && unroll_allow_upper_bound_ == false && unroll_allow_profile_based_peeling_ == false && unroll_full_unroll_count_ == 0 && unroll_opt_level_ == 0 && unroll_only_when_forced_ == false && unroll_forget_scev_ == false && eliminate_constants_ == false && eliminate_dead_code_ == false && eliminate_memory_ == false; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"AdaptorFactory/LlvmPassesConfiguration.cpp"},{"location":"Api/Files/_llvm_passes_configuration_8cpp/#adaptorfactoryllvmpassesconfigurationcpp","text":"","title":"AdaptorFactory/LlvmPassesConfiguration.cpp"},{"location":"Api/Files/_llvm_passes_configuration_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_llvm_passes_configuration_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AdaptorFactory/LlvmPassesConfiguration.hpp\" #include \"qir/qat/Commandline/ConfigurationManager.hpp\" namespace microsoft::quantum { void LlvmPassesConfiguration::setup(ConfigurationManager& config) { config.setSectionName(\"LLVM optimizations\", \"Enables specific LLVM optimizations before and after transformation.\"); // LLVM transformations config.addParameter(unroll_loops_, \"unroll-loops\", \"Aggressively unroll loops.\"); config.addParameter( unroll_allow_partial_, \"allow-partial\", \"Enables or disables partial unrolling. When disabled only full unrolling is allowed.\"); config.addParameter(unroll_allow_peeling_, \"allow-peeling\", \"Enables or disables loop peeling.\"); config.addParameter( unroll_allow_runtime_, \"allow-runtime\", \"Enables or disables unrolling of loops with runtime trip count.\"); config.addParameter( unroll_allow_upper_bound_, \"allow-upper-bound\", \"Enables or disables the use of trip count upper bound in loop unrolling.\"); config.addParameter( unroll_allow_profile_based_peeling_, \"allow-profile-based-peeling\", \"Enables or disables loop peeling basing on profile.\"); config.addParameter(unroll_full_unroll_count_, \"full-unroll-count\", \"Sets the max full unroll count.\"); config.addParameter(unroll_opt_level_, \"unroll-opt-level\", \"Sets the optimization level for loop unrolling.\"); config.addParameter( unroll_only_when_forced_, \"only-when-forced\", \"If true, only loops that explicitly request unrolling via metadata are considered.\"); config.addParameter( unroll_forget_scev_, \"forget-scev\", \"If true, forget all loops when unrolling. If false, forget top-most loop of \" \"the currently processed loops.\"); config.addParameter(always_inline_, \"always-inline\", \"Aggressively inline function calls.\"); config.addParameter(inline_parameter_, \"inlining-parameter\", \"Number of code lines acceptable when inlining.\"); config.addParameter(eliminate_constants_, \"eliminate-constants\", \"Uses LLVM pass to eliminate constants.\"); config.addParameter(eliminate_dead_code_, \"eliminate-dead-code\", \"Uses LLVMs aggressive dead code elimination.\"); config.addParameter(eliminate_memory_, \"eliminate-memory\", \"Maps memory into registers where feasible.\"); } bool LlvmPassesConfiguration::alwaysInline() const { return always_inline_; } bool LlvmPassesConfiguration::unrollLoops() const { return unroll_loops_; } int32_t LlvmPassesConfiguration::inlineParameter() const { return inline_parameter_; } bool LlvmPassesConfiguration::unrollAllowPartial() const { return unroll_allow_partial_; } bool LlvmPassesConfiguration::unrollAllowPeeling() const { return unroll_allow_peeling_; } bool LlvmPassesConfiguration::unrollAllowRuntime() const { return unroll_allow_runtime_; } bool LlvmPassesConfiguration::unrollAllowUpperBound() const { return unroll_allow_upper_bound_; } bool LlvmPassesConfiguration::unrollAllowProfilBasedPeeling() const { return unroll_allow_profile_based_peeling_; } uint64_t LlvmPassesConfiguration::unrolFullUnrollCount() const { return unroll_full_unroll_count_; } int32_t LlvmPassesConfiguration::unrollOptLevel() const { return unroll_opt_level_; } bool LlvmPassesConfiguration::unrollOnlyWhenForced() const { return unroll_only_when_forced_; } bool LlvmPassesConfiguration::unrollForgeScev() const { return unroll_forget_scev_; } bool LlvmPassesConfiguration::eliminateConstants() const { return eliminate_constants_; } bool LlvmPassesConfiguration::eliminateDeadCode() const { return eliminate_dead_code_; } bool LlvmPassesConfiguration::eliminateMemory() const { return eliminate_memory_; } LlvmPassesConfiguration LlvmPassesConfiguration::createDisabled() { LlvmPassesConfiguration ret; ret.always_inline_ = false; ret.inline_parameter_ = 0; ret.unroll_loops_ = false; ret.unroll_allow_partial_ = false; ret.unroll_allow_peeling_ = false; ret.unroll_allow_runtime_ = false; ret.unroll_allow_upper_bound_ = false; ret.unroll_allow_profile_based_peeling_ = false; ret.unroll_full_unroll_count_ = 0; ret.unroll_opt_level_ = 0; ret.unroll_only_when_forced_ = false; ret.unroll_forget_scev_ = false; ret.eliminate_constants_ = false; ret.eliminate_dead_code_ = false; ret.eliminate_memory_ = false; return ret; } LlvmPassesConfiguration LlvmPassesConfiguration::createUnrollInline() { LlvmPassesConfiguration ret; ret.always_inline_ = true; ret.inline_parameter_ = std::numeric_limits<int32_t>::max(); ret.unroll_loops_ = true; ret.unroll_allow_partial_ = true; ret.unroll_allow_peeling_ = true; ret.unroll_allow_runtime_ = true; ret.unroll_allow_upper_bound_ = true; ret.unroll_allow_profile_based_peeling_ = true; ret.unroll_full_unroll_count_ = 1024; ret.unroll_opt_level_ = 3; ret.unroll_only_when_forced_ = false; ret.unroll_forget_scev_ = false; ret.eliminate_constants_ = true; ret.eliminate_dead_code_ = true; ret.eliminate_memory_ = true; return ret; } bool LlvmPassesConfiguration::isDisabled() const { return always_inline_ == false && inline_parameter_ == 0 && unroll_loops_ == false && unroll_allow_partial_ == false && unroll_allow_peeling_ == false && unroll_allow_runtime_ == false && unroll_allow_upper_bound_ == false && unroll_allow_profile_based_peeling_ == false && unroll_full_unroll_count_ == 0 && unroll_opt_level_ == 0 && unroll_only_when_forced_ == false && unroll_forget_scev_ == false && eliminate_constants_ == false && eliminate_dead_code_ == false && eliminate_memory_ == false; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_llvm_passes_configuration_8hpp/","text":"AdaptorFactory/LlvmPassesConfiguration.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::LlvmPassesConfiguration Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include <limits> namespace microsoft::quantum { class LlvmPassesConfiguration { public: void setup(ConfigurationManager& config); bool alwaysInline() const; bool unrollLoops() const; int32_t inlineParameter() const; bool unrollAllowPartial() const; bool unrollAllowPeeling() const; bool unrollAllowRuntime() const; bool unrollAllowUpperBound() const; bool unrollAllowProfilBasedPeeling() const; uint64_t unrolFullUnrollCount() const; int32_t unrollOptLevel() const; bool unrollOnlyWhenForced() const; bool unrollForgeScev() const; bool eliminateConstants() const; bool eliminateDeadCode() const; bool eliminateMemory() const; // Configuration classification bool isDisabled() const; bool operator==(LlvmPassesConfiguration const& o) const { return always_inline_ == o.always_inline_ && inline_parameter_ == o.inline_parameter_ && unroll_loops_ == o.unroll_loops_ && unroll_allow_partial_ == o.unroll_allow_partial_ && unroll_allow_peeling_ == o.unroll_allow_peeling_ && unroll_allow_runtime_ == o.unroll_allow_runtime_ && unroll_allow_upper_bound_ == o.unroll_allow_upper_bound_ && unroll_allow_profile_based_peeling_ == o.unroll_allow_profile_based_peeling_ && unroll_full_unroll_count_ == o.unroll_full_unroll_count_ && unroll_opt_level_ == o.unroll_opt_level_ && unroll_only_when_forced_ == o.unroll_only_when_forced_ && unroll_forget_scev_ == o.unroll_forget_scev_ && eliminate_constants_ == o.eliminate_constants_ && eliminate_dead_code_ == o.eliminate_dead_code_ && eliminate_memory_ == o.eliminate_memory_; } static LlvmPassesConfiguration createDisabled(); static LlvmPassesConfiguration createUnrollInline(); private: bool always_inline_{false}; int32_t inline_parameter_{std::numeric_limits<int32_t>::max()}; bool unroll_loops_{false}; bool unroll_allow_partial_{true}; bool unroll_allow_peeling_{true}; bool unroll_allow_runtime_{true}; bool unroll_allow_upper_bound_{true}; bool unroll_allow_profile_based_peeling_{true}; uint64_t unroll_full_unroll_count_{1024}; int32_t unroll_opt_level_{3}; bool unroll_only_when_forced_{false}; bool unroll_forget_scev_{false}; bool eliminate_constants_{true}; bool eliminate_dead_code_{true}; bool eliminate_memory_{true}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"AdaptorFactory/LlvmPassesConfiguration.hpp"},{"location":"Api/Files/_llvm_passes_configuration_8hpp/#adaptorfactoryllvmpassesconfigurationhpp","text":"","title":"AdaptorFactory/LlvmPassesConfiguration.hpp"},{"location":"Api/Files/_llvm_passes_configuration_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_llvm_passes_configuration_8hpp/#classes","text":"Name class microsoft::quantum::LlvmPassesConfiguration","title":"Classes"},{"location":"Api/Files/_llvm_passes_configuration_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include <limits> namespace microsoft::quantum { class LlvmPassesConfiguration { public: void setup(ConfigurationManager& config); bool alwaysInline() const; bool unrollLoops() const; int32_t inlineParameter() const; bool unrollAllowPartial() const; bool unrollAllowPeeling() const; bool unrollAllowRuntime() const; bool unrollAllowUpperBound() const; bool unrollAllowProfilBasedPeeling() const; uint64_t unrolFullUnrollCount() const; int32_t unrollOptLevel() const; bool unrollOnlyWhenForced() const; bool unrollForgeScev() const; bool eliminateConstants() const; bool eliminateDeadCode() const; bool eliminateMemory() const; // Configuration classification bool isDisabled() const; bool operator==(LlvmPassesConfiguration const& o) const { return always_inline_ == o.always_inline_ && inline_parameter_ == o.inline_parameter_ && unroll_loops_ == o.unroll_loops_ && unroll_allow_partial_ == o.unroll_allow_partial_ && unroll_allow_peeling_ == o.unroll_allow_peeling_ && unroll_allow_runtime_ == o.unroll_allow_runtime_ && unroll_allow_upper_bound_ == o.unroll_allow_upper_bound_ && unroll_allow_profile_based_peeling_ == o.unroll_allow_profile_based_peeling_ && unroll_full_unroll_count_ == o.unroll_full_unroll_count_ && unroll_opt_level_ == o.unroll_opt_level_ && unroll_only_when_forced_ == o.unroll_only_when_forced_ && unroll_forget_scev_ == o.unroll_forget_scev_ && eliminate_constants_ == o.eliminate_constants_ && eliminate_dead_code_ == o.eliminate_dead_code_ && eliminate_memory_ == o.eliminate_memory_; } static LlvmPassesConfiguration createDisabled(); static LlvmPassesConfiguration createUnrollInline(); private: bool always_inline_{false}; int32_t inline_parameter_{std::numeric_limits<int32_t>::max()}; bool unroll_loops_{false}; bool unroll_allow_partial_{true}; bool unroll_allow_peeling_{true}; bool unroll_allow_runtime_{true}; bool unroll_allow_upper_bound_{true}; bool unroll_allow_profile_based_peeling_{true}; uint64_t unroll_full_unroll_count_{1024}; int32_t unroll_opt_level_{3}; bool unroll_only_when_forced_{false}; bool unroll_forget_scev_{false}; bool eliminate_constants_{true}; bool eliminate_dead_code_{true}; bool eliminate_memory_{true}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_load_8cpp/","text":"Rules/Notation/Load.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr load(IOperandPrototypePtr const& arg) { auto ret = std::make_shared<LoadPattern>(); ret->addChild(arg); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Notation/Load.cpp"},{"location":"Api/Files/_load_8cpp/#rulesnotationloadcpp","text":"","title":"Rules/Notation/Load.cpp"},{"location":"Api/Files/_load_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_load_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr load(IOperandPrototypePtr const& arg) { auto ret = std::make_shared<LoadPattern>(); ret->addChild(arg); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_log_collection_8cpp/","text":"Logging/LogCollection.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Logging/LogCollection.hpp\" #include \"qir/qat/Utils/Trim.hpp\" #include <fstream> #include <iostream> #include <vector> namespace microsoft::quantum { void LogCollection::debug(String const& message) { messages_.push_back({Type::Debug, current_location_, message}); } void LogCollection::info(String const& message) { messages_.push_back({Type::Info, current_location_, message}); } void LogCollection::warning(String const& message) { setHasWarnings(true); messages_.push_back({Type::Warning, current_location_, message}); } void LogCollection::error(String const& message) { setHasErrors(true); messages_.push_back({Type::Error, current_location_, message}); } void LogCollection::internalError(String const& message) { setHasErrors(true); messages_.push_back({Type::InternalError, current_location_, message}); } void LogCollection::setLocation(SourceLocation const& loc) { current_location_.setName(loc.name()); current_location_.setLine(loc.line()); current_location_.setColumn(loc.column()); } ILogger::Messages const& LogCollection::messages() const { return messages_; } void LogCollection::setLlvmHint(String const& value) { current_location_.setLlvmHint(value); trim(current_location_.llvmHint()); } void LogCollection::setFrontendHint(String const& value) { current_location_.setFrontendHint(value); trim(current_location_.frontendHint()); } void LogCollection::dump(std::ostream& out) const { bool not_first = false; out << \"[\"; for (auto& message : messages_) { if (not_first) { out << \",\"; } out << \"\\n\"; out << \" {\\n\"; switch (message.type) { case LogCollection::Type::Debug: out << \" \\\"type\\\": \\\"debug\\\",\\n\"; break; case LogCollection::Type::Info: out << \" \\\"type\\\": \\\"info\\\",\\n\"; break; case LogCollection::Type::Warning: out << \" \\\"type\\\": \\\"warning\\\",\\n\"; break; case LogCollection::Type::Error: out << \" \\\"type\\\": \\\"error\\\",\\n\"; break; case LogCollection::Type::InternalError: out << \" \\\"type\\\": \\\"internalError\\\",\\n\"; break; } out << \" \\\"message\\\": \\\"\" << message.message << \"\\\",\\n\"; out << \" \\\"location\\\": {\\n\"; out << \" \\\"filename\\\": \\\"\" << static_cast<std::string>(message.location.name()) << \"\\\",\\n\"; out << \" \\\"line\\\": \" << message.location.line() << \",\\n\"; out << \" \\\"column\\\": \" << message.location.column() << \",\\n\"; out << \" \\\"llvm_hint\\\": \\\"\" << message.location.llvmHint() << \"\\\",\\n\"; out << \" \\\"frontend_hint\\\": \\\"\" << message.location.frontendHint() << \"\\\"\\n\"; out << \" }\\n\"; out << \" }\"; not_first = true; } out << \"\\n]\\n\"; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Logging/LogCollection.cpp"},{"location":"Api/Files/_log_collection_8cpp/#logginglogcollectioncpp","text":"","title":"Logging/LogCollection.cpp"},{"location":"Api/Files/_log_collection_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_log_collection_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Logging/LogCollection.hpp\" #include \"qir/qat/Utils/Trim.hpp\" #include <fstream> #include <iostream> #include <vector> namespace microsoft::quantum { void LogCollection::debug(String const& message) { messages_.push_back({Type::Debug, current_location_, message}); } void LogCollection::info(String const& message) { messages_.push_back({Type::Info, current_location_, message}); } void LogCollection::warning(String const& message) { setHasWarnings(true); messages_.push_back({Type::Warning, current_location_, message}); } void LogCollection::error(String const& message) { setHasErrors(true); messages_.push_back({Type::Error, current_location_, message}); } void LogCollection::internalError(String const& message) { setHasErrors(true); messages_.push_back({Type::InternalError, current_location_, message}); } void LogCollection::setLocation(SourceLocation const& loc) { current_location_.setName(loc.name()); current_location_.setLine(loc.line()); current_location_.setColumn(loc.column()); } ILogger::Messages const& LogCollection::messages() const { return messages_; } void LogCollection::setLlvmHint(String const& value) { current_location_.setLlvmHint(value); trim(current_location_.llvmHint()); } void LogCollection::setFrontendHint(String const& value) { current_location_.setFrontendHint(value); trim(current_location_.frontendHint()); } void LogCollection::dump(std::ostream& out) const { bool not_first = false; out << \"[\"; for (auto& message : messages_) { if (not_first) { out << \",\"; } out << \"\\n\"; out << \" {\\n\"; switch (message.type) { case LogCollection::Type::Debug: out << \" \\\"type\\\": \\\"debug\\\",\\n\"; break; case LogCollection::Type::Info: out << \" \\\"type\\\": \\\"info\\\",\\n\"; break; case LogCollection::Type::Warning: out << \" \\\"type\\\": \\\"warning\\\",\\n\"; break; case LogCollection::Type::Error: out << \" \\\"type\\\": \\\"error\\\",\\n\"; break; case LogCollection::Type::InternalError: out << \" \\\"type\\\": \\\"internalError\\\",\\n\"; break; } out << \" \\\"message\\\": \\\"\" << message.message << \"\\\",\\n\"; out << \" \\\"location\\\": {\\n\"; out << \" \\\"filename\\\": \\\"\" << static_cast<std::string>(message.location.name()) << \"\\\",\\n\"; out << \" \\\"line\\\": \" << message.location.line() << \",\\n\"; out << \" \\\"column\\\": \" << message.location.column() << \",\\n\"; out << \" \\\"llvm_hint\\\": \\\"\" << message.location.llvmHint() << \"\\\",\\n\"; out << \" \\\"frontend_hint\\\": \\\"\" << message.location.frontendHint() << \"\\\"\\n\"; out << \" }\\n\"; out << \" }\"; not_first = true; } out << \"\\n]\\n\"; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_log_collection_8hpp/","text":"Logging/LogCollection.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::LogCollection Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Logging/SourceLocation.hpp\" #include <vector> namespace microsoft::quantum { class LogCollection : public ILogger { public: // Interface implementation // void debug(String const& message) override; void info(String const& message) override; void warning(String const& message) override; void error(String const& message) override; void internalError(String const& message) override; void setLocation(SourceLocation const& loc) override; void setLlvmHint(String const& value) override; void setFrontendHint(String const& value) override; Messages const& messages() const override; void dump(std::ostream& out) const override; private: Location current_location_{}; Messages messages_; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Logging/LogCollection.hpp"},{"location":"Api/Files/_log_collection_8hpp/#logginglogcollectionhpp","text":"","title":"Logging/LogCollection.hpp"},{"location":"Api/Files/_log_collection_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_log_collection_8hpp/#classes","text":"Name class microsoft::quantum::LogCollection","title":"Classes"},{"location":"Api/Files/_log_collection_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Logging/SourceLocation.hpp\" #include <vector> namespace microsoft::quantum { class LogCollection : public ILogger { public: // Interface implementation // void debug(String const& message) override; void info(String const& message) override; void warning(String const& message) override; void error(String const& message) override; void internalError(String const& message) override; void setLocation(SourceLocation const& loc) override; void setLlvmHint(String const& value) override; void setFrontendHint(String const& value) override; Messages const& messages() const override; void dump(std::ostream& out) const override; private: Location current_location_{}; Messages messages_; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_module_loader_8hpp/","text":"ModuleLoader/ModuleLoader.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ModuleLoader Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/ModuleLoader/DebugInfoUpdater.hpp\" #include \"qir/qat/ModuleLoader/InstructionLocationTable.hpp\" #include \"qir/qat/Passes/RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" namespace microsoft::quantum { class ModuleLoader { public: using Module = llvm::Module; using Linker = llvm::Linker; using SMDiagnostic = llvm::SMDiagnostic; explicit ModuleLoader( SpecConfiguration const& spec, Module* final_module, bool strip_existing_debug = false, bool add_ir_debug_info = false) : spec_{spec} , final_module_{final_module} , linker_{*final_module} , instruction_location_table_{InstructionLocationTable::create()} , strip_existing_debug_{strip_existing_debug} , add_ir_debug_info_{add_ir_debug_info} { } bool addModule(std::unique_ptr<Module>&& module, String const& filename = \"unknown\") { if (llvm::verifyModule(*module, &llvm::errs())) { llvm::errs() << filename << \": \" << \"input module is broken!\\n\"; return false; } return !linker_.linkInModule(std::move(module), Linker::Flags::None); } bool addIrFile(String input_file) { // Converting to absolute path llvm::SmallVector<char, 256> input_vec; input_vec.assign(input_file.begin(), input_file.end()); llvm::sys::fs::make_absolute(input_vec); input_file.resize(input_vec.size()); uint64_t i = 0; for (auto& s : input_vec) { input_file[i++] = s; } // Loading module SMDiagnostic err; std::unique_ptr<Module> module = llvm::parseIRFile(input_file, err, final_module_->getContext()); if (!module) { llvm::errs() << \"Failed to load \" << input_file << \"\\n\"; return false; } // Registering all debug info auto directory = llvm::sys::path::parent_path(input_file); auto filename = llvm::sys::path::filename(input_file); instruction_location_table_->registerModule(input_file, module.get()); if (strip_existing_debug_) { // Debug info llvm::StripDebugInfo(*module.get()); } // Whether or not to override debug symbols if (add_ir_debug_info_) { // Adding debug versioning auto debug_version_key = \"Debug Info Version\"; if (!module->getModuleFlag(debug_version_key)) { module->addModuleFlag(llvm::Module::Warning, debug_version_key, llvm::DEBUG_METADATA_VERSION); } // Update with debug information DebugInfoUpdater updater(instruction_location_table_, *module.get(), directory, filename); updater.update(); } // Transforming module SingleModuleTransformation transformation(spec_); if (!transformation.apply(module.get())) { llvm::errs() << \"Failed to prepare \" << input_file << \" using single module transformations.\\n\"; return false; } // Linking return addModule(std::move(module), input_file); } InstructionLocationTablePtr locationTable() const { return instruction_location_table_; } private: SpecConfiguration spec_{}; Module* final_module_; Linker linker_; InstructionLocationTablePtr instruction_location_table_{nullptr}; bool strip_existing_debug_{false}; bool add_ir_debug_info_{false}; // Single Module Transformation // class SingleModuleTransformation { public: using PassBuilder = llvm::PassBuilder; using OptimizationLevel = llvm::OptimizationLevel; using FunctionAnalysisManager = llvm::FunctionAnalysisManager; explicit SingleModuleTransformation( SpecConfiguration const& spec, OptimizationLevel const& optimization_level = OptimizationLevel::O0, bool debug = false) : optimization_level_{optimization_level} , debug_{debug} { pass_builder_.registerModuleAnalyses(module_analysis_manager_); pass_builder_.registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_.registerFunctionAnalyses(function_analysis_manager_); pass_builder_.registerLoopAnalyses(loop_analysis_manager_); pass_builder_.crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); module_pass_manager_.addPass(RemoveDisallowedAttributesPass(spec)); } bool apply(llvm::Module* module) { module_pass_manager_.run(*module, module_analysis_manager_); if (llvm::verifyModule(*module, &llvm::errs())) { return false; } return true; } bool isDebugMode() const { return debug_; } private: llvm::PassBuilder pass_builder_; llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; llvm::ModulePassManager module_pass_manager_{}; OptimizationLevel optimization_level_{}; bool debug_{false}; }; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"ModuleLoader/ModuleLoader.hpp"},{"location":"Api/Files/_module_loader_8hpp/#moduleloadermoduleloaderhpp","text":"","title":"ModuleLoader/ModuleLoader.hpp"},{"location":"Api/Files/_module_loader_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_module_loader_8hpp/#classes","text":"Name class microsoft::quantum::ModuleLoader","title":"Classes"},{"location":"Api/Files/_module_loader_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/ModuleLoader/DebugInfoUpdater.hpp\" #include \"qir/qat/ModuleLoader/InstructionLocationTable.hpp\" #include \"qir/qat/Passes/RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" namespace microsoft::quantum { class ModuleLoader { public: using Module = llvm::Module; using Linker = llvm::Linker; using SMDiagnostic = llvm::SMDiagnostic; explicit ModuleLoader( SpecConfiguration const& spec, Module* final_module, bool strip_existing_debug = false, bool add_ir_debug_info = false) : spec_{spec} , final_module_{final_module} , linker_{*final_module} , instruction_location_table_{InstructionLocationTable::create()} , strip_existing_debug_{strip_existing_debug} , add_ir_debug_info_{add_ir_debug_info} { } bool addModule(std::unique_ptr<Module>&& module, String const& filename = \"unknown\") { if (llvm::verifyModule(*module, &llvm::errs())) { llvm::errs() << filename << \": \" << \"input module is broken!\\n\"; return false; } return !linker_.linkInModule(std::move(module), Linker::Flags::None); } bool addIrFile(String input_file) { // Converting to absolute path llvm::SmallVector<char, 256> input_vec; input_vec.assign(input_file.begin(), input_file.end()); llvm::sys::fs::make_absolute(input_vec); input_file.resize(input_vec.size()); uint64_t i = 0; for (auto& s : input_vec) { input_file[i++] = s; } // Loading module SMDiagnostic err; std::unique_ptr<Module> module = llvm::parseIRFile(input_file, err, final_module_->getContext()); if (!module) { llvm::errs() << \"Failed to load \" << input_file << \"\\n\"; return false; } // Registering all debug info auto directory = llvm::sys::path::parent_path(input_file); auto filename = llvm::sys::path::filename(input_file); instruction_location_table_->registerModule(input_file, module.get()); if (strip_existing_debug_) { // Debug info llvm::StripDebugInfo(*module.get()); } // Whether or not to override debug symbols if (add_ir_debug_info_) { // Adding debug versioning auto debug_version_key = \"Debug Info Version\"; if (!module->getModuleFlag(debug_version_key)) { module->addModuleFlag(llvm::Module::Warning, debug_version_key, llvm::DEBUG_METADATA_VERSION); } // Update with debug information DebugInfoUpdater updater(instruction_location_table_, *module.get(), directory, filename); updater.update(); } // Transforming module SingleModuleTransformation transformation(spec_); if (!transformation.apply(module.get())) { llvm::errs() << \"Failed to prepare \" << input_file << \" using single module transformations.\\n\"; return false; } // Linking return addModule(std::move(module), input_file); } InstructionLocationTablePtr locationTable() const { return instruction_location_table_; } private: SpecConfiguration spec_{}; Module* final_module_; Linker linker_; InstructionLocationTablePtr instruction_location_table_{nullptr}; bool strip_existing_debug_{false}; bool add_ir_debug_info_{false}; // Single Module Transformation // class SingleModuleTransformation { public: using PassBuilder = llvm::PassBuilder; using OptimizationLevel = llvm::OptimizationLevel; using FunctionAnalysisManager = llvm::FunctionAnalysisManager; explicit SingleModuleTransformation( SpecConfiguration const& spec, OptimizationLevel const& optimization_level = OptimizationLevel::O0, bool debug = false) : optimization_level_{optimization_level} , debug_{debug} { pass_builder_.registerModuleAnalyses(module_analysis_manager_); pass_builder_.registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_.registerFunctionAnalyses(function_analysis_manager_); pass_builder_.registerLoopAnalyses(loop_analysis_manager_); pass_builder_.crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); module_pass_manager_.addPass(RemoveDisallowedAttributesPass(spec)); } bool apply(llvm::Module* module) { module_pass_manager_.run(*module, module_analysis_manager_); if (llvm::verifyModule(*module, &llvm::errs())) { return false; } return true; } bool isDebugMode() const { return debug_; } private: llvm::PassBuilder pass_builder_; llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; llvm::ModulePassManager module_pass_manager_{}; OptimizationLevel optimization_level_{}; bool debug_{false}; }; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_notation_8cpp/","text":"Rules/Notation/Notation.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { ReplacerFunction deleteInstruction() { return [](ReplacementRule::Builder&, ReplacementRule::Value* val, ReplacementRule::Captures&, ReplacementRule::Replacements& replacements) { auto type = val->getType(); auto instr = llvm::dyn_cast<llvm::Instruction>(val); if (instr == nullptr) { return false; } val->replaceAllUsesWith(llvm::UndefValue::get(type)); replacements.push_back({instr, nullptr}); return true; }; } ReplacerFunction deleteUnusedInstruction() { return [](ReplacementRule::Builder&, ReplacementRule::Value* val, ReplacementRule::Captures&, ReplacementRule::Replacements& replacements) { std::unordered_map<llvm::Value*, llvm::Value*> replace_set{replacements.begin(), replacements.end()}; auto instr = llvm::dyn_cast<llvm::Instruction>(val); if (instr) { bool is_used = false; for (auto u : instr->users()) { is_used |= replace_set.find(u) == replace_set.end(); } if (instr->use_empty() || !is_used) { replacements.push_back({instr, nullptr}); return true; } } return false; }; } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Notation/Notation.cpp"},{"location":"Api/Files/_notation_8cpp/#rulesnotationnotationcpp","text":"","title":"Rules/Notation/Notation.cpp"},{"location":"Api/Files/_notation_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_notation_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { ReplacerFunction deleteInstruction() { return [](ReplacementRule::Builder&, ReplacementRule::Value* val, ReplacementRule::Captures&, ReplacementRule::Replacements& replacements) { auto type = val->getType(); auto instr = llvm::dyn_cast<llvm::Instruction>(val); if (instr == nullptr) { return false; } val->replaceAllUsesWith(llvm::UndefValue::get(type)); replacements.push_back({instr, nullptr}); return true; }; } ReplacerFunction deleteUnusedInstruction() { return [](ReplacementRule::Builder&, ReplacementRule::Value* val, ReplacementRule::Captures&, ReplacementRule::Replacements& replacements) { std::unordered_map<llvm::Value*, llvm::Value*> replace_set{replacements.begin(), replacements.end()}; auto instr = llvm::dyn_cast<llvm::Instruction>(val); if (instr) { bool is_used = false; for (auto u : instr->users()) { is_used |= replace_set.find(u) == replace_set.end(); } if (instr->use_empty() || !is_used) { replacements.push_back({instr, nullptr}); return true; } } return false; }; } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_notation_8hpp/","text":"Rules/Notation/Notation.hpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Classes Name class microsoft::quantum::notation::Capture Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Call.hpp\" #include \"qir/qat/Rules/Notation/Call.ipp\" #include \"qir/qat/Rules/Notation/Phi.ipp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include \"qir/qat/Rules/Patterns/PhiPattern.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; using ReplacerFunction = std::function<bool( ReplacementRule::Builder&, ReplacementRule::Value*, ReplacementRule::Captures&, ReplacementRule::Replacements&)>; class Capture { public: explicit Capture(std::string const& name); // Note that this operator is delibrately unconventional IOperandPrototypePtr operator=(IOperandPrototypePtr const& other); // NOLINT private: std::string name_{}; }; template <typename... Args> IOperandPrototypePtr call(std::string const& name, Args... args); IOperandPrototypePtr unnamedInvoke(); template <typename... Args> IOperandPrototypePtr phi(Args... args); IOperandPrototypePtr callByNameOnly(std::string const& name); IOperandPrototypePtr bitCast(IOperandPrototypePtr const& arg); IOperandPrototypePtr intToPtr(IOperandPrototypePtr const& arg); IOperandPrototypePtr constInt(); IOperandPrototypePtr branch( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2); IOperandPrototypePtr switchOp( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2); IOperandPrototypePtr select( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2); IOperandPrototypePtr load(IOperandPrototypePtr const& arg); IOperandPrototypePtr zExt(IOperandPrototypePtr const& value); IOperandPrototypePtr store(IOperandPrototypePtr const& target, IOperandPrototypePtr const& value); IOperandPrototypePtr basicBlock(); static std::shared_ptr<AnyPattern> const _ = std::make_shared<AnyPattern>(); // NOLINT ReplacerFunction deleteInstruction(); ReplacerFunction deleteUnusedInstruction(); Capture operator\"\"_cap(char const* name, std::size_t); } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Notation/Notation.hpp"},{"location":"Api/Files/_notation_8hpp/#rulesnotationnotationhpp","text":"","title":"Rules/Notation/Notation.hpp"},{"location":"Api/Files/_notation_8hpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_notation_8hpp/#classes","text":"Name class microsoft::quantum::notation::Capture","title":"Classes"},{"location":"Api/Files/_notation_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Call.hpp\" #include \"qir/qat/Rules/Notation/Call.ipp\" #include \"qir/qat/Rules/Notation/Phi.ipp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include \"qir/qat/Rules/Patterns/PhiPattern.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; using ReplacerFunction = std::function<bool( ReplacementRule::Builder&, ReplacementRule::Value*, ReplacementRule::Captures&, ReplacementRule::Replacements&)>; class Capture { public: explicit Capture(std::string const& name); // Note that this operator is delibrately unconventional IOperandPrototypePtr operator=(IOperandPrototypePtr const& other); // NOLINT private: std::string name_{}; }; template <typename... Args> IOperandPrototypePtr call(std::string const& name, Args... args); IOperandPrototypePtr unnamedInvoke(); template <typename... Args> IOperandPrototypePtr phi(Args... args); IOperandPrototypePtr callByNameOnly(std::string const& name); IOperandPrototypePtr bitCast(IOperandPrototypePtr const& arg); IOperandPrototypePtr intToPtr(IOperandPrototypePtr const& arg); IOperandPrototypePtr constInt(); IOperandPrototypePtr branch( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2); IOperandPrototypePtr switchOp( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2); IOperandPrototypePtr select( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2); IOperandPrototypePtr load(IOperandPrototypePtr const& arg); IOperandPrototypePtr zExt(IOperandPrototypePtr const& value); IOperandPrototypePtr store(IOperandPrototypePtr const& target, IOperandPrototypePtr const& value); IOperandPrototypePtr basicBlock(); static std::shared_ptr<AnyPattern> const _ = std::make_shared<AnyPattern>(); // NOLINT ReplacerFunction deleteInstruction(); ReplacerFunction deleteUnusedInstruction(); Capture operator\"\"_cap(char const* name, std::size_t); } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_parameter_parser_8cpp/","text":"Commandline/ParameterParser.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ParameterParser.hpp\" #include <iostream> #include <stdexcept> #include <string> #include <unordered_map> namespace microsoft::quantum { void ParameterParser::parseArgs(int argc, char const** argv) { uint64_t i = 1; std::vector<ParsedValue> values; while (i < static_cast<uint64_t>(argc)) { values.push_back(parseSingleArg(argv[i])); ++i; } i = 0; while (i < values.size()) { auto& v = values[i]; ++i; if (!v.is_key) { arguments_.push_back(v.value); continue; } unused_properties_.insert(v.value); if (i >= values.size()) { settings_[v.value] = \"true\"; continue; } auto& v2 = values[i]; if (!v2.is_key && isOption(v.value)) { settings_[v.value] = v2.value; ++i; continue; } settings_[v.value] = \"true\"; } } void ParameterParser::addFlag(String const& v) { flags_.insert(v); } String const& ParameterParser::get(String const& name, String const& default_value) noexcept { auto it = settings_.find(name); if (it == settings_.end()) { return default_value; } markAsUsed(name); return it->second; } String const& ParameterParser::get(String const& name) { auto it = settings_.find(name); if (it == settings_.end()) { throw std::runtime_error(\"Could not find setting '\" + name + \"'.\"); } markAsUsed(name); return it->second; } void ParameterParser::markAsUsed(String const& name) { auto it = unused_properties_.find(name); if (it != unused_properties_.end()) { unused_properties_.erase(it); } } ParameterParser::UnusedSettings const& ParameterParser::unusedSettings() const { return unused_properties_; } bool ParameterParser::has(String const& name) const noexcept { auto it = settings_.find(name); return (it != settings_.end()); } ParameterParser::Arguments const& ParameterParser::arguments() const { return arguments_; } String const& ParameterParser::getArg(Arguments::size_type const& n) const { return arguments_[n]; } ParameterParser::ParsedValue ParameterParser::parseSingleArg(String key) { bool is_key = false; if (key.size() > 2 && key.substr(0, 2) == \"--\") { is_key = true; key = key.substr(2); } else if (key.size() > 1 && key.substr(0, 1) == \"-\") { is_key = true; // Mapping shorthand notation key = key.substr(1); auto it = shorthand_notation_.find(key); if (it == shorthand_notation_.end()) { throw std::runtime_error(\"Unknown short hand notation \" + key); } key = it->second; } return {is_key, key}; } bool ParameterParser::isOption(String const& key) { if (flags_.find(key) != flags_.end()) { return false; } return true; } void ParameterParser::reset() { arguments_.clear(); settings_.clear(); flags_.clear(); shorthand_notation_.clear(); } void ParameterParser::addShorthandNotation(String const& parameter, String const& shorthand) { shorthand_notation_[shorthand] = parameter; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Commandline/ParameterParser.cpp"},{"location":"Api/Files/_parameter_parser_8cpp/#commandlineparameterparsercpp","text":"","title":"Commandline/ParameterParser.cpp"},{"location":"Api/Files/_parameter_parser_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_parameter_parser_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ParameterParser.hpp\" #include <iostream> #include <stdexcept> #include <string> #include <unordered_map> namespace microsoft::quantum { void ParameterParser::parseArgs(int argc, char const** argv) { uint64_t i = 1; std::vector<ParsedValue> values; while (i < static_cast<uint64_t>(argc)) { values.push_back(parseSingleArg(argv[i])); ++i; } i = 0; while (i < values.size()) { auto& v = values[i]; ++i; if (!v.is_key) { arguments_.push_back(v.value); continue; } unused_properties_.insert(v.value); if (i >= values.size()) { settings_[v.value] = \"true\"; continue; } auto& v2 = values[i]; if (!v2.is_key && isOption(v.value)) { settings_[v.value] = v2.value; ++i; continue; } settings_[v.value] = \"true\"; } } void ParameterParser::addFlag(String const& v) { flags_.insert(v); } String const& ParameterParser::get(String const& name, String const& default_value) noexcept { auto it = settings_.find(name); if (it == settings_.end()) { return default_value; } markAsUsed(name); return it->second; } String const& ParameterParser::get(String const& name) { auto it = settings_.find(name); if (it == settings_.end()) { throw std::runtime_error(\"Could not find setting '\" + name + \"'.\"); } markAsUsed(name); return it->second; } void ParameterParser::markAsUsed(String const& name) { auto it = unused_properties_.find(name); if (it != unused_properties_.end()) { unused_properties_.erase(it); } } ParameterParser::UnusedSettings const& ParameterParser::unusedSettings() const { return unused_properties_; } bool ParameterParser::has(String const& name) const noexcept { auto it = settings_.find(name); return (it != settings_.end()); } ParameterParser::Arguments const& ParameterParser::arguments() const { return arguments_; } String const& ParameterParser::getArg(Arguments::size_type const& n) const { return arguments_[n]; } ParameterParser::ParsedValue ParameterParser::parseSingleArg(String key) { bool is_key = false; if (key.size() > 2 && key.substr(0, 2) == \"--\") { is_key = true; key = key.substr(2); } else if (key.size() > 1 && key.substr(0, 1) == \"-\") { is_key = true; // Mapping shorthand notation key = key.substr(1); auto it = shorthand_notation_.find(key); if (it == shorthand_notation_.end()) { throw std::runtime_error(\"Unknown short hand notation \" + key); } key = it->second; } return {is_key, key}; } bool ParameterParser::isOption(String const& key) { if (flags_.find(key) != flags_.end()) { return false; } return true; } void ParameterParser::reset() { arguments_.clear(); settings_.clear(); flags_.clear(); shorthand_notation_.clear(); } void ParameterParser::addShorthandNotation(String const& parameter, String const& shorthand) { shorthand_notation_[shorthand] = parameter; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_parameter_parser_8hpp/","text":"Commandline/ParameterParser.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ParameterParser Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <string> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft::quantum { class ParameterParser { public: using Arguments = std::vector<String>; using Flags = std::unordered_set<String>; using SettingsMap = std::unordered_map<String, String>; using UnusedSettings = std::unordered_set<String>; using ShorthandNotation = std::unordered_map<String, String>; // Construction and deconstrution configuration // ParameterParser() = default; // No copy construction. ParameterParser(ParameterParser const& other) = delete; // Allow move semantics. ParameterParser(ParameterParser&& other) = default; // Default destruction. ~ParameterParser() = default; // Configuration // void addFlag(String const& v); // Operation // void parseArgs(int argc, char const** argv); Arguments const& arguments() const; String const& getArg(Arguments::size_type const& n) const; String const& get(String const& name, String const& default_value) noexcept; String const& get(String const& name); void markAsUsed(String const& name); bool has(String const& name) const noexcept; void reset(); UnusedSettings const& unusedSettings() const; void addShorthandNotation(String const& parameter, String const& shorthand); private: struct ParsedValue { bool is_key{false}; String value; }; // Helper functions // // Parses a single argument and returns the parsed value. This function // determines if the string was specified to be a key or a value. ParsedValue parseSingleArg(String key); bool isOption(String const& key); // Storage of parsed data // Flags flags_{}; Arguments arguments_{}; SettingsMap settings_; UnusedSettings unused_properties_{}; ShorthandNotation shorthand_notation_{}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Commandline/ParameterParser.hpp"},{"location":"Api/Files/_parameter_parser_8hpp/#commandlineparameterparserhpp","text":"","title":"Commandline/ParameterParser.hpp"},{"location":"Api/Files/_parameter_parser_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_parameter_parser_8hpp/#classes","text":"Name class microsoft::quantum::ParameterParser","title":"Classes"},{"location":"Api/Files/_parameter_parser_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <string> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft::quantum { class ParameterParser { public: using Arguments = std::vector<String>; using Flags = std::unordered_set<String>; using SettingsMap = std::unordered_map<String, String>; using UnusedSettings = std::unordered_set<String>; using ShorthandNotation = std::unordered_map<String, String>; // Construction and deconstrution configuration // ParameterParser() = default; // No copy construction. ParameterParser(ParameterParser const& other) = delete; // Allow move semantics. ParameterParser(ParameterParser&& other) = default; // Default destruction. ~ParameterParser() = default; // Configuration // void addFlag(String const& v); // Operation // void parseArgs(int argc, char const** argv); Arguments const& arguments() const; String const& getArg(Arguments::size_type const& n) const; String const& get(String const& name, String const& default_value) noexcept; String const& get(String const& name); void markAsUsed(String const& name); bool has(String const& name) const noexcept; void reset(); UnusedSettings const& unusedSettings() const; void addShorthandNotation(String const& parameter, String const& shorthand); private: struct ParsedValue { bool is_key{false}; String value; }; // Helper functions // // Parses a single argument and returns the parsed value. This function // determines if the string was specified to be a key or a value. ParsedValue parseSingleArg(String key); bool isOption(String const& key); // Storage of parsed data // Flags flags_{}; Arguments arguments_{}; SettingsMap settings_; UnusedSettings unused_properties_{}; ShorthandNotation shorthand_notation_{}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_phi_8ipp/","text":"Rules/Notation/Phi.ipp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include \"qir/qat/Rules/Patterns/PhiPattern.hpp\" #include \"qir/qat/Rules/ReplacementRule.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; template <typename... Args> IOperandPrototypePtr phi(Args... args) { IOperandPrototypePtr ret = std::make_shared<PhiPattern>(); std::vector<IOperandPrototypePtr> arguments{args...}; // Adding arguments to matching for (auto &a : arguments) { ret->addChild(a); } return ret; } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Notation/Phi.ipp"},{"location":"Api/Files/_phi_8ipp/#rulesnotationphiipp","text":"","title":"Rules/Notation/Phi.ipp"},{"location":"Api/Files/_phi_8ipp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_phi_8ipp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include \"qir/qat/Rules/Patterns/PhiPattern.hpp\" #include \"qir/qat/Rules/ReplacementRule.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; template <typename... Args> IOperandPrototypePtr phi(Args... args) { IOperandPrototypePtr ret = std::make_shared<PhiPattern>(); std::vector<IOperandPrototypePtr> arguments{args...}; // Adding arguments to matching for (auto &a : arguments) { ret->addChild(a); } return ret; } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_phi_pattern_8cpp/","text":"Rules/Patterns/PhiPattern.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Rules/Patterns/PhiPattern.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" namespace microsoft::quantum { PhiPattern::~PhiPattern() = default; bool PhiPattern::match(Value* instr, Captures& captures) const { auto* phi_node = llvm::dyn_cast<llvm::PHINode>(instr); if (phi_node == nullptr) { return fail(instr, captures); } return success(instr, captures); } PhiPattern::Child PhiPattern::copy() const { auto ret = std::make_shared<PhiPattern>(); ret->copyPropertiesFrom(*this); return ret; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Patterns/PhiPattern.cpp"},{"location":"Api/Files/_phi_pattern_8cpp/#rulespatternsphipatterncpp","text":"","title":"Rules/Patterns/PhiPattern.cpp"},{"location":"Api/Files/_phi_pattern_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_phi_pattern_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Rules/Patterns/PhiPattern.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" namespace microsoft::quantum { PhiPattern::~PhiPattern() = default; bool PhiPattern::match(Value* instr, Captures& captures) const { auto* phi_node = llvm::dyn_cast<llvm::PHINode>(instr); if (phi_node == nullptr) { return fail(instr, captures); } return success(instr, captures); } PhiPattern::Child PhiPattern::copy() const { auto ret = std::make_shared<PhiPattern>(); ret->copyPropertiesFrom(*this); return ret; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_phi_pattern_8hpp/","text":"Rules/Patterns/PhiPattern.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::PhiPattern Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { class PhiPattern : public IOperandPrototype { public: using String = std::string; // Construction of the call pattern by name or move only. // PhiPattern() = default; PhiPattern(PhiPattern const& other) = delete; PhiPattern(PhiPattern&& other) = default; ~PhiPattern() override; // Phi implementation of the member functions in IOperandPrototype. // bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Patterns/PhiPattern.hpp"},{"location":"Api/Files/_phi_pattern_8hpp/#rulespatternsphipatternhpp","text":"","title":"Rules/Patterns/PhiPattern.hpp"},{"location":"Api/Files/_phi_pattern_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_phi_pattern_8hpp/#classes","text":"Name class microsoft::quantum::PhiPattern","title":"Classes"},{"location":"Api/Files/_phi_pattern_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { class PhiPattern : public IOperandPrototype { public: using String = std::string; // Construction of the call pattern by name or move only. // PhiPattern() = default; PhiPattern(PhiPattern const& other) = delete; PhiPattern(PhiPattern&& other) = default; ~PhiPattern() override; // Phi implementation of the member functions in IOperandPrototype. // bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_post_transform_validation_pass_8cpp/","text":"Passes/PostTransformValidation/PostTransformValidationPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/PostTransformValidation/PostTransformValidationPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { PostTransformValidationPass::PostTransformValidationPass( PostTransformValidationPassConfiguration const& cfg, ILoggerPtr const& logger) : config_{cfg} , logger_{logger} { } llvm::PreservedAnalyses PostTransformValidationPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { if (config_.requireStraightLineCode()) { uint64_t function_count{0}; for (auto& function : module) { if (function.isDeclaration()) { continue; } ++function_count; if (function_count > 1) { if (logger_) { logger_->errorExpectedStraightLineCodeMultipleFunctions(&function.getEntryBlock()); } else { throw std::runtime_error(\"Expected straight line code, but multiple functions present.\"); } } uint64_t block_count{0}; for (auto& block : function) { ++block_count; if (block_count > 1) { if (logger_) { logger_->errorExpectedStraightLineCodeMultipleBlocks(&block); } else { throw std::runtime_error(\"Expected straight line code, but multiple blocks present.\"); } } } } } return llvm::PreservedAnalyses::all(); } bool PostTransformValidationPass::isRequired() { return true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/PostTransformValidation/PostTransformValidationPass.cpp"},{"location":"Api/Files/_post_transform_validation_pass_8cpp/#passesposttransformvalidationposttransformvalidationpasscpp","text":"","title":"Passes/PostTransformValidation/PostTransformValidationPass.cpp"},{"location":"Api/Files/_post_transform_validation_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_post_transform_validation_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/PostTransformValidation/PostTransformValidationPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { PostTransformValidationPass::PostTransformValidationPass( PostTransformValidationPassConfiguration const& cfg, ILoggerPtr const& logger) : config_{cfg} , logger_{logger} { } llvm::PreservedAnalyses PostTransformValidationPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { if (config_.requireStraightLineCode()) { uint64_t function_count{0}; for (auto& function : module) { if (function.isDeclaration()) { continue; } ++function_count; if (function_count > 1) { if (logger_) { logger_->errorExpectedStraightLineCodeMultipleFunctions(&function.getEntryBlock()); } else { throw std::runtime_error(\"Expected straight line code, but multiple functions present.\"); } } uint64_t block_count{0}; for (auto& block : function) { ++block_count; if (block_count > 1) { if (logger_) { logger_->errorExpectedStraightLineCodeMultipleBlocks(&block); } else { throw std::runtime_error(\"Expected straight line code, but multiple blocks present.\"); } } } } } return llvm::PreservedAnalyses::all(); } bool PostTransformValidationPass::isRequired() { return true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_post_transform_validation_pass_8hpp/","text":"Passes/PostTransformValidation/PostTransformValidationPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::PostTransformValidationPass Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/PostTransformValidation/PostTransformValidationPass.hpp\" #include \"qir/qat/Passes/PostTransformValidation/PostTransformValidationPassConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class PostTransformValidationPass : public llvm::PassInfoMixin<PostTransformValidationPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using Location = ILogger::Location; using StringRef = llvm::StringRef; // Construction and destruction configuration. // explicit PostTransformValidationPass( PostTransformValidationPassConfiguration const& cfg, ILoggerPtr const& logger = nullptr); PostTransformValidationPass(PostTransformValidationPass const&) = delete; PostTransformValidationPass(PostTransformValidationPass&&) = default; ~PostTransformValidationPass() = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired(); private: using Locations = std::vector<Location>; PostTransformValidationPassConfiguration config_{}; ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/PostTransformValidation/PostTransformValidationPass.hpp"},{"location":"Api/Files/_post_transform_validation_pass_8hpp/#passesposttransformvalidationposttransformvalidationpasshpp","text":"","title":"Passes/PostTransformValidation/PostTransformValidationPass.hpp"},{"location":"Api/Files/_post_transform_validation_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_post_transform_validation_pass_8hpp/#classes","text":"Name class microsoft::quantum::PostTransformValidationPass","title":"Classes"},{"location":"Api/Files/_post_transform_validation_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/PostTransformValidation/PostTransformValidationPass.hpp\" #include \"qir/qat/Passes/PostTransformValidation/PostTransformValidationPassConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class PostTransformValidationPass : public llvm::PassInfoMixin<PostTransformValidationPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using Location = ILogger::Location; using StringRef = llvm::StringRef; // Construction and destruction configuration. // explicit PostTransformValidationPass( PostTransformValidationPassConfiguration const& cfg, ILoggerPtr const& logger = nullptr); PostTransformValidationPass(PostTransformValidationPass const&) = delete; PostTransformValidationPass(PostTransformValidationPass&&) = default; ~PostTransformValidationPass() = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired(); private: using Locations = std::vector<Location>; PostTransformValidationPassConfiguration config_{}; ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_post_transform_validation_pass_configuration_8hpp/","text":"Passes/PostTransformValidation/PostTransformValidationPassConfiguration.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::PostTransformValidationPassConfiguration Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include <limits> namespace microsoft::quantum { class PostTransformValidationPassConfiguration { public: using DeferredValuePtr = DeferredValue::DeferredValuePtr; void setup(ConfigurationManager& config) { config.setSectionName(\"Post transform validation\", \"\"); replace_qubits_on_reset_ = config.getParameter(\"replace-qubit-on-reset\"); defer_measurements_ = config.getParameter(\"defer-measurements\"); } static PostTransformValidationPassConfiguration createDisabled() { PostTransformValidationPassConfiguration ret; ret.disable_straightline_code_requirement_ = true; return ret; } bool requireStraightLineCode() const { if (disable_straightline_code_requirement_) { return false; } return replace_qubits_on_reset_->value<bool>() || defer_measurements_->value<bool>(); } private: bool disable_straightline_code_requirement_{false}; DeferredValuePtr replace_qubits_on_reset_{nullptr}; DeferredValuePtr defer_measurements_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/PostTransformValidation/PostTransformValidationPassConfiguration.hpp"},{"location":"Api/Files/_post_transform_validation_pass_configuration_8hpp/#passesposttransformvalidationposttransformvalidationpassconfigurationhpp","text":"","title":"Passes/PostTransformValidation/PostTransformValidationPassConfiguration.hpp"},{"location":"Api/Files/_post_transform_validation_pass_configuration_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_post_transform_validation_pass_configuration_8hpp/#classes","text":"Name class microsoft::quantum::PostTransformValidationPassConfiguration","title":"Classes"},{"location":"Api/Files/_post_transform_validation_pass_configuration_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include <limits> namespace microsoft::quantum { class PostTransformValidationPassConfiguration { public: using DeferredValuePtr = DeferredValue::DeferredValuePtr; void setup(ConfigurationManager& config) { config.setSectionName(\"Post transform validation\", \"\"); replace_qubits_on_reset_ = config.getParameter(\"replace-qubit-on-reset\"); defer_measurements_ = config.getParameter(\"defer-measurements\"); } static PostTransformValidationPassConfiguration createDisabled() { PostTransformValidationPassConfiguration ret; ret.disable_straightline_code_requirement_ = true; return ret; } bool requireStraightLineCode() const { if (disable_straightline_code_requirement_) { return false; } return replace_qubits_on_reset_->value<bool>() || defer_measurements_->value<bool>(); } private: bool disable_straightline_code_requirement_{false}; DeferredValuePtr replace_qubits_on_reset_{nullptr}; DeferredValuePtr defer_measurements_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_qat_types_8hpp/","text":"QatTypes/QatTypes.hpp Namespaces Name microsoft microsoft::quantum Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include <string> #include <unordered_map> namespace microsoft::quantum { using String = std::string; using StringMap = std::unordered_map<String, String>; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"QatTypes/QatTypes.hpp"},{"location":"Api/Files/_qat_types_8hpp/#qattypesqattypeshpp","text":"","title":"QatTypes/QatTypes.hpp"},{"location":"Api/Files/_qat_types_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_qat_types_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include <string> #include <unordered_map> namespace microsoft::quantum { using String = std::string; using StringMap = std::unordered_map<String, String>; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_qir_adaptor_8cpp/","text":"QirAdaptor/QirAdaptor.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/QirAdaptor/QirAdaptor.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" namespace microsoft::quantum { QirAdaptor::QirAdaptor( ConfigurationManager& configuration_manager, String const& name, ILoggerPtr const& logger, bool debug, llvm::TargetMachine* target_machine, AllocationManagerPtr qubit_allocation_manager, AllocationManagerPtr result_allocation_manager) : name_{name} , configuration_manager_{configuration_manager} , logger_{logger} , pass_instrumentation_callbacks_{std::make_unique<llvm::PassInstrumentationCallbacks>()} , standard_instrumentations_{std::make_unique<llvm::StandardInstrumentations>(debug)} , qubit_allocation_manager_{std::move(qubit_allocation_manager)} , result_allocation_manager_{std::move(result_allocation_manager)} , validator_{std::make_unique<Validator>( configuration_manager_.get<TargetProfileConfiguration>(), configuration_manager_.get<TargetQisConfiguration>(), logger, debug)} { standard_instrumentations_->registerCallbacks(*pass_instrumentation_callbacks_); // TODO(issue-13): Parameterize // pipeline_tuning_options_.LoopUnrolling = !DisableLoopUnrolling; // pipeline_tuning_options_.Coroutines = Coroutines; pass_builder_ = std::make_unique<llvm::PassBuilder>( target_machine, pipeline_tuning_options_, pgo_options_, pass_instrumentation_callbacks_.get()); registerEPCallbacks(); // Creating a full pass builder and registering each of the // components to make them accessible to the developer. pass_builder_->registerModuleAnalyses(module_analysis_manager_); pass_builder_->registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_->registerFunctionAnalyses(function_analysis_manager_); pass_builder_->registerLoopAnalyses(loop_analysis_manager_); pass_builder_->crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); } void QirAdaptor::registerEPCallbacks() { if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, peephole_ep_pipeline_)) { pass_builder_->registerPeepholeEPCallback( [this](llvm::FunctionPassManager& pass_manager, llvm::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse PeepholeEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline(pass_manager, peephole_ep_pipeline_)); }); } if (tryParsePipelineText<llvm::LoopPassManager>(*pass_builder_, late_loop_optimizations_ep_pipeline_)) { pass_builder_->registerLateLoopOptimizationsEPCallback( [this](llvm::LoopPassManager& pass_manager, llvm::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse LateLoopOptimizationsEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline(pass_manager, late_loop_optimizations_ep_pipeline_)); }); } if (tryParsePipelineText<llvm::LoopPassManager>(*pass_builder_, loop_optimizer_end_ep_pipeline_)) { pass_builder_->registerLoopOptimizerEndEPCallback( [this](llvm::LoopPassManager& pass_manager, llvm::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse LoopOptimizerEndEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline(pass_manager, loop_optimizer_end_ep_pipeline_)); }); } if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, scalar_optimizer_late_ep_pipeline_)) { pass_builder_->registerScalarOptimizerLateEPCallback( [this](llvm::FunctionPassManager& pass_manager, llvm::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse ScalarOptimizerLateEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline(pass_manager, scalar_optimizer_late_ep_pipeline_)); }); } if (tryParsePipelineText<llvm::CGSCCPassManager>(*pass_builder_, cgscc_optimizer_late_ep_pipeline_)) { pass_builder_->registerCGSCCOptimizerLateEPCallback( [this](llvm::CGSCCPassManager& pass_manager, llvm::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse CGSCCOptimizerLateEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline(pass_manager, cgscc_optimizer_late_ep_pipeline_)); }); } if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, vectorizer_start_ep_pipeline_)) { pass_builder_->registerVectorizerStartEPCallback( [this](llvm::FunctionPassManager& pass_manager, llvm::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse VectorizerStartEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline(pass_manager, vectorizer_start_ep_pipeline_)); }); } if (tryParsePipelineText<llvm::ModulePassManager>(*pass_builder_, pipeline_start_ep_pipeline_)) { pass_builder_->registerPipelineStartEPCallback( [this](llvm::ModulePassManager& pass_manager, llvm::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse PipelineStartEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline(pass_manager, pipeline_start_ep_pipeline_)); }); } if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, optimizer_last_ep_pipeline_)) { pass_builder_->registerOptimizerLastEPCallback( [this](llvm::ModulePassManager& pass_manager, llvm::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse OptimizerLastEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline(pass_manager, optimizer_last_ep_pipeline_)); }); } } void QirAdaptor::apply(llvm::Module& module) { module_pass_manager_.run(module, module_analysis_manager_); } bool QirAdaptor::verify(llvm::Module& module) { llvm::VerifierAnalysis verifier; auto result = verifier.run(module, module_analysis_manager_); return !result.IRBroken; } bool QirAdaptor::validate(llvm::Module& module) { return validator_->validate(module); } String const& QirAdaptor::name() const { return name_; } QirAdaptor::AllocationManagerPtr QirAdaptor::getQubitAllocationManager() { return qubit_allocation_manager_; } QirAdaptor::AllocationManagerPtr QirAdaptor::getResultAllocationManager() { return result_allocation_manager_; } void QirAdaptor::setValidator(ValidatorPtr&& validator) { validator_ = std::move(validator); } llvm::PassBuilder& QirAdaptor::passBuilder() { return *pass_builder_; } llvm::LoopAnalysisManager& QirAdaptor::loopAnalysisManager() { return loop_analysis_manager_; } llvm::FunctionAnalysisManager& QirAdaptor::functionAnalysisManager() { return function_analysis_manager_; } llvm::CGSCCAnalysisManager& QirAdaptor::gsccAnalysisManager() { return gscc_analysis_manager_; } llvm::ModuleAnalysisManager& QirAdaptor::moduleAnalysisManager() { return module_analysis_manager_; } llvm::ModulePassManager& QirAdaptor::modulePassManager() { return module_pass_manager_; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"QirAdaptor/QirAdaptor.cpp"},{"location":"Api/Files/_qir_adaptor_8cpp/#qiradaptorqiradaptorcpp","text":"","title":"QirAdaptor/QirAdaptor.cpp"},{"location":"Api/Files/_qir_adaptor_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_qir_adaptor_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/QirAdaptor/QirAdaptor.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" namespace microsoft::quantum { QirAdaptor::QirAdaptor( ConfigurationManager& configuration_manager, String const& name, ILoggerPtr const& logger, bool debug, llvm::TargetMachine* target_machine, AllocationManagerPtr qubit_allocation_manager, AllocationManagerPtr result_allocation_manager) : name_{name} , configuration_manager_{configuration_manager} , logger_{logger} , pass_instrumentation_callbacks_{std::make_unique<llvm::PassInstrumentationCallbacks>()} , standard_instrumentations_{std::make_unique<llvm::StandardInstrumentations>(debug)} , qubit_allocation_manager_{std::move(qubit_allocation_manager)} , result_allocation_manager_{std::move(result_allocation_manager)} , validator_{std::make_unique<Validator>( configuration_manager_.get<TargetProfileConfiguration>(), configuration_manager_.get<TargetQisConfiguration>(), logger, debug)} { standard_instrumentations_->registerCallbacks(*pass_instrumentation_callbacks_); // TODO(issue-13): Parameterize // pipeline_tuning_options_.LoopUnrolling = !DisableLoopUnrolling; // pipeline_tuning_options_.Coroutines = Coroutines; pass_builder_ = std::make_unique<llvm::PassBuilder>( target_machine, pipeline_tuning_options_, pgo_options_, pass_instrumentation_callbacks_.get()); registerEPCallbacks(); // Creating a full pass builder and registering each of the // components to make them accessible to the developer. pass_builder_->registerModuleAnalyses(module_analysis_manager_); pass_builder_->registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_->registerFunctionAnalyses(function_analysis_manager_); pass_builder_->registerLoopAnalyses(loop_analysis_manager_); pass_builder_->crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); } void QirAdaptor::registerEPCallbacks() { if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, peephole_ep_pipeline_)) { pass_builder_->registerPeepholeEPCallback( [this](llvm::FunctionPassManager& pass_manager, llvm::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse PeepholeEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline(pass_manager, peephole_ep_pipeline_)); }); } if (tryParsePipelineText<llvm::LoopPassManager>(*pass_builder_, late_loop_optimizations_ep_pipeline_)) { pass_builder_->registerLateLoopOptimizationsEPCallback( [this](llvm::LoopPassManager& pass_manager, llvm::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse LateLoopOptimizationsEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline(pass_manager, late_loop_optimizations_ep_pipeline_)); }); } if (tryParsePipelineText<llvm::LoopPassManager>(*pass_builder_, loop_optimizer_end_ep_pipeline_)) { pass_builder_->registerLoopOptimizerEndEPCallback( [this](llvm::LoopPassManager& pass_manager, llvm::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse LoopOptimizerEndEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline(pass_manager, loop_optimizer_end_ep_pipeline_)); }); } if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, scalar_optimizer_late_ep_pipeline_)) { pass_builder_->registerScalarOptimizerLateEPCallback( [this](llvm::FunctionPassManager& pass_manager, llvm::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse ScalarOptimizerLateEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline(pass_manager, scalar_optimizer_late_ep_pipeline_)); }); } if (tryParsePipelineText<llvm::CGSCCPassManager>(*pass_builder_, cgscc_optimizer_late_ep_pipeline_)) { pass_builder_->registerCGSCCOptimizerLateEPCallback( [this](llvm::CGSCCPassManager& pass_manager, llvm::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse CGSCCOptimizerLateEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline(pass_manager, cgscc_optimizer_late_ep_pipeline_)); }); } if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, vectorizer_start_ep_pipeline_)) { pass_builder_->registerVectorizerStartEPCallback( [this](llvm::FunctionPassManager& pass_manager, llvm::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse VectorizerStartEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline(pass_manager, vectorizer_start_ep_pipeline_)); }); } if (tryParsePipelineText<llvm::ModulePassManager>(*pass_builder_, pipeline_start_ep_pipeline_)) { pass_builder_->registerPipelineStartEPCallback( [this](llvm::ModulePassManager& pass_manager, llvm::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse PipelineStartEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline(pass_manager, pipeline_start_ep_pipeline_)); }); } if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, optimizer_last_ep_pipeline_)) { pass_builder_->registerOptimizerLastEPCallback( [this](llvm::ModulePassManager& pass_manager, llvm::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse OptimizerLastEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline(pass_manager, optimizer_last_ep_pipeline_)); }); } } void QirAdaptor::apply(llvm::Module& module) { module_pass_manager_.run(module, module_analysis_manager_); } bool QirAdaptor::verify(llvm::Module& module) { llvm::VerifierAnalysis verifier; auto result = verifier.run(module, module_analysis_manager_); return !result.IRBroken; } bool QirAdaptor::validate(llvm::Module& module) { return validator_->validate(module); } String const& QirAdaptor::name() const { return name_; } QirAdaptor::AllocationManagerPtr QirAdaptor::getQubitAllocationManager() { return qubit_allocation_manager_; } QirAdaptor::AllocationManagerPtr QirAdaptor::getResultAllocationManager() { return result_allocation_manager_; } void QirAdaptor::setValidator(ValidatorPtr&& validator) { validator_ = std::move(validator); } llvm::PassBuilder& QirAdaptor::passBuilder() { return *pass_builder_; } llvm::LoopAnalysisManager& QirAdaptor::loopAnalysisManager() { return loop_analysis_manager_; } llvm::FunctionAnalysisManager& QirAdaptor::functionAnalysisManager() { return function_analysis_manager_; } llvm::CGSCCAnalysisManager& QirAdaptor::gsccAnalysisManager() { return gscc_analysis_manager_; } llvm::ModuleAnalysisManager& QirAdaptor::moduleAnalysisManager() { return module_analysis_manager_; } llvm::ModulePassManager& QirAdaptor::modulePassManager() { return module_pass_manager_; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_qir_adaptor_8hpp/","text":"QirAdaptor/QirAdaptor.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::QirAdaptor Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AllocationManager/AllocationManager.hpp\" #include \"qir/qat/AllocationManager/IAllocationManager.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include \"qir/qat/Validator/Validator.hpp\" namespace microsoft::quantum { class QirAdaptorFactory; class QirAdaptor { public: using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; using ValidatorPtr = Validator::ValidatorPtr; using ILoggerPtr = std::shared_ptr<ILogger>; // Constructors // explicit QirAdaptor( ConfigurationManager& configuration_manager, String const& name, ILoggerPtr const& logger, bool debug, llvm::TargetMachine* target_machine = nullptr, AllocationManagerPtr qubit_allocation_manager = BasicAllocationManager::createNew(), AllocationManagerPtr result_allocation_manager = BasicAllocationManager::createNew()); // Default construction not allowed as this leads to invalid configuration of the allocation // managers. QirAdaptor() = delete; QirAdaptor(QirAdaptor const&) = delete; QirAdaptor(QirAdaptor&&) = delete; QirAdaptor& operator=(QirAdaptor const&) = delete; QirAdaptor& operator=(QirAdaptor&&) = delete; ~QirAdaptor() = default; // QirAdaptor methods // void apply(llvm::Module& module); bool verify(llvm::Module& module); bool validate(llvm::Module& module); AllocationManagerPtr getQubitAllocationManager(); AllocationManagerPtr getResultAllocationManager(); String const& name() const; llvm::PassBuilder& passBuilder(); llvm::LoopAnalysisManager& loopAnalysisManager(); llvm::FunctionAnalysisManager& functionAnalysisManager(); llvm::CGSCCAnalysisManager& gsccAnalysisManager(); llvm::ModuleAnalysisManager& moduleAnalysisManager(); llvm::ModulePassManager& modulePassManager(); ConfigurationManager& configurationManager() { return configuration_manager_; } protected: // Ensuring that QirAdaptorFactory has access to following protected functions. friend class QirAdaptorFactory; void setValidator(ValidatorPtr&& validator); private: using PassInstrumentationCallbacksPtr = std::unique_ptr<llvm::PassInstrumentationCallbacks>; using StandardInstrumentationsPtr = std::unique_ptr<llvm::StandardInstrumentations>; using PassBuilderPtr = std::unique_ptr<llvm::PassBuilder>; void registerEPCallbacks(); template <typename PassManager> bool tryParsePipelineText(llvm::PassBuilder& pass_builder, std::string const& pipeline_options) { if (pipeline_options.empty()) { return false; } PassManager pass_manager; if (auto err = pass_builder.parsePassPipeline(pass_manager, pipeline_options)) { llvm::errs() << \"Could not parse -\" << pipeline_options << \" pipeline: \" << toString(std::move(err)) << \"\\n\"; return false; } return true; } String name_{}; ConfigurationManager& configuration_manager_; ILoggerPtr logger_{nullptr}; // LLVM logic to run the passes // llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; llvm::Optional<llvm::PGOOptions> pgo_options_; PassInstrumentationCallbacksPtr pass_instrumentation_callbacks_; StandardInstrumentationsPtr standard_instrumentations_; llvm::PipelineTuningOptions pipeline_tuning_options_; PassBuilderPtr pass_builder_; llvm::ModulePassManager module_pass_manager_{}; llvm::FunctionPassManager function_pass_manager_{}; // Allocation management // AllocationManagerPtr qubit_allocation_manager_{}; AllocationManagerPtr result_allocation_manager_{}; ValidatorPtr validator_{}; std::string peephole_ep_pipeline_{\"\"}; std::string late_loop_optimizations_ep_pipeline_{\"\"}; std::string loop_optimizer_end_ep_pipeline_{\"\"}; std::string scalar_optimizer_late_ep_pipeline_{\"\"}; std::string cgscc_optimizer_late_ep_pipeline_{\"\"}; std::string vectorizer_start_ep_pipeline_{\"\"}; std::string pipeline_start_ep_pipeline_{\"\"}; std::string optimizer_last_ep_pipeline_{\"\"}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"QirAdaptor/QirAdaptor.hpp"},{"location":"Api/Files/_qir_adaptor_8hpp/#qiradaptorqiradaptorhpp","text":"","title":"QirAdaptor/QirAdaptor.hpp"},{"location":"Api/Files/_qir_adaptor_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_qir_adaptor_8hpp/#classes","text":"Name class microsoft::quantum::QirAdaptor","title":"Classes"},{"location":"Api/Files/_qir_adaptor_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AllocationManager/AllocationManager.hpp\" #include \"qir/qat/AllocationManager/IAllocationManager.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include \"qir/qat/Validator/Validator.hpp\" namespace microsoft::quantum { class QirAdaptorFactory; class QirAdaptor { public: using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; using ValidatorPtr = Validator::ValidatorPtr; using ILoggerPtr = std::shared_ptr<ILogger>; // Constructors // explicit QirAdaptor( ConfigurationManager& configuration_manager, String const& name, ILoggerPtr const& logger, bool debug, llvm::TargetMachine* target_machine = nullptr, AllocationManagerPtr qubit_allocation_manager = BasicAllocationManager::createNew(), AllocationManagerPtr result_allocation_manager = BasicAllocationManager::createNew()); // Default construction not allowed as this leads to invalid configuration of the allocation // managers. QirAdaptor() = delete; QirAdaptor(QirAdaptor const&) = delete; QirAdaptor(QirAdaptor&&) = delete; QirAdaptor& operator=(QirAdaptor const&) = delete; QirAdaptor& operator=(QirAdaptor&&) = delete; ~QirAdaptor() = default; // QirAdaptor methods // void apply(llvm::Module& module); bool verify(llvm::Module& module); bool validate(llvm::Module& module); AllocationManagerPtr getQubitAllocationManager(); AllocationManagerPtr getResultAllocationManager(); String const& name() const; llvm::PassBuilder& passBuilder(); llvm::LoopAnalysisManager& loopAnalysisManager(); llvm::FunctionAnalysisManager& functionAnalysisManager(); llvm::CGSCCAnalysisManager& gsccAnalysisManager(); llvm::ModuleAnalysisManager& moduleAnalysisManager(); llvm::ModulePassManager& modulePassManager(); ConfigurationManager& configurationManager() { return configuration_manager_; } protected: // Ensuring that QirAdaptorFactory has access to following protected functions. friend class QirAdaptorFactory; void setValidator(ValidatorPtr&& validator); private: using PassInstrumentationCallbacksPtr = std::unique_ptr<llvm::PassInstrumentationCallbacks>; using StandardInstrumentationsPtr = std::unique_ptr<llvm::StandardInstrumentations>; using PassBuilderPtr = std::unique_ptr<llvm::PassBuilder>; void registerEPCallbacks(); template <typename PassManager> bool tryParsePipelineText(llvm::PassBuilder& pass_builder, std::string const& pipeline_options) { if (pipeline_options.empty()) { return false; } PassManager pass_manager; if (auto err = pass_builder.parsePassPipeline(pass_manager, pipeline_options)) { llvm::errs() << \"Could not parse -\" << pipeline_options << \" pipeline: \" << toString(std::move(err)) << \"\\n\"; return false; } return true; } String name_{}; ConfigurationManager& configuration_manager_; ILoggerPtr logger_{nullptr}; // LLVM logic to run the passes // llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; llvm::Optional<llvm::PGOOptions> pgo_options_; PassInstrumentationCallbacksPtr pass_instrumentation_callbacks_; StandardInstrumentationsPtr standard_instrumentations_; llvm::PipelineTuningOptions pipeline_tuning_options_; PassBuilderPtr pass_builder_; llvm::ModulePassManager module_pass_manager_{}; llvm::FunctionPassManager function_pass_manager_{}; // Allocation management // AllocationManagerPtr qubit_allocation_manager_{}; AllocationManagerPtr result_allocation_manager_{}; ValidatorPtr validator_{}; std::string peephole_ep_pipeline_{\"\"}; std::string late_loop_optimizations_ep_pipeline_{\"\"}; std::string loop_optimizer_end_ep_pipeline_{\"\"}; std::string scalar_optimizer_late_ep_pipeline_{\"\"}; std::string cgscc_optimizer_late_ep_pipeline_{\"\"}; std::string vectorizer_start_ep_pipeline_{\"\"}; std::string pipeline_start_ep_pipeline_{\"\"}; std::string optimizer_last_ep_pipeline_{\"\"}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_qir_adaptor_factory_8cpp/","text":"AdaptorFactory/QirAdaptorFactory.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AdaptorFactory/QirAdaptorFactory.hpp\" #include \"qir/qat/AdaptorFactory/LlvmPassesConfiguration.hpp\" #include \"qir/qat/AdaptorFactory/TargetProfileMappingConfiguration.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Passes/DeferMeasurementPass/DeferMeasurementPass.hpp\" #include \"qir/qat/Passes/FunctionReplacementPass/FunctionAnnotatorPass.hpp\" #include \"qir/qat/Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.hpp\" #include \"qir/qat/Passes/FunctionReplacementPass/FunctionReplacementPass.hpp\" #include \"qir/qat/Passes/GroupingPass/GroupingAnalysisPass.hpp\" #include \"qir/qat/Passes/GroupingPass/GroupingPass.hpp\" #include \"qir/qat/Passes/GroupingPass/GroupingPassConfiguration.hpp\" #include \"qir/qat/Passes/PostTransformValidation/PostTransformValidationPass.hpp\" #include \"qir/qat/Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPass.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/AllocationAnalysisPass.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/QubitRemapPass.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/ReplaceQubitOnResetPass.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/ResourceAnnotationPass.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/Factory.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/TargetQisMappingPass.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/TargetQisMappingPassConfiguration.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetProfileConfiguration.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetQisConfiguration.hpp\" #include \"qir/qat/Passes/ZExtTransformPass/ZExtTransformPass.hpp\" #include \"qir/qat/Rules/RuleSet.hpp\" #include \"qir/qat/Utils/FunctionToModule.hpp\" namespace microsoft::quantum { std::shared_ptr<QirAdaptor> QirAdaptorFactory::newQirAdaptor( String const& name, OptimizationLevel const& /*optimization_level*/, bool debug) { debug_ = debug; auto qubit_allocation_manager = BasicAllocationManager::createNew(); auto result_allocation_manager = BasicAllocationManager::createNew(); if (configuration_manager_.has<TargetQisMappingPassConfiguration>()) { auto cfg = configuration_manager_.get<TargetQisMappingPassConfiguration>(); qubit_allocation_manager->setReuseRegisters(cfg.shouldReuseQubits()); result_allocation_manager->setReuseRegisters(cfg.shouldReuseResults()); } // Creating adaptor // TODO(issue-12): Set target machine auto ret = std::make_shared<QirAdaptor>( configuration_manager_, name, logger_, debug, nullptr, qubit_allocation_manager, result_allocation_manager); for (auto& c : components_) { if (debug) { llvm::outs() << \"Setting \" << c.first << \" up\\n\"; } c.second(*this, *ret); } // Creating validator auto validator = std::make_unique<Validator>( configuration_manager_.get<TargetProfileConfiguration>(), configuration_manager_.get<TargetQisConfiguration>(), logger_, debug); ret->setValidator(std::move(validator)); return ret; } void QirAdaptorFactory::newAdaptorContext(String const& name, bool debug) { qubit_allocation_manager_ = BasicAllocationManager::createNew(); result_allocation_manager_ = BasicAllocationManager::createNew(); if (configuration_manager_.has<TargetQisMappingPassConfiguration>()) { auto cfg = configuration_manager_.get<TargetQisMappingPassConfiguration>(); qubit_allocation_manager_->setReuseRegisters(cfg.shouldReuseQubits()); result_allocation_manager_->setReuseRegisters(cfg.shouldReuseResults()); } adaptor_ = std::make_shared<QirAdaptor>( configuration_manager_, name, logger_, debug, nullptr, qubit_allocation_manager_, result_allocation_manager_); } void QirAdaptorFactory::addComponent(String const& name) { if (adaptor_ == nullptr) { throw std::runtime_error(\"Please initialize a new context before adding a component.\"); } bool found = false; for (auto& c : components_) { if (c.first == name) { c.second(*this, *adaptor_); found = true; break; } } if (!found) { throw std::runtime_error(\"Could not find component \" + name); } } QirAdaptorFactory::QirAdaptorPtr QirAdaptorFactory::finalizeAdaptor() { auto ret = adaptor_; adaptor_.reset(); return ret; } llvm::ModulePassManager QirAdaptorFactory::createValidationModulePass(PassBuilder&, OptimizationLevel const&, bool) { throw std::runtime_error(\"Validation is not supported yet.\"); } bool QirAdaptorFactory::isDebugMode() const { return debug_; } void QirAdaptorFactory::replicateAdaptorComponent(String const& id) { for (auto& c : components_) { if (c.first == id) { auto setup_wrapper = c.second; components_.push_back({\"__unnamed__\", std::move(setup_wrapper)}); return; } } throw std::runtime_error(\"Component \" + id + \" not found.\"); } void QirAdaptorFactory::setupDefaultComponentPipeline() { using namespace llvm; ILoggerPtr logger = logger_; registerAdaptorComponent<FunctionReplacementConfiguration>( \"adaptor.replacement-linking\", [logger](FunctionReplacementConfiguration const& cfg, QirAdaptor& adaptor) { auto& mam = adaptor.moduleAnalysisManager(); mam.registerPass([&] { return FunctionReplacementAnalysisPass(cfg, logger); }); auto& ret = adaptor.modulePassManager(); ret.addPass(FunctionAnnotatorPass(cfg)); auto pass = FunctionReplacementPass(cfg); pass.setLogger(logger); ret.addPass(std::move(pass)); }); registerAdaptorComponent<LlvmPassesConfiguration>( \"adaptor.llvm-optimization\", [](LlvmPassesConfiguration const& cfg, QirAdaptor& adaptor) { auto& mpm = adaptor.modulePassManager(); // Eliminating intrinsic functions if (cfg.eliminateConstants()) { llvm::FunctionPassManager early_fpm; mpm.addPass(llvm::ForceFunctionAttrsPass()); mpm.addPass(llvm::InferFunctionAttrsPass()); early_fpm.addPass(llvm::SimplifyCFGPass()); early_fpm.addPass(llvm::EarlyCSEPass(false)); mpm.addPass(FunctionToModule(std::move(early_fpm))); } // Always inline if (cfg.alwaysInline()) { mpm.addPass(llvm::AlwaysInlinerPass()); auto inline_param = llvm::getInlineParams(cfg.inlineParameter()); llvm::ModuleInlinerWrapperPass inliner_pass = llvm::ModuleInlinerWrapperPass(inline_param); mpm.addPass(std::move(inliner_pass)); } llvm::FunctionPassManager fpm; // Unroll loop if (cfg.unrollLoops()) { llvm::LoopUnrollOptions loop_config( cfg.unrollOptLevel(), cfg.unrollOnlyWhenForced(), cfg.unrollForgeScev()); loop_config.setPartial(cfg.unrollAllowPartial()) .setPeeling(cfg.unrollAllowPeeling()) .setRuntime(cfg.unrollAllowRuntime()) .setUpperBound(cfg.unrollAllowUpperBound()) .setProfileBasedPeeling(cfg.unrollAllowProfilBasedPeeling()) .setFullUnrollMaxCount(static_cast<uint32_t>(cfg.unrolFullUnrollCount())); fpm.addPass(llvm::LoopUnrollPass(loop_config)); } if (cfg.eliminateMemory()) { fpm.addPass(llvm::PromotePass()); } if (cfg.eliminateConstants()) { fpm.addPass(llvm::SCCPPass()); } if (cfg.eliminateDeadCode()) { fpm.addPass(llvm::ADCEPass()); mpm.addPass(llvm::GlobalDCEPass()); } mpm.addPass(FunctionToModule(std::move(fpm))); }); registerAdaptorComponent<RemoveNonEntrypointFunctionsPassConfiguration>( \"adaptor.remove-non-entrypoint-functions\", [logger](RemoveNonEntrypointFunctionsPassConfiguration const& cfg, QirAdaptor& adaptor) { auto& mpm = adaptor.modulePassManager(); mpm.addPass(RemoveNonEntrypointFunctionsPass(cfg, logger)); }); registerAdaptorComponent<TargetQisMappingPassConfiguration>( \"adaptor.target-qis-mapping\", [logger](TargetQisMappingPassConfiguration const& cfg, QirAdaptor& adaptor) { auto& ret = adaptor.modulePassManager(); // Defining the mapping RuleSet rule_set; auto factory = RuleFactory( rule_set, adaptor.getQubitAllocationManager(), adaptor.getResultAllocationManager(), logger); factory.usingConfiguration(adaptor.configurationManager().get<TargetQisMappingPassConfiguration>()); // Creating adaptor pass auto pass = TargetQisMappingPass(std::move(rule_set), cfg); pass.setLogger(logger); ret.addPass(std::move(pass)); }); registerAdaptorComponent<TargetProfileMappingConfiguration>( \"adaptor.target-profile-mapping\", [logger](TargetProfileMappingConfiguration const& cfg, QirAdaptor& adaptor) { auto& mpm = adaptor.modulePassManager(); llvm::FunctionPassManager fpm; if (cfg.shouldAddInstCombinePass()) { fpm.addPass(llvm::InstCombinePass(1000)); } if (cfg.shouldAddAggressiveInstCombinePass()) { fpm.addPass(llvm::AggressiveInstCombinePass()); } if (cfg.shouldAddSccpPass()) { fpm.addPass(llvm::SCCPPass()); } if (cfg.shouldAddSimplifyCfgPass()) { fpm.addPass(llvm::SimplifyCFGPass()); } if (cfg.shouldLowerSwitch()) { fpm.addPass(llvm::LowerSwitchPass()); } if (cfg.shouldEliminateZExtI1()) { fpm.addPass(ZExtTransformPass()); } if (cfg.shouldDeferMeasurements()) { fpm.addPass(DeferMeasurementPass()); } mpm.addPass(FunctionToModule(std::move(fpm))); }); registerAdaptorComponent<PostTransformValidationPassConfiguration>( \"adaptor.straightline-code-requirement\", [logger](PostTransformValidationPassConfiguration const& cfg, QirAdaptor& adaptor) { auto& mpm = adaptor.modulePassManager(); mpm.addPass(PostTransformValidationPass(cfg, logger)); }); registerAdaptorComponent<StaticResourceComponentConfiguration>( \"adaptor.static-resources\", [logger](StaticResourceComponentConfiguration const& cfg, QirAdaptor& adaptor) { auto& mpm = adaptor.modulePassManager(); auto& fam = adaptor.functionAnalysisManager(); fam.registerPass([&] { return AllocationAnalysisPass(logger); }); llvm::FunctionPassManager fpm; fpm.addPass(ReplaceQubitOnResetPass(cfg, logger)); fpm.addPass(QubitRemapPass(cfg, logger)); if (cfg.shouldInlineAfterIdChange() && cfg.isChangingIds()) { fpm.addPass(llvm::InstCombinePass(1000)); fpm.addPass(llvm::AggressiveInstCombinePass()); fpm.addPass(llvm::SCCPPass()); fpm.addPass(llvm::SimplifyCFGPass()); fpm.addPass(llvm::LowerSwitchPass()); fpm.addPass(ZExtTransformPass()); } fpm.addPass(ResourceAnnotationPass(cfg, logger)); mpm.addPass(FunctionToModule(std::move(fpm))); }); registerAdaptorComponent<GroupingPassConfiguration>( \"adaptor.grouping\", [logger](GroupingPassConfiguration const& cfg, QirAdaptor& adaptor) { if (cfg.groupQis()) { auto& mam = adaptor.moduleAnalysisManager(); mam.registerPass([&] { return GroupingAnalysisPass(cfg, logger); }); auto& ret = adaptor.modulePassManager(); auto pass = GroupingPass(cfg); pass.setLogger(logger); ret.addPass(std::move(pass)); } }); } void QirAdaptorFactory::setLogger(ILoggerPtr const& logger) { logger_ = logger; } ConfigurationManager& QirAdaptorFactory::configurationManager() { return configuration_manager_; } ConfigurationManager const& QirAdaptorFactory::configurationManager() const { return configuration_manager_; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"AdaptorFactory/QirAdaptorFactory.cpp"},{"location":"Api/Files/_qir_adaptor_factory_8cpp/#adaptorfactoryqiradaptorfactorycpp","text":"","title":"AdaptorFactory/QirAdaptorFactory.cpp"},{"location":"Api/Files/_qir_adaptor_factory_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_qir_adaptor_factory_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AdaptorFactory/QirAdaptorFactory.hpp\" #include \"qir/qat/AdaptorFactory/LlvmPassesConfiguration.hpp\" #include \"qir/qat/AdaptorFactory/TargetProfileMappingConfiguration.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Passes/DeferMeasurementPass/DeferMeasurementPass.hpp\" #include \"qir/qat/Passes/FunctionReplacementPass/FunctionAnnotatorPass.hpp\" #include \"qir/qat/Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.hpp\" #include \"qir/qat/Passes/FunctionReplacementPass/FunctionReplacementPass.hpp\" #include \"qir/qat/Passes/GroupingPass/GroupingAnalysisPass.hpp\" #include \"qir/qat/Passes/GroupingPass/GroupingPass.hpp\" #include \"qir/qat/Passes/GroupingPass/GroupingPassConfiguration.hpp\" #include \"qir/qat/Passes/PostTransformValidation/PostTransformValidationPass.hpp\" #include \"qir/qat/Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPass.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/AllocationAnalysisPass.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/QubitRemapPass.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/ReplaceQubitOnResetPass.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/ResourceAnnotationPass.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/Factory.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/TargetQisMappingPass.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/TargetQisMappingPassConfiguration.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetProfileConfiguration.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetQisConfiguration.hpp\" #include \"qir/qat/Passes/ZExtTransformPass/ZExtTransformPass.hpp\" #include \"qir/qat/Rules/RuleSet.hpp\" #include \"qir/qat/Utils/FunctionToModule.hpp\" namespace microsoft::quantum { std::shared_ptr<QirAdaptor> QirAdaptorFactory::newQirAdaptor( String const& name, OptimizationLevel const& /*optimization_level*/, bool debug) { debug_ = debug; auto qubit_allocation_manager = BasicAllocationManager::createNew(); auto result_allocation_manager = BasicAllocationManager::createNew(); if (configuration_manager_.has<TargetQisMappingPassConfiguration>()) { auto cfg = configuration_manager_.get<TargetQisMappingPassConfiguration>(); qubit_allocation_manager->setReuseRegisters(cfg.shouldReuseQubits()); result_allocation_manager->setReuseRegisters(cfg.shouldReuseResults()); } // Creating adaptor // TODO(issue-12): Set target machine auto ret = std::make_shared<QirAdaptor>( configuration_manager_, name, logger_, debug, nullptr, qubit_allocation_manager, result_allocation_manager); for (auto& c : components_) { if (debug) { llvm::outs() << \"Setting \" << c.first << \" up\\n\"; } c.second(*this, *ret); } // Creating validator auto validator = std::make_unique<Validator>( configuration_manager_.get<TargetProfileConfiguration>(), configuration_manager_.get<TargetQisConfiguration>(), logger_, debug); ret->setValidator(std::move(validator)); return ret; } void QirAdaptorFactory::newAdaptorContext(String const& name, bool debug) { qubit_allocation_manager_ = BasicAllocationManager::createNew(); result_allocation_manager_ = BasicAllocationManager::createNew(); if (configuration_manager_.has<TargetQisMappingPassConfiguration>()) { auto cfg = configuration_manager_.get<TargetQisMappingPassConfiguration>(); qubit_allocation_manager_->setReuseRegisters(cfg.shouldReuseQubits()); result_allocation_manager_->setReuseRegisters(cfg.shouldReuseResults()); } adaptor_ = std::make_shared<QirAdaptor>( configuration_manager_, name, logger_, debug, nullptr, qubit_allocation_manager_, result_allocation_manager_); } void QirAdaptorFactory::addComponent(String const& name) { if (adaptor_ == nullptr) { throw std::runtime_error(\"Please initialize a new context before adding a component.\"); } bool found = false; for (auto& c : components_) { if (c.first == name) { c.second(*this, *adaptor_); found = true; break; } } if (!found) { throw std::runtime_error(\"Could not find component \" + name); } } QirAdaptorFactory::QirAdaptorPtr QirAdaptorFactory::finalizeAdaptor() { auto ret = adaptor_; adaptor_.reset(); return ret; } llvm::ModulePassManager QirAdaptorFactory::createValidationModulePass(PassBuilder&, OptimizationLevel const&, bool) { throw std::runtime_error(\"Validation is not supported yet.\"); } bool QirAdaptorFactory::isDebugMode() const { return debug_; } void QirAdaptorFactory::replicateAdaptorComponent(String const& id) { for (auto& c : components_) { if (c.first == id) { auto setup_wrapper = c.second; components_.push_back({\"__unnamed__\", std::move(setup_wrapper)}); return; } } throw std::runtime_error(\"Component \" + id + \" not found.\"); } void QirAdaptorFactory::setupDefaultComponentPipeline() { using namespace llvm; ILoggerPtr logger = logger_; registerAdaptorComponent<FunctionReplacementConfiguration>( \"adaptor.replacement-linking\", [logger](FunctionReplacementConfiguration const& cfg, QirAdaptor& adaptor) { auto& mam = adaptor.moduleAnalysisManager(); mam.registerPass([&] { return FunctionReplacementAnalysisPass(cfg, logger); }); auto& ret = adaptor.modulePassManager(); ret.addPass(FunctionAnnotatorPass(cfg)); auto pass = FunctionReplacementPass(cfg); pass.setLogger(logger); ret.addPass(std::move(pass)); }); registerAdaptorComponent<LlvmPassesConfiguration>( \"adaptor.llvm-optimization\", [](LlvmPassesConfiguration const& cfg, QirAdaptor& adaptor) { auto& mpm = adaptor.modulePassManager(); // Eliminating intrinsic functions if (cfg.eliminateConstants()) { llvm::FunctionPassManager early_fpm; mpm.addPass(llvm::ForceFunctionAttrsPass()); mpm.addPass(llvm::InferFunctionAttrsPass()); early_fpm.addPass(llvm::SimplifyCFGPass()); early_fpm.addPass(llvm::EarlyCSEPass(false)); mpm.addPass(FunctionToModule(std::move(early_fpm))); } // Always inline if (cfg.alwaysInline()) { mpm.addPass(llvm::AlwaysInlinerPass()); auto inline_param = llvm::getInlineParams(cfg.inlineParameter()); llvm::ModuleInlinerWrapperPass inliner_pass = llvm::ModuleInlinerWrapperPass(inline_param); mpm.addPass(std::move(inliner_pass)); } llvm::FunctionPassManager fpm; // Unroll loop if (cfg.unrollLoops()) { llvm::LoopUnrollOptions loop_config( cfg.unrollOptLevel(), cfg.unrollOnlyWhenForced(), cfg.unrollForgeScev()); loop_config.setPartial(cfg.unrollAllowPartial()) .setPeeling(cfg.unrollAllowPeeling()) .setRuntime(cfg.unrollAllowRuntime()) .setUpperBound(cfg.unrollAllowUpperBound()) .setProfileBasedPeeling(cfg.unrollAllowProfilBasedPeeling()) .setFullUnrollMaxCount(static_cast<uint32_t>(cfg.unrolFullUnrollCount())); fpm.addPass(llvm::LoopUnrollPass(loop_config)); } if (cfg.eliminateMemory()) { fpm.addPass(llvm::PromotePass()); } if (cfg.eliminateConstants()) { fpm.addPass(llvm::SCCPPass()); } if (cfg.eliminateDeadCode()) { fpm.addPass(llvm::ADCEPass()); mpm.addPass(llvm::GlobalDCEPass()); } mpm.addPass(FunctionToModule(std::move(fpm))); }); registerAdaptorComponent<RemoveNonEntrypointFunctionsPassConfiguration>( \"adaptor.remove-non-entrypoint-functions\", [logger](RemoveNonEntrypointFunctionsPassConfiguration const& cfg, QirAdaptor& adaptor) { auto& mpm = adaptor.modulePassManager(); mpm.addPass(RemoveNonEntrypointFunctionsPass(cfg, logger)); }); registerAdaptorComponent<TargetQisMappingPassConfiguration>( \"adaptor.target-qis-mapping\", [logger](TargetQisMappingPassConfiguration const& cfg, QirAdaptor& adaptor) { auto& ret = adaptor.modulePassManager(); // Defining the mapping RuleSet rule_set; auto factory = RuleFactory( rule_set, adaptor.getQubitAllocationManager(), adaptor.getResultAllocationManager(), logger); factory.usingConfiguration(adaptor.configurationManager().get<TargetQisMappingPassConfiguration>()); // Creating adaptor pass auto pass = TargetQisMappingPass(std::move(rule_set), cfg); pass.setLogger(logger); ret.addPass(std::move(pass)); }); registerAdaptorComponent<TargetProfileMappingConfiguration>( \"adaptor.target-profile-mapping\", [logger](TargetProfileMappingConfiguration const& cfg, QirAdaptor& adaptor) { auto& mpm = adaptor.modulePassManager(); llvm::FunctionPassManager fpm; if (cfg.shouldAddInstCombinePass()) { fpm.addPass(llvm::InstCombinePass(1000)); } if (cfg.shouldAddAggressiveInstCombinePass()) { fpm.addPass(llvm::AggressiveInstCombinePass()); } if (cfg.shouldAddSccpPass()) { fpm.addPass(llvm::SCCPPass()); } if (cfg.shouldAddSimplifyCfgPass()) { fpm.addPass(llvm::SimplifyCFGPass()); } if (cfg.shouldLowerSwitch()) { fpm.addPass(llvm::LowerSwitchPass()); } if (cfg.shouldEliminateZExtI1()) { fpm.addPass(ZExtTransformPass()); } if (cfg.shouldDeferMeasurements()) { fpm.addPass(DeferMeasurementPass()); } mpm.addPass(FunctionToModule(std::move(fpm))); }); registerAdaptorComponent<PostTransformValidationPassConfiguration>( \"adaptor.straightline-code-requirement\", [logger](PostTransformValidationPassConfiguration const& cfg, QirAdaptor& adaptor) { auto& mpm = adaptor.modulePassManager(); mpm.addPass(PostTransformValidationPass(cfg, logger)); }); registerAdaptorComponent<StaticResourceComponentConfiguration>( \"adaptor.static-resources\", [logger](StaticResourceComponentConfiguration const& cfg, QirAdaptor& adaptor) { auto& mpm = adaptor.modulePassManager(); auto& fam = adaptor.functionAnalysisManager(); fam.registerPass([&] { return AllocationAnalysisPass(logger); }); llvm::FunctionPassManager fpm; fpm.addPass(ReplaceQubitOnResetPass(cfg, logger)); fpm.addPass(QubitRemapPass(cfg, logger)); if (cfg.shouldInlineAfterIdChange() && cfg.isChangingIds()) { fpm.addPass(llvm::InstCombinePass(1000)); fpm.addPass(llvm::AggressiveInstCombinePass()); fpm.addPass(llvm::SCCPPass()); fpm.addPass(llvm::SimplifyCFGPass()); fpm.addPass(llvm::LowerSwitchPass()); fpm.addPass(ZExtTransformPass()); } fpm.addPass(ResourceAnnotationPass(cfg, logger)); mpm.addPass(FunctionToModule(std::move(fpm))); }); registerAdaptorComponent<GroupingPassConfiguration>( \"adaptor.grouping\", [logger](GroupingPassConfiguration const& cfg, QirAdaptor& adaptor) { if (cfg.groupQis()) { auto& mam = adaptor.moduleAnalysisManager(); mam.registerPass([&] { return GroupingAnalysisPass(cfg, logger); }); auto& ret = adaptor.modulePassManager(); auto pass = GroupingPass(cfg); pass.setLogger(logger); ret.addPass(std::move(pass)); } }); } void QirAdaptorFactory::setLogger(ILoggerPtr const& logger) { logger_ = logger; } ConfigurationManager& QirAdaptorFactory::configurationManager() { return configuration_manager_; } ConfigurationManager const& QirAdaptorFactory::configurationManager() const { return configuration_manager_; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_qir_adaptor_factory_8hpp/","text":"AdaptorFactory/QirAdaptorFactory.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::QirAdaptorFactory Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AdaptorFactory/LlvmPassesConfiguration.hpp\" #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Passes/PostTransformValidation/PostTransformValidationPassConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include \"qir/qat/QirAdaptor/QirAdaptor.hpp\" namespace microsoft::quantum { class QirAdaptorFactory { public: // LLVM types // using PassBuilder = llvm::PassBuilder; using OptimizationLevel = llvm::OptimizationLevel; using FunctionAnalysisManager = llvm::FunctionAnalysisManager; using QirAdaptorPtr = std::shared_ptr<QirAdaptor>; using BasicAllocationManagerPtr = std::shared_ptr<BasicAllocationManager>; using FunctionPassManager = llvm::FunctionPassManager; template <typename R> using SetupFunction = std::function<void(R const&, QirAdaptor&)>; using SetupFunctionWrapper = std::function<void(QirAdaptorFactory&, QirAdaptor&)>; using Components = std::vector<std::pair<String, SetupFunctionWrapper>>; using ILoggerPtr = ILogger::ILoggerPtr; // Construction, moves and copies // explicit QirAdaptorFactory(ConfigurationManager& configuration_manager) : configuration_manager_{configuration_manager} { } ~QirAdaptorFactory() = default; QirAdaptorFactory(QirAdaptorFactory const&) = delete; QirAdaptorFactory(QirAdaptorFactory&&) = delete; QirAdaptorFactory& operator=(QirAdaptorFactory const&) = delete; QirAdaptorFactory& operator=(QirAdaptorFactory&&) = delete; // QirAdaptor generation interface // ConfigurationManager& configurationManager(); ConfigurationManager const& configurationManager() const; QirAdaptorPtr newQirAdaptor(String const& name, OptimizationLevel const& optimization_level, bool debug); void newAdaptorContext(String const& name, bool debug = false); void addComponent(String const& name); QirAdaptorPtr finalizeAdaptor(); // Defining the generator // template <typename R> void registerAdaptorComponent(String const& id, SetupFunction<R> setup); template <typename R> void replaceAdaptorComponent(String const& id, SetupFunction<R> setup); template <typename R> void registerAnonymousAdaptorComponent(SetupFunction<R> setup); void replicateAdaptorComponent(String const& id); bool isDebugMode() const; void setupDefaultComponentPipeline(); void setLogger(ILoggerPtr const& logger = nullptr); protected: llvm::ModulePassManager createValidationModulePass( PassBuilder& pass_builder, OptimizationLevel const& optimization_level, bool debug); private: ILoggerPtr logger_{nullptr}; ConfigurationManager& configuration_manager_; Components components_; bool debug_{false}; BasicAllocationManagerPtr qubit_allocation_manager_; BasicAllocationManagerPtr result_allocation_manager_; QirAdaptorPtr adaptor_{}; }; template <typename R> void QirAdaptorFactory::registerAdaptorComponent(String const& id, SetupFunction<R> setup) { configuration_manager_.addConfig<R>(id); // Ensuring that the adaptor configuration section can be disabled from the commandline configuration_manager_.allowDisableSectionById(id); auto setup_wrapper = [setup](QirAdaptorFactory& generator, QirAdaptor& adaptor) { if (generator.configuration_manager_.isActive<R>()) { auto& config = generator.configuration_manager_.get<R>(); setup(config, adaptor); } }; components_.push_back({id, std::move(setup_wrapper)}); } template <typename R> void QirAdaptorFactory::replaceAdaptorComponent(String const& id, SetupFunction<R> setup) { auto setup_wrapper = [setup](QirAdaptorFactory& generator, QirAdaptor& adaptor) { if (generator.configuration_manager_.isActive<R>()) { auto& config = generator.configuration_manager_.get<R>(); setup(config, adaptor); } }; for (auto& component : components_) { if (component.first == id) { component.second = std::move(setup_wrapper); return; } } throw std::runtime_error(\"Could not find component \" + id); } template <typename R> void QirAdaptorFactory::registerAnonymousAdaptorComponent(SetupFunction<R> setup) { if (!configuration_manager_.configWasRegistered<R>()) { throw std::runtime_error(\"Configuration '\" + static_cast<String>(typeid(R).name()) + \"' does not exist.\"); } auto setup_wrapper = [setup](QirAdaptorFactory& generation, QirAdaptor& adaptor) { if (generation.configuration_manager_.isActive<R>()) { auto& config = generation.configuration_manager_.get<R>(); setup(config, adaptor); } }; components_.push_back({\"__unnamed__\", std::move(setup_wrapper)}); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"AdaptorFactory/QirAdaptorFactory.hpp"},{"location":"Api/Files/_qir_adaptor_factory_8hpp/#adaptorfactoryqiradaptorfactoryhpp","text":"","title":"AdaptorFactory/QirAdaptorFactory.hpp"},{"location":"Api/Files/_qir_adaptor_factory_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_qir_adaptor_factory_8hpp/#classes","text":"Name class microsoft::quantum::QirAdaptorFactory","title":"Classes"},{"location":"Api/Files/_qir_adaptor_factory_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AdaptorFactory/LlvmPassesConfiguration.hpp\" #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Passes/PostTransformValidation/PostTransformValidationPassConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include \"qir/qat/QirAdaptor/QirAdaptor.hpp\" namespace microsoft::quantum { class QirAdaptorFactory { public: // LLVM types // using PassBuilder = llvm::PassBuilder; using OptimizationLevel = llvm::OptimizationLevel; using FunctionAnalysisManager = llvm::FunctionAnalysisManager; using QirAdaptorPtr = std::shared_ptr<QirAdaptor>; using BasicAllocationManagerPtr = std::shared_ptr<BasicAllocationManager>; using FunctionPassManager = llvm::FunctionPassManager; template <typename R> using SetupFunction = std::function<void(R const&, QirAdaptor&)>; using SetupFunctionWrapper = std::function<void(QirAdaptorFactory&, QirAdaptor&)>; using Components = std::vector<std::pair<String, SetupFunctionWrapper>>; using ILoggerPtr = ILogger::ILoggerPtr; // Construction, moves and copies // explicit QirAdaptorFactory(ConfigurationManager& configuration_manager) : configuration_manager_{configuration_manager} { } ~QirAdaptorFactory() = default; QirAdaptorFactory(QirAdaptorFactory const&) = delete; QirAdaptorFactory(QirAdaptorFactory&&) = delete; QirAdaptorFactory& operator=(QirAdaptorFactory const&) = delete; QirAdaptorFactory& operator=(QirAdaptorFactory&&) = delete; // QirAdaptor generation interface // ConfigurationManager& configurationManager(); ConfigurationManager const& configurationManager() const; QirAdaptorPtr newQirAdaptor(String const& name, OptimizationLevel const& optimization_level, bool debug); void newAdaptorContext(String const& name, bool debug = false); void addComponent(String const& name); QirAdaptorPtr finalizeAdaptor(); // Defining the generator // template <typename R> void registerAdaptorComponent(String const& id, SetupFunction<R> setup); template <typename R> void replaceAdaptorComponent(String const& id, SetupFunction<R> setup); template <typename R> void registerAnonymousAdaptorComponent(SetupFunction<R> setup); void replicateAdaptorComponent(String const& id); bool isDebugMode() const; void setupDefaultComponentPipeline(); void setLogger(ILoggerPtr const& logger = nullptr); protected: llvm::ModulePassManager createValidationModulePass( PassBuilder& pass_builder, OptimizationLevel const& optimization_level, bool debug); private: ILoggerPtr logger_{nullptr}; ConfigurationManager& configuration_manager_; Components components_; bool debug_{false}; BasicAllocationManagerPtr qubit_allocation_manager_; BasicAllocationManagerPtr result_allocation_manager_; QirAdaptorPtr adaptor_{}; }; template <typename R> void QirAdaptorFactory::registerAdaptorComponent(String const& id, SetupFunction<R> setup) { configuration_manager_.addConfig<R>(id); // Ensuring that the adaptor configuration section can be disabled from the commandline configuration_manager_.allowDisableSectionById(id); auto setup_wrapper = [setup](QirAdaptorFactory& generator, QirAdaptor& adaptor) { if (generator.configuration_manager_.isActive<R>()) { auto& config = generator.configuration_manager_.get<R>(); setup(config, adaptor); } }; components_.push_back({id, std::move(setup_wrapper)}); } template <typename R> void QirAdaptorFactory::replaceAdaptorComponent(String const& id, SetupFunction<R> setup) { auto setup_wrapper = [setup](QirAdaptorFactory& generator, QirAdaptor& adaptor) { if (generator.configuration_manager_.isActive<R>()) { auto& config = generator.configuration_manager_.get<R>(); setup(config, adaptor); } }; for (auto& component : components_) { if (component.first == id) { component.second = std::move(setup_wrapper); return; } } throw std::runtime_error(\"Could not find component \" + id); } template <typename R> void QirAdaptorFactory::registerAnonymousAdaptorComponent(SetupFunction<R> setup) { if (!configuration_manager_.configWasRegistered<R>()) { throw std::runtime_error(\"Configuration '\" + static_cast<String>(typeid(R).name()) + \"' does not exist.\"); } auto setup_wrapper = [setup](QirAdaptorFactory& generation, QirAdaptor& adaptor) { if (generation.configuration_manager_.isActive<R>()) { auto& config = generation.configuration_manager_.get<R>(); setup(config, adaptor); } }; components_.push_back({\"__unnamed__\", std::move(setup_wrapper)}); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_qubit_remap_pass_8cpp/","text":"Passes/StaticResourceComponent/QubitRemapPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/StaticResourceComponent/QubitRemapPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/AllocationAnalysisPass.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { QubitRemapPass::QubitRemapPass(StaticResourceComponentConfiguration const& cfg, ILoggerPtr const& logger) : config_{cfg} , logger_{logger} { } llvm::PreservedAnalyses QubitRemapPass::run(llvm::Function& function, llvm::FunctionAnalysisManager& fam) { if (!config_.shouldReindexQubits()) { return llvm::PreservedAnalyses::all(); } auto& function_details = fam.getResult<AllocationAnalysisPass>(function); llvm::IRBuilder<> builder{function.getContext()}; std::unordered_map<uint64_t, uint64_t> qubits_mapping{}; std::unordered_map<uint64_t, uint64_t> results_mapping{}; // Re-indexing for (auto const& value : function_details.resource_access) { auto const& index = value.index; switch (value.type) { case AllocationAnalysis::QubitResource: if (qubits_mapping.find(index) == qubits_mapping.end()) { qubits_mapping[index] = qubits_mapping.size(); } break; case AllocationAnalysis::ResultResource: if (results_mapping.find(index) == results_mapping.end()) { results_mapping[index] = results_mapping.size(); } break; case AllocationAnalysis::NotResource: break; } } // Updating values for (auto const& value : function_details.resource_access) { auto const& index = value.index; auto op = value.operand; auto pointer_type = llvm::dyn_cast<llvm::PointerType>(op->getType()); if (!pointer_type) { continue; } uint64_t remapped_index = value.index; switch (value.type) { case AllocationAnalysis::QubitResource: if (qubits_mapping.find(index) != qubits_mapping.end()) { remapped_index = qubits_mapping[index]; } break; case AllocationAnalysis::ResultResource: if (results_mapping.find(index) != results_mapping.end()) { remapped_index = results_mapping[index]; } break; case AllocationAnalysis::NotResource: continue; } builder.SetInsertPoint(value.used_by); // Removing non-null attribute if it exists as remapping may change this auto call_instr = llvm::dyn_cast<llvm::CallInst>(value.used_by); if (call_instr) { auto attrs = call_instr->getAttributes(); auto newlist = attrs.removeParamAttribute( function.getContext(), static_cast<uint32_t>(value.operand_id), llvm::Attribute::NonNull); call_instr->setAttributes(newlist); } // Creating replacement instruction auto idx = llvm::APInt(64, remapped_index); auto new_index = llvm::ConstantInt::get(function.getContext(), idx); llvm::Value* new_instr = nullptr; new_instr = nullptr; new_instr = new llvm::IntToPtrInst(new_index, pointer_type); builder.Insert(new_instr); value.used_by->setOperand(static_cast<uint32_t>(value.operand_id), new_instr); } return llvm::PreservedAnalyses::none(); } bool QubitRemapPass::isRequired() { return true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/StaticResourceComponent/QubitRemapPass.cpp"},{"location":"Api/Files/_qubit_remap_pass_8cpp/#passesstaticresourcecomponentqubitremappasscpp","text":"","title":"Passes/StaticResourceComponent/QubitRemapPass.cpp"},{"location":"Api/Files/_qubit_remap_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_qubit_remap_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/StaticResourceComponent/QubitRemapPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/AllocationAnalysisPass.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { QubitRemapPass::QubitRemapPass(StaticResourceComponentConfiguration const& cfg, ILoggerPtr const& logger) : config_{cfg} , logger_{logger} { } llvm::PreservedAnalyses QubitRemapPass::run(llvm::Function& function, llvm::FunctionAnalysisManager& fam) { if (!config_.shouldReindexQubits()) { return llvm::PreservedAnalyses::all(); } auto& function_details = fam.getResult<AllocationAnalysisPass>(function); llvm::IRBuilder<> builder{function.getContext()}; std::unordered_map<uint64_t, uint64_t> qubits_mapping{}; std::unordered_map<uint64_t, uint64_t> results_mapping{}; // Re-indexing for (auto const& value : function_details.resource_access) { auto const& index = value.index; switch (value.type) { case AllocationAnalysis::QubitResource: if (qubits_mapping.find(index) == qubits_mapping.end()) { qubits_mapping[index] = qubits_mapping.size(); } break; case AllocationAnalysis::ResultResource: if (results_mapping.find(index) == results_mapping.end()) { results_mapping[index] = results_mapping.size(); } break; case AllocationAnalysis::NotResource: break; } } // Updating values for (auto const& value : function_details.resource_access) { auto const& index = value.index; auto op = value.operand; auto pointer_type = llvm::dyn_cast<llvm::PointerType>(op->getType()); if (!pointer_type) { continue; } uint64_t remapped_index = value.index; switch (value.type) { case AllocationAnalysis::QubitResource: if (qubits_mapping.find(index) != qubits_mapping.end()) { remapped_index = qubits_mapping[index]; } break; case AllocationAnalysis::ResultResource: if (results_mapping.find(index) != results_mapping.end()) { remapped_index = results_mapping[index]; } break; case AllocationAnalysis::NotResource: continue; } builder.SetInsertPoint(value.used_by); // Removing non-null attribute if it exists as remapping may change this auto call_instr = llvm::dyn_cast<llvm::CallInst>(value.used_by); if (call_instr) { auto attrs = call_instr->getAttributes(); auto newlist = attrs.removeParamAttribute( function.getContext(), static_cast<uint32_t>(value.operand_id), llvm::Attribute::NonNull); call_instr->setAttributes(newlist); } // Creating replacement instruction auto idx = llvm::APInt(64, remapped_index); auto new_index = llvm::ConstantInt::get(function.getContext(), idx); llvm::Value* new_instr = nullptr; new_instr = nullptr; new_instr = new llvm::IntToPtrInst(new_index, pointer_type); builder.Insert(new_instr); value.used_by->setOperand(static_cast<uint32_t>(value.operand_id), new_instr); } return llvm::PreservedAnalyses::none(); } bool QubitRemapPass::isRequired() { return true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_qubit_remap_pass_8hpp/","text":"Passes/StaticResourceComponent/QubitRemapPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::QubitRemapPass Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class QubitRemapPass : public llvm::PassInfoMixin<QubitRemapPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using Location = ILogger::Location; using StringRef = llvm::StringRef; enum ResourceType { None, Qubit, Result }; // Construction and destruction configuration. // explicit QubitRemapPass(StaticResourceComponentConfiguration const& cfg, ILoggerPtr const& logger = nullptr); QubitRemapPass(QubitRemapPass const&) = delete; QubitRemapPass(QubitRemapPass&&) = default; ~QubitRemapPass() = default; llvm::PreservedAnalyses run(llvm::Function& function, llvm::FunctionAnalysisManager& mam); static bool isRequired(); private: bool extractResourceId(llvm::Value* value, uint64_t& return_value, ResourceType& type) const; StaticResourceComponentConfiguration config_{}; ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/StaticResourceComponent/QubitRemapPass.hpp"},{"location":"Api/Files/_qubit_remap_pass_8hpp/#passesstaticresourcecomponentqubitremappasshpp","text":"","title":"Passes/StaticResourceComponent/QubitRemapPass.hpp"},{"location":"Api/Files/_qubit_remap_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_qubit_remap_pass_8hpp/#classes","text":"Name class microsoft::quantum::QubitRemapPass","title":"Classes"},{"location":"Api/Files/_qubit_remap_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class QubitRemapPass : public llvm::PassInfoMixin<QubitRemapPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using Location = ILogger::Location; using StringRef = llvm::StringRef; enum ResourceType { None, Qubit, Result }; // Construction and destruction configuration. // explicit QubitRemapPass(StaticResourceComponentConfiguration const& cfg, ILoggerPtr const& logger = nullptr); QubitRemapPass(QubitRemapPass const&) = delete; QubitRemapPass(QubitRemapPass&&) = default; ~QubitRemapPass() = default; llvm::PreservedAnalyses run(llvm::Function& function, llvm::FunctionAnalysisManager& mam); static bool isRequired(); private: bool extractResourceId(llvm::Value* value, uint64_t& return_value, ResourceType& type) const; StaticResourceComponentConfiguration config_{}; ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_remove_disallowed_attributes_pass_8hpp/","text":"Passes/RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::RemoveDisallowedAttributesPass Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/SpecConfiguration.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_set> #include <vector> namespace microsoft::quantum { class RemoveDisallowedAttributesPass : public llvm::PassInfoMixin<RemoveDisallowedAttributesPass> { public: explicit RemoveDisallowedAttributesPass(SpecConfiguration const& spec) : allowed_attrs_{ static_cast<String>(spec.entryPointAttr()), static_cast<String>(spec.qirProfilesAttr()), static_cast<String>(spec.outputLabelingSchemaAttr()), static_cast<String>(spec.requiredNumQubitsAttr()), static_cast<String>(spec.requiredNumResultsAttr()), static_cast<String>(spec.replaceWithAttr()), static_cast<String>(spec.irreversibleAttr()), } { } llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { for (auto& fnc : module) { std::unordered_map<String, String> to_keep; auto name = static_cast<std::string>(fnc.getName()); // Skipping any LLVM function if (fnc.isIntrinsic()) { continue; } // Finding all valid attributes for (auto& attrset : fnc.getAttributes()) { for (auto& attr : attrset) { auto r = static_cast<String>(attr.getAsString()); std::string value{}; auto p = r.find('='); if (p != std::string::npos) { value = r.substr(p + 1, r.size() - p - 1); r = r.substr(0, p); } // Stripping quotes if (r.size() >= 2 && r[0] == '\"' && r[r.size() - 1] == '\"') { r = r.substr(1, r.size() - 2); } if (value.size() >= 2 && value[0] == '\"' && value[value.size() - 1] == '\"') { value = value.substr(1, value.size() - 2); } // Inserting if allowed if (allowed_attrs_.find(r) != allowed_attrs_.end()) { to_keep.insert(std::make_pair(r, value)); } } } // Deleting every fnc.setAttributes({}); for (auto& attr : to_keep) { if (attr.second.empty()) { fnc.addFnAttr(attr.first); } else { fnc.addFnAttr(attr.first, attr.second); } } // Updating all users attributes for (auto user : fnc.users()) { auto call = llvm::dyn_cast<llvm::CallInst>(user); if (call != nullptr) { call->setAttributes(fnc.getAttributes()); } } } return llvm::PreservedAnalyses::none(); } private: std::unordered_set<String> allowed_attrs_; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp"},{"location":"Api/Files/_remove_disallowed_attributes_pass_8hpp/#passesremovedisallowedattributespassremovedisallowedattributespasshpp","text":"","title":"Passes/RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp"},{"location":"Api/Files/_remove_disallowed_attributes_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_remove_disallowed_attributes_pass_8hpp/#classes","text":"Name class microsoft::quantum::RemoveDisallowedAttributesPass","title":"Classes"},{"location":"Api/Files/_remove_disallowed_attributes_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/SpecConfiguration.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_set> #include <vector> namespace microsoft::quantum { class RemoveDisallowedAttributesPass : public llvm::PassInfoMixin<RemoveDisallowedAttributesPass> { public: explicit RemoveDisallowedAttributesPass(SpecConfiguration const& spec) : allowed_attrs_{ static_cast<String>(spec.entryPointAttr()), static_cast<String>(spec.qirProfilesAttr()), static_cast<String>(spec.outputLabelingSchemaAttr()), static_cast<String>(spec.requiredNumQubitsAttr()), static_cast<String>(spec.requiredNumResultsAttr()), static_cast<String>(spec.replaceWithAttr()), static_cast<String>(spec.irreversibleAttr()), } { } llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { for (auto& fnc : module) { std::unordered_map<String, String> to_keep; auto name = static_cast<std::string>(fnc.getName()); // Skipping any LLVM function if (fnc.isIntrinsic()) { continue; } // Finding all valid attributes for (auto& attrset : fnc.getAttributes()) { for (auto& attr : attrset) { auto r = static_cast<String>(attr.getAsString()); std::string value{}; auto p = r.find('='); if (p != std::string::npos) { value = r.substr(p + 1, r.size() - p - 1); r = r.substr(0, p); } // Stripping quotes if (r.size() >= 2 && r[0] == '\"' && r[r.size() - 1] == '\"') { r = r.substr(1, r.size() - 2); } if (value.size() >= 2 && value[0] == '\"' && value[value.size() - 1] == '\"') { value = value.substr(1, value.size() - 2); } // Inserting if allowed if (allowed_attrs_.find(r) != allowed_attrs_.end()) { to_keep.insert(std::make_pair(r, value)); } } } // Deleting every fnc.setAttributes({}); for (auto& attr : to_keep) { if (attr.second.empty()) { fnc.addFnAttr(attr.first); } else { fnc.addFnAttr(attr.first, attr.second); } } // Updating all users attributes for (auto user : fnc.users()) { auto call = llvm::dyn_cast<llvm::CallInst>(user); if (call != nullptr) { call->setAttributes(fnc.getAttributes()); } } } return llvm::PreservedAnalyses::none(); } private: std::unordered_set<String> allowed_attrs_; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_remove_non_entrypoint_functions_pass_8cpp/","text":"Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { RemoveNonEntrypointFunctionsPass::RemoveNonEntrypointFunctionsPass( RemoveNonEntrypointFunctionsPassConfiguration const& cfg, ILoggerPtr const& logger) : config_{cfg} , logger_{logger} { } llvm::PreservedAnalyses RemoveNonEntrypointFunctionsPass::run( llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { std::vector<llvm::Function*> deletables; auto entry_point_attr = config_.entryPointAttr(); for (auto& function : module) { if (function.isDeclaration()) { continue; } if (function.hasFnAttribute(entry_point_attr)) { continue; } deletables.push_back(&function); } for (auto& x : deletables) { if (x->use_empty()) { x->eraseFromParent(); } } return llvm::PreservedAnalyses::none(); } bool RemoveNonEntrypointFunctionsPass::isRequired() { return true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPass.cpp"},{"location":"Api/Files/_remove_non_entrypoint_functions_pass_8cpp/#passesremovenonentrypointfunctionsremovenonentrypointfunctionspasscpp","text":"","title":"Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPass.cpp"},{"location":"Api/Files/_remove_non_entrypoint_functions_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_remove_non_entrypoint_functions_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { RemoveNonEntrypointFunctionsPass::RemoveNonEntrypointFunctionsPass( RemoveNonEntrypointFunctionsPassConfiguration const& cfg, ILoggerPtr const& logger) : config_{cfg} , logger_{logger} { } llvm::PreservedAnalyses RemoveNonEntrypointFunctionsPass::run( llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { std::vector<llvm::Function*> deletables; auto entry_point_attr = config_.entryPointAttr(); for (auto& function : module) { if (function.isDeclaration()) { continue; } if (function.hasFnAttribute(entry_point_attr)) { continue; } deletables.push_back(&function); } for (auto& x : deletables) { if (x->use_empty()) { x->eraseFromParent(); } } return llvm::PreservedAnalyses::none(); } bool RemoveNonEntrypointFunctionsPass::isRequired() { return true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_remove_non_entrypoint_functions_pass_8hpp/","text":"Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::RemoveNonEntrypointFunctionsPass Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPass.hpp\" #include \"qir/qat/Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPassConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class RemoveNonEntrypointFunctionsPass : public llvm::PassInfoMixin<RemoveNonEntrypointFunctionsPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using Location = ILogger::Location; using StringRef = llvm::StringRef; // Construction and destruction configuration. // explicit RemoveNonEntrypointFunctionsPass( RemoveNonEntrypointFunctionsPassConfiguration const& cfg, ILoggerPtr const& logger = nullptr); RemoveNonEntrypointFunctionsPass(RemoveNonEntrypointFunctionsPass const&) = delete; RemoveNonEntrypointFunctionsPass(RemoveNonEntrypointFunctionsPass&&) = default; ~RemoveNonEntrypointFunctionsPass() = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired(); private: using Locations = std::vector<Location>; RemoveNonEntrypointFunctionsPassConfiguration config_{}; ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPass.hpp"},{"location":"Api/Files/_remove_non_entrypoint_functions_pass_8hpp/#passesremovenonentrypointfunctionsremovenonentrypointfunctionspasshpp","text":"","title":"Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPass.hpp"},{"location":"Api/Files/_remove_non_entrypoint_functions_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_remove_non_entrypoint_functions_pass_8hpp/#classes","text":"Name class microsoft::quantum::RemoveNonEntrypointFunctionsPass","title":"Classes"},{"location":"Api/Files/_remove_non_entrypoint_functions_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPass.hpp\" #include \"qir/qat/Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPassConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class RemoveNonEntrypointFunctionsPass : public llvm::PassInfoMixin<RemoveNonEntrypointFunctionsPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using Location = ILogger::Location; using StringRef = llvm::StringRef; // Construction and destruction configuration. // explicit RemoveNonEntrypointFunctionsPass( RemoveNonEntrypointFunctionsPassConfiguration const& cfg, ILoggerPtr const& logger = nullptr); RemoveNonEntrypointFunctionsPass(RemoveNonEntrypointFunctionsPass const&) = delete; RemoveNonEntrypointFunctionsPass(RemoveNonEntrypointFunctionsPass&&) = default; ~RemoveNonEntrypointFunctionsPass() = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired(); private: using Locations = std::vector<Location>; RemoveNonEntrypointFunctionsPassConfiguration config_{}; ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_remove_non_entrypoint_functions_pass_configuration_8hpp/","text":"Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPassConfiguration.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::RemoveNonEntrypointFunctionsPassConfiguration Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include <limits> namespace microsoft::quantum { class RemoveNonEntrypointFunctionsPassConfiguration { public: using DeferredValuePtr = DeferredValue::DeferredValuePtr; void setup(ConfigurationManager& config) { config.setSectionName(\"Remove Non-Entrypoint Functions\", \"\"); entry_point_attr_ = config.getParameter(\"entry-point-attr\"); } static RemoveNonEntrypointFunctionsPassConfiguration createDisabled() { RemoveNonEntrypointFunctionsPassConfiguration ret; return ret; } std::string entryPointAttr() const { return entry_point_attr_->value<std::string>(); } private: DeferredValuePtr entry_point_attr_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPassConfiguration.hpp"},{"location":"Api/Files/_remove_non_entrypoint_functions_pass_configuration_8hpp/#passesremovenonentrypointfunctionsremovenonentrypointfunctionspassconfigurationhpp","text":"","title":"Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPassConfiguration.hpp"},{"location":"Api/Files/_remove_non_entrypoint_functions_pass_configuration_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_remove_non_entrypoint_functions_pass_configuration_8hpp/#classes","text":"Name class microsoft::quantum::RemoveNonEntrypointFunctionsPassConfiguration","title":"Classes"},{"location":"Api/Files/_remove_non_entrypoint_functions_pass_configuration_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include <limits> namespace microsoft::quantum { class RemoveNonEntrypointFunctionsPassConfiguration { public: using DeferredValuePtr = DeferredValue::DeferredValuePtr; void setup(ConfigurationManager& config) { config.setSectionName(\"Remove Non-Entrypoint Functions\", \"\"); entry_point_attr_ = config.getParameter(\"entry-point-attr\"); } static RemoveNonEntrypointFunctionsPassConfiguration createDisabled() { RemoveNonEntrypointFunctionsPassConfiguration ret; return ret; } std::string entryPointAttr() const { return entry_point_attr_->value<std::string>(); } private: DeferredValuePtr entry_point_attr_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_replace_qubit_on_reset_pass_8cpp/","text":"Passes/StaticResourceComponent/ReplaceQubitOnResetPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/StaticResourceComponent/ReplaceQubitOnResetPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/AllocationAnalysisPass.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { ReplaceQubitOnResetPass::ReplaceQubitOnResetPass( StaticResourceComponentConfiguration const& cfg, ILoggerPtr const& logger) : config_{cfg} , logger_{logger} { } llvm::PreservedAnalyses ReplaceQubitOnResetPass::run(llvm::Function& function, llvm::FunctionAnalysisManager& fam) { if (!config_.shouldReplaceQubitsOnReset()) { return llvm::PreservedAnalyses::all(); } auto& function_details = fam.getResult<AllocationAnalysisPass>(function); auto& access_map = function_details.access_map; llvm::IRBuilder<> builder{function.getContext()}; std::unordered_map<uint64_t, uint64_t> qubits_mapping{}; std::unordered_map<uint64_t, uint64_t> results_mapping{}; // Re-indexing for (auto const& value : function_details.resource_access) { auto const& index = value.index; switch (value.type) { case AllocationAnalysis::QubitResource: if (qubits_mapping.find(index) == qubits_mapping.end()) { qubits_mapping[index] = index; } break; case AllocationAnalysis::ResultResource: if (results_mapping.find(index) == results_mapping.end()) { results_mapping[index] = index; } break; case AllocationAnalysis::NotResource: break; } } uint64_t next_qubit_index = qubits_mapping.size(); std::unordered_set<llvm::Value*> already_replaced{}; std::vector<llvm::Instruction*> to_remove{}; // Updating values for (auto& block : function) { for (auto& instr : block) { auto call_instr = llvm::dyn_cast<llvm::CallInst>(&instr); if (call_instr) { auto f = call_instr->getCalledFunction(); if (f == nullptr) { continue; } auto call_name = static_cast<std::string>(f->getName()); if (call_name == \"__quantum__qis__reset__body\") { auto op = call_instr->getOperand(0); auto it = access_map.find(op); if (it != access_map.end()) { qubits_mapping[it->second.index] = next_qubit_index++; to_remove.push_back(&instr); } continue; } } for (uint64_t i = 0; i < instr.getNumOperands(); ++i) { auto op = instr.getOperand(static_cast<uint32_t>(i)); // In case we already did the mapping, we skip to next instruction if (already_replaced.find(op) != already_replaced.end()) { continue; } // We only perform the mapping for constant integer casts. Anything else // cannot be remapped. auto it = access_map.find(op); if (it != access_map.end()) { auto n = it->second.index; auto& type = it->second.type; uint64_t remapped_index = 0; // Getting remapped index based on resource type if (type == AllocationAnalysis::QubitResource) { if (qubits_mapping.find(n) != qubits_mapping.end()) { remapped_index = qubits_mapping[n]; } else { if (logger_) { logger_->setLocationFromValue(op); logger_->internalError(\"Original qubit index not found.\"); } else { throw std::runtime_error(\"Original qubit index not found.\"); } continue; } } else if (type == AllocationAnalysis::ResultResource) { if (results_mapping.find(n) != results_mapping.end()) { remapped_index = results_mapping[n]; } else { if (logger_) { logger_->setLocationFromValue(op); logger_->internalError(\"Original result index not found.\"); } else { throw std::runtime_error(\"Original result index not found.\"); } continue; } } else { if (logger_) { logger_->setLocationFromValue(op); logger_->internalError(\"Operand class could not be determined\"); } else { throw std::runtime_error(\"Operand class could not be determined\"); } continue; } auto pointer_type = llvm::dyn_cast<llvm::PointerType>(op->getType()); if (!pointer_type) { continue; } // Removing operand nonnull if present if (call_instr) { auto attrs = call_instr->getAttributes(); auto newlist = attrs.removeParamAttribute( function.getContext(), static_cast<uint32_t>(i), llvm::Attribute::NonNull); call_instr->setAttributes(newlist); } // Creating new instruction with remapped index builder.SetInsertPoint(&instr); auto idx = llvm::APInt(64, remapped_index); auto new_index = llvm::ConstantInt::get(function.getContext(), idx); llvm::Value* new_instr = nullptr; new_instr = nullptr; new_instr = new llvm::IntToPtrInst(new_index, pointer_type); builder.Insert(new_instr); auto op_as_instr = llvm::dyn_cast<llvm::Instruction>(op); if (op_as_instr) { to_remove.push_back(op_as_instr); } instr.setOperand(static_cast<uint32_t>(i), new_instr); already_replaced.insert(new_instr); } } } } // Removing reset instructions std::reverse(to_remove.begin(), to_remove.end()); for (auto ptr : to_remove) { if (ptr->use_empty()) { ptr->eraseFromParent(); } } return llvm::PreservedAnalyses::none(); } bool ReplaceQubitOnResetPass::isRequired() { return true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/StaticResourceComponent/ReplaceQubitOnResetPass.cpp"},{"location":"Api/Files/_replace_qubit_on_reset_pass_8cpp/#passesstaticresourcecomponentreplacequbitonresetpasscpp","text":"","title":"Passes/StaticResourceComponent/ReplaceQubitOnResetPass.cpp"},{"location":"Api/Files/_replace_qubit_on_reset_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_replace_qubit_on_reset_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/StaticResourceComponent/ReplaceQubitOnResetPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/AllocationAnalysisPass.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { ReplaceQubitOnResetPass::ReplaceQubitOnResetPass( StaticResourceComponentConfiguration const& cfg, ILoggerPtr const& logger) : config_{cfg} , logger_{logger} { } llvm::PreservedAnalyses ReplaceQubitOnResetPass::run(llvm::Function& function, llvm::FunctionAnalysisManager& fam) { if (!config_.shouldReplaceQubitsOnReset()) { return llvm::PreservedAnalyses::all(); } auto& function_details = fam.getResult<AllocationAnalysisPass>(function); auto& access_map = function_details.access_map; llvm::IRBuilder<> builder{function.getContext()}; std::unordered_map<uint64_t, uint64_t> qubits_mapping{}; std::unordered_map<uint64_t, uint64_t> results_mapping{}; // Re-indexing for (auto const& value : function_details.resource_access) { auto const& index = value.index; switch (value.type) { case AllocationAnalysis::QubitResource: if (qubits_mapping.find(index) == qubits_mapping.end()) { qubits_mapping[index] = index; } break; case AllocationAnalysis::ResultResource: if (results_mapping.find(index) == results_mapping.end()) { results_mapping[index] = index; } break; case AllocationAnalysis::NotResource: break; } } uint64_t next_qubit_index = qubits_mapping.size(); std::unordered_set<llvm::Value*> already_replaced{}; std::vector<llvm::Instruction*> to_remove{}; // Updating values for (auto& block : function) { for (auto& instr : block) { auto call_instr = llvm::dyn_cast<llvm::CallInst>(&instr); if (call_instr) { auto f = call_instr->getCalledFunction(); if (f == nullptr) { continue; } auto call_name = static_cast<std::string>(f->getName()); if (call_name == \"__quantum__qis__reset__body\") { auto op = call_instr->getOperand(0); auto it = access_map.find(op); if (it != access_map.end()) { qubits_mapping[it->second.index] = next_qubit_index++; to_remove.push_back(&instr); } continue; } } for (uint64_t i = 0; i < instr.getNumOperands(); ++i) { auto op = instr.getOperand(static_cast<uint32_t>(i)); // In case we already did the mapping, we skip to next instruction if (already_replaced.find(op) != already_replaced.end()) { continue; } // We only perform the mapping for constant integer casts. Anything else // cannot be remapped. auto it = access_map.find(op); if (it != access_map.end()) { auto n = it->second.index; auto& type = it->second.type; uint64_t remapped_index = 0; // Getting remapped index based on resource type if (type == AllocationAnalysis::QubitResource) { if (qubits_mapping.find(n) != qubits_mapping.end()) { remapped_index = qubits_mapping[n]; } else { if (logger_) { logger_->setLocationFromValue(op); logger_->internalError(\"Original qubit index not found.\"); } else { throw std::runtime_error(\"Original qubit index not found.\"); } continue; } } else if (type == AllocationAnalysis::ResultResource) { if (results_mapping.find(n) != results_mapping.end()) { remapped_index = results_mapping[n]; } else { if (logger_) { logger_->setLocationFromValue(op); logger_->internalError(\"Original result index not found.\"); } else { throw std::runtime_error(\"Original result index not found.\"); } continue; } } else { if (logger_) { logger_->setLocationFromValue(op); logger_->internalError(\"Operand class could not be determined\"); } else { throw std::runtime_error(\"Operand class could not be determined\"); } continue; } auto pointer_type = llvm::dyn_cast<llvm::PointerType>(op->getType()); if (!pointer_type) { continue; } // Removing operand nonnull if present if (call_instr) { auto attrs = call_instr->getAttributes(); auto newlist = attrs.removeParamAttribute( function.getContext(), static_cast<uint32_t>(i), llvm::Attribute::NonNull); call_instr->setAttributes(newlist); } // Creating new instruction with remapped index builder.SetInsertPoint(&instr); auto idx = llvm::APInt(64, remapped_index); auto new_index = llvm::ConstantInt::get(function.getContext(), idx); llvm::Value* new_instr = nullptr; new_instr = nullptr; new_instr = new llvm::IntToPtrInst(new_index, pointer_type); builder.Insert(new_instr); auto op_as_instr = llvm::dyn_cast<llvm::Instruction>(op); if (op_as_instr) { to_remove.push_back(op_as_instr); } instr.setOperand(static_cast<uint32_t>(i), new_instr); already_replaced.insert(new_instr); } } } } // Removing reset instructions std::reverse(to_remove.begin(), to_remove.end()); for (auto ptr : to_remove) { if (ptr->use_empty()) { ptr->eraseFromParent(); } } return llvm::PreservedAnalyses::none(); } bool ReplaceQubitOnResetPass::isRequired() { return true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_replace_qubit_on_reset_pass_8hpp/","text":"Passes/StaticResourceComponent/ReplaceQubitOnResetPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ReplaceQubitOnResetPass Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class ReplaceQubitOnResetPass : public llvm::PassInfoMixin<ReplaceQubitOnResetPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using Location = ILogger::Location; using StringRef = llvm::StringRef; // Construction and destruction configuration. // explicit ReplaceQubitOnResetPass( StaticResourceComponentConfiguration const& cfg, ILoggerPtr const& logger = nullptr); ReplaceQubitOnResetPass(ReplaceQubitOnResetPass const&) = delete; ReplaceQubitOnResetPass(ReplaceQubitOnResetPass&&) = default; ~ReplaceQubitOnResetPass() = default; llvm::PreservedAnalyses run(llvm::Function& function, llvm::FunctionAnalysisManager& mam); static bool isRequired(); private: StaticResourceComponentConfiguration config_{}; ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/StaticResourceComponent/ReplaceQubitOnResetPass.hpp"},{"location":"Api/Files/_replace_qubit_on_reset_pass_8hpp/#passesstaticresourcecomponentreplacequbitonresetpasshpp","text":"","title":"Passes/StaticResourceComponent/ReplaceQubitOnResetPass.hpp"},{"location":"Api/Files/_replace_qubit_on_reset_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_replace_qubit_on_reset_pass_8hpp/#classes","text":"Name class microsoft::quantum::ReplaceQubitOnResetPass","title":"Classes"},{"location":"Api/Files/_replace_qubit_on_reset_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class ReplaceQubitOnResetPass : public llvm::PassInfoMixin<ReplaceQubitOnResetPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using Location = ILogger::Location; using StringRef = llvm::StringRef; // Construction and destruction configuration. // explicit ReplaceQubitOnResetPass( StaticResourceComponentConfiguration const& cfg, ILoggerPtr const& logger = nullptr); ReplaceQubitOnResetPass(ReplaceQubitOnResetPass const&) = delete; ReplaceQubitOnResetPass(ReplaceQubitOnResetPass&&) = default; ~ReplaceQubitOnResetPass() = default; llvm::PreservedAnalyses run(llvm::Function& function, llvm::FunctionAnalysisManager& mam); static bool isRequired(); private: StaticResourceComponentConfiguration config_{}; ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_replacement_rule_8cpp/","text":"Rules/ReplacementRule.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Rules/ReplacementRule.hpp\" namespace microsoft::quantum { ReplacementRule::ReplacementRule(IOperandPrototypePtr&& pattern, ReplaceFunction&& replacer) : pattern_{std::move(pattern)} , replacer_{std::move(replacer)} { } ReplacementRule::ReplacementRule(String const& name, IOperandPrototypePtr&& pattern, ReplaceFunction&& replacer) : pattern_{std::move(pattern)} , replacer_{std::move(replacer)} , name_{name} { } void ReplacementRule::setPattern(IOperandPrototypePtr&& pattern) { pattern_ = std::move(pattern); } void ReplacementRule::setReplacer(ReplaceFunction const& replacer) { replacer_ = replacer; } bool ReplacementRule::match(Value* value, Captures& captures) const { if (pattern_ == nullptr) { return false; } return pattern_->match(value, captures); } bool ReplacementRule::replace(Builder& builder, Value* value, Captures& captures, Replacements& replacements) const { if (replacer_) { auto ret = replacer_(builder, value, captures, replacements); // In case replacement failed, the captures are deleted. if (!ret) { captures.clear(); } return ret; } return false; } String ReplacementRule::name() const { return name_; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/ReplacementRule.cpp"},{"location":"Api/Files/_replacement_rule_8cpp/#rulesreplacementrulecpp","text":"","title":"Rules/ReplacementRule.cpp"},{"location":"Api/Files/_replacement_rule_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_replacement_rule_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Rules/ReplacementRule.hpp\" namespace microsoft::quantum { ReplacementRule::ReplacementRule(IOperandPrototypePtr&& pattern, ReplaceFunction&& replacer) : pattern_{std::move(pattern)} , replacer_{std::move(replacer)} { } ReplacementRule::ReplacementRule(String const& name, IOperandPrototypePtr&& pattern, ReplaceFunction&& replacer) : pattern_{std::move(pattern)} , replacer_{std::move(replacer)} , name_{name} { } void ReplacementRule::setPattern(IOperandPrototypePtr&& pattern) { pattern_ = std::move(pattern); } void ReplacementRule::setReplacer(ReplaceFunction const& replacer) { replacer_ = replacer; } bool ReplacementRule::match(Value* value, Captures& captures) const { if (pattern_ == nullptr) { return false; } return pattern_->match(value, captures); } bool ReplacementRule::replace(Builder& builder, Value* value, Captures& captures, Replacements& replacements) const { if (replacer_) { auto ret = replacer_(builder, value, captures, replacements); // In case replacement failed, the captures are deleted. if (!ret) { captures.clear(); } return ret; } return false; } String ReplacementRule::name() const { return name_; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_replacement_rule_8hpp/","text":"Rules/ReplacementRule.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ReplacementRule Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { class ReplacementRule { public: using Captures = IOperandPrototype::Captures; using Value = llvm::Value; using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; using Builder = llvm::IRBuilder<>; using Replacements = std::vector<std::pair<Value*, Value*>>; using ReplaceFunction = std::function<bool(Builder&, Value*, Captures&, Replacements&)>; // Constructors and destructors // ReplacementRule() = default; ReplacementRule(String const& name, IOperandPrototypePtr&& pattern, ReplaceFunction&& replacer); ReplacementRule(IOperandPrototypePtr&& pattern, ReplaceFunction&& replacer); // Rule configuration // void setPattern(IOperandPrototypePtr&& pattern); void setReplacer(ReplaceFunction const& replacer); // Operation // bool match(Value* value, Captures& captures) const; bool replace(Builder& builder, Value* value, Captures& captures, Replacements& replacements) const; String name() const; private: IOperandPrototypePtr pattern_{nullptr}; ReplaceFunction replacer_{nullptr}; String name_{\"unnamed\"}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/ReplacementRule.hpp"},{"location":"Api/Files/_replacement_rule_8hpp/#rulesreplacementrulehpp","text":"","title":"Rules/ReplacementRule.hpp"},{"location":"Api/Files/_replacement_rule_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_replacement_rule_8hpp/#classes","text":"Name class microsoft::quantum::ReplacementRule","title":"Classes"},{"location":"Api/Files/_replacement_rule_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { class ReplacementRule { public: using Captures = IOperandPrototype::Captures; using Value = llvm::Value; using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; using Builder = llvm::IRBuilder<>; using Replacements = std::vector<std::pair<Value*, Value*>>; using ReplaceFunction = std::function<bool(Builder&, Value*, Captures&, Replacements&)>; // Constructors and destructors // ReplacementRule() = default; ReplacementRule(String const& name, IOperandPrototypePtr&& pattern, ReplaceFunction&& replacer); ReplacementRule(IOperandPrototypePtr&& pattern, ReplaceFunction&& replacer); // Rule configuration // void setPattern(IOperandPrototypePtr&& pattern); void setReplacer(ReplaceFunction const& replacer); // Operation // bool match(Value* value, Captures& captures) const; bool replace(Builder& builder, Value* value, Captures& captures, Replacements& replacements) const; String name() const; private: IOperandPrototypePtr pattern_{nullptr}; ReplaceFunction replacer_{nullptr}; String name_{\"unnamed\"}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_resource_annotation_pass_8cpp/","text":"Passes/StaticResourceComponent/ResourceAnnotationPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/StaticResourceComponent/ResourceAnnotationPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/AllocationAnalysisPass.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { ResourceAnnotationPass::ResourceAnnotationPass( StaticResourceComponentConfiguration const& cfg, ILoggerPtr const& logger) : config_{cfg} , logger_{logger} { } llvm::PreservedAnalyses ResourceAnnotationPass::run(llvm::Function& function, llvm::FunctionAnalysisManager& fam) { if (!config_.shouldAnnotateResultUse() && !config_.shouldAnnotateQubitUse()) { return llvm::PreservedAnalyses::all(); } auto stats = fam.getResult<AllocationAnalysisPass>(function); if (config_.shouldAnnotateQubitUse()) { std::stringstream ss{\"\"}; ss << stats.usage_qubit_counts; function.addFnAttr(config_.requiredNumQubitsAttr(), ss.str()); } if (config_.shouldAnnotateMaxQubitIndex()) { std::stringstream ss{\"\"}; ss << stats.largest_qubit_index; function.addFnAttr(config_.maxIndexQubitsAttr(), ss.str()); } if (config_.shouldAnnotateResultUse()) { std::stringstream ss{\"\"}; ss << stats.usage_result_counts; function.addFnAttr(config_.requiredNumResultsAttr(), ss.str()); } if (config_.shouldAnnotateMaxResultIndex()) { std::stringstream ss{\"\"}; ss << stats.largest_result_index; function.addFnAttr(config_.maxIndexResultsAttr(), ss.str()); } return llvm::PreservedAnalyses::none(); } bool ResourceAnnotationPass::isRequired() { return true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/StaticResourceComponent/ResourceAnnotationPass.cpp"},{"location":"Api/Files/_resource_annotation_pass_8cpp/#passesstaticresourcecomponentresourceannotationpasscpp","text":"","title":"Passes/StaticResourceComponent/ResourceAnnotationPass.cpp"},{"location":"Api/Files/_resource_annotation_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_resource_annotation_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/StaticResourceComponent/ResourceAnnotationPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/AllocationAnalysisPass.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { ResourceAnnotationPass::ResourceAnnotationPass( StaticResourceComponentConfiguration const& cfg, ILoggerPtr const& logger) : config_{cfg} , logger_{logger} { } llvm::PreservedAnalyses ResourceAnnotationPass::run(llvm::Function& function, llvm::FunctionAnalysisManager& fam) { if (!config_.shouldAnnotateResultUse() && !config_.shouldAnnotateQubitUse()) { return llvm::PreservedAnalyses::all(); } auto stats = fam.getResult<AllocationAnalysisPass>(function); if (config_.shouldAnnotateQubitUse()) { std::stringstream ss{\"\"}; ss << stats.usage_qubit_counts; function.addFnAttr(config_.requiredNumQubitsAttr(), ss.str()); } if (config_.shouldAnnotateMaxQubitIndex()) { std::stringstream ss{\"\"}; ss << stats.largest_qubit_index; function.addFnAttr(config_.maxIndexQubitsAttr(), ss.str()); } if (config_.shouldAnnotateResultUse()) { std::stringstream ss{\"\"}; ss << stats.usage_result_counts; function.addFnAttr(config_.requiredNumResultsAttr(), ss.str()); } if (config_.shouldAnnotateMaxResultIndex()) { std::stringstream ss{\"\"}; ss << stats.largest_result_index; function.addFnAttr(config_.maxIndexResultsAttr(), ss.str()); } return llvm::PreservedAnalyses::none(); } bool ResourceAnnotationPass::isRequired() { return true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_resource_annotation_pass_8hpp/","text":"Passes/StaticResourceComponent/ResourceAnnotationPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ResourceAnnotationPass Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class ResourceAnnotationPass : public llvm::PassInfoMixin<ResourceAnnotationPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using Location = ILogger::Location; using StringRef = llvm::StringRef; enum ResourceType { None, Qubit, Result }; // Construction and destruction configuration. // explicit ResourceAnnotationPass( StaticResourceComponentConfiguration const& cfg, ILoggerPtr const& logger = nullptr); ResourceAnnotationPass(ResourceAnnotationPass const&) = delete; ResourceAnnotationPass(ResourceAnnotationPass&&) = default; ~ResourceAnnotationPass() = default; llvm::PreservedAnalyses run(llvm::Function& function, llvm::FunctionAnalysisManager& fam); static bool isRequired(); private: StaticResourceComponentConfiguration config_{}; ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/StaticResourceComponent/ResourceAnnotationPass.hpp"},{"location":"Api/Files/_resource_annotation_pass_8hpp/#passesstaticresourcecomponentresourceannotationpasshpp","text":"","title":"Passes/StaticResourceComponent/ResourceAnnotationPass.hpp"},{"location":"Api/Files/_resource_annotation_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_resource_annotation_pass_8hpp/#classes","text":"Name class microsoft::quantum::ResourceAnnotationPass","title":"Classes"},{"location":"Api/Files/_resource_annotation_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class ResourceAnnotationPass : public llvm::PassInfoMixin<ResourceAnnotationPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using Location = ILogger::Location; using StringRef = llvm::StringRef; enum ResourceType { None, Qubit, Result }; // Construction and destruction configuration. // explicit ResourceAnnotationPass( StaticResourceComponentConfiguration const& cfg, ILoggerPtr const& logger = nullptr); ResourceAnnotationPass(ResourceAnnotationPass const&) = delete; ResourceAnnotationPass(ResourceAnnotationPass&&) = default; ~ResourceAnnotationPass() = default; llvm::PreservedAnalyses run(llvm::Function& function, llvm::FunctionAnalysisManager& fam); static bool isRequired(); private: StaticResourceComponentConfiguration config_{}; ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_rule_set_8cpp/","text":"Rules/RuleSet.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Rules/RuleSet.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/ReplacementRule.hpp\" #include <iostream> #include <vector> namespace microsoft::quantum { bool RuleSet::matchAndReplace(Instruction* value, Replacements& replacements, ReplaceDirection const& dir) { Rules* rules = &rules_; if (dir == ReplaceDirection::ReplaceBackwards) { rules = &rules_backwards_; } Captures captures; for (auto const& rule : *rules) { // Checking if the rule is matched and keep track of captured nodes if (rule->match(value, captures)) { // If it is matched, we attempt to replace it llvm::IRBuilder<> builder{value}; if (rule->replace(builder, value, captures, replacements)) { return true; } else { captures.clear(); } } } return false; } void RuleSet::addRule(ReplacementRulePtr const& rule, ReplaceDirection const& dir) { switch (dir) { case ReplaceDirection::ReplaceForwards: rules_.push_back(rule); break; case ReplaceDirection::ReplaceBackwards: rules_backwards_.push_back(rule); break; } } void RuleSet::addRule(ReplacementRule&& rule, ReplaceDirection const& dir) { addRule(std::make_shared<ReplacementRule>(std::move(rule)), dir); } void RuleSet::clear() { rules_.clear(); rules_backwards_.clear(); } uint64_t RuleSet::size() const { return rules_.size() + rules_backwards_.size(); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/RuleSet.cpp"},{"location":"Api/Files/_rule_set_8cpp/#rulesrulesetcpp","text":"","title":"Rules/RuleSet.cpp"},{"location":"Api/Files/_rule_set_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_rule_set_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Rules/RuleSet.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/ReplacementRule.hpp\" #include <iostream> #include <vector> namespace microsoft::quantum { bool RuleSet::matchAndReplace(Instruction* value, Replacements& replacements, ReplaceDirection const& dir) { Rules* rules = &rules_; if (dir == ReplaceDirection::ReplaceBackwards) { rules = &rules_backwards_; } Captures captures; for (auto const& rule : *rules) { // Checking if the rule is matched and keep track of captured nodes if (rule->match(value, captures)) { // If it is matched, we attempt to replace it llvm::IRBuilder<> builder{value}; if (rule->replace(builder, value, captures, replacements)) { return true; } else { captures.clear(); } } } return false; } void RuleSet::addRule(ReplacementRulePtr const& rule, ReplaceDirection const& dir) { switch (dir) { case ReplaceDirection::ReplaceForwards: rules_.push_back(rule); break; case ReplaceDirection::ReplaceBackwards: rules_backwards_.push_back(rule); break; } } void RuleSet::addRule(ReplacementRule&& rule, ReplaceDirection const& dir) { addRule(std::make_shared<ReplacementRule>(std::move(rule)), dir); } void RuleSet::clear() { rules_.clear(); rules_backwards_.clear(); } uint64_t RuleSet::size() const { return rules_.size() + rules_backwards_.size(); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_rule_set_8hpp/","text":"Rules/RuleSet.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::RuleSet Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AllocationManager/IAllocationManager.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" #include \"qir/qat/Rules/ReplacementRule.hpp\" #include <memory> #include <vector> namespace microsoft::quantum { class RuleSet { public: using ReplacementRulePtr = std::shared_ptr<ReplacementRule>; using Rules = std::vector<ReplacementRulePtr>; using Replacements = ReplacementRule::Replacements; using Captures = IOperandPrototype::Captures; using Instruction = llvm::Instruction; using Value = llvm::Value; using Builder = ReplacementRule::Builder; using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; enum ReplaceDirection { ReplaceForwards, ReplaceBackwards }; // Constructors // RuleSet() = default; RuleSet(RuleSet const&) = default; RuleSet(RuleSet&&) = default; ~RuleSet() = default; // Operators // RuleSet& operator=(RuleSet const&) = default; RuleSet& operator=(RuleSet&&) = default; // Operating rule sets // bool matchAndReplace(Instruction* value, Replacements& replacements, ReplaceDirection const& dir = ReplaceForwards); // Set up and configuration // void addRule(ReplacementRulePtr const& rule, ReplaceDirection const& dir = ReplaceForwards); void addRule(ReplacementRule&& rule, ReplaceDirection const& dir = ReplaceForwards); void clear(); uint64_t size() const; private: Rules rules_; Rules rules_backwards_; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/RuleSet.hpp"},{"location":"Api/Files/_rule_set_8hpp/#rulesrulesethpp","text":"","title":"Rules/RuleSet.hpp"},{"location":"Api/Files/_rule_set_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_rule_set_8hpp/#classes","text":"Name class microsoft::quantum::RuleSet","title":"Classes"},{"location":"Api/Files/_rule_set_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AllocationManager/IAllocationManager.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" #include \"qir/qat/Rules/ReplacementRule.hpp\" #include <memory> #include <vector> namespace microsoft::quantum { class RuleSet { public: using ReplacementRulePtr = std::shared_ptr<ReplacementRule>; using Rules = std::vector<ReplacementRulePtr>; using Replacements = ReplacementRule::Replacements; using Captures = IOperandPrototype::Captures; using Instruction = llvm::Instruction; using Value = llvm::Value; using Builder = ReplacementRule::Builder; using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; enum ReplaceDirection { ReplaceForwards, ReplaceBackwards }; // Constructors // RuleSet() = default; RuleSet(RuleSet const&) = default; RuleSet(RuleSet&&) = default; ~RuleSet() = default; // Operators // RuleSet& operator=(RuleSet const&) = default; RuleSet& operator=(RuleSet&&) = default; // Operating rule sets // bool matchAndReplace(Instruction* value, Replacements& replacements, ReplaceDirection const& dir = ReplaceForwards); // Set up and configuration // void addRule(ReplacementRulePtr const& rule, ReplaceDirection const& dir = ReplaceForwards); void addRule(ReplacementRule&& rule, ReplaceDirection const& dir = ReplaceForwards); void clear(); uint64_t size() const; private: Rules rules_; Rules rules_backwards_; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_select_8cpp/","text":"Rules/Notation/Select.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr select( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2) { auto select_pattern = std::make_shared<SelectPattern>(); select_pattern->addChild(cond); select_pattern->addChild(arg1); select_pattern->addChild(arg2); return static_cast<IOperandPrototypePtr>(select_pattern); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Notation/Select.cpp"},{"location":"Api/Files/_select_8cpp/#rulesnotationselectcpp","text":"","title":"Rules/Notation/Select.cpp"},{"location":"Api/Files/_select_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_select_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr select( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2) { auto select_pattern = std::make_shared<SelectPattern>(); select_pattern->addChild(cond); select_pattern->addChild(arg1); select_pattern->addChild(arg2); return static_cast<IOperandPrototypePtr>(select_pattern); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_serialization_traits_8hpp/","text":"Commandline/SerializationTraits.hpp Namespaces Name microsoft microsoft::quantum Classes Name struct microsoft::quantum::HasQatSerializers Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/external/yaml.hpp\" #include <type_traits> namespace microsoft::quantum { template <typename C> struct HasQatSerializers { private: template <typename T> static constexpr auto checkToYaml(T*) -> typename std::is_same<decltype(std::declval<T>().toYaml(std::declval<YAML::Node&>())), void>::type; template <typename> static constexpr std::false_type checkToYaml(...); template <typename T> static constexpr auto checkFromYaml(T*) -> typename std::is_same<decltype(std::declval<T>().fromYaml(std::declval<YAML::Node>())), void>::type; template <typename> static constexpr std::false_type checkFromYaml(...); template <typename T> static constexpr auto checkToString(T*) -> typename std::is_same<decltype(std::declval<T>().toString(std::declval<std::string&>())), void>::type; template <typename> static constexpr std::false_type checkToString(...); template <typename T> static constexpr auto checkFromString(T*) -> typename std::is_same<decltype(std::declval<T>().fromString(std::declval<std::string>())), void>::type; template <typename> static constexpr std::false_type checkFromString(...); typedef decltype(checkToYaml<C>(nullptr)) CheckToYaml; typedef decltype(checkFromYaml<C>(nullptr)) CheckFromYaml; typedef decltype(checkToString<C>(nullptr)) CheckToString; typedef decltype(checkFromString<C>(nullptr)) CheckFromString; public: static constexpr bool VALUE = CheckToYaml::value && CheckFromYaml::value && CheckToString::value && CheckFromString::value; }; static_assert(!HasQatSerializers<int32_t>::VALUE, \"Expected int32 to be not serializable.\"); static_assert(!HasQatSerializers<uint64_t>::VALUE, \"Expected uint64 to be not serializable.\"); static_assert(!HasQatSerializers<bool>::VALUE, \"Expected bool to be not serializable.\"); static_assert(!HasQatSerializers<String>::VALUE, \"Expected string to be not serializable.\"); } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Commandline/SerializationTraits.hpp"},{"location":"Api/Files/_serialization_traits_8hpp/#commandlineserializationtraitshpp","text":"","title":"Commandline/SerializationTraits.hpp"},{"location":"Api/Files/_serialization_traits_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_serialization_traits_8hpp/#classes","text":"Name struct microsoft::quantum::HasQatSerializers","title":"Classes"},{"location":"Api/Files/_serialization_traits_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/external/yaml.hpp\" #include <type_traits> namespace microsoft::quantum { template <typename C> struct HasQatSerializers { private: template <typename T> static constexpr auto checkToYaml(T*) -> typename std::is_same<decltype(std::declval<T>().toYaml(std::declval<YAML::Node&>())), void>::type; template <typename> static constexpr std::false_type checkToYaml(...); template <typename T> static constexpr auto checkFromYaml(T*) -> typename std::is_same<decltype(std::declval<T>().fromYaml(std::declval<YAML::Node>())), void>::type; template <typename> static constexpr std::false_type checkFromYaml(...); template <typename T> static constexpr auto checkToString(T*) -> typename std::is_same<decltype(std::declval<T>().toString(std::declval<std::string&>())), void>::type; template <typename> static constexpr std::false_type checkToString(...); template <typename T> static constexpr auto checkFromString(T*) -> typename std::is_same<decltype(std::declval<T>().fromString(std::declval<std::string>())), void>::type; template <typename> static constexpr std::false_type checkFromString(...); typedef decltype(checkToYaml<C>(nullptr)) CheckToYaml; typedef decltype(checkFromYaml<C>(nullptr)) CheckFromYaml; typedef decltype(checkToString<C>(nullptr)) CheckToString; typedef decltype(checkFromString<C>(nullptr)) CheckFromString; public: static constexpr bool VALUE = CheckToYaml::value && CheckFromYaml::value && CheckToString::value && CheckFromString::value; }; static_assert(!HasQatSerializers<int32_t>::VALUE, \"Expected int32 to be not serializable.\"); static_assert(!HasQatSerializers<uint64_t>::VALUE, \"Expected uint64 to be not serializable.\"); static_assert(!HasQatSerializers<bool>::VALUE, \"Expected bool to be not serializable.\"); static_assert(!HasQatSerializers<String>::VALUE, \"Expected string to be not serializable.\"); } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_source_location_8hpp/","text":"Logging/SourceLocation.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::SourceLocation Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <utility> #include <vector> namespace microsoft::quantum { class SourceLocation { public: using StringRef = llvm::StringRef; SourceLocation() = default; SourceLocation(String v_name, int64_t v_line, int64_t v_column) : name_{std::move(v_name)} , line_{v_line} , column_{v_column} { } enum { InvalidPosition = -1 }; explicit operator bool() const { return line_ != InvalidPosition && column_ != InvalidPosition; } static SourceLocation invalidPosition() { return {\"\", InvalidPosition, InvalidPosition}; } String& name() { return name_; } String const& name() const { return name_; } void setName(String const& name) { name_ = name; } int64_t& line() { return line_; } int64_t const& line() const { return line_; } void setLine(int64_t line) { line_ = line; } int64_t& column() { return column_; } int64_t const& column() const { return column_; } void setColumn(int64_t column) { column_ = column; } private: String name_{}; int64_t line_{0}; int64_t column_{0}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Logging/SourceLocation.hpp"},{"location":"Api/Files/_source_location_8hpp/#loggingsourcelocationhpp","text":"","title":"Logging/SourceLocation.hpp"},{"location":"Api/Files/_source_location_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_source_location_8hpp/#classes","text":"Name class microsoft::quantum::SourceLocation","title":"Classes"},{"location":"Api/Files/_source_location_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <utility> #include <vector> namespace microsoft::quantum { class SourceLocation { public: using StringRef = llvm::StringRef; SourceLocation() = default; SourceLocation(String v_name, int64_t v_line, int64_t v_column) : name_{std::move(v_name)} , line_{v_line} , column_{v_column} { } enum { InvalidPosition = -1 }; explicit operator bool() const { return line_ != InvalidPosition && column_ != InvalidPosition; } static SourceLocation invalidPosition() { return {\"\", InvalidPosition, InvalidPosition}; } String& name() { return name_; } String const& name() const { return name_; } void setName(String const& name) { name_ = name; } int64_t& line() { return line_; } int64_t const& line() const { return line_; } void setLine(int64_t line) { line_ = line; } int64_t& column() { return column_; } int64_t const& column() const { return column_; } void setColumn(int64_t column) { column_ = column; } private: String name_{}; int64_t line_{0}; int64_t column_{0}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_spec_configuration_8hpp/","text":"Commandline/SpecConfiguration.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::SpecConfiguration Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" namespace microsoft { namespace quantum { class SpecConfiguration { public: void setup(ConfigurationManager& config) { config.setSectionName(\"Specification\", \"Convention for a given specification\"); config.addParameter( version_, \"spec-version\", \"Specification version.\", ConfigurationManager::ParameterVisibility::ConfigOnly); config.addParameter( entry_point_attr_, \"entry-point-attr\", \"Specifies the attribute name indicating the entry point.\"); config.addParameter( qir_profiles_attr_, \"qir-profiles-attr\", \"Specifies the attribute name indicating the profile compliance.\"); config.addParameter( output_labeling_schema_attr_, \"output-labeling-schema-attr\", \"Specifies the attribute name indicating the output labaling scheme.\"); config.addParameter( required_num_qubits_attr_, \"required-num-qubits-attr\", \"Specifies the attribute name indicating the required number of qubits.\"); config.addParameter( required_num_results_attr_, \"required-num-results-attr\", \"Specifies the attribute name indicating the required number of results.\"); config.addParameter( max_index_qubits_attr_, \"max-index-qubits-attr\", \"Specifies the attribute name indicating the maxiumum index of qubits used.\"); config.addParameter( max_index_results_attr_, \"max-index-results-attr\", \"Specifies the attribute name indicating the maxiumum index of results used.\"); config.addParameter( replace_with_attr_, \"replace-with-attr\", \"Specifies the attribute name indicating replacement linking.\"); config.addParameter( irreversible_attr_, \"irreversible-attr\", \"Specifies the attribute name indicating irrevesibility.\"); config.addParameter(qir_runtime_prefix_, \"qir-runtime-prefix\", \"QIR runtime prefix.\"); } String version() const { return version_; } String entryPointAttr() const { return entry_point_attr_; } String qirProfilesAttr() const { return qir_profiles_attr_; } String outputLabelingSchemaAttr() const { return output_labeling_schema_attr_; } String requiredNumQubitsAttr() const { return required_num_qubits_attr_; } String requiredNumResultsAttr() const { return required_num_results_attr_; } String replaceWithAttr() const { return replace_with_attr_; } String irreversibleAttr() const { return irreversible_attr_; } String qirRuntimePrefix() const { return qir_runtime_prefix_; } private: String version_{\"0.9\"}; // Attribute names // // TODO(issue-150): Update to comply with spec once Q# is updated String entry_point_attr_{\"EntryPoint\"}; String qir_profiles_attr_{\"qir_profiles\"}; String output_labeling_schema_attr_{\"output_labeling_schema\"}; String required_num_qubits_attr_{\"requiredQubits\"}; String required_num_results_attr_{\"requiredResults\"}; String max_index_qubits_attr_{\"maxQubitIndex\"}; String max_index_results_attr_{\"maxResultIndex\"}; String replace_with_attr_{\"replaceWith\"}; String irreversible_attr_{\"irreversible\"}; // Naming convention // String qir_runtime_prefix_{\"__quantum__rt__\"}; }; } // namespace quantum } // namespace microsoft Updated on 28 October 2022 at 19:30:16 UTC","title":"Commandline/SpecConfiguration.hpp"},{"location":"Api/Files/_spec_configuration_8hpp/#commandlinespecconfigurationhpp","text":"","title":"Commandline/SpecConfiguration.hpp"},{"location":"Api/Files/_spec_configuration_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_spec_configuration_8hpp/#classes","text":"Name class microsoft::quantum::SpecConfiguration","title":"Classes"},{"location":"Api/Files/_spec_configuration_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" namespace microsoft { namespace quantum { class SpecConfiguration { public: void setup(ConfigurationManager& config) { config.setSectionName(\"Specification\", \"Convention for a given specification\"); config.addParameter( version_, \"spec-version\", \"Specification version.\", ConfigurationManager::ParameterVisibility::ConfigOnly); config.addParameter( entry_point_attr_, \"entry-point-attr\", \"Specifies the attribute name indicating the entry point.\"); config.addParameter( qir_profiles_attr_, \"qir-profiles-attr\", \"Specifies the attribute name indicating the profile compliance.\"); config.addParameter( output_labeling_schema_attr_, \"output-labeling-schema-attr\", \"Specifies the attribute name indicating the output labaling scheme.\"); config.addParameter( required_num_qubits_attr_, \"required-num-qubits-attr\", \"Specifies the attribute name indicating the required number of qubits.\"); config.addParameter( required_num_results_attr_, \"required-num-results-attr\", \"Specifies the attribute name indicating the required number of results.\"); config.addParameter( max_index_qubits_attr_, \"max-index-qubits-attr\", \"Specifies the attribute name indicating the maxiumum index of qubits used.\"); config.addParameter( max_index_results_attr_, \"max-index-results-attr\", \"Specifies the attribute name indicating the maxiumum index of results used.\"); config.addParameter( replace_with_attr_, \"replace-with-attr\", \"Specifies the attribute name indicating replacement linking.\"); config.addParameter( irreversible_attr_, \"irreversible-attr\", \"Specifies the attribute name indicating irrevesibility.\"); config.addParameter(qir_runtime_prefix_, \"qir-runtime-prefix\", \"QIR runtime prefix.\"); } String version() const { return version_; } String entryPointAttr() const { return entry_point_attr_; } String qirProfilesAttr() const { return qir_profiles_attr_; } String outputLabelingSchemaAttr() const { return output_labeling_schema_attr_; } String requiredNumQubitsAttr() const { return required_num_qubits_attr_; } String requiredNumResultsAttr() const { return required_num_results_attr_; } String replaceWithAttr() const { return replace_with_attr_; } String irreversibleAttr() const { return irreversible_attr_; } String qirRuntimePrefix() const { return qir_runtime_prefix_; } private: String version_{\"0.9\"}; // Attribute names // // TODO(issue-150): Update to comply with spec once Q# is updated String entry_point_attr_{\"EntryPoint\"}; String qir_profiles_attr_{\"qir_profiles\"}; String output_labeling_schema_attr_{\"output_labeling_schema\"}; String required_num_qubits_attr_{\"requiredQubits\"}; String required_num_results_attr_{\"requiredResults\"}; String max_index_qubits_attr_{\"maxQubitIndex\"}; String max_index_results_attr_{\"maxResultIndex\"}; String replace_with_attr_{\"replaceWith\"}; String irreversible_attr_{\"irreversible\"}; // Naming convention // String qir_runtime_prefix_{\"__quantum__rt__\"}; }; } // namespace quantum } // namespace microsoft Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_static_resource_component_configuration_8cpp/","text":"Passes/StaticResourceComponent/StaticResourceComponentConfiguration.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp\" #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" namespace microsoft::quantum { void StaticResourceComponentConfiguration::setup(ConfigurationManager& config) { config.setSectionName(\"Static resource manipulation\", \"Manipulates statically allocated qubits and results\"); config.addParameter(annotate_qubit_use_, \"annotate-qubit-use\", \"Annotate the number of qubits used\"); config.addParameter(annotate_result_use_, \"annotate-result-use\", \"Annotate the number of results used\"); config.addParameter(annotate_max_qubit_index_, \"annotate-max-qubit-index\", \"Annotate the maximum qubit index used\"); config.addParameter( annotate_max_result_index_, \"annotate-max-result-index\", \"Annotate the maximum result index used\"); config.addParameter( reindex_qubits_, \"reindex-qubits\", \"Re-indexes statically allocated qubits with sequential ids starting from 0\"); config.addParameter( replace_qubit_on_reset_, \"replace-qubit-on-reset\", \"Replaces a qubit with new qubit if the qubit is reset\"); config.addParameter(inline_after_id_change_, \"inline-after-id-change\", \"Inlines instructions after id was changed\"); required_num_qubits_attr_ = config.getParameter(\"required-num-qubits-attr\"); required_num_results_attr_ = config.getParameter(\"required-num-results-attr\"); max_index_qubits_attr_ = config.getParameter(\"max-index-qubits-attr\"); max_index_results_attr_ = config.getParameter(\"max-index-results-attr\"); } String StaticResourceComponentConfiguration::requiredNumQubitsAttr() const { if (required_num_qubits_attr_ == nullptr) { return \"requiredQubits\"; } return required_num_qubits_attr_->value<String>(); } String StaticResourceComponentConfiguration::maxIndexQubitsAttr() const { if (max_index_qubits_attr_ == nullptr) { return \"maxQubitIndex\"; } return max_index_qubits_attr_->value<String>(); } String StaticResourceComponentConfiguration::requiredNumResultsAttr() const { if (required_num_results_attr_ == nullptr) { return \"requiredResults\"; } return required_num_results_attr_->value<String>(); } String StaticResourceComponentConfiguration::maxIndexResultsAttr() const { if (max_index_results_attr_ == nullptr) { return \"maxResultIndex\"; } return max_index_results_attr_->value<String>(); } bool StaticResourceComponentConfiguration::shouldAnnotateQubitUse() const { return annotate_qubit_use_; } bool StaticResourceComponentConfiguration::shouldAnnotateResultUse() const { return annotate_result_use_; } bool StaticResourceComponentConfiguration::shouldAnnotateMaxQubitIndex() const { return annotate_max_qubit_index_; } bool StaticResourceComponentConfiguration::shouldAnnotateMaxResultIndex() const { return annotate_max_result_index_; } bool StaticResourceComponentConfiguration::shouldReplaceQubitsOnReset() const { return replace_qubit_on_reset_; } bool StaticResourceComponentConfiguration::shouldReindexQubits() const { return reindex_qubits_; } bool StaticResourceComponentConfiguration::shouldInlineAfterIdChange() const { return inline_after_id_change_; } bool StaticResourceComponentConfiguration::isChangingIds() const { return reindex_qubits_ || replace_qubit_on_reset_; } StaticResourceComponentConfiguration StaticResourceComponentConfiguration::createDisabled() { StaticResourceComponentConfiguration ret; ret.annotate_qubit_use_ = false; ret.annotate_result_use_ = false; ret.annotate_max_qubit_index_ = false; ret.annotate_max_result_index_ = false; ret.replace_qubit_on_reset_ = false; ret.reindex_qubits_ = false; ret.inline_after_id_change_ = false; return ret; } void StaticResourceComponentConfiguration::enableAnnotateQubitUse() { annotate_qubit_use_ = true; } void StaticResourceComponentConfiguration::enableAnnotateResultUse() { annotate_result_use_ = true; } void StaticResourceComponentConfiguration::enableAnnotateMaxQubitIndex() { annotate_max_qubit_index_ = true; } void StaticResourceComponentConfiguration::enableAnnotateMaxResultIndex() { annotate_max_result_index_ = true; } void StaticResourceComponentConfiguration::enableReplaceQubitOnReset() { replace_qubit_on_reset_ = true; } void StaticResourceComponentConfiguration::enableReindexQubits() { reindex_qubits_ = true; } void StaticResourceComponentConfiguration::enableInlineAfterIdChange() { inline_after_id_change_ = true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/StaticResourceComponent/StaticResourceComponentConfiguration.cpp"},{"location":"Api/Files/_static_resource_component_configuration_8cpp/#passesstaticresourcecomponentstaticresourcecomponentconfigurationcpp","text":"","title":"Passes/StaticResourceComponent/StaticResourceComponentConfiguration.cpp"},{"location":"Api/Files/_static_resource_component_configuration_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_static_resource_component_configuration_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp\" #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" namespace microsoft::quantum { void StaticResourceComponentConfiguration::setup(ConfigurationManager& config) { config.setSectionName(\"Static resource manipulation\", \"Manipulates statically allocated qubits and results\"); config.addParameter(annotate_qubit_use_, \"annotate-qubit-use\", \"Annotate the number of qubits used\"); config.addParameter(annotate_result_use_, \"annotate-result-use\", \"Annotate the number of results used\"); config.addParameter(annotate_max_qubit_index_, \"annotate-max-qubit-index\", \"Annotate the maximum qubit index used\"); config.addParameter( annotate_max_result_index_, \"annotate-max-result-index\", \"Annotate the maximum result index used\"); config.addParameter( reindex_qubits_, \"reindex-qubits\", \"Re-indexes statically allocated qubits with sequential ids starting from 0\"); config.addParameter( replace_qubit_on_reset_, \"replace-qubit-on-reset\", \"Replaces a qubit with new qubit if the qubit is reset\"); config.addParameter(inline_after_id_change_, \"inline-after-id-change\", \"Inlines instructions after id was changed\"); required_num_qubits_attr_ = config.getParameter(\"required-num-qubits-attr\"); required_num_results_attr_ = config.getParameter(\"required-num-results-attr\"); max_index_qubits_attr_ = config.getParameter(\"max-index-qubits-attr\"); max_index_results_attr_ = config.getParameter(\"max-index-results-attr\"); } String StaticResourceComponentConfiguration::requiredNumQubitsAttr() const { if (required_num_qubits_attr_ == nullptr) { return \"requiredQubits\"; } return required_num_qubits_attr_->value<String>(); } String StaticResourceComponentConfiguration::maxIndexQubitsAttr() const { if (max_index_qubits_attr_ == nullptr) { return \"maxQubitIndex\"; } return max_index_qubits_attr_->value<String>(); } String StaticResourceComponentConfiguration::requiredNumResultsAttr() const { if (required_num_results_attr_ == nullptr) { return \"requiredResults\"; } return required_num_results_attr_->value<String>(); } String StaticResourceComponentConfiguration::maxIndexResultsAttr() const { if (max_index_results_attr_ == nullptr) { return \"maxResultIndex\"; } return max_index_results_attr_->value<String>(); } bool StaticResourceComponentConfiguration::shouldAnnotateQubitUse() const { return annotate_qubit_use_; } bool StaticResourceComponentConfiguration::shouldAnnotateResultUse() const { return annotate_result_use_; } bool StaticResourceComponentConfiguration::shouldAnnotateMaxQubitIndex() const { return annotate_max_qubit_index_; } bool StaticResourceComponentConfiguration::shouldAnnotateMaxResultIndex() const { return annotate_max_result_index_; } bool StaticResourceComponentConfiguration::shouldReplaceQubitsOnReset() const { return replace_qubit_on_reset_; } bool StaticResourceComponentConfiguration::shouldReindexQubits() const { return reindex_qubits_; } bool StaticResourceComponentConfiguration::shouldInlineAfterIdChange() const { return inline_after_id_change_; } bool StaticResourceComponentConfiguration::isChangingIds() const { return reindex_qubits_ || replace_qubit_on_reset_; } StaticResourceComponentConfiguration StaticResourceComponentConfiguration::createDisabled() { StaticResourceComponentConfiguration ret; ret.annotate_qubit_use_ = false; ret.annotate_result_use_ = false; ret.annotate_max_qubit_index_ = false; ret.annotate_max_result_index_ = false; ret.replace_qubit_on_reset_ = false; ret.reindex_qubits_ = false; ret.inline_after_id_change_ = false; return ret; } void StaticResourceComponentConfiguration::enableAnnotateQubitUse() { annotate_qubit_use_ = true; } void StaticResourceComponentConfiguration::enableAnnotateResultUse() { annotate_result_use_ = true; } void StaticResourceComponentConfiguration::enableAnnotateMaxQubitIndex() { annotate_max_qubit_index_ = true; } void StaticResourceComponentConfiguration::enableAnnotateMaxResultIndex() { annotate_max_result_index_ = true; } void StaticResourceComponentConfiguration::enableReplaceQubitOnReset() { replace_qubit_on_reset_ = true; } void StaticResourceComponentConfiguration::enableReindexQubits() { reindex_qubits_ = true; } void StaticResourceComponentConfiguration::enableInlineAfterIdChange() { inline_after_id_change_ = true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_static_resource_component_configuration_8hpp/","text":"Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::StaticResourceComponentConfiguration Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" namespace microsoft::quantum { class StaticResourceComponentConfiguration { public: using Set = std::unordered_set<std::string>; using DeferredValuePtr = DeferredValue::DeferredValuePtr; // Setup and construction // StaticResourceComponentConfiguration() = default; void setup(ConfigurationManager& config); bool shouldAnnotateQubitUse() const; bool shouldAnnotateResultUse() const; bool shouldAnnotateMaxQubitIndex() const; bool shouldAnnotateMaxResultIndex() const; bool shouldReplaceQubitsOnReset() const; bool shouldReindexQubits() const; bool shouldInlineAfterIdChange() const; bool isChangingIds() const; static StaticResourceComponentConfiguration createDisabled(); void enableAnnotateQubitUse(); void enableAnnotateResultUse(); void enableAnnotateMaxQubitIndex(); void enableAnnotateMaxResultIndex(); void enableReplaceQubitOnReset(); void enableReindexQubits(); void enableInlineAfterIdChange(); // Attribute names used for annotation // String requiredNumQubitsAttr() const; String requiredNumResultsAttr() const; String maxIndexQubitsAttr() const; String maxIndexResultsAttr() const; private: bool annotate_qubit_use_{true}; bool annotate_result_use_{true}; bool annotate_max_qubit_index_{true}; bool annotate_max_result_index_{true}; bool replace_qubit_on_reset_{false}; bool reindex_qubits_{false}; bool inline_after_id_change_{true}; DeferredValuePtr required_num_qubits_attr_{nullptr}; DeferredValuePtr required_num_results_attr_{nullptr}; DeferredValuePtr max_index_qubits_attr_{nullptr}; DeferredValuePtr max_index_results_attr_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp"},{"location":"Api/Files/_static_resource_component_configuration_8hpp/#passesstaticresourcecomponentstaticresourcecomponentconfigurationhpp","text":"","title":"Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp"},{"location":"Api/Files/_static_resource_component_configuration_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_static_resource_component_configuration_8hpp/#classes","text":"Name class microsoft::quantum::StaticResourceComponentConfiguration","title":"Classes"},{"location":"Api/Files/_static_resource_component_configuration_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" namespace microsoft::quantum { class StaticResourceComponentConfiguration { public: using Set = std::unordered_set<std::string>; using DeferredValuePtr = DeferredValue::DeferredValuePtr; // Setup and construction // StaticResourceComponentConfiguration() = default; void setup(ConfigurationManager& config); bool shouldAnnotateQubitUse() const; bool shouldAnnotateResultUse() const; bool shouldAnnotateMaxQubitIndex() const; bool shouldAnnotateMaxResultIndex() const; bool shouldReplaceQubitsOnReset() const; bool shouldReindexQubits() const; bool shouldInlineAfterIdChange() const; bool isChangingIds() const; static StaticResourceComponentConfiguration createDisabled(); void enableAnnotateQubitUse(); void enableAnnotateResultUse(); void enableAnnotateMaxQubitIndex(); void enableAnnotateMaxResultIndex(); void enableReplaceQubitOnReset(); void enableReindexQubits(); void enableInlineAfterIdChange(); // Attribute names used for annotation // String requiredNumQubitsAttr() const; String requiredNumResultsAttr() const; String maxIndexQubitsAttr() const; String maxIndexResultsAttr() const; private: bool annotate_qubit_use_{true}; bool annotate_result_use_{true}; bool annotate_max_qubit_index_{true}; bool annotate_max_result_index_{true}; bool replace_qubit_on_reset_{false}; bool reindex_qubits_{false}; bool inline_after_id_change_{true}; DeferredValuePtr required_num_qubits_attr_{nullptr}; DeferredValuePtr required_num_results_attr_{nullptr}; DeferredValuePtr max_index_qubits_attr_{nullptr}; DeferredValuePtr max_index_results_attr_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_store_8cpp/","text":"Rules/Notation/Store.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr store(IOperandPrototypePtr const& target, IOperandPrototypePtr const& value) { auto ret = std::make_shared<StorePattern>(); ret->addChild(target); ret->addChild(value); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Notation/Store.cpp"},{"location":"Api/Files/_store_8cpp/#rulesnotationstorecpp","text":"","title":"Rules/Notation/Store.cpp"},{"location":"Api/Files/_store_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_store_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr store(IOperandPrototypePtr const& target, IOperandPrototypePtr const& value) { auto ret = std::make_shared<StorePattern>(); ret->addChild(target); ret->addChild(value); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_switch_8cpp/","text":"Rules/Notation/Switch.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr switchOp( IOperandPrototypePtr const& /*cond*/, IOperandPrototypePtr const& /*arg1*/, IOperandPrototypePtr const& /*arg2*/) { auto switch_pattern = std::make_shared<SwitchPattern>(); // TODO(issue-17): finish switch pattern // switch_pattern->addChild(cond); // switch_pattern->addChild(arg1); // switch_pattern->addChild(arg2); return static_cast<IOperandPrototypePtr>(switch_pattern); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Notation/Switch.cpp"},{"location":"Api/Files/_switch_8cpp/#rulesnotationswitchcpp","text":"","title":"Rules/Notation/Switch.cpp"},{"location":"Api/Files/_switch_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_switch_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr switchOp( IOperandPrototypePtr const& /*cond*/, IOperandPrototypePtr const& /*arg1*/, IOperandPrototypePtr const& /*arg2*/) { auto switch_pattern = std::make_shared<SwitchPattern>(); // TODO(issue-17): finish switch pattern // switch_pattern->addChild(cond); // switch_pattern->addChild(arg1); // switch_pattern->addChild(arg2); return static_cast<IOperandPrototypePtr>(switch_pattern); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_target_profile_configuration_8cpp/","text":"Passes/ValidationPass/TargetProfileConfiguration.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/ValidationPass/TargetProfileConfiguration.hpp\" #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetQisConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" namespace microsoft::quantum { void TargetProfileConfiguration::setup(ConfigurationManager& config) { config.setSectionName(\"Target profile validation\", \"Configuration for profile validation\"); config.addParameter(allow_internal_calls_, \"allow-internal-calls\", \"Whether or not internal calls are allowed.\"); config.addParameter(allow_poison_, \"allow-poison\", \"Whether or not poison values are allowed.\"); config.addParameter(allow_undef_, \"allow-undef\", \"Whether or not undef values are allowed.\"); config.addParameter(opcodes_, \"opcodes\", \"Allowed opcodes\", ConfigurationManager::ParameterVisibility::ConfigOnly); config.addParameter( allowlist_opcodes_, \"allowlist-opcodes\", \"Whether or not to use allow list for op-codes.\", ConfigurationManager::ParameterVisibility::ConfigOnly); config.addParameter( allowlist_external_calls_, \"allowlist-external-calls\", \"Whether or not to use allow list external calls.\", ConfigurationManager::ParameterVisibility::ConfigOnly); config.addParameter( allowlist_pointer_types_, \"allowlist-pointer-types\", \"Whether or not to use allow list pointer types.\", ConfigurationManager::ParameterVisibility::ConfigOnly); config.addParameter( allow_primitive_return_, \"allow-primitive-return\", \"Whether or not primitive return types are allowed.\", ConfigurationManager::ParameterVisibility::ConfigOnly); config.addParameter( allow_struct_return_, \"allow-struct-return\", \"Whether or not struct return types are allowed.\", ConfigurationManager::ParameterVisibility::ConfigOnly); config.addParameter( allow_pointer_return_, \"allow-pointer-return\", \"Whether or not pointer return types are allowed.\", ConfigurationManager::ParameterVisibility::ConfigOnly); config.addParameter( external_calls_, \"external-calls\", \"Allowed external calls.\", ConfigurationManager::ParameterVisibility::ConfigOnly); config.addParameter( allowed_pointer_types_, \"allowed-pointer-types\", \"Allowed pointer types.\", ConfigurationManager::ParameterVisibility::ConfigOnly); } String TargetProfileConfiguration::targetName() const { return target_name_; } TargetProfileConfiguration TargetProfileConfiguration::fromQirTargetName(String const& name) { auto adaptor = TargetProfileConfiguration(); if (name == \"generic\") { adaptor.opcodes_ = OpcodeSet{}; adaptor.external_calls_ = Set{}; adaptor.allowed_pointer_types_ = Set{}; adaptor.allowlist_opcodes_ = false; adaptor.allowlist_external_calls_ = false; adaptor.allowlist_pointer_types_ = false; adaptor.allow_internal_calls_ = true; adaptor.allow_primitive_return_ = true; adaptor.allow_struct_return_ = true; adaptor.allow_pointer_return_ = true; } else if (name == \"default\") { adaptor.allow_internal_calls_ = false; adaptor.allowlist_external_calls_ = true; adaptor.allowlist_opcodes_ = true; adaptor.opcodes_ = OpcodeSet({ {\"ret\"}, {\"call\"}, {\"inttoptr\"}, {\"br\"}, {\"add\"}, {\"sub\"}, {\"mul\"}, {\"fadd\"}, {\"fsub\"}, {\"fmul\"}, {\"lshr\"}, {\"and\"}, {\"or\"}, {\"xor\"}, /* {\"icmp\", \"eq\"}, {\"icmp\", \"ne\"}, {\"icmp\", \"ugt\"}, {\"icmp\", \"uge\"}, {\"icmp\", \"ult\"}, {\"icmp\", \"ule\"}, {\"fcmp\", \"oeq\"}, {\"fcmp\", \"ogt\"}, {\"fcmp\", \"oge\"}, {\"fcmp\", \"olt\"}, {\"fcmp\", \"ole\"}, {\"fcmp\", \"one\"}, */ }); adaptor.external_calls_ = Set{}; adaptor.allowlist_pointer_types_ = true; adaptor.allowed_pointer_types_ = {\"i8*\", \"i16*\", \"i32*\", \"i64*\", \"Qubit*\", \"Qubit**\", \"Result*\", \"Result**\"}; } else { throw std::runtime_error(\"Invalid adaptor \" + name); } adaptor.target_name_ = name; return adaptor; } OpcodeSet const& TargetProfileConfiguration::allowedOpcodes() const { return opcodes_; } TargetProfileConfiguration::Set const& TargetProfileConfiguration::allowedExternalCallNames() const { return external_calls_; } bool TargetProfileConfiguration::allowInternalCalls() const { return allow_internal_calls_; } bool TargetProfileConfiguration::allowlistOpcodes() const { return allowlist_opcodes_; } bool TargetProfileConfiguration::allowlistExternalCalls() const { return allowlist_external_calls_; } bool TargetProfileConfiguration::allowlistPointerTypes() const { return allowlist_pointer_types_; } TargetProfileConfiguration::Set const& TargetProfileConfiguration::allowedPointerTypes() const { return allowed_pointer_types_; } void TargetProfileConfiguration::addAllowedExternalCall(String const& name) { external_calls_.insert(name); } void TargetProfileConfiguration::addAllowedOpcode(String const& name) { opcodes_.data().insert(name); } void TargetProfileConfiguration::addAllowedPointerType(String const& name) { allowed_pointer_types_.insert(name); } bool TargetProfileConfiguration::allowPoison() const { return allow_poison_; } bool TargetProfileConfiguration::allowUndef() const { return allow_undef_; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/ValidationPass/TargetProfileConfiguration.cpp"},{"location":"Api/Files/_target_profile_configuration_8cpp/#passesvalidationpasstargetprofileconfigurationcpp","text":"","title":"Passes/ValidationPass/TargetProfileConfiguration.cpp"},{"location":"Api/Files/_target_profile_configuration_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_target_profile_configuration_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/ValidationPass/TargetProfileConfiguration.hpp\" #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetQisConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" namespace microsoft::quantum { void TargetProfileConfiguration::setup(ConfigurationManager& config) { config.setSectionName(\"Target profile validation\", \"Configuration for profile validation\"); config.addParameter(allow_internal_calls_, \"allow-internal-calls\", \"Whether or not internal calls are allowed.\"); config.addParameter(allow_poison_, \"allow-poison\", \"Whether or not poison values are allowed.\"); config.addParameter(allow_undef_, \"allow-undef\", \"Whether or not undef values are allowed.\"); config.addParameter(opcodes_, \"opcodes\", \"Allowed opcodes\", ConfigurationManager::ParameterVisibility::ConfigOnly); config.addParameter( allowlist_opcodes_, \"allowlist-opcodes\", \"Whether or not to use allow list for op-codes.\", ConfigurationManager::ParameterVisibility::ConfigOnly); config.addParameter( allowlist_external_calls_, \"allowlist-external-calls\", \"Whether or not to use allow list external calls.\", ConfigurationManager::ParameterVisibility::ConfigOnly); config.addParameter( allowlist_pointer_types_, \"allowlist-pointer-types\", \"Whether or not to use allow list pointer types.\", ConfigurationManager::ParameterVisibility::ConfigOnly); config.addParameter( allow_primitive_return_, \"allow-primitive-return\", \"Whether or not primitive return types are allowed.\", ConfigurationManager::ParameterVisibility::ConfigOnly); config.addParameter( allow_struct_return_, \"allow-struct-return\", \"Whether or not struct return types are allowed.\", ConfigurationManager::ParameterVisibility::ConfigOnly); config.addParameter( allow_pointer_return_, \"allow-pointer-return\", \"Whether or not pointer return types are allowed.\", ConfigurationManager::ParameterVisibility::ConfigOnly); config.addParameter( external_calls_, \"external-calls\", \"Allowed external calls.\", ConfigurationManager::ParameterVisibility::ConfigOnly); config.addParameter( allowed_pointer_types_, \"allowed-pointer-types\", \"Allowed pointer types.\", ConfigurationManager::ParameterVisibility::ConfigOnly); } String TargetProfileConfiguration::targetName() const { return target_name_; } TargetProfileConfiguration TargetProfileConfiguration::fromQirTargetName(String const& name) { auto adaptor = TargetProfileConfiguration(); if (name == \"generic\") { adaptor.opcodes_ = OpcodeSet{}; adaptor.external_calls_ = Set{}; adaptor.allowed_pointer_types_ = Set{}; adaptor.allowlist_opcodes_ = false; adaptor.allowlist_external_calls_ = false; adaptor.allowlist_pointer_types_ = false; adaptor.allow_internal_calls_ = true; adaptor.allow_primitive_return_ = true; adaptor.allow_struct_return_ = true; adaptor.allow_pointer_return_ = true; } else if (name == \"default\") { adaptor.allow_internal_calls_ = false; adaptor.allowlist_external_calls_ = true; adaptor.allowlist_opcodes_ = true; adaptor.opcodes_ = OpcodeSet({ {\"ret\"}, {\"call\"}, {\"inttoptr\"}, {\"br\"}, {\"add\"}, {\"sub\"}, {\"mul\"}, {\"fadd\"}, {\"fsub\"}, {\"fmul\"}, {\"lshr\"}, {\"and\"}, {\"or\"}, {\"xor\"}, /* {\"icmp\", \"eq\"}, {\"icmp\", \"ne\"}, {\"icmp\", \"ugt\"}, {\"icmp\", \"uge\"}, {\"icmp\", \"ult\"}, {\"icmp\", \"ule\"}, {\"fcmp\", \"oeq\"}, {\"fcmp\", \"ogt\"}, {\"fcmp\", \"oge\"}, {\"fcmp\", \"olt\"}, {\"fcmp\", \"ole\"}, {\"fcmp\", \"one\"}, */ }); adaptor.external_calls_ = Set{}; adaptor.allowlist_pointer_types_ = true; adaptor.allowed_pointer_types_ = {\"i8*\", \"i16*\", \"i32*\", \"i64*\", \"Qubit*\", \"Qubit**\", \"Result*\", \"Result**\"}; } else { throw std::runtime_error(\"Invalid adaptor \" + name); } adaptor.target_name_ = name; return adaptor; } OpcodeSet const& TargetProfileConfiguration::allowedOpcodes() const { return opcodes_; } TargetProfileConfiguration::Set const& TargetProfileConfiguration::allowedExternalCallNames() const { return external_calls_; } bool TargetProfileConfiguration::allowInternalCalls() const { return allow_internal_calls_; } bool TargetProfileConfiguration::allowlistOpcodes() const { return allowlist_opcodes_; } bool TargetProfileConfiguration::allowlistExternalCalls() const { return allowlist_external_calls_; } bool TargetProfileConfiguration::allowlistPointerTypes() const { return allowlist_pointer_types_; } TargetProfileConfiguration::Set const& TargetProfileConfiguration::allowedPointerTypes() const { return allowed_pointer_types_; } void TargetProfileConfiguration::addAllowedExternalCall(String const& name) { external_calls_.insert(name); } void TargetProfileConfiguration::addAllowedOpcode(String const& name) { opcodes_.data().insert(name); } void TargetProfileConfiguration::addAllowedPointerType(String const& name) { allowed_pointer_types_.insert(name); } bool TargetProfileConfiguration::allowPoison() const { return allow_poison_; } bool TargetProfileConfiguration::allowUndef() const { return allow_undef_; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_target_profile_configuration_8hpp/","text":"Passes/ValidationPass/TargetProfileConfiguration.hpp Namespaces Name microsoft microsoft::quantum std Classes Name class microsoft::quantum::OpcodeValue struct std::hash< microsoft::quantum::OpcodeValue > class microsoft::quantum::OpcodeSet class microsoft::quantum::TargetProfileConfiguration Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <set> namespace microsoft::quantum { class OpcodeValue { public: OpcodeValue(String const& name, String const& fi = \"\") // NOLINT : id_{name} , predicate_{fi} { } OpcodeValue() = default; OpcodeValue(OpcodeValue&&) = default; OpcodeValue(OpcodeValue const&) = default; OpcodeValue& operator=(OpcodeValue&&) = default; OpcodeValue& operator=(OpcodeValue const&) = default; bool operator==(OpcodeValue const& other) const { return id_ == other.id_ && predicate_ == other.predicate_; } String& id() { return id_; } String const& id() const { return id_; } String& predicate() { return predicate_; } String const& predicate() const { return predicate_; } private: String id_{\"\"}; String predicate_{\"\"}; }; } // namespace microsoft::quantum namespace std { template <> struct hash<microsoft::quantum::OpcodeValue> { size_t operator()(microsoft::quantum::OpcodeValue const& x) const { hash<std::string> hasher; return hasher(x.id() + \".\" + x.predicate()); } }; } // namespace std namespace microsoft::quantum { class OpcodeSet { public: using Container = std::unordered_set<OpcodeValue>; explicit OpcodeSet(Container const& data = {}) : data_{data} { } explicit OpcodeSet(Container&& data) : data_{std::move(data)} { } Container& data() { return data_; } Container const& data() const { return data_; } void toString(String& value) const { std::stringstream val; bool not_first = false; for (auto const& d : data_) { if (not_first) { val << \";\"; } val << d.id() << \",\" << d.predicate(); not_first = true; } value = val.str(); } void insertPart(String const& part) { // bind_.insert(part); auto p = part.find(','); if (p == std::string::npos) { throw std::runtime_error(\"Execpted ',' but it is not present in opcode segment\"); } auto a = part.substr(0, p); auto b = part.substr(p + 1, part.size() - p - 1); data_.insert(OpcodeValue(a, b)); } void fromString(String const& value) { data_.clear(); std::size_t last_p = 0; auto p = value.find(';', last_p); while (p != String::npos) { auto part = value.substr(last_p, p - last_p); insertPart(part); last_p = p + 1; p = value.find(';', last_p); } if (last_p < value.size()) { auto part = value.substr(last_p, p - last_p); insertPart(part); } } void toYaml(YAML::Node& node) const { for (auto const& d : data_) { YAML::Node pair; pair[\"id\"] = d.id(); pair[\"predicate\"] = d.predicate(); node.push_back(pair); } } void fromYaml(YAML::Node const& node) { for (auto& pair : node) { auto a = pair[\"id\"].as<String>(); auto b = pair[\"predicate\"].as<String>(); data_.insert(OpcodeValue(a, b)); } } private: Container data_; }; static_assert(HasQatSerializers<OpcodeSet>::VALUE, \"Expected OpcodeSet to be serializable.\"); class TargetProfileConfiguration { public: using Set = std::unordered_set<std::string>; // using OpcodeSet = std::unordered_set<OpcodeValue>; // Setup and construction // TargetProfileConfiguration() = default; void setup(ConfigurationManager& config); static TargetProfileConfiguration fromQirTargetName(String const& name); OpcodeSet const& allowedOpcodes() const; Set const& allowedExternalCallNames() const; bool allowInternalCalls() const; bool allowlistOpcodes() const; bool allowlistExternalCalls() const; bool allowlistPointerTypes() const; Set const& allowedPointerTypes() const; bool allowPoison() const; bool allowUndef() const; String targetName() const; private: void addAllowedExternalCall(String const& name); void addAllowedOpcode(String const& name); void addAllowedPointerType(String const& name); String target_name_{\"null\"}; OpcodeSet opcodes_{}; Set external_calls_{}; Set allowed_pointer_types_{}; bool allowlist_opcodes_{true}; bool allowlist_external_calls_{true}; bool allow_internal_calls_{false}; bool allowlist_pointer_types_{false}; bool allow_primitive_return_{true}; bool allow_struct_return_{true}; bool allow_pointer_return_{true}; bool allow_poison_{true}; bool allow_undef_{true}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/ValidationPass/TargetProfileConfiguration.hpp"},{"location":"Api/Files/_target_profile_configuration_8hpp/#passesvalidationpasstargetprofileconfigurationhpp","text":"","title":"Passes/ValidationPass/TargetProfileConfiguration.hpp"},{"location":"Api/Files/_target_profile_configuration_8hpp/#namespaces","text":"Name microsoft microsoft::quantum std","title":"Namespaces"},{"location":"Api/Files/_target_profile_configuration_8hpp/#classes","text":"Name class microsoft::quantum::OpcodeValue struct std::hash< microsoft::quantum::OpcodeValue > class microsoft::quantum::OpcodeSet class microsoft::quantum::TargetProfileConfiguration","title":"Classes"},{"location":"Api/Files/_target_profile_configuration_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <set> namespace microsoft::quantum { class OpcodeValue { public: OpcodeValue(String const& name, String const& fi = \"\") // NOLINT : id_{name} , predicate_{fi} { } OpcodeValue() = default; OpcodeValue(OpcodeValue&&) = default; OpcodeValue(OpcodeValue const&) = default; OpcodeValue& operator=(OpcodeValue&&) = default; OpcodeValue& operator=(OpcodeValue const&) = default; bool operator==(OpcodeValue const& other) const { return id_ == other.id_ && predicate_ == other.predicate_; } String& id() { return id_; } String const& id() const { return id_; } String& predicate() { return predicate_; } String const& predicate() const { return predicate_; } private: String id_{\"\"}; String predicate_{\"\"}; }; } // namespace microsoft::quantum namespace std { template <> struct hash<microsoft::quantum::OpcodeValue> { size_t operator()(microsoft::quantum::OpcodeValue const& x) const { hash<std::string> hasher; return hasher(x.id() + \".\" + x.predicate()); } }; } // namespace std namespace microsoft::quantum { class OpcodeSet { public: using Container = std::unordered_set<OpcodeValue>; explicit OpcodeSet(Container const& data = {}) : data_{data} { } explicit OpcodeSet(Container&& data) : data_{std::move(data)} { } Container& data() { return data_; } Container const& data() const { return data_; } void toString(String& value) const { std::stringstream val; bool not_first = false; for (auto const& d : data_) { if (not_first) { val << \";\"; } val << d.id() << \",\" << d.predicate(); not_first = true; } value = val.str(); } void insertPart(String const& part) { // bind_.insert(part); auto p = part.find(','); if (p == std::string::npos) { throw std::runtime_error(\"Execpted ',' but it is not present in opcode segment\"); } auto a = part.substr(0, p); auto b = part.substr(p + 1, part.size() - p - 1); data_.insert(OpcodeValue(a, b)); } void fromString(String const& value) { data_.clear(); std::size_t last_p = 0; auto p = value.find(';', last_p); while (p != String::npos) { auto part = value.substr(last_p, p - last_p); insertPart(part); last_p = p + 1; p = value.find(';', last_p); } if (last_p < value.size()) { auto part = value.substr(last_p, p - last_p); insertPart(part); } } void toYaml(YAML::Node& node) const { for (auto const& d : data_) { YAML::Node pair; pair[\"id\"] = d.id(); pair[\"predicate\"] = d.predicate(); node.push_back(pair); } } void fromYaml(YAML::Node const& node) { for (auto& pair : node) { auto a = pair[\"id\"].as<String>(); auto b = pair[\"predicate\"].as<String>(); data_.insert(OpcodeValue(a, b)); } } private: Container data_; }; static_assert(HasQatSerializers<OpcodeSet>::VALUE, \"Expected OpcodeSet to be serializable.\"); class TargetProfileConfiguration { public: using Set = std::unordered_set<std::string>; // using OpcodeSet = std::unordered_set<OpcodeValue>; // Setup and construction // TargetProfileConfiguration() = default; void setup(ConfigurationManager& config); static TargetProfileConfiguration fromQirTargetName(String const& name); OpcodeSet const& allowedOpcodes() const; Set const& allowedExternalCallNames() const; bool allowInternalCalls() const; bool allowlistOpcodes() const; bool allowlistExternalCalls() const; bool allowlistPointerTypes() const; Set const& allowedPointerTypes() const; bool allowPoison() const; bool allowUndef() const; String targetName() const; private: void addAllowedExternalCall(String const& name); void addAllowedOpcode(String const& name); void addAllowedPointerType(String const& name); String target_name_{\"null\"}; OpcodeSet opcodes_{}; Set external_calls_{}; Set allowed_pointer_types_{}; bool allowlist_opcodes_{true}; bool allowlist_external_calls_{true}; bool allow_internal_calls_{false}; bool allowlist_pointer_types_{false}; bool allow_primitive_return_{true}; bool allow_struct_return_{true}; bool allow_pointer_return_{true}; bool allow_poison_{true}; bool allow_undef_{true}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_target_profile_mapping_configuration_8hpp/","text":"AdaptorFactory/TargetProfileMappingConfiguration.hpp Namespaces Name microsoft microsoft::quantum Classes Name struct microsoft::quantum::TargetProfileMappingConfiguration Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" namespace microsoft::quantum { struct TargetProfileMappingConfiguration { public: void setup(ConfigurationManager& config) { config.setSectionName(\"Target profile mapping\", \"Changes the IR to comply with profile requirements.\"); config.addParameter(lower_switch_, \"lower-switch\", \"Lower switch statements.\"); config.addParameter( should_eleminate_zext_i1_, \"should-eleminate-zext-i1\", \"Replace zext instruction for i1 with select.\"); config.addParameter( defer_measurements_, \"defer-measurements\", \"Wether or not measurement and recording functions should be moved to the end of the program.\"); } static TargetProfileMappingConfiguration createDisabled() { TargetProfileMappingConfiguration ret; ret.inst_combine_pass_ = false; ret.aggressive_inst_combine_pass_ = false; ret.sccp_pass_ = false; ret.simplify_cfg_pass_ = false; ret.lower_switch_ = false; ret.should_eleminate_zext_i1_ = false; ret.defer_measurements_ = false; return ret; } bool shouldAddInstCombinePass() const { return inst_combine_pass_; } bool shouldAddAggressiveInstCombinePass() const { return aggressive_inst_combine_pass_; } bool shouldAddSccpPass() const { return sccp_pass_; } bool shouldAddSimplifyCfgPass() const { return simplify_cfg_pass_; } bool shouldLowerSwitch() const { return lower_switch_; } bool shouldEliminateZExtI1() const { return should_eleminate_zext_i1_; } bool shouldDeferMeasurements() const { return defer_measurements_; } void setUseDeferMeasurements(bool const& v) { defer_measurements_ = v; } private: bool inst_combine_pass_{true}; bool aggressive_inst_combine_pass_{true}; bool sccp_pass_{true}; bool simplify_cfg_pass_{true}; bool lower_switch_{true}; bool should_eleminate_zext_i1_{true}; bool defer_measurements_{false}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"AdaptorFactory/TargetProfileMappingConfiguration.hpp"},{"location":"Api/Files/_target_profile_mapping_configuration_8hpp/#adaptorfactorytargetprofilemappingconfigurationhpp","text":"","title":"AdaptorFactory/TargetProfileMappingConfiguration.hpp"},{"location":"Api/Files/_target_profile_mapping_configuration_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_target_profile_mapping_configuration_8hpp/#classes","text":"Name struct microsoft::quantum::TargetProfileMappingConfiguration","title":"Classes"},{"location":"Api/Files/_target_profile_mapping_configuration_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" namespace microsoft::quantum { struct TargetProfileMappingConfiguration { public: void setup(ConfigurationManager& config) { config.setSectionName(\"Target profile mapping\", \"Changes the IR to comply with profile requirements.\"); config.addParameter(lower_switch_, \"lower-switch\", \"Lower switch statements.\"); config.addParameter( should_eleminate_zext_i1_, \"should-eleminate-zext-i1\", \"Replace zext instruction for i1 with select.\"); config.addParameter( defer_measurements_, \"defer-measurements\", \"Wether or not measurement and recording functions should be moved to the end of the program.\"); } static TargetProfileMappingConfiguration createDisabled() { TargetProfileMappingConfiguration ret; ret.inst_combine_pass_ = false; ret.aggressive_inst_combine_pass_ = false; ret.sccp_pass_ = false; ret.simplify_cfg_pass_ = false; ret.lower_switch_ = false; ret.should_eleminate_zext_i1_ = false; ret.defer_measurements_ = false; return ret; } bool shouldAddInstCombinePass() const { return inst_combine_pass_; } bool shouldAddAggressiveInstCombinePass() const { return aggressive_inst_combine_pass_; } bool shouldAddSccpPass() const { return sccp_pass_; } bool shouldAddSimplifyCfgPass() const { return simplify_cfg_pass_; } bool shouldLowerSwitch() const { return lower_switch_; } bool shouldEliminateZExtI1() const { return should_eleminate_zext_i1_; } bool shouldDeferMeasurements() const { return defer_measurements_; } void setUseDeferMeasurements(bool const& v) { defer_measurements_ = v; } private: bool inst_combine_pass_{true}; bool aggressive_inst_combine_pass_{true}; bool sccp_pass_{true}; bool simplify_cfg_pass_{true}; bool lower_switch_{true}; bool should_eleminate_zext_i1_{true}; bool defer_measurements_{false}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_target_qis_configuration_8cpp/","text":"Passes/ValidationPass/TargetQisConfiguration.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/ValidationPass/TargetQisConfiguration.hpp\" #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" namespace microsoft::quantum { void TargetQisConfiguration::setup(ConfigurationManager& config) { config.setSectionName(\"Target QIS validation\", \"Configuration for QIS validation\"); // CLI and config accessible config.addParameter( allowed_qis_, \"allowed-qis\", \"Allowed quantum instruction set.\", ConfigurationManager::ParameterVisibility::ConfigOnly); config.addParameter(allow_any_qis_, \"allow-any-qis\", \"Whether or not to allow any quantum instruction.\"); config.addParameter(irreversible_operations_, \"irreversible-operations\", \"Set of irreversal operation names.\"); config.addParameter(requires_qubits_, \"requires-qubits\", \"Whether or not qubits are required in the IR.\"); config.addParameter(requires_results_, \"requires-results\", \"Whether or not results are required in the IR.\"); } String TargetQisConfiguration::targetName() const { return target_name_; } bool TargetQisConfiguration::requiresQubits() const { return requires_qubits_; } bool TargetQisConfiguration::requiresResults() const { return requires_results_; } TargetQisConfiguration TargetQisConfiguration::fromQirTargetName(String const& name) { auto target_config = TargetQisConfiguration(); if (name == \"generic\") { target_config.allow_any_qis_ = true; } else if (name == \"default\") { target_config.allow_any_qis_ = false; target_config.allowed_qis_ = Set{ \"__quantum__qis__cnot__body:void (%Qubit*, %Qubit*)\", \"__quantum__qis__cz__body:void (%Qubit*, %Qubit*)\", \"__quantum__qis__cx__body:void (%Qubit*, %Qubit*)\", \"__quantum__qis__cy__body:void (%Qubit*, %Qubit*)\", \"__quantum__qis__h__body:void (%Qubit*)\", \"__quantum__qis__s__body:void (%Qubit*)\", \"__quantum__qis__s__adj:void (%Qubit*)\", \"__quantum__qis__t__body:void (%Qubit*)\", \"__quantum__qis__t__adj:void (%Qubit*)\", \"__quantum__qis__x__body:void (%Qubit*)\", \"__quantum__qis__y__body:void (%Qubit*)\", \"__quantum__qis__z__body:void (%Qubit*)\", \"__quantum__qis__rx__body:void (double, %Qubit*)\", \"__quantum__qis__ry__body:void (double, %Qubit*)\", \"__quantum__qis__rz__body:void (double, %Qubit*)\", \"__quantum__qis__reset__body:void (%Qubit*)\", \"__quantum__qis__mz__body:void (%Qubit*, %Result*)\", \"__quantum__qis__read_result__body:i1 (%Result*)\", }; target_config.irreversible_operations_ = Set{\"__quantum__qis__mz__body\", \"__quantum__qis__reset__body\"}; } else { throw std::runtime_error(\"Invalid adaptor \" + name); } target_config.target_name_ = name; return target_config; } TargetQisConfiguration::Set const& TargetQisConfiguration::allowedQis() const { return allowed_qis_; } TargetQisConfiguration::Set const& TargetQisConfiguration::irreversibleOperations() const { return irreversible_operations_; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/ValidationPass/TargetQisConfiguration.cpp"},{"location":"Api/Files/_target_qis_configuration_8cpp/#passesvalidationpasstargetqisconfigurationcpp","text":"","title":"Passes/ValidationPass/TargetQisConfiguration.cpp"},{"location":"Api/Files/_target_qis_configuration_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_target_qis_configuration_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/ValidationPass/TargetQisConfiguration.hpp\" #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" namespace microsoft::quantum { void TargetQisConfiguration::setup(ConfigurationManager& config) { config.setSectionName(\"Target QIS validation\", \"Configuration for QIS validation\"); // CLI and config accessible config.addParameter( allowed_qis_, \"allowed-qis\", \"Allowed quantum instruction set.\", ConfigurationManager::ParameterVisibility::ConfigOnly); config.addParameter(allow_any_qis_, \"allow-any-qis\", \"Whether or not to allow any quantum instruction.\"); config.addParameter(irreversible_operations_, \"irreversible-operations\", \"Set of irreversal operation names.\"); config.addParameter(requires_qubits_, \"requires-qubits\", \"Whether or not qubits are required in the IR.\"); config.addParameter(requires_results_, \"requires-results\", \"Whether or not results are required in the IR.\"); } String TargetQisConfiguration::targetName() const { return target_name_; } bool TargetQisConfiguration::requiresQubits() const { return requires_qubits_; } bool TargetQisConfiguration::requiresResults() const { return requires_results_; } TargetQisConfiguration TargetQisConfiguration::fromQirTargetName(String const& name) { auto target_config = TargetQisConfiguration(); if (name == \"generic\") { target_config.allow_any_qis_ = true; } else if (name == \"default\") { target_config.allow_any_qis_ = false; target_config.allowed_qis_ = Set{ \"__quantum__qis__cnot__body:void (%Qubit*, %Qubit*)\", \"__quantum__qis__cz__body:void (%Qubit*, %Qubit*)\", \"__quantum__qis__cx__body:void (%Qubit*, %Qubit*)\", \"__quantum__qis__cy__body:void (%Qubit*, %Qubit*)\", \"__quantum__qis__h__body:void (%Qubit*)\", \"__quantum__qis__s__body:void (%Qubit*)\", \"__quantum__qis__s__adj:void (%Qubit*)\", \"__quantum__qis__t__body:void (%Qubit*)\", \"__quantum__qis__t__adj:void (%Qubit*)\", \"__quantum__qis__x__body:void (%Qubit*)\", \"__quantum__qis__y__body:void (%Qubit*)\", \"__quantum__qis__z__body:void (%Qubit*)\", \"__quantum__qis__rx__body:void (double, %Qubit*)\", \"__quantum__qis__ry__body:void (double, %Qubit*)\", \"__quantum__qis__rz__body:void (double, %Qubit*)\", \"__quantum__qis__reset__body:void (%Qubit*)\", \"__quantum__qis__mz__body:void (%Qubit*, %Result*)\", \"__quantum__qis__read_result__body:i1 (%Result*)\", }; target_config.irreversible_operations_ = Set{\"__quantum__qis__mz__body\", \"__quantum__qis__reset__body\"}; } else { throw std::runtime_error(\"Invalid adaptor \" + name); } target_config.target_name_ = name; return target_config; } TargetQisConfiguration::Set const& TargetQisConfiguration::allowedQis() const { return allowed_qis_; } TargetQisConfiguration::Set const& TargetQisConfiguration::irreversibleOperations() const { return irreversible_operations_; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_target_qis_configuration_8hpp/","text":"Passes/ValidationPass/TargetQisConfiguration.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::TargetQisConfiguration Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <set> namespace microsoft::quantum { class TargetQisConfiguration { public: using Set = std::unordered_set<std::string>; // Setup and construction // TargetQisConfiguration() = default; void setup(ConfigurationManager& config); static TargetQisConfiguration fromQirTargetName(String const& name); Set const& allowedQis() const; Set const& irreversibleOperations() const; bool requiresQubits() const; bool requiresResults() const; String targetName() const; private: String target_name_{\"null\"}; bool allow_any_qis_{false}; Set allowed_qis_{}; Set irreversible_operations_{}; bool requires_qubits_{false}; bool requires_results_{false}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/ValidationPass/TargetQisConfiguration.hpp"},{"location":"Api/Files/_target_qis_configuration_8hpp/#passesvalidationpasstargetqisconfigurationhpp","text":"","title":"Passes/ValidationPass/TargetQisConfiguration.hpp"},{"location":"Api/Files/_target_qis_configuration_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_target_qis_configuration_8hpp/#classes","text":"Name class microsoft::quantum::TargetQisConfiguration","title":"Classes"},{"location":"Api/Files/_target_qis_configuration_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <set> namespace microsoft::quantum { class TargetQisConfiguration { public: using Set = std::unordered_set<std::string>; // Setup and construction // TargetQisConfiguration() = default; void setup(ConfigurationManager& config); static TargetQisConfiguration fromQirTargetName(String const& name); Set const& allowedQis() const; Set const& irreversibleOperations() const; bool requiresQubits() const; bool requiresResults() const; String targetName() const; private: String target_name_{\"null\"}; bool allow_any_qis_{false}; Set allowed_qis_{}; Set irreversible_operations_{}; bool requires_qubits_{false}; bool requires_results_{false}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_target_qis_mapping_pass_8cpp/","text":"Passes/TargetQisMappingPass/TargetQisMappingPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/TargetQisMappingPass/TargetQisMappingPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/Factory.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/ReplacementRule.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { TargetQisMappingPass::TargetQisMappingPass(RuleSet&& rule_set, TargetQisMappingPassConfiguration const& config) : rule_set_{std::move(rule_set)} , config_{config} { } void TargetQisMappingPass::setupCopyAndExpand() { using namespace microsoft::quantum::notation; addConstExprRule( {branch(\"cond\"_cap = constInt(), \"if_false\"_cap = _, \"if_true\"_cap = _), [](Builder& builder, Value* val, Captures& captures, Replacements& replacements) { auto cst = llvm::dyn_cast<llvm::ConstantInt>(captures[\"cond\"]); auto instr = llvm::dyn_cast<llvm::Instruction>(val); if (cst == nullptr || instr == nullptr) { return false; } auto type = instr->getType(); if (type == nullptr) { return false; } auto branch_cond = cst->getValue().getZExtValue(); if (branch_cond) { auto if_true = llvm::dyn_cast<llvm::BasicBlock>(captures[\"if_true\"]); builder.CreateBr(if_true); instr->replaceAllUsesWith(llvm::UndefValue::get(type)); } else { auto if_false = llvm::dyn_cast<llvm::BasicBlock>(captures[\"if_false\"]); builder.CreateBr(if_false); instr->replaceAllUsesWith(llvm::UndefValue::get(type)); } replacements.push_back({val, nullptr}); return true; }}); if (config_.assumeNoExceptions()) { // Replacing all invokes with calls addConstExprRule( {unnamedInvoke(), [](Builder& builder, Value* val, Captures&, Replacements& replacements) { auto invoke = llvm::dyn_cast<llvm::InvokeInst>(val); if (invoke == nullptr) { return false; } auto callee_function = invoke->getCalledFunction(); // List with new call arguments std::vector<llvm::Value*> new_arguments; for (unsigned i = 0; i < invoke->getNumArgOperands(); ++i) { // Getting the i'th argument llvm::Value* arg = invoke->getArgOperand(i); new_arguments.push_back(arg); } // Creating a new call auto* new_call = builder.CreateCall(callee_function, new_arguments); builder.CreateBr(invoke->getNormalDest()); new_call->takeName(invoke); // Replace all calls to old function with calls to new function invoke->replaceAllUsesWith(new_call); replacements.push_back({invoke, nullptr}); return true; }}); } } void TargetQisMappingPass::addConstExprRule(ReplacementRule&& rule) { auto ret = std::make_shared<ReplacementRule>(std::move(rule)); const_expr_replacements_.addRule(ret); } void TargetQisMappingPass::constantFoldFunction(llvm::Function& fnc) { std::vector<llvm::Instruction*> to_delete; // Folding all constants for (auto& basic_block : fnc) { for (auto& instr : basic_block) { auto module = instr.getModule(); auto const& dl = module->getDataLayout(); auto cst = llvm::ConstantFoldInstruction(&instr, dl, nullptr); if (cst != nullptr) { instr.replaceAllUsesWith(cst); to_delete.push_back(&instr); } } } // Deleting constants for (auto& x : to_delete) { x->eraseFromParent(); } // Folding constant expressions Replacements replacements; for (auto& basic_block : fnc) { for (auto& instr : basic_block) { const_expr_replacements_.matchAndReplace(&instr, replacements); } } for (auto& r : replacements) { if (r.second != nullptr) { throw std::runtime_error(\"Real replacements not implemented.\"); } auto instr = llvm::dyn_cast<llvm::Instruction>(r.first); if (instr != nullptr) { instr->eraseFromParent(); continue; } auto block = llvm::dyn_cast<llvm::BasicBlock>(r.first); if (block != nullptr) { llvm::DeleteDeadBlock(block); } } } llvm::Value* TargetQisMappingPass::copyAndExpand( llvm::Value* input, DeletableInstructions& schedule_instruction_deletion) { llvm::Value* ret = input; auto* call_instr = llvm::dyn_cast<llvm::CallInst>(input); auto instr_ptr = llvm::dyn_cast<llvm::Instruction>(input); if (call_instr != nullptr && instr_ptr != nullptr) { auto& instr = *instr_ptr; auto callee_function = call_instr->getCalledFunction(); if (callee_function != nullptr && !callee_function->isDeclaration()) { ConstantArguments argument_constants{}; std::vector<uint32_t> remaining_arguments{}; uint32_t idx = 0; auto n = static_cast<uint32_t>(callee_function->arg_size()); // Finding argument constants while (idx < n) { auto arg = callee_function->getArg(idx); auto value = call_instr->getArgOperand(idx); auto cst = llvm::dyn_cast<llvm::ConstantInt>(value); if (cst != nullptr) { argument_constants[arg->getName().str()] = cst; } else { remaining_arguments.push_back(idx); } ++idx; } // Making a function copy auto new_callee = expandFunctionCall(*callee_function, argument_constants); // Replacing call if a new function was created if (new_callee != nullptr) { llvm::IRBuilder<> builder(call_instr); // List with new call arguments std::vector<llvm::Value*> new_arguments; for (auto const& i : remaining_arguments) { // Getting the i'th argument llvm::Value* arg = call_instr->getArgOperand(i); // Adding arguments that were not constant if (argument_constants.find(arg->getName().str()) == argument_constants.end()) { new_arguments.push_back(arg); } } // Creating a new call auto* new_call = builder.CreateCall(new_callee, new_arguments); new_call->takeName(call_instr); new_call->setTailCall(call_instr->isTailCall()); new_call->setTailCallKind(call_instr->getTailCallKind()); if (call_instr->canReturnTwice()) { new_call->setCanReturnTwice(); } new_call->setCallingConv(call_instr->getCallingConv()); new_call->setAttributes(call_instr->getAttributes()); // Replace all calls to old function with calls to new function instr.replaceAllUsesWith(new_call); // Deleting instruction schedule_instruction_deletion.push_back(&instr); // Folding constants in the new function as we may have replaced some of // the arguments with constants constantFoldFunction(*new_callee); // Recursion: Returning the new call as the instruction to be analysed ret = new_call; } // Deleting the function the original function if it is no longer in use if (callee_function->use_empty()) { callee_function->eraseFromParent(); } } } return ret; } llvm::Value* TargetQisMappingPass::detectActiveCode(llvm::Value* input, DeletableInstructions&) { active_pieces_.insert(input); return input; } bool TargetQisMappingPass::runOnFunction(llvm::Function& function, InstructionModifier const& modifier) { if (function.isDeclaration()) { return false; } if (depth_ >= config_.maxRecursion()) { requireLogger(); logger_->errorFunctionInliningMaxRecursion(config_.maxRecursion(), &function); return false; } ++depth_; // Keep track of instructions scheduled for deletion DeletableInstructions schedule_instruction_deletion; // Block queue std::deque<llvm::BasicBlock*> queue; std::unordered_set<llvm::BasicBlock*> blocks_queued; queue.push_back(&function.getEntryBlock()); blocks_queued.insert(&function.getEntryBlock()); // Executing the modifier on the function itsel modifier(&function, schedule_instruction_deletion); while (!queue.empty()) { auto& basic_block = *(queue.front()); queue.pop_front(); // Executing the modifier on the block modifier(&basic_block, schedule_instruction_deletion); for (auto& instr : basic_block) { // Modifying instruction as needed auto instr_ptr = modifier(&instr, schedule_instruction_deletion); // In case the instruction was scheduled for deletion if (instr_ptr == nullptr) { continue; } // Checking if we are calling a function auto call_instr = llvm::dyn_cast<llvm::CallBase>(instr_ptr); if (call_instr != nullptr) { auto callee_function = call_instr->getCalledFunction(); if (callee_function != nullptr && !callee_function->isDeclaration()) { runOnFunction(*callee_function, modifier); } } // Following the branches to their basic blocks auto* br_instr = llvm::dyn_cast<llvm::BranchInst>(&instr); if (br_instr != nullptr) { for (uint32_t i = 0; i < br_instr->getNumOperands(); ++i) { // TODO(issue-19): This may not work on multi path branches (conditional) // as we may accidentally add the final path (contains qubit release) // and we cannot make assumptions since optimization may have rearranged // everything. In this case, we should revert to the order they appear in the // function auto bb = llvm::dyn_cast<llvm::BasicBlock>(br_instr->getOperand(i)); if (bb != nullptr) { // Ensuring that we are not scheduling the same block twice if (blocks_queued.find(bb) == blocks_queued.end()) { queue.push_back(bb); blocks_queued.insert(bb); } } } continue; } // Follow the branches of auto* switch_instr = llvm::dyn_cast<llvm::SwitchInst>(&instr); if (switch_instr != nullptr) { for (uint64_t i = 0; i < switch_instr->getNumSuccessors(); ++i) { auto bb = switch_instr->getSuccessor(static_cast<uint32_t>(i)); // Ensuring that we are not scheduling the same block twice if (blocks_queued.find(bb) == blocks_queued.end()) { queue.push_back(bb); blocks_queued.insert(bb); } } continue; } // Checking if this is an invoke call auto* invoke_inst = llvm::dyn_cast<llvm::InvokeInst>(&instr); if (invoke_inst != nullptr) { // Checking that configuration is correct if (!config_.assumeNoExceptions()) { // TODO(issue-20): Unify error reporting throw std::runtime_error(\"Exceptions paths cannot be handled at compile time. Either disable \" \"transform-execution-path-only or add assumption assume-no-except\"); } // Adding the block which is the on the \"no except\" path auto bb = invoke_inst->getNormalDest(); if (blocks_queued.find(bb) == blocks_queued.end()) { queue.push_back(bb); blocks_queued.insert(bb); } } } } // Deleting constants for (auto& x : schedule_instruction_deletion) { x->eraseFromParent(); } --depth_; return true; } bool TargetQisMappingPass::isActive(llvm::Value* value) const { return active_pieces_.find(value) != active_pieces_.end(); } void TargetQisMappingPass::runCopyAndExpand(llvm::Module& module, llvm::ModuleAnalysisManager&) { replacements_.clear(); // For every instruction in every block, we attempt a match // and replace. for (auto& function : module) { if (function.hasFnAttribute(config_.entryPointAttr())) { runOnFunction( function, [this](llvm::Value* value, DeletableInstructions& modifier) { return copyAndExpand(value, modifier); }); } } // Active code detection for (auto& global : module.globals()) { active_pieces_.insert(&global); for (auto& op : global.operands()) { active_pieces_.insert(op); } } for (auto& function : module) { bool is_active = false; // Checking if the function is referenced by a global variable for (auto user : function.users()) { // If the user is active, then it should be expected that the function is also active if (isActive(user)) { is_active = true; break; } } if (is_active || function.hasFnAttribute(config_.entryPointAttr())) { // Marking function as active active_pieces_.insert(&function); // Detecting active code runOnFunction( function, [this](llvm::Value* value, DeletableInstructions& modifier) { return detectActiveCode(value, modifier); }); } } processReplacements(); } void TargetQisMappingPass::processReplacements() { // Applying all replacements std::unordered_set<llvm::Value*> already_removed; for (auto it = replacements_.rbegin(); it != replacements_.rend(); ++it) { // Ignoring values that were already removed. if (already_removed.find(it->first) != already_removed.end()) { continue; } already_removed.insert(it->first); auto instr1 = llvm::dyn_cast<llvm::Instruction>(it->first); if (instr1 == nullptr) { requireLogger(); logger_->setLocationFromValue(nullptr); logger_->internalError(\"Cannot replace with non-instruction replacements\"); continue; } // Checking if have a replacement for the instruction if (it->second != nullptr) { // ... if so, we just replace it, auto instr2 = llvm::dyn_cast<llvm::Instruction>(it->second); if (instr2 == nullptr) { requireLogger(); logger_->setLocationFromValue(instr1); logger_->internalError(\"Attempt to replace with non-instruction value. This is not allowed.\"); continue; } llvm::ReplaceInstWithInst(instr1, instr2); } else { // ... otherwize we delete the the instruction // Removing all uses if (!instr1->use_empty()) { auto type = instr1->getType(); if (type != nullptr) { instr1->replaceAllUsesWith(llvm::UndefValue::get(type)); } } // And finally we delete the instruction. The if statement // is first and foremost a precaution which prevents the program // from seg-faulting in the unlikely case that instr1->getType() is null. if (instr1->use_empty()) { instr1->eraseFromParent(); } } } replacements_.clear(); } void TargetQisMappingPass::runDetectActiveCode(llvm::Module& module, llvm::ModuleAnalysisManager&) { blocks_to_delete_.clear(); functions_to_delete_.clear(); for (auto& function : module) { if (isActive(&function)) { for (auto& block : function) { if (!isActive(&block)) { blocks_to_delete_.push_back(&block); } } } else if (!function.isDeclaration()) { functions_to_delete_.push_back(&function); } } } void TargetQisMappingPass::runDeleteDeadCode(llvm::Module&, llvm::ModuleAnalysisManager&) { // Removing all function references and scheduling blocks for deletion for (auto& function : functions_to_delete_) { // Schedule for deletion function->replaceAllUsesWith(llvm::UndefValue::get(function->getType())); function->clearGC(); function->clearMetadata(); // Deleteing blocks in reverse order std::vector<llvm::BasicBlock*> blocks; for (auto& block : *function) { blocks.push_back(&block); } // Removing backwards to avoid segfault for (auto it = blocks.rbegin(); it != blocks.rend(); ++it) { auto& block = **it; // Deleting instructions in reverse order (needed because it is a DAG structure) std::vector<llvm::Instruction*> instructions; for (auto& instr : block) { instructions.push_back(&instr); } // Removing all instructions for (auto it2 = instructions.rbegin(); it2 != instructions.rend(); ++it2) { auto& instr = **it2; instr.replaceAllUsesWith(llvm::UndefValue::get(instr.getType())); instr.eraseFromParent(); } // Removing all block references block.replaceAllUsesWith(llvm::UndefValue::get(block.getType())); // Scheduling block deletion blocks_to_delete_.push_back(&block); } } // Deleting all blocks for (auto block : blocks_to_delete_) { if (block->use_empty()) { block->eraseFromParent(); } else { requireLogger(); logger_->setLocationFromValue(block); logger_->internalError(\"Block was supposed to be unused\"); } } // Removing functions for (auto& function : functions_to_delete_) { if (function->isDeclaration() && function->use_empty()) { function->eraseFromParent(); } } } void TargetQisMappingPass::runReplacePhi(llvm::Module& module, llvm::ModuleAnalysisManager&) { using namespace microsoft::quantum::notation; auto rule = phi(\"b1\"_cap = _, \"b2\"_cap = _); IOperandPrototype::Captures captures; std::vector<llvm::Instruction*> to_delete; std::unordered_map<llvm::Instruction*, llvm::Value*> replacements; for (auto& function : module) { for (auto& block : function) { std::vector<llvm::Instruction*> instrs; for (auto& instr : block) { if (rule->match(&instr, captures)) { auto phi = llvm::dyn_cast<llvm::PHINode>(&instr); if (phi == nullptr) { continue; } auto val1 = captures[\"b1\"]; auto val2 = captures[\"b2\"]; auto block1 = phi->getIncomingBlock(0); // TODO(issue-21): Make sure that block1 matches val1 auto block2 = phi->getIncomingBlock(1); if (!isActive(block1)) { val2->takeName(&instr); replacements[&instr] = val2; to_delete.push_back(&instr); } else if (!isActive(block2)) { val1->takeName(&instr); replacements[&instr] = val2; to_delete.push_back(&instr); } captures.clear(); } } } } for (auto& r : replacements) { r.first->replaceAllUsesWith(r.second); } for (auto& x : to_delete) { x->eraseFromParent(); } } void TargetQisMappingPass::runApplyRules(llvm::Module& module, llvm::ModuleAnalysisManager&) { replacements_.clear(); std::unordered_set<llvm::Value*> already_visited; for (auto& function : module) { if (function.hasFnAttribute(config_.entryPointAttr())) { runOnFunction( function, [this, &already_visited](llvm::Value* value, DeletableInstructions&) { auto instr = llvm::dyn_cast<llvm::Instruction>(value); // Sanity check if (already_visited.find(value) != already_visited.end()) { requireLogger(); logger_->setLocationFromValue(value); logger_->internalError(\"Instruction was visited twice while applying rule to function.\"); return value; } already_visited.insert(value); // Checking if we should analyse if (instr != nullptr) { rule_set_.matchAndReplace(instr, replacements_); } return value; }); } } processReplacements(); } llvm::PreservedAnalyses TargetQisMappingPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& mam) { // In case the module is instructed to clone functions, if (config_.shouldCloneFunctions()) { setupCopyAndExpand(); runCopyAndExpand(module, mam); } // Deleting dead code if configured to do so. This process consists // of three steps: detecting dead code, removing phi nodes (and references) // and finally deleting the code. This implementation is aggressive in the sense // that any code that we cannot prove to be active is considered dead. if (config_.shouldDeleteDeadCode()) { runDetectActiveCode(module, mam); runReplacePhi(module, mam); runDeleteDeadCode(module, mam); } // Applying rule set if (config_.shouldTransformExecutionPathOnly()) { // TODO(tfr): This implementation path lacks backwards replacement (see else section) // We only apply transformation rules to code which is reachable // via the execution path. runApplyRules(module, mam); } else { // Otherwise we apply to all sections of the code. replacements_.clear(); for (auto& function : module) { // Creating a list of all instructions in the function // and matching rules in forward direction for (auto& block : function) { for (auto& instr : block) { rule_set_.matchAndReplace(&instr, replacements_); } } // Matching in reverse order std::vector<llvm::Instruction*> instructions; for (auto& block : function) { for (auto& instr : block) { instructions.push_back(&instr); } } std::reverse(instructions.begin(), instructions.end()); for (auto instr : instructions) { rule_set_.matchAndReplace(instr, replacements_, RuleSet::ReplaceDirection::ReplaceBackwards); } } processReplacements(); } return llvm::PreservedAnalyses::none(); } llvm::Function* TargetQisMappingPass::expandFunctionCall(llvm::Function& callee, ConstantArguments const& const_args) { auto module = callee.getParent(); auto& context = module->getContext(); llvm::IRBuilder<> builder(context); // Copying the original function llvm::ValueToValueMapTy remapper; std::vector<llvm::Type*> arg_types; // The user might be deleting arguments to the function by specifying them in // the VMap. If so, we need to not add the arguments to the arg ty vector // for (auto const& arg : callee.args()) { // Skipping constant arguments if (const_args.find(arg.getName().str()) != const_args.end()) { continue; } arg_types.push_back(arg.getType()); } // Creating a new function llvm::FunctionType* function_type = llvm::FunctionType::get( callee.getFunctionType()->getReturnType(), arg_types, callee.getFunctionType()->isVarArg()); auto function = llvm::Function::Create(function_type, callee.getLinkage(), callee.getAddressSpace(), callee.getName(), module); // Copying the non-const arguments auto dest_args_it = function->arg_begin(); for (auto const& arg : callee.args()) { auto const_it = const_args.find(arg.getName().str()); if (const_it == const_args.end()) { // Mapping remaining function arguments dest_args_it->setName(arg.getName()); remapper[&arg] = &*dest_args_it++; } else { remapper[&arg] = llvm::ConstantInt::get(context, const_it->second->getValue()); } } llvm::SmallVector<llvm::ReturnInst*, 8> returns; // Ignore returns cloned. llvm::CloneFunctionInto( function, &callee, remapper, llvm::CloneFunctionChangeType::LocalChangesOnly, returns, \"\", nullptr); verifyFunction(*function); return function; } void TargetQisMappingPass::setLogger(ILoggerPtr logger) { logger_ = std::move(logger); } bool TargetQisMappingPass::isRequired() { return true; } void TargetQisMappingPass::requireLogger() { if (logger_ == nullptr) { throw std::runtime_error(\"TargetQisMappingPass does not have a logger, but need it to emit messages.\"); } } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/TargetQisMappingPass/TargetQisMappingPass.cpp"},{"location":"Api/Files/_target_qis_mapping_pass_8cpp/#passestargetqismappingpasstargetqismappingpasscpp","text":"","title":"Passes/TargetQisMappingPass/TargetQisMappingPass.cpp"},{"location":"Api/Files/_target_qis_mapping_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_target_qis_mapping_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/TargetQisMappingPass/TargetQisMappingPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/Factory.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/ReplacementRule.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { TargetQisMappingPass::TargetQisMappingPass(RuleSet&& rule_set, TargetQisMappingPassConfiguration const& config) : rule_set_{std::move(rule_set)} , config_{config} { } void TargetQisMappingPass::setupCopyAndExpand() { using namespace microsoft::quantum::notation; addConstExprRule( {branch(\"cond\"_cap = constInt(), \"if_false\"_cap = _, \"if_true\"_cap = _), [](Builder& builder, Value* val, Captures& captures, Replacements& replacements) { auto cst = llvm::dyn_cast<llvm::ConstantInt>(captures[\"cond\"]); auto instr = llvm::dyn_cast<llvm::Instruction>(val); if (cst == nullptr || instr == nullptr) { return false; } auto type = instr->getType(); if (type == nullptr) { return false; } auto branch_cond = cst->getValue().getZExtValue(); if (branch_cond) { auto if_true = llvm::dyn_cast<llvm::BasicBlock>(captures[\"if_true\"]); builder.CreateBr(if_true); instr->replaceAllUsesWith(llvm::UndefValue::get(type)); } else { auto if_false = llvm::dyn_cast<llvm::BasicBlock>(captures[\"if_false\"]); builder.CreateBr(if_false); instr->replaceAllUsesWith(llvm::UndefValue::get(type)); } replacements.push_back({val, nullptr}); return true; }}); if (config_.assumeNoExceptions()) { // Replacing all invokes with calls addConstExprRule( {unnamedInvoke(), [](Builder& builder, Value* val, Captures&, Replacements& replacements) { auto invoke = llvm::dyn_cast<llvm::InvokeInst>(val); if (invoke == nullptr) { return false; } auto callee_function = invoke->getCalledFunction(); // List with new call arguments std::vector<llvm::Value*> new_arguments; for (unsigned i = 0; i < invoke->getNumArgOperands(); ++i) { // Getting the i'th argument llvm::Value* arg = invoke->getArgOperand(i); new_arguments.push_back(arg); } // Creating a new call auto* new_call = builder.CreateCall(callee_function, new_arguments); builder.CreateBr(invoke->getNormalDest()); new_call->takeName(invoke); // Replace all calls to old function with calls to new function invoke->replaceAllUsesWith(new_call); replacements.push_back({invoke, nullptr}); return true; }}); } } void TargetQisMappingPass::addConstExprRule(ReplacementRule&& rule) { auto ret = std::make_shared<ReplacementRule>(std::move(rule)); const_expr_replacements_.addRule(ret); } void TargetQisMappingPass::constantFoldFunction(llvm::Function& fnc) { std::vector<llvm::Instruction*> to_delete; // Folding all constants for (auto& basic_block : fnc) { for (auto& instr : basic_block) { auto module = instr.getModule(); auto const& dl = module->getDataLayout(); auto cst = llvm::ConstantFoldInstruction(&instr, dl, nullptr); if (cst != nullptr) { instr.replaceAllUsesWith(cst); to_delete.push_back(&instr); } } } // Deleting constants for (auto& x : to_delete) { x->eraseFromParent(); } // Folding constant expressions Replacements replacements; for (auto& basic_block : fnc) { for (auto& instr : basic_block) { const_expr_replacements_.matchAndReplace(&instr, replacements); } } for (auto& r : replacements) { if (r.second != nullptr) { throw std::runtime_error(\"Real replacements not implemented.\"); } auto instr = llvm::dyn_cast<llvm::Instruction>(r.first); if (instr != nullptr) { instr->eraseFromParent(); continue; } auto block = llvm::dyn_cast<llvm::BasicBlock>(r.first); if (block != nullptr) { llvm::DeleteDeadBlock(block); } } } llvm::Value* TargetQisMappingPass::copyAndExpand( llvm::Value* input, DeletableInstructions& schedule_instruction_deletion) { llvm::Value* ret = input; auto* call_instr = llvm::dyn_cast<llvm::CallInst>(input); auto instr_ptr = llvm::dyn_cast<llvm::Instruction>(input); if (call_instr != nullptr && instr_ptr != nullptr) { auto& instr = *instr_ptr; auto callee_function = call_instr->getCalledFunction(); if (callee_function != nullptr && !callee_function->isDeclaration()) { ConstantArguments argument_constants{}; std::vector<uint32_t> remaining_arguments{}; uint32_t idx = 0; auto n = static_cast<uint32_t>(callee_function->arg_size()); // Finding argument constants while (idx < n) { auto arg = callee_function->getArg(idx); auto value = call_instr->getArgOperand(idx); auto cst = llvm::dyn_cast<llvm::ConstantInt>(value); if (cst != nullptr) { argument_constants[arg->getName().str()] = cst; } else { remaining_arguments.push_back(idx); } ++idx; } // Making a function copy auto new_callee = expandFunctionCall(*callee_function, argument_constants); // Replacing call if a new function was created if (new_callee != nullptr) { llvm::IRBuilder<> builder(call_instr); // List with new call arguments std::vector<llvm::Value*> new_arguments; for (auto const& i : remaining_arguments) { // Getting the i'th argument llvm::Value* arg = call_instr->getArgOperand(i); // Adding arguments that were not constant if (argument_constants.find(arg->getName().str()) == argument_constants.end()) { new_arguments.push_back(arg); } } // Creating a new call auto* new_call = builder.CreateCall(new_callee, new_arguments); new_call->takeName(call_instr); new_call->setTailCall(call_instr->isTailCall()); new_call->setTailCallKind(call_instr->getTailCallKind()); if (call_instr->canReturnTwice()) { new_call->setCanReturnTwice(); } new_call->setCallingConv(call_instr->getCallingConv()); new_call->setAttributes(call_instr->getAttributes()); // Replace all calls to old function with calls to new function instr.replaceAllUsesWith(new_call); // Deleting instruction schedule_instruction_deletion.push_back(&instr); // Folding constants in the new function as we may have replaced some of // the arguments with constants constantFoldFunction(*new_callee); // Recursion: Returning the new call as the instruction to be analysed ret = new_call; } // Deleting the function the original function if it is no longer in use if (callee_function->use_empty()) { callee_function->eraseFromParent(); } } } return ret; } llvm::Value* TargetQisMappingPass::detectActiveCode(llvm::Value* input, DeletableInstructions&) { active_pieces_.insert(input); return input; } bool TargetQisMappingPass::runOnFunction(llvm::Function& function, InstructionModifier const& modifier) { if (function.isDeclaration()) { return false; } if (depth_ >= config_.maxRecursion()) { requireLogger(); logger_->errorFunctionInliningMaxRecursion(config_.maxRecursion(), &function); return false; } ++depth_; // Keep track of instructions scheduled for deletion DeletableInstructions schedule_instruction_deletion; // Block queue std::deque<llvm::BasicBlock*> queue; std::unordered_set<llvm::BasicBlock*> blocks_queued; queue.push_back(&function.getEntryBlock()); blocks_queued.insert(&function.getEntryBlock()); // Executing the modifier on the function itsel modifier(&function, schedule_instruction_deletion); while (!queue.empty()) { auto& basic_block = *(queue.front()); queue.pop_front(); // Executing the modifier on the block modifier(&basic_block, schedule_instruction_deletion); for (auto& instr : basic_block) { // Modifying instruction as needed auto instr_ptr = modifier(&instr, schedule_instruction_deletion); // In case the instruction was scheduled for deletion if (instr_ptr == nullptr) { continue; } // Checking if we are calling a function auto call_instr = llvm::dyn_cast<llvm::CallBase>(instr_ptr); if (call_instr != nullptr) { auto callee_function = call_instr->getCalledFunction(); if (callee_function != nullptr && !callee_function->isDeclaration()) { runOnFunction(*callee_function, modifier); } } // Following the branches to their basic blocks auto* br_instr = llvm::dyn_cast<llvm::BranchInst>(&instr); if (br_instr != nullptr) { for (uint32_t i = 0; i < br_instr->getNumOperands(); ++i) { // TODO(issue-19): This may not work on multi path branches (conditional) // as we may accidentally add the final path (contains qubit release) // and we cannot make assumptions since optimization may have rearranged // everything. In this case, we should revert to the order they appear in the // function auto bb = llvm::dyn_cast<llvm::BasicBlock>(br_instr->getOperand(i)); if (bb != nullptr) { // Ensuring that we are not scheduling the same block twice if (blocks_queued.find(bb) == blocks_queued.end()) { queue.push_back(bb); blocks_queued.insert(bb); } } } continue; } // Follow the branches of auto* switch_instr = llvm::dyn_cast<llvm::SwitchInst>(&instr); if (switch_instr != nullptr) { for (uint64_t i = 0; i < switch_instr->getNumSuccessors(); ++i) { auto bb = switch_instr->getSuccessor(static_cast<uint32_t>(i)); // Ensuring that we are not scheduling the same block twice if (blocks_queued.find(bb) == blocks_queued.end()) { queue.push_back(bb); blocks_queued.insert(bb); } } continue; } // Checking if this is an invoke call auto* invoke_inst = llvm::dyn_cast<llvm::InvokeInst>(&instr); if (invoke_inst != nullptr) { // Checking that configuration is correct if (!config_.assumeNoExceptions()) { // TODO(issue-20): Unify error reporting throw std::runtime_error(\"Exceptions paths cannot be handled at compile time. Either disable \" \"transform-execution-path-only or add assumption assume-no-except\"); } // Adding the block which is the on the \"no except\" path auto bb = invoke_inst->getNormalDest(); if (blocks_queued.find(bb) == blocks_queued.end()) { queue.push_back(bb); blocks_queued.insert(bb); } } } } // Deleting constants for (auto& x : schedule_instruction_deletion) { x->eraseFromParent(); } --depth_; return true; } bool TargetQisMappingPass::isActive(llvm::Value* value) const { return active_pieces_.find(value) != active_pieces_.end(); } void TargetQisMappingPass::runCopyAndExpand(llvm::Module& module, llvm::ModuleAnalysisManager&) { replacements_.clear(); // For every instruction in every block, we attempt a match // and replace. for (auto& function : module) { if (function.hasFnAttribute(config_.entryPointAttr())) { runOnFunction( function, [this](llvm::Value* value, DeletableInstructions& modifier) { return copyAndExpand(value, modifier); }); } } // Active code detection for (auto& global : module.globals()) { active_pieces_.insert(&global); for (auto& op : global.operands()) { active_pieces_.insert(op); } } for (auto& function : module) { bool is_active = false; // Checking if the function is referenced by a global variable for (auto user : function.users()) { // If the user is active, then it should be expected that the function is also active if (isActive(user)) { is_active = true; break; } } if (is_active || function.hasFnAttribute(config_.entryPointAttr())) { // Marking function as active active_pieces_.insert(&function); // Detecting active code runOnFunction( function, [this](llvm::Value* value, DeletableInstructions& modifier) { return detectActiveCode(value, modifier); }); } } processReplacements(); } void TargetQisMappingPass::processReplacements() { // Applying all replacements std::unordered_set<llvm::Value*> already_removed; for (auto it = replacements_.rbegin(); it != replacements_.rend(); ++it) { // Ignoring values that were already removed. if (already_removed.find(it->first) != already_removed.end()) { continue; } already_removed.insert(it->first); auto instr1 = llvm::dyn_cast<llvm::Instruction>(it->first); if (instr1 == nullptr) { requireLogger(); logger_->setLocationFromValue(nullptr); logger_->internalError(\"Cannot replace with non-instruction replacements\"); continue; } // Checking if have a replacement for the instruction if (it->second != nullptr) { // ... if so, we just replace it, auto instr2 = llvm::dyn_cast<llvm::Instruction>(it->second); if (instr2 == nullptr) { requireLogger(); logger_->setLocationFromValue(instr1); logger_->internalError(\"Attempt to replace with non-instruction value. This is not allowed.\"); continue; } llvm::ReplaceInstWithInst(instr1, instr2); } else { // ... otherwize we delete the the instruction // Removing all uses if (!instr1->use_empty()) { auto type = instr1->getType(); if (type != nullptr) { instr1->replaceAllUsesWith(llvm::UndefValue::get(type)); } } // And finally we delete the instruction. The if statement // is first and foremost a precaution which prevents the program // from seg-faulting in the unlikely case that instr1->getType() is null. if (instr1->use_empty()) { instr1->eraseFromParent(); } } } replacements_.clear(); } void TargetQisMappingPass::runDetectActiveCode(llvm::Module& module, llvm::ModuleAnalysisManager&) { blocks_to_delete_.clear(); functions_to_delete_.clear(); for (auto& function : module) { if (isActive(&function)) { for (auto& block : function) { if (!isActive(&block)) { blocks_to_delete_.push_back(&block); } } } else if (!function.isDeclaration()) { functions_to_delete_.push_back(&function); } } } void TargetQisMappingPass::runDeleteDeadCode(llvm::Module&, llvm::ModuleAnalysisManager&) { // Removing all function references and scheduling blocks for deletion for (auto& function : functions_to_delete_) { // Schedule for deletion function->replaceAllUsesWith(llvm::UndefValue::get(function->getType())); function->clearGC(); function->clearMetadata(); // Deleteing blocks in reverse order std::vector<llvm::BasicBlock*> blocks; for (auto& block : *function) { blocks.push_back(&block); } // Removing backwards to avoid segfault for (auto it = blocks.rbegin(); it != blocks.rend(); ++it) { auto& block = **it; // Deleting instructions in reverse order (needed because it is a DAG structure) std::vector<llvm::Instruction*> instructions; for (auto& instr : block) { instructions.push_back(&instr); } // Removing all instructions for (auto it2 = instructions.rbegin(); it2 != instructions.rend(); ++it2) { auto& instr = **it2; instr.replaceAllUsesWith(llvm::UndefValue::get(instr.getType())); instr.eraseFromParent(); } // Removing all block references block.replaceAllUsesWith(llvm::UndefValue::get(block.getType())); // Scheduling block deletion blocks_to_delete_.push_back(&block); } } // Deleting all blocks for (auto block : blocks_to_delete_) { if (block->use_empty()) { block->eraseFromParent(); } else { requireLogger(); logger_->setLocationFromValue(block); logger_->internalError(\"Block was supposed to be unused\"); } } // Removing functions for (auto& function : functions_to_delete_) { if (function->isDeclaration() && function->use_empty()) { function->eraseFromParent(); } } } void TargetQisMappingPass::runReplacePhi(llvm::Module& module, llvm::ModuleAnalysisManager&) { using namespace microsoft::quantum::notation; auto rule = phi(\"b1\"_cap = _, \"b2\"_cap = _); IOperandPrototype::Captures captures; std::vector<llvm::Instruction*> to_delete; std::unordered_map<llvm::Instruction*, llvm::Value*> replacements; for (auto& function : module) { for (auto& block : function) { std::vector<llvm::Instruction*> instrs; for (auto& instr : block) { if (rule->match(&instr, captures)) { auto phi = llvm::dyn_cast<llvm::PHINode>(&instr); if (phi == nullptr) { continue; } auto val1 = captures[\"b1\"]; auto val2 = captures[\"b2\"]; auto block1 = phi->getIncomingBlock(0); // TODO(issue-21): Make sure that block1 matches val1 auto block2 = phi->getIncomingBlock(1); if (!isActive(block1)) { val2->takeName(&instr); replacements[&instr] = val2; to_delete.push_back(&instr); } else if (!isActive(block2)) { val1->takeName(&instr); replacements[&instr] = val2; to_delete.push_back(&instr); } captures.clear(); } } } } for (auto& r : replacements) { r.first->replaceAllUsesWith(r.second); } for (auto& x : to_delete) { x->eraseFromParent(); } } void TargetQisMappingPass::runApplyRules(llvm::Module& module, llvm::ModuleAnalysisManager&) { replacements_.clear(); std::unordered_set<llvm::Value*> already_visited; for (auto& function : module) { if (function.hasFnAttribute(config_.entryPointAttr())) { runOnFunction( function, [this, &already_visited](llvm::Value* value, DeletableInstructions&) { auto instr = llvm::dyn_cast<llvm::Instruction>(value); // Sanity check if (already_visited.find(value) != already_visited.end()) { requireLogger(); logger_->setLocationFromValue(value); logger_->internalError(\"Instruction was visited twice while applying rule to function.\"); return value; } already_visited.insert(value); // Checking if we should analyse if (instr != nullptr) { rule_set_.matchAndReplace(instr, replacements_); } return value; }); } } processReplacements(); } llvm::PreservedAnalyses TargetQisMappingPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& mam) { // In case the module is instructed to clone functions, if (config_.shouldCloneFunctions()) { setupCopyAndExpand(); runCopyAndExpand(module, mam); } // Deleting dead code if configured to do so. This process consists // of three steps: detecting dead code, removing phi nodes (and references) // and finally deleting the code. This implementation is aggressive in the sense // that any code that we cannot prove to be active is considered dead. if (config_.shouldDeleteDeadCode()) { runDetectActiveCode(module, mam); runReplacePhi(module, mam); runDeleteDeadCode(module, mam); } // Applying rule set if (config_.shouldTransformExecutionPathOnly()) { // TODO(tfr): This implementation path lacks backwards replacement (see else section) // We only apply transformation rules to code which is reachable // via the execution path. runApplyRules(module, mam); } else { // Otherwise we apply to all sections of the code. replacements_.clear(); for (auto& function : module) { // Creating a list of all instructions in the function // and matching rules in forward direction for (auto& block : function) { for (auto& instr : block) { rule_set_.matchAndReplace(&instr, replacements_); } } // Matching in reverse order std::vector<llvm::Instruction*> instructions; for (auto& block : function) { for (auto& instr : block) { instructions.push_back(&instr); } } std::reverse(instructions.begin(), instructions.end()); for (auto instr : instructions) { rule_set_.matchAndReplace(instr, replacements_, RuleSet::ReplaceDirection::ReplaceBackwards); } } processReplacements(); } return llvm::PreservedAnalyses::none(); } llvm::Function* TargetQisMappingPass::expandFunctionCall(llvm::Function& callee, ConstantArguments const& const_args) { auto module = callee.getParent(); auto& context = module->getContext(); llvm::IRBuilder<> builder(context); // Copying the original function llvm::ValueToValueMapTy remapper; std::vector<llvm::Type*> arg_types; // The user might be deleting arguments to the function by specifying them in // the VMap. If so, we need to not add the arguments to the arg ty vector // for (auto const& arg : callee.args()) { // Skipping constant arguments if (const_args.find(arg.getName().str()) != const_args.end()) { continue; } arg_types.push_back(arg.getType()); } // Creating a new function llvm::FunctionType* function_type = llvm::FunctionType::get( callee.getFunctionType()->getReturnType(), arg_types, callee.getFunctionType()->isVarArg()); auto function = llvm::Function::Create(function_type, callee.getLinkage(), callee.getAddressSpace(), callee.getName(), module); // Copying the non-const arguments auto dest_args_it = function->arg_begin(); for (auto const& arg : callee.args()) { auto const_it = const_args.find(arg.getName().str()); if (const_it == const_args.end()) { // Mapping remaining function arguments dest_args_it->setName(arg.getName()); remapper[&arg] = &*dest_args_it++; } else { remapper[&arg] = llvm::ConstantInt::get(context, const_it->second->getValue()); } } llvm::SmallVector<llvm::ReturnInst*, 8> returns; // Ignore returns cloned. llvm::CloneFunctionInto( function, &callee, remapper, llvm::CloneFunctionChangeType::LocalChangesOnly, returns, \"\", nullptr); verifyFunction(*function); return function; } void TargetQisMappingPass::setLogger(ILoggerPtr logger) { logger_ = std::move(logger); } bool TargetQisMappingPass::isRequired() { return true; } void TargetQisMappingPass::requireLogger() { if (logger_ == nullptr) { throw std::runtime_error(\"TargetQisMappingPass does not have a logger, but need it to emit messages.\"); } } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_target_qis_mapping_pass_8hpp/","text":"Passes/TargetQisMappingPass/TargetQisMappingPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::TargetQisMappingPass Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/TargetQisMappingPassConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include \"qir/qat/QirAdaptor/QirAdaptor.hpp\" #include \"qir/qat/Rules/RuleSet.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class TargetQisMappingPass : public llvm::PassInfoMixin<TargetQisMappingPass> { public: using Replacements = ReplacementRule::Replacements; using Instruction = llvm::Instruction; using Rules = std::vector<ReplacementRule>; using Value = llvm::Value; using Builder = ReplacementRule::Builder; using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; using Captures = RuleSet::Captures; using ConstantArguments = std::unordered_map<std::string, llvm::ConstantInt*>; using ILoggerPtr = ILogger::ILoggerPtr; // Construction and destruction configuration. // TargetQisMappingPass(RuleSet&& rule_set, TargetQisMappingPassConfiguration const& config); TargetQisMappingPass(TargetQisMappingPass const&) = delete; TargetQisMappingPass(TargetQisMappingPass&&) = default; ~TargetQisMappingPass() = default; // Operators // TargetQisMappingPass& operator=(TargetQisMappingPass const&) = delete; TargetQisMappingPass& operator=(TargetQisMappingPass&&) = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); using DeletableInstructions = std::vector<llvm::Instruction*>; using InstructionModifier = std::function<llvm::Value*(llvm::Value*, DeletableInstructions&)>; // Generic helper functions // bool runOnFunction(llvm::Function& function, InstructionModifier const& modifier); void processReplacements(); // Copy and expand // void setupCopyAndExpand(); void runCopyAndExpand(llvm::Module& module, llvm::ModuleAnalysisManager& mam); llvm::Value* copyAndExpand(llvm::Value* input, DeletableInstructions&); llvm::Function* expandFunctionCall(llvm::Function& callee, ConstantArguments const& const_args = {}); void constantFoldFunction(llvm::Function& callee); void addConstExprRule(ReplacementRule&& rule); // Dead code detection // void runDetectActiveCode(llvm::Module& module, llvm::ModuleAnalysisManager& mam); void runDeleteDeadCode(llvm::Module& module, llvm::ModuleAnalysisManager& mam); llvm::Value* detectActiveCode(llvm::Value* input, DeletableInstructions&); llvm::Value* deleteDeadCode(llvm::Value* input, DeletableInstructions&); bool isActive(llvm::Value* value) const; void followUsers(llvm::Value* value); // Phi replacement // void runReplacePhi(llvm::Module& module, llvm::ModuleAnalysisManager& mam); // Rules // void runApplyRules(llvm::Module& module, llvm::ModuleAnalysisManager& mam); bool onQubitRelease(llvm::Instruction* instruction, Captures& captures); bool onQubitAllocate(llvm::Instruction* instruction, Captures& captures); static bool isRequired(); // Logger // void setLogger(ILoggerPtr logger); private: void requireLogger(); // Pass configuration // RuleSet rule_set_{}; TargetQisMappingPassConfiguration config_{}; // Logging and data collection // ILoggerPtr logger_{nullptr}; // Execution path unrolling // uint64_t depth_{0}; // Copy and expand // RuleSet const_expr_replacements_{}; // Dead code elimination // std::unordered_set<Value*> active_pieces_{}; std::vector<llvm::BasicBlock*> blocks_to_delete_{}; std::vector<llvm::Function*> functions_to_delete_{}; // Phi detection // Replacements replacements_; // QirAdaptor // QirAdaptor* adaptor_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/TargetQisMappingPass/TargetQisMappingPass.hpp"},{"location":"Api/Files/_target_qis_mapping_pass_8hpp/#passestargetqismappingpasstargetqismappingpasshpp","text":"","title":"Passes/TargetQisMappingPass/TargetQisMappingPass.hpp"},{"location":"Api/Files/_target_qis_mapping_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_target_qis_mapping_pass_8hpp/#classes","text":"Name class microsoft::quantum::TargetQisMappingPass","title":"Classes"},{"location":"Api/Files/_target_qis_mapping_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/TargetQisMappingPassConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include \"qir/qat/QirAdaptor/QirAdaptor.hpp\" #include \"qir/qat/Rules/RuleSet.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class TargetQisMappingPass : public llvm::PassInfoMixin<TargetQisMappingPass> { public: using Replacements = ReplacementRule::Replacements; using Instruction = llvm::Instruction; using Rules = std::vector<ReplacementRule>; using Value = llvm::Value; using Builder = ReplacementRule::Builder; using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; using Captures = RuleSet::Captures; using ConstantArguments = std::unordered_map<std::string, llvm::ConstantInt*>; using ILoggerPtr = ILogger::ILoggerPtr; // Construction and destruction configuration. // TargetQisMappingPass(RuleSet&& rule_set, TargetQisMappingPassConfiguration const& config); TargetQisMappingPass(TargetQisMappingPass const&) = delete; TargetQisMappingPass(TargetQisMappingPass&&) = default; ~TargetQisMappingPass() = default; // Operators // TargetQisMappingPass& operator=(TargetQisMappingPass const&) = delete; TargetQisMappingPass& operator=(TargetQisMappingPass&&) = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); using DeletableInstructions = std::vector<llvm::Instruction*>; using InstructionModifier = std::function<llvm::Value*(llvm::Value*, DeletableInstructions&)>; // Generic helper functions // bool runOnFunction(llvm::Function& function, InstructionModifier const& modifier); void processReplacements(); // Copy and expand // void setupCopyAndExpand(); void runCopyAndExpand(llvm::Module& module, llvm::ModuleAnalysisManager& mam); llvm::Value* copyAndExpand(llvm::Value* input, DeletableInstructions&); llvm::Function* expandFunctionCall(llvm::Function& callee, ConstantArguments const& const_args = {}); void constantFoldFunction(llvm::Function& callee); void addConstExprRule(ReplacementRule&& rule); // Dead code detection // void runDetectActiveCode(llvm::Module& module, llvm::ModuleAnalysisManager& mam); void runDeleteDeadCode(llvm::Module& module, llvm::ModuleAnalysisManager& mam); llvm::Value* detectActiveCode(llvm::Value* input, DeletableInstructions&); llvm::Value* deleteDeadCode(llvm::Value* input, DeletableInstructions&); bool isActive(llvm::Value* value) const; void followUsers(llvm::Value* value); // Phi replacement // void runReplacePhi(llvm::Module& module, llvm::ModuleAnalysisManager& mam); // Rules // void runApplyRules(llvm::Module& module, llvm::ModuleAnalysisManager& mam); bool onQubitRelease(llvm::Instruction* instruction, Captures& captures); bool onQubitAllocate(llvm::Instruction* instruction, Captures& captures); static bool isRequired(); // Logger // void setLogger(ILoggerPtr logger); private: void requireLogger(); // Pass configuration // RuleSet rule_set_{}; TargetQisMappingPassConfiguration config_{}; // Logging and data collection // ILoggerPtr logger_{nullptr}; // Execution path unrolling // uint64_t depth_{0}; // Copy and expand // RuleSet const_expr_replacements_{}; // Dead code elimination // std::unordered_set<Value*> active_pieces_{}; std::vector<llvm::BasicBlock*> blocks_to_delete_{}; std::vector<llvm::Function*> functions_to_delete_{}; // Phi detection // Replacements replacements_; // QirAdaptor // QirAdaptor* adaptor_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_target_qis_mapping_pass_configuration_8hpp/","text":"Passes/TargetQisMappingPass/TargetQisMappingPassConfiguration.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::TargetQisMappingPassConfiguration Configuration class for the RuleTransformation pass. Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" namespace microsoft::quantum { class TargetQisMappingPassConfiguration { public: using DeferredValuePtr = DeferredValue::DeferredValuePtr; // Setup and construction // void setup(ConfigurationManager& config); static TargetQisMappingPassConfiguration createDisabled(); static TargetQisMappingPassConfiguration createReuseQubitsOnly(); // Configuration classes // bool isDisabled() const; bool isDefault() const; bool operator==(TargetQisMappingPassConfiguration const& ref) const; // Properties // bool shouldDeleteDeadCode() const; bool shouldCloneFunctions() const; bool assumeNoExceptions() const; bool shouldTransformExecutionPathOnly() const; uint64_t maxRecursion() const; bool shouldReuseQubits() const; bool shouldAnnotateQubitUse() const; bool shouldReuseResults() const; bool shouldAnnotateResultUse() const; bool shouldGroupMeasurements() const; bool oneShotMeasurement() const; std::string entryPointAttr() const; bool disableReferenceCounting() const; bool disableAliasCounting() const; bool disableStringSupport() const; bool disableRecordOutputSupport() const; bool optimizeResultOne() const; bool optimizeResultZero() const; bool optimizeQuantumConstants() const; bool optimizeResultComparison() const; bool removeGetZeroOrOne() const; bool useStaticQubitArrayAllocation() const; bool useStaticQubitAllocation() const; bool useStaticResultAllocation() const; uint32_t defaultIntegerWidth() const; private: // Code expansion and trimming // bool delete_dead_code_{true}; bool clone_functions_{true}; bool transform_execution_path_only_{true}; uint64_t max_recursion_{512}; DeferredValuePtr entry_point_attr_{nullptr}; // Branching bool assume_no_exceptions_{false}; // Allocation options // bool reuse_qubits_{true}; bool reuse_results_{true}; // Rules Configuration bool disable_reference_counting_{true}; bool disable_alias_counting_{true}; bool disable_string_support_{true}; bool disable_record_output_support_{true}; // Optimizations bool optimize_result_one_{true}; bool optimize_result_zero_{true}; bool optimize_result_comparison_{true}; bool optimize_quantum_constants_{true}; bool remove_get_one_or_zero_{true}; bool use_static_qubit_array_allocation_{true}; bool use_static_qubit_allocation_{true}; bool use_static_result_allocation_{true}; uint32_t default_integer_width_{64}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/TargetQisMappingPass/TargetQisMappingPassConfiguration.hpp"},{"location":"Api/Files/_target_qis_mapping_pass_configuration_8hpp/#passestargetqismappingpasstargetqismappingpassconfigurationhpp","text":"","title":"Passes/TargetQisMappingPass/TargetQisMappingPassConfiguration.hpp"},{"location":"Api/Files/_target_qis_mapping_pass_configuration_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_target_qis_mapping_pass_configuration_8hpp/#classes","text":"Name class microsoft::quantum::TargetQisMappingPassConfiguration Configuration class for the RuleTransformation pass.","title":"Classes"},{"location":"Api/Files/_target_qis_mapping_pass_configuration_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" namespace microsoft::quantum { class TargetQisMappingPassConfiguration { public: using DeferredValuePtr = DeferredValue::DeferredValuePtr; // Setup and construction // void setup(ConfigurationManager& config); static TargetQisMappingPassConfiguration createDisabled(); static TargetQisMappingPassConfiguration createReuseQubitsOnly(); // Configuration classes // bool isDisabled() const; bool isDefault() const; bool operator==(TargetQisMappingPassConfiguration const& ref) const; // Properties // bool shouldDeleteDeadCode() const; bool shouldCloneFunctions() const; bool assumeNoExceptions() const; bool shouldTransformExecutionPathOnly() const; uint64_t maxRecursion() const; bool shouldReuseQubits() const; bool shouldAnnotateQubitUse() const; bool shouldReuseResults() const; bool shouldAnnotateResultUse() const; bool shouldGroupMeasurements() const; bool oneShotMeasurement() const; std::string entryPointAttr() const; bool disableReferenceCounting() const; bool disableAliasCounting() const; bool disableStringSupport() const; bool disableRecordOutputSupport() const; bool optimizeResultOne() const; bool optimizeResultZero() const; bool optimizeQuantumConstants() const; bool optimizeResultComparison() const; bool removeGetZeroOrOne() const; bool useStaticQubitArrayAllocation() const; bool useStaticQubitAllocation() const; bool useStaticResultAllocation() const; uint32_t defaultIntegerWidth() const; private: // Code expansion and trimming // bool delete_dead_code_{true}; bool clone_functions_{true}; bool transform_execution_path_only_{true}; uint64_t max_recursion_{512}; DeferredValuePtr entry_point_attr_{nullptr}; // Branching bool assume_no_exceptions_{false}; // Allocation options // bool reuse_qubits_{true}; bool reuse_results_{true}; // Rules Configuration bool disable_reference_counting_{true}; bool disable_alias_counting_{true}; bool disable_string_support_{true}; bool disable_record_output_support_{true}; // Optimizations bool optimize_result_one_{true}; bool optimize_result_zero_{true}; bool optimize_result_comparison_{true}; bool optimize_quantum_constants_{true}; bool remove_get_one_or_zero_{true}; bool use_static_qubit_array_allocation_{true}; bool use_static_qubit_allocation_{true}; bool use_static_result_allocation_{true}; uint32_t default_integer_width_{64}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_test_vm_8hpp/","text":"TestTools/TestVm.hpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::details Classes Name class microsoft::quantum::TestProgram class microsoft::quantum::TestVM Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <stdexcept> #include <unordered_map> namespace microsoft::quantum { namespace details { inline void initFramework() { static bool was_initialized{false}; if (was_initialized) { return; } was_initialized = true; llvm::InitializeNativeTarget(); llvm::InitializeNativeTargetAsmPrinter(); } } // namespace details class TestProgram { public: TestProgram() = default; TestProgram(std::unique_ptr<llvm::Module>&& module, std::unique_ptr<llvm::LLVMContext>&& context) : context_{std::move(context)} , module_{std::move(module)} { } TestProgram(TestProgram&&) = default; TestProgram(TestProgram const&) = delete; ~TestProgram() = default; void parseFromScript(String const& name, String const& script) { context_ = std::make_unique<llvm::LLVMContext>(); llvm::SMDiagnostic error; module_ = llvm::parseIR(llvm::MemoryBufferRef(script, name), error, *context_); if (!module_) { throw std::runtime_error(\"Failed to parse script\"); } } llvm::Module& module() { return *module_; } private: friend class TestVM; std::unique_ptr<llvm::LLVMContext> context_; std::unique_ptr<llvm::Module> module_; }; class TestVM { public: explicit TestVM(TestProgram& program) : program_{program} { details::initFramework(); } template <typename T> void attachGlobalExternalVariable(String const& name, T* pointer); template <typename R, typename X> void attachRuntimeFunction(String const& name, R (*pointer)(X)); template <typename R, typename... Args> void attachRuntimeFunction(String const& name, R (*pointer)(Args...)); template <typename R> void attachRuntimeFunction(String const& name, R (*pointer)()); template <typename R, typename... Args> R run(String const& name, Args&&... args); template <typename R> R run(String const& name); private: void buildVm() { llvm::ExitOnError exit_on_error; lljit_ = exit_on_error(llvm::orc::LLJITBuilder().create()); exit_on_error(lljit_->addIRModule( llvm::orc::ThreadSafeModule(std::move(program_.module_), std::move(program_.context_)))); llvm::orc::SymbolMap symbols_map; for (auto const& p : symbols_map_) { symbols_map.insert({lljit_->mangleAndIntern(p.first), p.second}); } exit_on_error(lljit_->getMainJITDylib().define(absoluteSymbols(std::move(symbols_map)))); } TestProgram& program_; std::unique_ptr<llvm::orc::LLJIT> lljit_; std::unordered_map<String, llvm::JITEvaluatedSymbol> symbols_map_; }; template <typename T> void TestVM::attachGlobalExternalVariable(String const& name, T* pointer) { auto& module = *program_.module_; auto variable = module.getNamedGlobal(name); variable->setInitializer(nullptr); variable->setVisibility(llvm::GlobalValue::VisibilityTypes::DefaultVisibility); variable->setLinkage(llvm::GlobalValue::ExternalLinkage); variable->setExternallyInitialized(true); variable->setDSOLocal(false); // Adding link to external pointer symbols_map_.insert({name, llvm::JITEvaluatedSymbol::fromPointer(pointer)}); } template <typename R, typename... Args> void TestVM::attachRuntimeFunction(String const& name, R (*pointer)(Args...)) { symbols_map_.insert({name, llvm::JITEvaluatedSymbol::fromPointer(pointer)}); } template <typename R, typename X> void TestVM::attachRuntimeFunction(String const& name, R (*pointer)(X)) { symbols_map_.insert({name, llvm::JITEvaluatedSymbol::fromPointer(pointer)}); } template <typename R> void TestVM::attachRuntimeFunction(String const& name, R (*pointer)()) { symbols_map_.insert({name, llvm::JITEvaluatedSymbol::fromPointer(pointer)}); } template <typename R, typename... Args> R TestVM::run(String const& name, Args&&... args) { buildVm(); llvm::ExitOnError exit_on_error; // Calling object constructors exit_on_error(lljit_->initialize(lljit_->getMainJITDylib())); auto function_symbol = exit_on_error(lljit_->lookup(name)); using FunctionPtr = R (*)(Args...); auto* function = static_cast<FunctionPtr>(function_symbol.getAddress()); auto ret = function(std::forward<Args>(args)...); // Calling object destructors exit_on_error(lljit_->deinitialize(lljit_->getMainJITDylib())); return ret; } template <typename R> R TestVM::run(String const& name) { buildVm(); llvm::ExitOnError exit_on_error; // Calling object constructors exit_on_error(lljit_->initialize(lljit_->getMainJITDylib())); auto function_symbol = exit_on_error(lljit_->lookup(name)); using FunctionPtr = R (*)(); auto* function = reinterpret_cast<FunctionPtr>(function_symbol.getAddress()); // NOLINT auto ret = function(); // Calling object destructors exit_on_error(lljit_->deinitialize(lljit_->getMainJITDylib())); return ret; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"TestTools/TestVm.hpp"},{"location":"Api/Files/_test_vm_8hpp/#testtoolstestvmhpp","text":"","title":"TestTools/TestVm.hpp"},{"location":"Api/Files/_test_vm_8hpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::details","title":"Namespaces"},{"location":"Api/Files/_test_vm_8hpp/#classes","text":"Name class microsoft::quantum::TestProgram class microsoft::quantum::TestVM","title":"Classes"},{"location":"Api/Files/_test_vm_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <stdexcept> #include <unordered_map> namespace microsoft::quantum { namespace details { inline void initFramework() { static bool was_initialized{false}; if (was_initialized) { return; } was_initialized = true; llvm::InitializeNativeTarget(); llvm::InitializeNativeTargetAsmPrinter(); } } // namespace details class TestProgram { public: TestProgram() = default; TestProgram(std::unique_ptr<llvm::Module>&& module, std::unique_ptr<llvm::LLVMContext>&& context) : context_{std::move(context)} , module_{std::move(module)} { } TestProgram(TestProgram&&) = default; TestProgram(TestProgram const&) = delete; ~TestProgram() = default; void parseFromScript(String const& name, String const& script) { context_ = std::make_unique<llvm::LLVMContext>(); llvm::SMDiagnostic error; module_ = llvm::parseIR(llvm::MemoryBufferRef(script, name), error, *context_); if (!module_) { throw std::runtime_error(\"Failed to parse script\"); } } llvm::Module& module() { return *module_; } private: friend class TestVM; std::unique_ptr<llvm::LLVMContext> context_; std::unique_ptr<llvm::Module> module_; }; class TestVM { public: explicit TestVM(TestProgram& program) : program_{program} { details::initFramework(); } template <typename T> void attachGlobalExternalVariable(String const& name, T* pointer); template <typename R, typename X> void attachRuntimeFunction(String const& name, R (*pointer)(X)); template <typename R, typename... Args> void attachRuntimeFunction(String const& name, R (*pointer)(Args...)); template <typename R> void attachRuntimeFunction(String const& name, R (*pointer)()); template <typename R, typename... Args> R run(String const& name, Args&&... args); template <typename R> R run(String const& name); private: void buildVm() { llvm::ExitOnError exit_on_error; lljit_ = exit_on_error(llvm::orc::LLJITBuilder().create()); exit_on_error(lljit_->addIRModule( llvm::orc::ThreadSafeModule(std::move(program_.module_), std::move(program_.context_)))); llvm::orc::SymbolMap symbols_map; for (auto const& p : symbols_map_) { symbols_map.insert({lljit_->mangleAndIntern(p.first), p.second}); } exit_on_error(lljit_->getMainJITDylib().define(absoluteSymbols(std::move(symbols_map)))); } TestProgram& program_; std::unique_ptr<llvm::orc::LLJIT> lljit_; std::unordered_map<String, llvm::JITEvaluatedSymbol> symbols_map_; }; template <typename T> void TestVM::attachGlobalExternalVariable(String const& name, T* pointer) { auto& module = *program_.module_; auto variable = module.getNamedGlobal(name); variable->setInitializer(nullptr); variable->setVisibility(llvm::GlobalValue::VisibilityTypes::DefaultVisibility); variable->setLinkage(llvm::GlobalValue::ExternalLinkage); variable->setExternallyInitialized(true); variable->setDSOLocal(false); // Adding link to external pointer symbols_map_.insert({name, llvm::JITEvaluatedSymbol::fromPointer(pointer)}); } template <typename R, typename... Args> void TestVM::attachRuntimeFunction(String const& name, R (*pointer)(Args...)) { symbols_map_.insert({name, llvm::JITEvaluatedSymbol::fromPointer(pointer)}); } template <typename R, typename X> void TestVM::attachRuntimeFunction(String const& name, R (*pointer)(X)) { symbols_map_.insert({name, llvm::JITEvaluatedSymbol::fromPointer(pointer)}); } template <typename R> void TestVM::attachRuntimeFunction(String const& name, R (*pointer)()) { symbols_map_.insert({name, llvm::JITEvaluatedSymbol::fromPointer(pointer)}); } template <typename R, typename... Args> R TestVM::run(String const& name, Args&&... args) { buildVm(); llvm::ExitOnError exit_on_error; // Calling object constructors exit_on_error(lljit_->initialize(lljit_->getMainJITDylib())); auto function_symbol = exit_on_error(lljit_->lookup(name)); using FunctionPtr = R (*)(Args...); auto* function = static_cast<FunctionPtr>(function_symbol.getAddress()); auto ret = function(std::forward<Args>(args)...); // Calling object destructors exit_on_error(lljit_->deinitialize(lljit_->getMainJITDylib())); return ret; } template <typename R> R TestVM::run(String const& name) { buildVm(); llvm::ExitOnError exit_on_error; // Calling object constructors exit_on_error(lljit_->initialize(lljit_->getMainJITDylib())); auto function_symbol = exit_on_error(lljit_->lookup(name)); using FunctionPtr = R (*)(); auto* function = reinterpret_cast<FunctionPtr>(function_symbol.getAddress()); // NOLINT auto ret = function(); // Calling object destructors exit_on_error(lljit_->deinitialize(lljit_->getMainJITDylib())); return ret; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_transformation_rules_pass_configuration_8cpp/","text":"Passes/TargetQisMappingPass/TransformationRulesPassConfiguration.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/TargetQisMappingPassConfiguration.hpp\" namespace microsoft::quantum { void TargetQisMappingPassConfiguration::setup(ConfigurationManager& config) { config.setSectionName(\"Target QIS mapping\", \"Modification of the IR to adapt a specific QIS.\"); // Experimental settings config.addExperimentalParameter(delete_dead_code_, true, false, \"delete-dead-code\", \"Deleted dead code.\"); config.addExperimentalParameter( clone_functions_, true, false, \"clone-functions\", \"Clone functions to ensure correct qubit allocation.\"); config.addExperimentalParameter( transform_execution_path_only_, true, false, \"transform-execution-path-only\", \"Transform execution paths only.\"); config.addExperimentalParameter( max_recursion_, max_recursion_, uint64_t(1), \"max-recursion\", \"Defines the maximum recursion when unrolling the execution path\"); config.addExperimentalParameter( assume_no_exceptions_, false, false, \"assume-no-except\", \"Assumes that no exception will occur during runtime.\"); config.addParameter(reuse_qubits_, false, \"reuse-qubits\", \"Use to define whether or not to reuse qubits.\"); config.addParameter(reuse_results_, false, \"reuse-results\", \"Use to define whether or not to reuse results.\"); // Rules config.addParameter( optimize_result_one_, true, \"optimize-result-one\", \"Maps branching based on quantum measurements compared to one to base adaptor \" \"type measurement.\"); config.addParameter( optimize_result_zero_, true, \"optimize-result-zero\", \"Maps branching based on quantum measurements compared to zero to base adaptor \" \"type measurement.\"); config.addParameter( optimize_result_comparison_, true, \"optimize-result-comparison\", \"Maps branching based on quantum measurements compared to each other to base adaptor \" \"type measurement.\"); config.addParameter( use_static_qubit_array_allocation_, \"use-static-qubit-array-allocation\", \"Maps allocation of qubit arrays to static array allocation.\"); config.addParameter( use_static_qubit_allocation_, \"use-static-qubit-allocation\", \"Maps qubit allocation to static allocation.\"); config.addParameter( use_static_result_allocation_, \"use-static-result-allocation\", \"Maps result allocation to static allocation.\"); config.addParameter( disable_reference_counting_, true, \"disable-reference-counting\", \"Disables reference counting by instruction removal.\"); config.addParameter( disable_alias_counting_, true, \"disable-alias-counting\", \"Disables alias counting by instruction removal.\"); config.addParameter( disable_string_support_, true, \"disable-string-support\", \"Disables string support by instruction removal.\"); config.addParameter( disable_record_output_support_, true, \"disable-record-output-support\", \"Disables record output support by instruction removal.\"); // Ready settings entry_point_attr_ = config.getParameter(\"entry-point-attr\"); } TargetQisMappingPassConfiguration TargetQisMappingPassConfiguration::createDisabled() { TargetQisMappingPassConfiguration ret; ret.delete_dead_code_ = false; ret.clone_functions_ = false; ret.transform_execution_path_only_ = false; ret.max_recursion_ = 512; ret.reuse_qubits_ = false; ret.reuse_results_ = false; ret.disable_reference_counting_ = false; ret.disable_alias_counting_ = false; ret.disable_string_support_ = false; ret.disable_record_output_support_ = false; ret.optimize_result_one_ = false; ret.optimize_result_zero_ = false; ret.optimize_result_comparison_ = false; ret.optimize_quantum_constants_ = false; ret.remove_get_one_or_zero_ = false; ret.use_static_qubit_array_allocation_ = false; ret.use_static_qubit_allocation_ = false; ret.use_static_result_allocation_ = false; return ret; } TargetQisMappingPassConfiguration TargetQisMappingPassConfiguration::createReuseQubitsOnly() { TargetQisMappingPassConfiguration ret; ret.delete_dead_code_ = false; ret.clone_functions_ = false; ret.transform_execution_path_only_ = false; ret.max_recursion_ = 512; ret.reuse_qubits_ = true; ret.reuse_results_ = false; ret.disable_reference_counting_ = false; ret.disable_alias_counting_ = false; ret.disable_string_support_ = false; ret.disable_record_output_support_ = false; ret.optimize_result_one_ = false; ret.optimize_result_zero_ = false; ret.optimize_result_comparison_ = false; ret.optimize_quantum_constants_ = false; ret.remove_get_one_or_zero_ = false; ret.use_static_qubit_array_allocation_ = false; ret.use_static_qubit_allocation_ = false; ret.use_static_result_allocation_ = false; return ret; } bool TargetQisMappingPassConfiguration::shouldDeleteDeadCode() const { return delete_dead_code_; } bool TargetQisMappingPassConfiguration::shouldCloneFunctions() const { return clone_functions_; } bool TargetQisMappingPassConfiguration::shouldTransformExecutionPathOnly() const { return transform_execution_path_only_; } uint64_t TargetQisMappingPassConfiguration::maxRecursion() const { return max_recursion_; } bool TargetQisMappingPassConfiguration::shouldReuseQubits() const { return reuse_qubits_; } bool TargetQisMappingPassConfiguration::shouldReuseResults() const { return reuse_results_; } std::string TargetQisMappingPassConfiguration::entryPointAttr() const { if (entry_point_attr_ == nullptr) { throw std::runtime_error(\"Specification entryPoint not found.\"); } return entry_point_attr_->value<std::string>(); } bool TargetQisMappingPassConfiguration::assumeNoExceptions() const { return assume_no_exceptions_; } bool TargetQisMappingPassConfiguration::disableReferenceCounting() const { return disable_reference_counting_; } bool TargetQisMappingPassConfiguration::disableAliasCounting() const { return disable_alias_counting_; } bool TargetQisMappingPassConfiguration::disableStringSupport() const { return disable_string_support_; } bool TargetQisMappingPassConfiguration::disableRecordOutputSupport() const { return disable_record_output_support_; } bool TargetQisMappingPassConfiguration::optimizeResultOne() const { return optimize_result_one_; } bool TargetQisMappingPassConfiguration::optimizeResultZero() const { return optimize_result_zero_; } bool TargetQisMappingPassConfiguration::optimizeQuantumConstants() const { return optimize_quantum_constants_; } bool TargetQisMappingPassConfiguration::optimizeResultComparison() const { return optimize_result_comparison_; } bool TargetQisMappingPassConfiguration::removeGetZeroOrOne() const { return remove_get_one_or_zero_; } bool TargetQisMappingPassConfiguration::useStaticQubitArrayAllocation() const { return use_static_qubit_array_allocation_; } bool TargetQisMappingPassConfiguration::useStaticQubitAllocation() const { return use_static_qubit_allocation_; } bool TargetQisMappingPassConfiguration::useStaticResultAllocation() const { return use_static_result_allocation_; } uint32_t TargetQisMappingPassConfiguration::defaultIntegerWidth() const { return default_integer_width_; } bool TargetQisMappingPassConfiguration::isDisabled() const { return ( delete_dead_code_ == false && clone_functions_ == false && transform_execution_path_only_ == false && reuse_qubits_ == false && disable_reference_counting_ == false && disable_alias_counting_ == false && disable_string_support_ == false && disable_record_output_support_ == false && optimize_result_one_ == false && optimize_result_zero_ == false && optimize_quantum_constants_ == false && optimize_result_comparison_ == false && remove_get_one_or_zero_ == false && use_static_qubit_array_allocation_ == false && use_static_qubit_allocation_ == false && use_static_result_allocation_ == false); } bool TargetQisMappingPassConfiguration::isDefault() const { TargetQisMappingPassConfiguration ref{}; return ( delete_dead_code_ == ref.delete_dead_code_ && clone_functions_ == ref.clone_functions_ && transform_execution_path_only_ == ref.transform_execution_path_only_ && max_recursion_ == ref.max_recursion_ && assume_no_exceptions_ == ref.assume_no_exceptions_ && reuse_qubits_ == ref.reuse_qubits_ && reuse_results_ == ref.reuse_results_ && disable_reference_counting_ == ref.disable_reference_counting_ && disable_alias_counting_ == ref.disable_alias_counting_ && disable_string_support_ == ref.disable_string_support_ && disable_record_output_support_ == ref.disable_record_output_support_ && optimize_result_one_ == ref.optimize_result_one_ && optimize_result_zero_ == ref.optimize_result_zero_ && optimize_result_comparison_ == ref.optimize_result_comparison_ && remove_get_one_or_zero_ == ref.remove_get_one_or_zero_ && optimize_quantum_constants_ == ref.optimize_quantum_constants_ && use_static_qubit_array_allocation_ == ref.use_static_qubit_array_allocation_ && use_static_qubit_allocation_ == ref.use_static_qubit_allocation_ && use_static_result_allocation_ == ref.use_static_result_allocation_); } bool TargetQisMappingPassConfiguration::operator==(TargetQisMappingPassConfiguration const& ref) const { return ( delete_dead_code_ == ref.delete_dead_code_ && clone_functions_ == ref.clone_functions_ && transform_execution_path_only_ == ref.transform_execution_path_only_ && reuse_qubits_ == ref.reuse_qubits_); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/TargetQisMappingPass/TransformationRulesPassConfiguration.cpp"},{"location":"Api/Files/_transformation_rules_pass_configuration_8cpp/#passestargetqismappingpasstransformationrulespassconfigurationcpp","text":"","title":"Passes/TargetQisMappingPass/TransformationRulesPassConfiguration.cpp"},{"location":"Api/Files/_transformation_rules_pass_configuration_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_transformation_rules_pass_configuration_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Commandline/ConfigurationManager.hpp\" #include \"qir/qat/Passes/TargetQisMappingPass/TargetQisMappingPassConfiguration.hpp\" namespace microsoft::quantum { void TargetQisMappingPassConfiguration::setup(ConfigurationManager& config) { config.setSectionName(\"Target QIS mapping\", \"Modification of the IR to adapt a specific QIS.\"); // Experimental settings config.addExperimentalParameter(delete_dead_code_, true, false, \"delete-dead-code\", \"Deleted dead code.\"); config.addExperimentalParameter( clone_functions_, true, false, \"clone-functions\", \"Clone functions to ensure correct qubit allocation.\"); config.addExperimentalParameter( transform_execution_path_only_, true, false, \"transform-execution-path-only\", \"Transform execution paths only.\"); config.addExperimentalParameter( max_recursion_, max_recursion_, uint64_t(1), \"max-recursion\", \"Defines the maximum recursion when unrolling the execution path\"); config.addExperimentalParameter( assume_no_exceptions_, false, false, \"assume-no-except\", \"Assumes that no exception will occur during runtime.\"); config.addParameter(reuse_qubits_, false, \"reuse-qubits\", \"Use to define whether or not to reuse qubits.\"); config.addParameter(reuse_results_, false, \"reuse-results\", \"Use to define whether or not to reuse results.\"); // Rules config.addParameter( optimize_result_one_, true, \"optimize-result-one\", \"Maps branching based on quantum measurements compared to one to base adaptor \" \"type measurement.\"); config.addParameter( optimize_result_zero_, true, \"optimize-result-zero\", \"Maps branching based on quantum measurements compared to zero to base adaptor \" \"type measurement.\"); config.addParameter( optimize_result_comparison_, true, \"optimize-result-comparison\", \"Maps branching based on quantum measurements compared to each other to base adaptor \" \"type measurement.\"); config.addParameter( use_static_qubit_array_allocation_, \"use-static-qubit-array-allocation\", \"Maps allocation of qubit arrays to static array allocation.\"); config.addParameter( use_static_qubit_allocation_, \"use-static-qubit-allocation\", \"Maps qubit allocation to static allocation.\"); config.addParameter( use_static_result_allocation_, \"use-static-result-allocation\", \"Maps result allocation to static allocation.\"); config.addParameter( disable_reference_counting_, true, \"disable-reference-counting\", \"Disables reference counting by instruction removal.\"); config.addParameter( disable_alias_counting_, true, \"disable-alias-counting\", \"Disables alias counting by instruction removal.\"); config.addParameter( disable_string_support_, true, \"disable-string-support\", \"Disables string support by instruction removal.\"); config.addParameter( disable_record_output_support_, true, \"disable-record-output-support\", \"Disables record output support by instruction removal.\"); // Ready settings entry_point_attr_ = config.getParameter(\"entry-point-attr\"); } TargetQisMappingPassConfiguration TargetQisMappingPassConfiguration::createDisabled() { TargetQisMappingPassConfiguration ret; ret.delete_dead_code_ = false; ret.clone_functions_ = false; ret.transform_execution_path_only_ = false; ret.max_recursion_ = 512; ret.reuse_qubits_ = false; ret.reuse_results_ = false; ret.disable_reference_counting_ = false; ret.disable_alias_counting_ = false; ret.disable_string_support_ = false; ret.disable_record_output_support_ = false; ret.optimize_result_one_ = false; ret.optimize_result_zero_ = false; ret.optimize_result_comparison_ = false; ret.optimize_quantum_constants_ = false; ret.remove_get_one_or_zero_ = false; ret.use_static_qubit_array_allocation_ = false; ret.use_static_qubit_allocation_ = false; ret.use_static_result_allocation_ = false; return ret; } TargetQisMappingPassConfiguration TargetQisMappingPassConfiguration::createReuseQubitsOnly() { TargetQisMappingPassConfiguration ret; ret.delete_dead_code_ = false; ret.clone_functions_ = false; ret.transform_execution_path_only_ = false; ret.max_recursion_ = 512; ret.reuse_qubits_ = true; ret.reuse_results_ = false; ret.disable_reference_counting_ = false; ret.disable_alias_counting_ = false; ret.disable_string_support_ = false; ret.disable_record_output_support_ = false; ret.optimize_result_one_ = false; ret.optimize_result_zero_ = false; ret.optimize_result_comparison_ = false; ret.optimize_quantum_constants_ = false; ret.remove_get_one_or_zero_ = false; ret.use_static_qubit_array_allocation_ = false; ret.use_static_qubit_allocation_ = false; ret.use_static_result_allocation_ = false; return ret; } bool TargetQisMappingPassConfiguration::shouldDeleteDeadCode() const { return delete_dead_code_; } bool TargetQisMappingPassConfiguration::shouldCloneFunctions() const { return clone_functions_; } bool TargetQisMappingPassConfiguration::shouldTransformExecutionPathOnly() const { return transform_execution_path_only_; } uint64_t TargetQisMappingPassConfiguration::maxRecursion() const { return max_recursion_; } bool TargetQisMappingPassConfiguration::shouldReuseQubits() const { return reuse_qubits_; } bool TargetQisMappingPassConfiguration::shouldReuseResults() const { return reuse_results_; } std::string TargetQisMappingPassConfiguration::entryPointAttr() const { if (entry_point_attr_ == nullptr) { throw std::runtime_error(\"Specification entryPoint not found.\"); } return entry_point_attr_->value<std::string>(); } bool TargetQisMappingPassConfiguration::assumeNoExceptions() const { return assume_no_exceptions_; } bool TargetQisMappingPassConfiguration::disableReferenceCounting() const { return disable_reference_counting_; } bool TargetQisMappingPassConfiguration::disableAliasCounting() const { return disable_alias_counting_; } bool TargetQisMappingPassConfiguration::disableStringSupport() const { return disable_string_support_; } bool TargetQisMappingPassConfiguration::disableRecordOutputSupport() const { return disable_record_output_support_; } bool TargetQisMappingPassConfiguration::optimizeResultOne() const { return optimize_result_one_; } bool TargetQisMappingPassConfiguration::optimizeResultZero() const { return optimize_result_zero_; } bool TargetQisMappingPassConfiguration::optimizeQuantumConstants() const { return optimize_quantum_constants_; } bool TargetQisMappingPassConfiguration::optimizeResultComparison() const { return optimize_result_comparison_; } bool TargetQisMappingPassConfiguration::removeGetZeroOrOne() const { return remove_get_one_or_zero_; } bool TargetQisMappingPassConfiguration::useStaticQubitArrayAllocation() const { return use_static_qubit_array_allocation_; } bool TargetQisMappingPassConfiguration::useStaticQubitAllocation() const { return use_static_qubit_allocation_; } bool TargetQisMappingPassConfiguration::useStaticResultAllocation() const { return use_static_result_allocation_; } uint32_t TargetQisMappingPassConfiguration::defaultIntegerWidth() const { return default_integer_width_; } bool TargetQisMappingPassConfiguration::isDisabled() const { return ( delete_dead_code_ == false && clone_functions_ == false && transform_execution_path_only_ == false && reuse_qubits_ == false && disable_reference_counting_ == false && disable_alias_counting_ == false && disable_string_support_ == false && disable_record_output_support_ == false && optimize_result_one_ == false && optimize_result_zero_ == false && optimize_quantum_constants_ == false && optimize_result_comparison_ == false && remove_get_one_or_zero_ == false && use_static_qubit_array_allocation_ == false && use_static_qubit_allocation_ == false && use_static_result_allocation_ == false); } bool TargetQisMappingPassConfiguration::isDefault() const { TargetQisMappingPassConfiguration ref{}; return ( delete_dead_code_ == ref.delete_dead_code_ && clone_functions_ == ref.clone_functions_ && transform_execution_path_only_ == ref.transform_execution_path_only_ && max_recursion_ == ref.max_recursion_ && assume_no_exceptions_ == ref.assume_no_exceptions_ && reuse_qubits_ == ref.reuse_qubits_ && reuse_results_ == ref.reuse_results_ && disable_reference_counting_ == ref.disable_reference_counting_ && disable_alias_counting_ == ref.disable_alias_counting_ && disable_string_support_ == ref.disable_string_support_ && disable_record_output_support_ == ref.disable_record_output_support_ && optimize_result_one_ == ref.optimize_result_one_ && optimize_result_zero_ == ref.optimize_result_zero_ && optimize_result_comparison_ == ref.optimize_result_comparison_ && remove_get_one_or_zero_ == ref.remove_get_one_or_zero_ && optimize_quantum_constants_ == ref.optimize_quantum_constants_ && use_static_qubit_array_allocation_ == ref.use_static_qubit_array_allocation_ && use_static_qubit_allocation_ == ref.use_static_qubit_allocation_ && use_static_result_allocation_ == ref.use_static_result_allocation_); } bool TargetQisMappingPassConfiguration::operator==(TargetQisMappingPassConfiguration const& ref) const { return ( delete_dead_code_ == ref.delete_dead_code_ && clone_functions_ == ref.clone_functions_ && transform_execution_path_only_ == ref.transform_execution_path_only_ && reuse_qubits_ == ref.reuse_qubits_); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_trim_8hpp/","text":"Utils/Trim.hpp Namespaces Name microsoft microsoft::quantum Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include <algorithm> #include <string> namespace microsoft::quantum { inline void ltrim(std::string& str) { str.erase(str.begin(), std::find_if(str.begin(), str.end(), [](uint8_t ch) { return !std::isspace(ch); })); } inline void rtrim(std::string& str) { str.erase(std::find_if(str.rbegin(), str.rend(), [](uint8_t ch) { return !std::isspace(ch); }).base(), str.end()); } inline void trim(std::string& s) { ltrim(s); rtrim(s); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Utils/Trim.hpp"},{"location":"Api/Files/_trim_8hpp/#utilstrimhpp","text":"","title":"Utils/Trim.hpp"},{"location":"Api/Files/_trim_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_trim_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include <algorithm> #include <string> namespace microsoft::quantum { inline void ltrim(std::string& str) { str.erase(str.begin(), std::find_if(str.begin(), str.end(), [](uint8_t ch) { return !std::isspace(ch); })); } inline void rtrim(std::string& str) { str.erase(std::find_if(str.rbegin(), str.rend(), [](uint8_t ch) { return !std::isspace(ch); }).base(), str.end()); } inline void trim(std::string& s) { ltrim(s); rtrim(s); } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_unnamed_invoke_8cpp/","text":"Rules/Notation/UnnamedInvoke.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/UnnamedInvokePattern.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr unnamedInvoke() { auto ret = std::make_shared<UnnamedInvokePattern>(); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Notation/UnnamedInvoke.cpp"},{"location":"Api/Files/_unnamed_invoke_8cpp/#rulesnotationunnamedinvokecpp","text":"","title":"Rules/Notation/UnnamedInvoke.cpp"},{"location":"Api/Files/_unnamed_invoke_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_unnamed_invoke_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/UnnamedInvokePattern.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr unnamedInvoke() { auto ret = std::make_shared<UnnamedInvokePattern>(); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_unnamed_invoke_pattern_8cpp/","text":"Rules/Patterns/UnnamedInvokePattern.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Rules/Patterns/UnnamedInvokePattern.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" namespace microsoft::quantum { UnnamedInvokePattern::~UnnamedInvokePattern() = default; bool UnnamedInvokePattern::match(Value* instr, Captures& captures) const { auto* call_instr = llvm::dyn_cast<llvm::InvokeInst>(instr); if (call_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } UnnamedInvokePattern::Child UnnamedInvokePattern::copy() const { auto ret = std::make_shared<UnnamedInvokePattern>(); ret->copyPropertiesFrom(*this); return ret; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Patterns/UnnamedInvokePattern.cpp"},{"location":"Api/Files/_unnamed_invoke_pattern_8cpp/#rulespatternsunnamedinvokepatterncpp","text":"","title":"Rules/Patterns/UnnamedInvokePattern.cpp"},{"location":"Api/Files/_unnamed_invoke_pattern_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_unnamed_invoke_pattern_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Rules/Patterns/UnnamedInvokePattern.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" namespace microsoft::quantum { UnnamedInvokePattern::~UnnamedInvokePattern() = default; bool UnnamedInvokePattern::match(Value* instr, Captures& captures) const { auto* call_instr = llvm::dyn_cast<llvm::InvokeInst>(instr); if (call_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } UnnamedInvokePattern::Child UnnamedInvokePattern::copy() const { auto ret = std::make_shared<UnnamedInvokePattern>(); ret->copyPropertiesFrom(*this); return ret; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_unnamed_invoke_pattern_8hpp/","text":"Rules/Patterns/UnnamedInvokePattern.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::UnnamedInvokePattern Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { class UnnamedInvokePattern : public IOperandPrototype { public: using String = std::string; // Construction // UnnamedInvokePattern() = default; UnnamedInvokePattern(UnnamedInvokePattern const& other) = delete; UnnamedInvokePattern(UnnamedInvokePattern&& other) = default; ~UnnamedInvokePattern() override; // Call implementation of the member functions in IOperandPrototype. // bool match(Value* instr, Captures& captures) const override; Child copy() const override; private: }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Patterns/UnnamedInvokePattern.hpp"},{"location":"Api/Files/_unnamed_invoke_pattern_8hpp/#rulespatternsunnamedinvokepatternhpp","text":"","title":"Rules/Patterns/UnnamedInvokePattern.hpp"},{"location":"Api/Files/_unnamed_invoke_pattern_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_unnamed_invoke_pattern_8hpp/#classes","text":"Name class microsoft::quantum::UnnamedInvokePattern","title":"Classes"},{"location":"Api/Files/_unnamed_invoke_pattern_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/IOperandPrototype.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { class UnnamedInvokePattern : public IOperandPrototype { public: using String = std::string; // Construction // UnnamedInvokePattern() = default; UnnamedInvokePattern(UnnamedInvokePattern const& other) = delete; UnnamedInvokePattern(UnnamedInvokePattern&& other) = default; ~UnnamedInvokePattern() override; // Call implementation of the member functions in IOperandPrototype. // bool match(Value* instr, Captures& captures) const override; Child copy() const override; private: }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_validation_pass_8cpp/","text":"Passes/ValidationPass/ValidationPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/ValidationPass/ValidationPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/AllocationAnalysisPass.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { ValidationPass::ValidationPass( TargetProfileConfiguration const& profile, TargetQisConfiguration const& qis, ILoggerPtr const& logger) : profile_config_{profile} , qis_config_{qis} , logger_{logger} { } void ValidationPass::callChecks(Instruction& instr) { auto call_instr = llvm::dyn_cast<llvm::CallBase>(&instr); if (call_instr != nullptr) { auto f = call_instr->getCalledFunction(); if (f == nullptr) { return; } String signature; llvm::raw_string_ostream ostream(signature); ostream << f->getName() << \":\"; ostream << *f->getFunctionType(); if (f->isDeclaration()) { if (external_calls_.find(signature) != external_calls_.end()) { ++external_calls_[signature]; } else { external_calls_[signature] = 1; } external_call_location_[signature].push_back(current_location_); } else { if (internal_calls_.find(signature) != internal_calls_.end()) { ++internal_calls_[signature]; } else { internal_calls_[signature] = 1; } internal_call_location_[signature].push_back(current_location_); } } } void ValidationPass::pointerChecks(Instruction& instr) { for (auto& op : instr.operands()) { // Skipping function pointers auto function_pointer = llvm::dyn_cast<llvm::Function>(op); if (function_pointer) { continue; } // Skipping non-pointer types auto pointer_type = llvm::dyn_cast<llvm::PointerType>(op->getType()); if (!pointer_type) { continue; } uint64_t n = 1; llvm::Type* element_type = pointer_type->getElementType(); while (pointer_type == llvm::dyn_cast<llvm::PointerType>(element_type)) { element_type = pointer_type->getElementType(); ++n; } String name{}; if (element_type->isStructTy()) { name = static_cast<String>(element_type->getStructName()); } else { llvm::raw_string_ostream rso(name); element_type->print(rso); } // Adding indirection to the name while (n != 0) { name += \"*\"; --n; } auto it = pointers_.find(name); if (it == pointers_.end()) { pointers_[name] = 1; } else { ++it->second; } pointer_location_[name].push_back(current_location_); } } bool ValidationPass::satisfyingOpcodeRequirements(llvm::Module& module) { auto ret = true; if (profile_config_.allowlistOpcodes()) { auto const& allowed_ops = profile_config_.allowedOpcodes(); for (auto& function : module) { for (auto& block : function) { for (auto& instr : block) { auto loc = logger_->resolveLocation(&instr); current_location_ = Location{loc}; llvm::DebugLoc dl = instr.getDebugLoc(); if (dl) { current_location_ = Location{static_cast<String>(dl->getFilename()), dl->getLine(), dl->getColumn(), \"\", \"\"}; } llvm::raw_string_ostream rso(current_location_.llvmHint()); instr.print(rso); String opname = static_cast<String>(instr.getOpcodeName()); String first_arg{\"\"}; String code = opname; auto cmp = llvm::dyn_cast<llvm::CmpInst>(&instr); if (cmp) { switch (cmp->getPredicate()) { case llvm::CmpInst::Predicate::FCMP_FALSE: first_arg = \"false\"; break; case llvm::CmpInst::Predicate::FCMP_OEQ: first_arg = \"oeq\"; break; case llvm::CmpInst::Predicate::FCMP_OGT: first_arg = \"ogt\"; break; case llvm::CmpInst::Predicate::FCMP_OGE: first_arg = \"oge\"; break; case llvm::CmpInst::Predicate::FCMP_OLT: first_arg = \"olt\"; break; case llvm::CmpInst::Predicate::FCMP_OLE: first_arg = \"ole\"; break; case llvm::CmpInst::Predicate::FCMP_ONE: first_arg = \"one\"; break; case llvm::CmpInst::Predicate::FCMP_ORD: first_arg = \"ord\"; break; case llvm::CmpInst::Predicate::FCMP_UNO: first_arg = \"uno\"; break; case llvm::CmpInst::Predicate::FCMP_UEQ: first_arg = \"ueq\"; break; case llvm::CmpInst::Predicate::FCMP_UGT: first_arg = \"ugt\"; break; case llvm::CmpInst::Predicate::FCMP_UGE: first_arg = \"uge\"; break; case llvm::CmpInst::Predicate::FCMP_ULT: first_arg = \"ult\"; break; case llvm::CmpInst::Predicate::FCMP_ULE: first_arg = \"ule\"; break; case llvm::CmpInst::Predicate::FCMP_UNE: first_arg = \"une\"; break; case llvm::CmpInst::Predicate::FCMP_TRUE: first_arg = \"true\"; break; case llvm::CmpInst::Predicate::ICMP_EQ: first_arg = \"eq\"; break; case llvm::CmpInst::Predicate::ICMP_NE: first_arg = \"ne\"; break; case llvm::CmpInst::Predicate::ICMP_UGT: first_arg = \"ugt\"; break; case llvm::CmpInst::Predicate::ICMP_UGE: first_arg = \"uge\"; break; case llvm::CmpInst::Predicate::ICMP_ULT: first_arg = \"ult\"; break; case llvm::CmpInst::Predicate::ICMP_ULE: first_arg = \"ule\"; break; case llvm::CmpInst::Predicate::ICMP_SGT: first_arg = \"sgt\"; break; case llvm::CmpInst::Predicate::ICMP_SGE: first_arg = \"sge\"; break; case llvm::CmpInst::Predicate::ICMP_SLT: first_arg = \"slt\"; break; case llvm::CmpInst::Predicate::ICMP_SLE: first_arg = \"sle\"; break; case llvm::CmpInst::Predicate::BAD_FCMP_PREDICATE: first_arg = \"badfcmp\"; break; case llvm::CmpInst::Predicate::BAD_ICMP_PREDICATE: first_arg = \"badicmp\"; break; } } if (!first_arg.empty()) { code += \" \" + first_arg; } OpcodeValue opcode1{opname}; OpcodeValue opcode2{opname, first_arg}; if (allowed_ops.data().find(opcode1) == allowed_ops.data().end() && allowed_ops.data().find(opcode2) == allowed_ops.data().end()) { logger_->setLocation( {current_location_.name(), current_location_.line(), current_location_.column()}); logger_->setLlvmHint(current_location_.llvmHint()); logger_->errorOpcodeNotAllowed(code, profile_config_.targetName()); ret = false; } } } } } return ret; } bool ValidationPass::satisfyingInternalCallRequirements() { if (!profile_config_.allowInternalCalls() && !internal_calls_.empty()) { logger_->setLlvmHint(\"\"); // TODO(issue-60): Add location // Emitting error logger_->errorCustomFunctionsNotAllowed(); return false; } return true; } bool ValidationPass::satisfyingExternalCallRequirements() { auto ret = true; if (profile_config_.allowlistExternalCalls()) { auto const& allowed_functions = profile_config_.allowedExternalCallNames(); auto const& allowed_qis = qis_config_.allowedQis(); for (auto const& k : external_calls_) { if (allowed_functions.find(k.first) == allowed_functions.end() && allowed_qis.find(k.first) == allowed_qis.end()) { logger_->setLlvmHint(\"\"); // Adding debug location if (external_call_location_.find(k.first) != external_call_location_.end()) { auto const& locs = external_call_location_[k.first]; if (!locs.empty()) { auto const& loc = locs.front(); logger_->setLocation({loc.name(), loc.line(), loc.column()}); logger_->setLlvmHint(loc.llvmHint()); } } // Emitting error logger_->errorExternalCallsNotAllowed(k.first, profile_config_.targetName()); ret = false; } } } return ret; } bool ValidationPass::satisfyingPointerRequirements() { auto ret = true; if (profile_config_.allowlistPointerTypes()) { auto const& allowed = profile_config_.allowedPointerTypes(); for (auto const& k : pointers_) { if (allowed.find(k.first) == allowed.end()) { logger_->setLlvmHint(\"\"); // Adding debug location if (pointer_location_.find(k.first) != pointer_location_.end()) { auto const& locs = pointer_location_[k.first]; if (!locs.empty()) { auto const& loc = locs.front(); logger_->setLocation({loc.name(), loc.line(), loc.column()}); logger_->setLlvmHint(loc.llvmHint()); } } // Emitting error logger_->errorTypeNotAllowed(k.first, profile_config_.targetName()); ret = false; } } } return ret; } llvm::PreservedAnalyses ValidationPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { for (auto& function : module) { for (auto& block : function) { for (auto& instr : block) { auto loc = logger_->resolveLocation(&instr); current_location_ = Location{loc}; llvm::DebugLoc dl = instr.getDebugLoc(); if (dl) { current_location_ = Location{static_cast<String>(dl->getFilename()), dl->getLine(), dl->getColumn(), \"\", \"\"}; } llvm::raw_string_ostream rso(current_location_.llvmHint()); instr.print(rso); callChecks(instr); pointerChecks(instr); } } } bool raise_exception = false; raise_exception |= !satisfyingOpcodeRequirements(module); raise_exception |= !satisfyingExternalCallRequirements(); raise_exception |= !satisfyingInternalCallRequirements(); raise_exception |= !satisfyingPointerRequirements(); if (raise_exception) { throw std::runtime_error(\"QIR is not valid within the defined adaptor\"); } return llvm::PreservedAnalyses::all(); } bool ValidationPass::isRequired() { return true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/ValidationPass/ValidationPass.cpp"},{"location":"Api/Files/_validation_pass_8cpp/#passesvalidationpassvalidationpasscpp","text":"","title":"Passes/ValidationPass/ValidationPass.cpp"},{"location":"Api/Files/_validation_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_validation_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/ValidationPass/ValidationPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/AllocationAnalysisPass.hpp\" #include <fstream> #include <iostream> namespace microsoft::quantum { ValidationPass::ValidationPass( TargetProfileConfiguration const& profile, TargetQisConfiguration const& qis, ILoggerPtr const& logger) : profile_config_{profile} , qis_config_{qis} , logger_{logger} { } void ValidationPass::callChecks(Instruction& instr) { auto call_instr = llvm::dyn_cast<llvm::CallBase>(&instr); if (call_instr != nullptr) { auto f = call_instr->getCalledFunction(); if (f == nullptr) { return; } String signature; llvm::raw_string_ostream ostream(signature); ostream << f->getName() << \":\"; ostream << *f->getFunctionType(); if (f->isDeclaration()) { if (external_calls_.find(signature) != external_calls_.end()) { ++external_calls_[signature]; } else { external_calls_[signature] = 1; } external_call_location_[signature].push_back(current_location_); } else { if (internal_calls_.find(signature) != internal_calls_.end()) { ++internal_calls_[signature]; } else { internal_calls_[signature] = 1; } internal_call_location_[signature].push_back(current_location_); } } } void ValidationPass::pointerChecks(Instruction& instr) { for (auto& op : instr.operands()) { // Skipping function pointers auto function_pointer = llvm::dyn_cast<llvm::Function>(op); if (function_pointer) { continue; } // Skipping non-pointer types auto pointer_type = llvm::dyn_cast<llvm::PointerType>(op->getType()); if (!pointer_type) { continue; } uint64_t n = 1; llvm::Type* element_type = pointer_type->getElementType(); while (pointer_type == llvm::dyn_cast<llvm::PointerType>(element_type)) { element_type = pointer_type->getElementType(); ++n; } String name{}; if (element_type->isStructTy()) { name = static_cast<String>(element_type->getStructName()); } else { llvm::raw_string_ostream rso(name); element_type->print(rso); } // Adding indirection to the name while (n != 0) { name += \"*\"; --n; } auto it = pointers_.find(name); if (it == pointers_.end()) { pointers_[name] = 1; } else { ++it->second; } pointer_location_[name].push_back(current_location_); } } bool ValidationPass::satisfyingOpcodeRequirements(llvm::Module& module) { auto ret = true; if (profile_config_.allowlistOpcodes()) { auto const& allowed_ops = profile_config_.allowedOpcodes(); for (auto& function : module) { for (auto& block : function) { for (auto& instr : block) { auto loc = logger_->resolveLocation(&instr); current_location_ = Location{loc}; llvm::DebugLoc dl = instr.getDebugLoc(); if (dl) { current_location_ = Location{static_cast<String>(dl->getFilename()), dl->getLine(), dl->getColumn(), \"\", \"\"}; } llvm::raw_string_ostream rso(current_location_.llvmHint()); instr.print(rso); String opname = static_cast<String>(instr.getOpcodeName()); String first_arg{\"\"}; String code = opname; auto cmp = llvm::dyn_cast<llvm::CmpInst>(&instr); if (cmp) { switch (cmp->getPredicate()) { case llvm::CmpInst::Predicate::FCMP_FALSE: first_arg = \"false\"; break; case llvm::CmpInst::Predicate::FCMP_OEQ: first_arg = \"oeq\"; break; case llvm::CmpInst::Predicate::FCMP_OGT: first_arg = \"ogt\"; break; case llvm::CmpInst::Predicate::FCMP_OGE: first_arg = \"oge\"; break; case llvm::CmpInst::Predicate::FCMP_OLT: first_arg = \"olt\"; break; case llvm::CmpInst::Predicate::FCMP_OLE: first_arg = \"ole\"; break; case llvm::CmpInst::Predicate::FCMP_ONE: first_arg = \"one\"; break; case llvm::CmpInst::Predicate::FCMP_ORD: first_arg = \"ord\"; break; case llvm::CmpInst::Predicate::FCMP_UNO: first_arg = \"uno\"; break; case llvm::CmpInst::Predicate::FCMP_UEQ: first_arg = \"ueq\"; break; case llvm::CmpInst::Predicate::FCMP_UGT: first_arg = \"ugt\"; break; case llvm::CmpInst::Predicate::FCMP_UGE: first_arg = \"uge\"; break; case llvm::CmpInst::Predicate::FCMP_ULT: first_arg = \"ult\"; break; case llvm::CmpInst::Predicate::FCMP_ULE: first_arg = \"ule\"; break; case llvm::CmpInst::Predicate::FCMP_UNE: first_arg = \"une\"; break; case llvm::CmpInst::Predicate::FCMP_TRUE: first_arg = \"true\"; break; case llvm::CmpInst::Predicate::ICMP_EQ: first_arg = \"eq\"; break; case llvm::CmpInst::Predicate::ICMP_NE: first_arg = \"ne\"; break; case llvm::CmpInst::Predicate::ICMP_UGT: first_arg = \"ugt\"; break; case llvm::CmpInst::Predicate::ICMP_UGE: first_arg = \"uge\"; break; case llvm::CmpInst::Predicate::ICMP_ULT: first_arg = \"ult\"; break; case llvm::CmpInst::Predicate::ICMP_ULE: first_arg = \"ule\"; break; case llvm::CmpInst::Predicate::ICMP_SGT: first_arg = \"sgt\"; break; case llvm::CmpInst::Predicate::ICMP_SGE: first_arg = \"sge\"; break; case llvm::CmpInst::Predicate::ICMP_SLT: first_arg = \"slt\"; break; case llvm::CmpInst::Predicate::ICMP_SLE: first_arg = \"sle\"; break; case llvm::CmpInst::Predicate::BAD_FCMP_PREDICATE: first_arg = \"badfcmp\"; break; case llvm::CmpInst::Predicate::BAD_ICMP_PREDICATE: first_arg = \"badicmp\"; break; } } if (!first_arg.empty()) { code += \" \" + first_arg; } OpcodeValue opcode1{opname}; OpcodeValue opcode2{opname, first_arg}; if (allowed_ops.data().find(opcode1) == allowed_ops.data().end() && allowed_ops.data().find(opcode2) == allowed_ops.data().end()) { logger_->setLocation( {current_location_.name(), current_location_.line(), current_location_.column()}); logger_->setLlvmHint(current_location_.llvmHint()); logger_->errorOpcodeNotAllowed(code, profile_config_.targetName()); ret = false; } } } } } return ret; } bool ValidationPass::satisfyingInternalCallRequirements() { if (!profile_config_.allowInternalCalls() && !internal_calls_.empty()) { logger_->setLlvmHint(\"\"); // TODO(issue-60): Add location // Emitting error logger_->errorCustomFunctionsNotAllowed(); return false; } return true; } bool ValidationPass::satisfyingExternalCallRequirements() { auto ret = true; if (profile_config_.allowlistExternalCalls()) { auto const& allowed_functions = profile_config_.allowedExternalCallNames(); auto const& allowed_qis = qis_config_.allowedQis(); for (auto const& k : external_calls_) { if (allowed_functions.find(k.first) == allowed_functions.end() && allowed_qis.find(k.first) == allowed_qis.end()) { logger_->setLlvmHint(\"\"); // Adding debug location if (external_call_location_.find(k.first) != external_call_location_.end()) { auto const& locs = external_call_location_[k.first]; if (!locs.empty()) { auto const& loc = locs.front(); logger_->setLocation({loc.name(), loc.line(), loc.column()}); logger_->setLlvmHint(loc.llvmHint()); } } // Emitting error logger_->errorExternalCallsNotAllowed(k.first, profile_config_.targetName()); ret = false; } } } return ret; } bool ValidationPass::satisfyingPointerRequirements() { auto ret = true; if (profile_config_.allowlistPointerTypes()) { auto const& allowed = profile_config_.allowedPointerTypes(); for (auto const& k : pointers_) { if (allowed.find(k.first) == allowed.end()) { logger_->setLlvmHint(\"\"); // Adding debug location if (pointer_location_.find(k.first) != pointer_location_.end()) { auto const& locs = pointer_location_[k.first]; if (!locs.empty()) { auto const& loc = locs.front(); logger_->setLocation({loc.name(), loc.line(), loc.column()}); logger_->setLlvmHint(loc.llvmHint()); } } // Emitting error logger_->errorTypeNotAllowed(k.first, profile_config_.targetName()); ret = false; } } } return ret; } llvm::PreservedAnalyses ValidationPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { for (auto& function : module) { for (auto& block : function) { for (auto& instr : block) { auto loc = logger_->resolveLocation(&instr); current_location_ = Location{loc}; llvm::DebugLoc dl = instr.getDebugLoc(); if (dl) { current_location_ = Location{static_cast<String>(dl->getFilename()), dl->getLine(), dl->getColumn(), \"\", \"\"}; } llvm::raw_string_ostream rso(current_location_.llvmHint()); instr.print(rso); callChecks(instr); pointerChecks(instr); } } } bool raise_exception = false; raise_exception |= !satisfyingOpcodeRequirements(module); raise_exception |= !satisfyingExternalCallRequirements(); raise_exception |= !satisfyingInternalCallRequirements(); raise_exception |= !satisfyingPointerRequirements(); if (raise_exception) { throw std::runtime_error(\"QIR is not valid within the defined adaptor\"); } return llvm::PreservedAnalyses::all(); } bool ValidationPass::isRequired() { return true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_validation_pass_8hpp/","text":"Passes/ValidationPass/ValidationPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ValidationPass Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetProfileConfiguration.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetQisConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class ValidationPass : public llvm::PassInfoMixin<ValidationPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using Location = ILogger::Location; using StringRef = llvm::StringRef; // Construction and destruction configuration. // explicit ValidationPass( TargetProfileConfiguration const& profile, TargetQisConfiguration const& qis, ILoggerPtr const& logger = nullptr); ValidationPass(ValidationPass const&) = delete; ValidationPass(ValidationPass&&) = default; ~ValidationPass() = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired(); private: void callChecks(Instruction& instr); void pointerChecks(Instruction& instr); bool satisfyingOpcodeRequirements(llvm::Module& module); bool satisfyingInternalCallRequirements(); bool satisfyingExternalCallRequirements(); bool satisfyingPointerRequirements(); using Locations = std::vector<Location>; TargetProfileConfiguration profile_config_{}; TargetQisConfiguration qis_config_{}; Location current_location_{}; std::unordered_map<std::string, uint64_t> opcodes_; std::unordered_map<std::string, Locations> opcode_location_; std::unordered_map<std::string, uint64_t> external_calls_; std::unordered_map<std::string, Locations> external_call_location_; std::unordered_map<std::string, uint64_t> internal_calls_; std::unordered_map<std::string, Locations> internal_call_location_; std::unordered_map<std::string, uint64_t> pointers_; std::unordered_map<std::string, Locations> pointer_location_; ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/ValidationPass/ValidationPass.hpp"},{"location":"Api/Files/_validation_pass_8hpp/#passesvalidationpassvalidationpasshpp","text":"","title":"Passes/ValidationPass/ValidationPass.hpp"},{"location":"Api/Files/_validation_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_validation_pass_8hpp/#classes","text":"Name class microsoft::quantum::ValidationPass","title":"Classes"},{"location":"Api/Files/_validation_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetProfileConfiguration.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetQisConfiguration.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class ValidationPass : public llvm::PassInfoMixin<ValidationPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using Location = ILogger::Location; using StringRef = llvm::StringRef; // Construction and destruction configuration. // explicit ValidationPass( TargetProfileConfiguration const& profile, TargetQisConfiguration const& qis, ILoggerPtr const& logger = nullptr); ValidationPass(ValidationPass const&) = delete; ValidationPass(ValidationPass&&) = default; ~ValidationPass() = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired(); private: void callChecks(Instruction& instr); void pointerChecks(Instruction& instr); bool satisfyingOpcodeRequirements(llvm::Module& module); bool satisfyingInternalCallRequirements(); bool satisfyingExternalCallRequirements(); bool satisfyingPointerRequirements(); using Locations = std::vector<Location>; TargetProfileConfiguration profile_config_{}; TargetQisConfiguration qis_config_{}; Location current_location_{}; std::unordered_map<std::string, uint64_t> opcodes_; std::unordered_map<std::string, Locations> opcode_location_; std::unordered_map<std::string, uint64_t> external_calls_; std::unordered_map<std::string, Locations> external_call_location_; std::unordered_map<std::string, uint64_t> internal_calls_; std::unordered_map<std::string, Locations> internal_call_location_; std::unordered_map<std::string, uint64_t> pointers_; std::unordered_map<std::string, Locations> pointer_location_; ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_validator_8cpp/","text":"Validator/Validator.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Validator/Validator.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/CommentLogger.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Logging/LogCollection.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/AllocationAnalysisPass.hpp\" #include \"qir/qat/Passes/ValidationPass/FunctionValidationPass.hpp\" #include \"qir/qat/Passes/ValidationPass/ValidationPass.hpp\" #include <fstream> namespace microsoft::quantum { Validator::Validator( TargetProfileConfiguration const& profile, TargetQisConfiguration const& qis, ILoggerPtr const& logger, bool /*debug*/, llvm::TargetMachine* target_machine) : logger_{logger} { pass_builder_ = std::make_unique<llvm::PassBuilder>(target_machine); pass_builder_->registerModuleAnalyses(module_analysis_manager_); pass_builder_->registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_->registerFunctionAnalyses(function_analysis_manager_); pass_builder_->registerLoopAnalyses(loop_analysis_manager_); pass_builder_->crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); // Checking if we need to use provided logger or install one if (logger_) { function_analysis_manager_.registerPass([&] { return AllocationAnalysisPass(logger_); }); module_pass_manager_.addPass( llvm::createModuleToFunctionPassAdaptor(FunctionValidationPass(profile, qis, logger_))); module_pass_manager_.addPass(ValidationPass(profile, qis, logger_)); } else { // Our default is a pass that logs errors via comments auto comment_logger = std::make_shared<CommentLogger>(); function_analysis_manager_.registerPass([&] { return AllocationAnalysisPass(comment_logger); }); module_pass_manager_.addPass( llvm::createModuleToFunctionPassAdaptor(FunctionValidationPass(profile, qis, comment_logger))); module_pass_manager_.addPass(ValidationPass(profile, qis, comment_logger)); } } bool Validator::validate(llvm::Module& module) { llvm::VerifierAnalysis verifier; auto result = verifier.run(module, module_analysis_manager_); if (result.IRBroken) { if (logger_) { logger_->error(\"Fatal error: Invalid IR.\"); } return false; } try { module_pass_manager_.run(module, module_analysis_manager_); } catch (std::exception const& e) { if (logger_) { logger_->error(\"Fatal error: \" + static_cast<std::string>(e.what())); } return false; } if (logger_) { return !(logger_->hadErrors() || logger_->hadWarnings()); } return true; } llvm::PassBuilder& Validator::passBuilder() { return *pass_builder_; } llvm::LoopAnalysisManager& Validator::loopAnalysisManager() { return loop_analysis_manager_; } llvm::FunctionAnalysisManager& Validator::functionAnalysisManager() { return function_analysis_manager_; } llvm::CGSCCAnalysisManager& Validator::gsccAnalysisManager() { return gscc_analysis_manager_; } llvm::ModuleAnalysisManager& Validator::moduleAnalysisManager() { return module_analysis_manager_; } Validator::ILoggerPtr Validator::logger() const { return logger_; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Validator/Validator.cpp"},{"location":"Api/Files/_validator_8cpp/#validatorvalidatorcpp","text":"","title":"Validator/Validator.cpp"},{"location":"Api/Files/_validator_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_validator_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Validator/Validator.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/CommentLogger.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Logging/LogCollection.hpp\" #include \"qir/qat/Passes/StaticResourceComponent/AllocationAnalysisPass.hpp\" #include \"qir/qat/Passes/ValidationPass/FunctionValidationPass.hpp\" #include \"qir/qat/Passes/ValidationPass/ValidationPass.hpp\" #include <fstream> namespace microsoft::quantum { Validator::Validator( TargetProfileConfiguration const& profile, TargetQisConfiguration const& qis, ILoggerPtr const& logger, bool /*debug*/, llvm::TargetMachine* target_machine) : logger_{logger} { pass_builder_ = std::make_unique<llvm::PassBuilder>(target_machine); pass_builder_->registerModuleAnalyses(module_analysis_manager_); pass_builder_->registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_->registerFunctionAnalyses(function_analysis_manager_); pass_builder_->registerLoopAnalyses(loop_analysis_manager_); pass_builder_->crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); // Checking if we need to use provided logger or install one if (logger_) { function_analysis_manager_.registerPass([&] { return AllocationAnalysisPass(logger_); }); module_pass_manager_.addPass( llvm::createModuleToFunctionPassAdaptor(FunctionValidationPass(profile, qis, logger_))); module_pass_manager_.addPass(ValidationPass(profile, qis, logger_)); } else { // Our default is a pass that logs errors via comments auto comment_logger = std::make_shared<CommentLogger>(); function_analysis_manager_.registerPass([&] { return AllocationAnalysisPass(comment_logger); }); module_pass_manager_.addPass( llvm::createModuleToFunctionPassAdaptor(FunctionValidationPass(profile, qis, comment_logger))); module_pass_manager_.addPass(ValidationPass(profile, qis, comment_logger)); } } bool Validator::validate(llvm::Module& module) { llvm::VerifierAnalysis verifier; auto result = verifier.run(module, module_analysis_manager_); if (result.IRBroken) { if (logger_) { logger_->error(\"Fatal error: Invalid IR.\"); } return false; } try { module_pass_manager_.run(module, module_analysis_manager_); } catch (std::exception const& e) { if (logger_) { logger_->error(\"Fatal error: \" + static_cast<std::string>(e.what())); } return false; } if (logger_) { return !(logger_->hadErrors() || logger_->hadWarnings()); } return true; } llvm::PassBuilder& Validator::passBuilder() { return *pass_builder_; } llvm::LoopAnalysisManager& Validator::loopAnalysisManager() { return loop_analysis_manager_; } llvm::FunctionAnalysisManager& Validator::functionAnalysisManager() { return function_analysis_manager_; } llvm::CGSCCAnalysisManager& Validator::gsccAnalysisManager() { return gscc_analysis_manager_; } llvm::ModuleAnalysisManager& Validator::moduleAnalysisManager() { return module_analysis_manager_; } Validator::ILoggerPtr Validator::logger() const { return logger_; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_validator_8hpp/","text":"Validator/Validator.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::Validator Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AllocationManager/AllocationManager.hpp\" #include \"qir/qat/AllocationManager/IAllocationManager.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Logging/LogCollection.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetProfileConfiguration.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetQisConfiguration.hpp\" #include <memory> namespace microsoft::quantum { class Validator { public: using ValidatorPtr = std::unique_ptr<Validator>; using ILoggerPtr = ILogger::ILoggerPtr; // Constructors // explicit Validator( TargetProfileConfiguration const& profile, TargetQisConfiguration const& qis, ILoggerPtr const& logger, bool debug, llvm::TargetMachine* target_machine = nullptr); // Default construction not allowed to ensure that LLVM modules and passes are set up correctly. // Copy construction is prohibited due to restriction on classes held by Validator. Validator() = delete; Validator(Validator const&) = delete; Validator(Validator&&) = delete; Validator& operator=(Validator const&) = delete; Validator& operator=(Validator&&) = delete; ~Validator() = default; // Validator methods // bool validate(llvm::Module& module); ILoggerPtr logger() const; protected: using PassBuilderPtr = std::unique_ptr<llvm::PassBuilder>; llvm::PassBuilder& passBuilder(); llvm::LoopAnalysisManager& loopAnalysisManager(); llvm::FunctionAnalysisManager& functionAnalysisManager(); llvm::CGSCCAnalysisManager& gsccAnalysisManager(); llvm::ModuleAnalysisManager& moduleAnalysisManager(); private: // LLVM logic to run the passes // llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; PassBuilderPtr pass_builder_; llvm::ModulePassManager module_pass_manager_{}; ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Validator/Validator.hpp"},{"location":"Api/Files/_validator_8hpp/#validatorvalidatorhpp","text":"","title":"Validator/Validator.hpp"},{"location":"Api/Files/_validator_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_validator_8hpp/#classes","text":"Name class microsoft::quantum::Validator","title":"Classes"},{"location":"Api/Files/_validator_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/AllocationManager/AllocationManager.hpp\" #include \"qir/qat/AllocationManager/IAllocationManager.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/Logging/LogCollection.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetProfileConfiguration.hpp\" #include \"qir/qat/Passes/ValidationPass/TargetQisConfiguration.hpp\" #include <memory> namespace microsoft::quantum { class Validator { public: using ValidatorPtr = std::unique_ptr<Validator>; using ILoggerPtr = ILogger::ILoggerPtr; // Constructors // explicit Validator( TargetProfileConfiguration const& profile, TargetQisConfiguration const& qis, ILoggerPtr const& logger, bool debug, llvm::TargetMachine* target_machine = nullptr); // Default construction not allowed to ensure that LLVM modules and passes are set up correctly. // Copy construction is prohibited due to restriction on classes held by Validator. Validator() = delete; Validator(Validator const&) = delete; Validator(Validator&&) = delete; Validator& operator=(Validator const&) = delete; Validator& operator=(Validator&&) = delete; ~Validator() = default; // Validator methods // bool validate(llvm::Module& module); ILoggerPtr logger() const; protected: using PassBuilderPtr = std::unique_ptr<llvm::PassBuilder>; llvm::PassBuilder& passBuilder(); llvm::LoopAnalysisManager& loopAnalysisManager(); llvm::FunctionAnalysisManager& functionAnalysisManager(); llvm::CGSCCAnalysisManager& gsccAnalysisManager(); llvm::ModuleAnalysisManager& moduleAnalysisManager(); private: // LLVM logic to run the passes // llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; PassBuilderPtr pass_builder_; llvm::ModulePassManager module_pass_manager_{}; ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_version_8cpp/","text":"Version/Version.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Version/Version.hpp\" #include <cstdint> #include <iostream> #include <string> namespace microsoft::quantum { void displayCliHeader(bool extended_info) { std::cout << \"QAT v. \" << version::FULL << std::endl; std::cout << \"Copyright (c) Microsoft Corporation.\" << std::endl; std::cout << \"Licensed under the MIT License.\" << std::endl; if (extended_info) { std::cout << \"FULL \" << version::FULL << std::endl; std::cout << \"MAJOR \" << version::MAJOR << std::endl; std::cout << \"MINOR \" << version::MINOR << std::endl; std::cout << \"REVISION \" << version::REVISION << std::endl; std::cout << \"CHANNEL \" << version::CHANNEL << std::endl; std::cout << \"PATCH \" << version::PATCH << std::endl; std::cout << \"COMMIT_HASH \" << version::COMMIT_HASH << std::endl; std::cout << \"WORK_IN_PROGRESS \" << version::WORK_IN_PROGRESS << std::endl; std::cout << \"COMPILED WITH \"; #ifdef __clang__ std::cout << \"Clang \" << __clang_major__ << \".\" << __clang_minor__ << \".\" << __clang_patchlevel__; #elif __GNUC__ std::cout << \"GCC \" << __GNUC__ << \".\" << __GNUC_MINOR__ << \".\" << __GNUC_PATCHLEVEL__; #else std::cout << \"unknown compiler\"; #endif std::cout << std::endl; } } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Version/Version.cpp"},{"location":"Api/Files/_version_8cpp/#versionversioncpp","text":"","title":"Version/Version.cpp"},{"location":"Api/Files/_version_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_version_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Version/Version.hpp\" #include <cstdint> #include <iostream> #include <string> namespace microsoft::quantum { void displayCliHeader(bool extended_info) { std::cout << \"QAT v. \" << version::FULL << std::endl; std::cout << \"Copyright (c) Microsoft Corporation.\" << std::endl; std::cout << \"Licensed under the MIT License.\" << std::endl; if (extended_info) { std::cout << \"FULL \" << version::FULL << std::endl; std::cout << \"MAJOR \" << version::MAJOR << std::endl; std::cout << \"MINOR \" << version::MINOR << std::endl; std::cout << \"REVISION \" << version::REVISION << std::endl; std::cout << \"CHANNEL \" << version::CHANNEL << std::endl; std::cout << \"PATCH \" << version::PATCH << std::endl; std::cout << \"COMMIT_HASH \" << version::COMMIT_HASH << std::endl; std::cout << \"WORK_IN_PROGRESS \" << version::WORK_IN_PROGRESS << std::endl; std::cout << \"COMPILED WITH \"; #ifdef __clang__ std::cout << \"Clang \" << __clang_major__ << \".\" << __clang_minor__ << \".\" << __clang_patchlevel__; #elif __GNUC__ std::cout << \"GCC \" << __GNUC__ << \".\" << __GNUC_MINOR__ << \".\" << __GNUC_PATCHLEVEL__; #else std::cout << \"unknown compiler\"; #endif std::cout << std::endl; } } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_version_8tpl_8hpp/","text":"Version/Version.tpl.hpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::version Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include <cstdint> #include <string> namespace microsoft::quantum { namespace version { constexpr char const* const FULL = \"${MICROSOFT_VERSION_FULL}\"; constexpr uint32_t const MAJOR = ${MICROSOFT_VERSION_MAJOR}; constexpr uint32_t const MINOR = ${MICROSOFT_VERSION_MINOR}; constexpr uint32_t const REVISION = ${MICROSOFT_VERSION_REVISION}; constexpr char const* const CHANNEL = \"${MICROSOFT_VERSION_CHANNEL}\"; constexpr uint32_t const PATCH = ${MICROSOFT_VERSION_PATCH}; constexpr char const* const COMMIT_HASH = \"${MICROSOFT_VERSION_COMMIT}\"; constexpr bool const WORK_IN_PROGRESS = ${MICROSOFT_VERSION_WIP}; } // namespace version void displayCliHeader(bool extended_info = false); } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Version/Version.tpl.hpp"},{"location":"Api/Files/_version_8tpl_8hpp/#versionversiontplhpp","text":"","title":"Version/Version.tpl.hpp"},{"location":"Api/Files/_version_8tpl_8hpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::version","title":"Namespaces"},{"location":"Api/Files/_version_8tpl_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include <cstdint> #include <string> namespace microsoft::quantum { namespace version { constexpr char const* const FULL = \"${MICROSOFT_VERSION_FULL}\"; constexpr uint32_t const MAJOR = ${MICROSOFT_VERSION_MAJOR}; constexpr uint32_t const MINOR = ${MICROSOFT_VERSION_MINOR}; constexpr uint32_t const REVISION = ${MICROSOFT_VERSION_REVISION}; constexpr char const* const CHANNEL = \"${MICROSOFT_VERSION_CHANNEL}\"; constexpr uint32_t const PATCH = ${MICROSOFT_VERSION_PATCH}; constexpr char const* const COMMIT_HASH = \"${MICROSOFT_VERSION_COMMIT}\"; constexpr bool const WORK_IN_PROGRESS = ${MICROSOFT_VERSION_WIP}; } // namespace version void displayCliHeader(bool extended_info = false); } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_z_ext_8cpp/","text":"Rules/Notation/ZExt.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr zExt(IOperandPrototypePtr const& value) { auto ret = std::make_shared<ZExtPattern>(); ret->addChild(value); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Notation/ZExt.cpp"},{"location":"Api/Files/_z_ext_8cpp/#rulesnotationzextcpp","text":"","title":"Rules/Notation/ZExt.cpp"},{"location":"Api/Files/_z_ext_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_z_ext_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Rules/Notation/Notation.hpp\" #include \"qir/qat/Rules/Patterns/AnyPattern.hpp\" #include \"qir/qat/Rules/Patterns/CallPattern.hpp\" #include \"qir/qat/Rules/Patterns/Instruction.hpp\" #include <unordered_map> #include <vector> namespace microsoft::quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr zExt(IOperandPrototypePtr const& value) { auto ret = std::make_shared<ZExtPattern>(); ret->addChild(value); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Files/_z_ext_transform_pass_8cpp/","text":"Passes/ZExtTransformPass/ZExtTransformPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/ZExtTransformPass/ZExtTransformPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { llvm::PreservedAnalyses ZExtTransformPass::run(llvm::Function& function, llvm::FunctionAnalysisManager& /*fam*/) { std::vector<llvm::Instruction*> to_delete; auto builder = llvm::IRBuilder<>(function.getContext()); for (auto& block : function) { for (auto& instr : block) { auto cast_instr = llvm::dyn_cast<llvm::ZExtInst>(&instr); if (!cast_instr) { continue; } auto arg = instr.getOperand(0); auto input_type = arg->getType(); if (!input_type->isIntegerTy(1)) { continue; } auto output_type = instr.getType(); if (!output_type->isIntegerTy()) { continue; } uint64_t width = output_type->getIntegerBitWidth(); auto one = llvm::APInt(static_cast<uint32_t>(width), 1); auto one_value = llvm::ConstantInt::get(builder.getContext(), one); auto zero = llvm::APInt(static_cast<uint32_t>(width), 0); auto zero_value = llvm::ConstantInt::get(builder.getContext(), zero); builder.SetInsertPoint(&instr); auto new_val = builder.CreateSelect(arg, one_value, zero_value); new_val->takeName(&instr); instr.replaceAllUsesWith(new_val); to_delete.push_back(&instr); } } if (to_delete.empty()) { return llvm::PreservedAnalyses::all(); } for (auto it = to_delete.rbegin(); it != to_delete.rend(); ++it) { auto ptr = *it; if (!ptr->use_empty()) { throw std::runtime_error(\"Could not remove replaced instruction while transforming zext to select.\\n\"); } else { ptr->eraseFromParent(); } } return llvm::PreservedAnalyses::none(); } bool ZExtTransformPass::isRequired() { return true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/ZExtTransformPass/ZExtTransformPass.cpp"},{"location":"Api/Files/_z_ext_transform_pass_8cpp/#passeszexttransformpasszexttransformpasscpp","text":"","title":"Passes/ZExtTransformPass/ZExtTransformPass.cpp"},{"location":"Api/Files/_z_ext_transform_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_z_ext_transform_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Passes/ZExtTransformPass/ZExtTransformPass.hpp\" #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { llvm::PreservedAnalyses ZExtTransformPass::run(llvm::Function& function, llvm::FunctionAnalysisManager& /*fam*/) { std::vector<llvm::Instruction*> to_delete; auto builder = llvm::IRBuilder<>(function.getContext()); for (auto& block : function) { for (auto& instr : block) { auto cast_instr = llvm::dyn_cast<llvm::ZExtInst>(&instr); if (!cast_instr) { continue; } auto arg = instr.getOperand(0); auto input_type = arg->getType(); if (!input_type->isIntegerTy(1)) { continue; } auto output_type = instr.getType(); if (!output_type->isIntegerTy()) { continue; } uint64_t width = output_type->getIntegerBitWidth(); auto one = llvm::APInt(static_cast<uint32_t>(width), 1); auto one_value = llvm::ConstantInt::get(builder.getContext(), one); auto zero = llvm::APInt(static_cast<uint32_t>(width), 0); auto zero_value = llvm::ConstantInt::get(builder.getContext(), zero); builder.SetInsertPoint(&instr); auto new_val = builder.CreateSelect(arg, one_value, zero_value); new_val->takeName(&instr); instr.replaceAllUsesWith(new_val); to_delete.push_back(&instr); } } if (to_delete.empty()) { return llvm::PreservedAnalyses::all(); } for (auto it = to_delete.rbegin(); it != to_delete.rend(); ++it) { auto ptr = *it; if (!ptr->use_empty()) { throw std::runtime_error(\"Could not remove replaced instruction while transforming zext to select.\\n\"); } else { ptr->eraseFromParent(); } } return llvm::PreservedAnalyses::none(); } bool ZExtTransformPass::isRequired() { return true; } } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/_z_ext_transform_pass_8hpp/","text":"Passes/ZExtTransformPass/ZExtTransformPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ZExtTransformPass Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class ZExtTransformPass : public llvm::PassInfoMixin<ZExtTransformPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using Location = ILogger::Location; using StringRef = llvm::StringRef; // Construction and destruction configuration. // ZExtTransformPass() = default; ZExtTransformPass(ZExtTransformPass const&) = delete; ZExtTransformPass(ZExtTransformPass&&) = default; ~ZExtTransformPass() = default; llvm::PreservedAnalyses run(llvm::Function& function, llvm::FunctionAnalysisManager& fam); static bool isRequired(); private: ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/ZExtTransformPass/ZExtTransformPass.hpp"},{"location":"Api/Files/_z_ext_transform_pass_8hpp/#passeszexttransformpasszexttransformpasshpp","text":"","title":"Passes/ZExtTransformPass/ZExtTransformPass.hpp"},{"location":"Api/Files/_z_ext_transform_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_z_ext_transform_pass_8hpp/#classes","text":"Name class microsoft::quantum::ZExtTransformPass","title":"Classes"},{"location":"Api/Files/_z_ext_transform_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"qir/qat/Llvm/Llvm.hpp\" #include \"qir/qat/Logging/ILogger.hpp\" #include \"qir/qat/QatTypes/QatTypes.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft::quantum { class ZExtTransformPass : public llvm::PassInfoMixin<ZExtTransformPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = ILogger::ILoggerPtr; using Location = ILogger::Location; using StringRef = llvm::StringRef; // Construction and destruction configuration. // ZExtTransformPass() = default; ZExtTransformPass(ZExtTransformPass const&) = delete; ZExtTransformPass(ZExtTransformPass&&) = default; ~ZExtTransformPass() = default; llvm::PreservedAnalyses run(llvm::Function& function, llvm::FunctionAnalysisManager& fam); static bool isRequired(); private: ILoggerPtr logger_{nullptr}; }; } // namespace microsoft::quantum Updated on 28 October 2022 at 19:30:16 UTC","title":"Source code"},{"location":"Api/Files/dir_057849f2a92a904b8f008cf0365e4758/","text":"TestTools Files Name TestTools/IrManipulationTestHelper.cpp TestTools/IrManipulationTestHelper.hpp TestTools/TestVm.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"TestTools"},{"location":"Api/Files/dir_057849f2a92a904b8f008cf0365e4758/#testtools","text":"","title":"TestTools"},{"location":"Api/Files/dir_057849f2a92a904b8f008cf0365e4758/#files","text":"Name TestTools/IrManipulationTestHelper.cpp TestTools/IrManipulationTestHelper.hpp TestTools/TestVm.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Files"},{"location":"Api/Files/dir_06707ac4992ac72be902822087de860f/","text":"Passes/GroupingPass Files Name Passes/GroupingPass/GroupingAnalysisPass.cpp Passes/GroupingPass/GroupingAnalysisPass.hpp Passes/GroupingPass/GroupingPass.cpp Passes/GroupingPass/GroupingPass.hpp Passes/GroupingPass/GroupingPassConfiguration.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/GroupingPass"},{"location":"Api/Files/dir_06707ac4992ac72be902822087de860f/#passesgroupingpass","text":"","title":"Passes/GroupingPass"},{"location":"Api/Files/dir_06707ac4992ac72be902822087de860f/#files","text":"Name Passes/GroupingPass/GroupingAnalysisPass.cpp Passes/GroupingPass/GroupingAnalysisPass.hpp Passes/GroupingPass/GroupingPass.cpp Passes/GroupingPass/GroupingPass.hpp Passes/GroupingPass/GroupingPassConfiguration.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Files"},{"location":"Api/Files/dir_0a824aa1f70ce3b829ef378253b085da/","text":"Utils Files Name Utils/FunctionToModule.hpp Utils/Trim.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Utils"},{"location":"Api/Files/dir_0a824aa1f70ce3b829ef378253b085da/#utils","text":"","title":"Utils"},{"location":"Api/Files/dir_0a824aa1f70ce3b829ef378253b085da/#files","text":"Name Utils/FunctionToModule.hpp Utils/Trim.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Files"},{"location":"Api/Files/dir_0c7569bb855645e4ebd09c6100c8b750/","text":"Passes/DeferMeasurementPass Files Name Passes/DeferMeasurementPass/DeferMeasurementPass.cpp Passes/DeferMeasurementPass/DeferMeasurementPass.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/DeferMeasurementPass"},{"location":"Api/Files/dir_0c7569bb855645e4ebd09c6100c8b750/#passesdefermeasurementpass","text":"","title":"Passes/DeferMeasurementPass"},{"location":"Api/Files/dir_0c7569bb855645e4ebd09c6100c8b750/#files","text":"Name Passes/DeferMeasurementPass/DeferMeasurementPass.cpp Passes/DeferMeasurementPass/DeferMeasurementPass.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Files"},{"location":"Api/Files/dir_10c15797e36d9f6023729f20017a6c03/","text":"Passes/PostTransformValidation Files Name Passes/PostTransformValidation/PostTransformValidationPass.cpp Passes/PostTransformValidation/PostTransformValidationPass.hpp Passes/PostTransformValidation/PostTransformValidationPassConfiguration.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/PostTransformValidation"},{"location":"Api/Files/dir_10c15797e36d9f6023729f20017a6c03/#passesposttransformvalidation","text":"","title":"Passes/PostTransformValidation"},{"location":"Api/Files/dir_10c15797e36d9f6023729f20017a6c03/#files","text":"Name Passes/PostTransformValidation/PostTransformValidationPass.cpp Passes/PostTransformValidation/PostTransformValidationPass.hpp Passes/PostTransformValidation/PostTransformValidationPassConfiguration.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Files"},{"location":"Api/Files/dir_13002e6e9a3be65aeac8e1b6c1ea9008/","text":"AllocationManager Files Name AllocationManager/AllocationManager.cpp AllocationManager/AllocationManager.hpp AllocationManager/IAllocationManager.cpp AllocationManager/IAllocationManager.hpp Updated on 28 October 2022 at 19:30:16 UTC","title":"AllocationManager"},{"location":"Api/Files/dir_13002e6e9a3be65aeac8e1b6c1ea9008/#allocationmanager","text":"","title":"AllocationManager"},{"location":"Api/Files/dir_13002e6e9a3be65aeac8e1b6c1ea9008/#files","text":"Name AllocationManager/AllocationManager.cpp AllocationManager/AllocationManager.hpp AllocationManager/IAllocationManager.cpp AllocationManager/IAllocationManager.hpp Updated on 28 October 2022 at 19:30:16 UTC","title":"Files"},{"location":"Api/Files/dir_1f6822dce43bfa076b3c0c3c2ab875f3/","text":"Passes/ValidationPass Files Name Passes/ValidationPass/FunctionValidationPass.cpp Passes/ValidationPass/FunctionValidationPass.hpp Passes/ValidationPass/TargetProfileConfiguration.cpp Passes/ValidationPass/TargetProfileConfiguration.hpp Passes/ValidationPass/TargetQisConfiguration.cpp Passes/ValidationPass/TargetQisConfiguration.hpp Passes/ValidationPass/ValidationPass.cpp Passes/ValidationPass/ValidationPass.hpp Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/ValidationPass"},{"location":"Api/Files/dir_1f6822dce43bfa076b3c0c3c2ab875f3/#passesvalidationpass","text":"","title":"Passes/ValidationPass"},{"location":"Api/Files/dir_1f6822dce43bfa076b3c0c3c2ab875f3/#files","text":"Name Passes/ValidationPass/FunctionValidationPass.cpp Passes/ValidationPass/FunctionValidationPass.hpp Passes/ValidationPass/TargetProfileConfiguration.cpp Passes/ValidationPass/TargetProfileConfiguration.hpp Passes/ValidationPass/TargetQisConfiguration.cpp Passes/ValidationPass/TargetQisConfiguration.hpp Passes/ValidationPass/ValidationPass.cpp Passes/ValidationPass/ValidationPass.hpp Updated on 28 October 2022 at 19:30:16 UTC","title":"Files"},{"location":"Api/Files/dir_2d85567291775b265725bb7c4e64cdd8/","text":"Passes/StaticResourceComponent Files Name Passes/StaticResourceComponent/AllocationAnalysisPass.cpp Passes/StaticResourceComponent/AllocationAnalysisPass.hpp Passes/StaticResourceComponent/QubitRemapPass.cpp Passes/StaticResourceComponent/QubitRemapPass.hpp Passes/StaticResourceComponent/ReplaceQubitOnResetPass.cpp Passes/StaticResourceComponent/ReplaceQubitOnResetPass.hpp Passes/StaticResourceComponent/ResourceAnnotationPass.cpp Passes/StaticResourceComponent/ResourceAnnotationPass.hpp Passes/StaticResourceComponent/StaticResourceComponentConfiguration.cpp Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/StaticResourceComponent"},{"location":"Api/Files/dir_2d85567291775b265725bb7c4e64cdd8/#passesstaticresourcecomponent","text":"","title":"Passes/StaticResourceComponent"},{"location":"Api/Files/dir_2d85567291775b265725bb7c4e64cdd8/#files","text":"Name Passes/StaticResourceComponent/AllocationAnalysisPass.cpp Passes/StaticResourceComponent/AllocationAnalysisPass.hpp Passes/StaticResourceComponent/QubitRemapPass.cpp Passes/StaticResourceComponent/QubitRemapPass.hpp Passes/StaticResourceComponent/ReplaceQubitOnResetPass.cpp Passes/StaticResourceComponent/ReplaceQubitOnResetPass.hpp Passes/StaticResourceComponent/ResourceAnnotationPass.cpp Passes/StaticResourceComponent/ResourceAnnotationPass.hpp Passes/StaticResourceComponent/StaticResourceComponentConfiguration.cpp Passes/StaticResourceComponent/StaticResourceComponentConfiguration.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Files"},{"location":"Api/Files/dir_46e4ac26363cdfa62d85590f6bd5db50/","text":"QatTypes Files Name QatTypes/QatTypes.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"QatTypes"},{"location":"Api/Files/dir_46e4ac26363cdfa62d85590f6bd5db50/#qattypes","text":"","title":"QatTypes"},{"location":"Api/Files/dir_46e4ac26363cdfa62d85590f6bd5db50/#files","text":"Name QatTypes/QatTypes.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Files"},{"location":"Api/Files/dir_4b03aed240e916356291e962f5734b39/","text":"Passes Directories Name Passes/DeferMeasurementPass Passes/DivisionByZeroPass Passes/FunctionReplacementPass Passes/GroupingPass Passes/PostTransformValidation Passes/RemoveDisallowedAttributesPass Passes/RemoveNonEntrypointFunctions Passes/StaticResourceComponent Passes/TargetQisMappingPass Passes/ValidationPass Passes/ZExtTransformPass Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes"},{"location":"Api/Files/dir_4b03aed240e916356291e962f5734b39/#passes","text":"","title":"Passes"},{"location":"Api/Files/dir_4b03aed240e916356291e962f5734b39/#directories","text":"Name Passes/DeferMeasurementPass Passes/DivisionByZeroPass Passes/FunctionReplacementPass Passes/GroupingPass Passes/PostTransformValidation Passes/RemoveDisallowedAttributesPass Passes/RemoveNonEntrypointFunctions Passes/StaticResourceComponent Passes/TargetQisMappingPass Passes/ValidationPass Passes/ZExtTransformPass Updated on 28 October 2022 at 19:30:15 UTC","title":"Directories"},{"location":"Api/Files/dir_4cfa8840d1bdb58ac4dfb9f9b8f9e0c7/","text":"QirAdaptor Files Name QirAdaptor/QirAdaptor.cpp QirAdaptor/QirAdaptor.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"QirAdaptor"},{"location":"Api/Files/dir_4cfa8840d1bdb58ac4dfb9f9b8f9e0c7/#qiradaptor","text":"","title":"QirAdaptor"},{"location":"Api/Files/dir_4cfa8840d1bdb58ac4dfb9f9b8f9e0c7/#files","text":"Name QirAdaptor/QirAdaptor.cpp QirAdaptor/QirAdaptor.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Files"},{"location":"Api/Files/dir_4ecff2ba04018cbc639e787b47aa4826/","text":"Passes/DivisionByZeroPass Files Name Passes/DivisionByZeroPass/DivisionByZeroPass.cpp Passes/DivisionByZeroPass/DivisionByZeroPass.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/DivisionByZeroPass"},{"location":"Api/Files/dir_4ecff2ba04018cbc639e787b47aa4826/#passesdivisionbyzeropass","text":"","title":"Passes/DivisionByZeroPass"},{"location":"Api/Files/dir_4ecff2ba04018cbc639e787b47aa4826/#files","text":"Name Passes/DivisionByZeroPass/DivisionByZeroPass.cpp Passes/DivisionByZeroPass/DivisionByZeroPass.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Files"},{"location":"Api/Files/dir_5e2e6bb3767fb61e254fda27d10d8563/","text":"Passes/FunctionReplacementPass Files Name Passes/FunctionReplacementPass/FunctionAnnotatorPass.cpp Passes/FunctionReplacementPass/FunctionAnnotatorPass.hpp Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.cpp Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.hpp Passes/FunctionReplacementPass/FunctionReplacementConfiguration.hpp Passes/FunctionReplacementPass/FunctionReplacementPass.cpp Passes/FunctionReplacementPass/FunctionReplacementPass.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/FunctionReplacementPass"},{"location":"Api/Files/dir_5e2e6bb3767fb61e254fda27d10d8563/#passesfunctionreplacementpass","text":"","title":"Passes/FunctionReplacementPass"},{"location":"Api/Files/dir_5e2e6bb3767fb61e254fda27d10d8563/#files","text":"Name Passes/FunctionReplacementPass/FunctionAnnotatorPass.cpp Passes/FunctionReplacementPass/FunctionAnnotatorPass.hpp Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.cpp Passes/FunctionReplacementPass/FunctionReplacementAnalysisPass.hpp Passes/FunctionReplacementPass/FunctionReplacementConfiguration.hpp Passes/FunctionReplacementPass/FunctionReplacementPass.cpp Passes/FunctionReplacementPass/FunctionReplacementPass.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Files"},{"location":"Api/Files/dir_6abb076d4d0fb3ef7ab0d1b2c7c28557/","text":"AdaptorFactory Files Name AdaptorFactory/ConfigurableQirAdaptorFactory.cpp AdaptorFactory/ConfigurableQirAdaptorFactory.hpp AdaptorFactory/LlvmPassesConfiguration.cpp AdaptorFactory/LlvmPassesConfiguration.hpp AdaptorFactory/QirAdaptorFactory.cpp AdaptorFactory/QirAdaptorFactory.hpp AdaptorFactory/TargetProfileMappingConfiguration.hpp Updated on 28 October 2022 at 19:30:16 UTC","title":"AdaptorFactory"},{"location":"Api/Files/dir_6abb076d4d0fb3ef7ab0d1b2c7c28557/#adaptorfactory","text":"","title":"AdaptorFactory"},{"location":"Api/Files/dir_6abb076d4d0fb3ef7ab0d1b2c7c28557/#files","text":"Name AdaptorFactory/ConfigurableQirAdaptorFactory.cpp AdaptorFactory/ConfigurableQirAdaptorFactory.hpp AdaptorFactory/LlvmPassesConfiguration.cpp AdaptorFactory/LlvmPassesConfiguration.hpp AdaptorFactory/QirAdaptorFactory.cpp AdaptorFactory/QirAdaptorFactory.hpp AdaptorFactory/TargetProfileMappingConfiguration.hpp Updated on 28 October 2022 at 19:30:16 UTC","title":"Files"},{"location":"Api/Files/dir_76e799bfaed323ed7497703f1980580e/","text":"Commandline Files Name Commandline/ConfigBind.hpp Commandline/ConfigurationManager.cpp Commandline/ConfigurationManager.hpp Commandline/IConfigBind.cpp Commandline/IConfigBind.hpp Commandline/ParameterParser.cpp Commandline/ParameterParser.hpp Commandline/SerializationTraits.hpp Commandline/SpecConfiguration.hpp Updated on 28 October 2022 at 19:30:16 UTC","title":"Commandline"},{"location":"Api/Files/dir_76e799bfaed323ed7497703f1980580e/#commandline","text":"","title":"Commandline"},{"location":"Api/Files/dir_76e799bfaed323ed7497703f1980580e/#files","text":"Name Commandline/ConfigBind.hpp Commandline/ConfigurationManager.cpp Commandline/ConfigurationManager.hpp Commandline/IConfigBind.cpp Commandline/IConfigBind.hpp Commandline/ParameterParser.cpp Commandline/ParameterParser.hpp Commandline/SerializationTraits.hpp Commandline/SpecConfiguration.hpp Updated on 28 October 2022 at 19:30:16 UTC","title":"Files"},{"location":"Api/Files/dir_796b3cf875c53f008e9fa858f7830e6b/","text":"Passes/RemoveDisallowedAttributesPass Files Name Passes/RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/RemoveDisallowedAttributesPass"},{"location":"Api/Files/dir_796b3cf875c53f008e9fa858f7830e6b/#passesremovedisallowedattributespass","text":"","title":"Passes/RemoveDisallowedAttributesPass"},{"location":"Api/Files/dir_796b3cf875c53f008e9fa858f7830e6b/#files","text":"Name Passes/RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Files"},{"location":"Api/Files/dir_a1c5909b11c5c8bda254c1d4e660dcd9/","text":"Passes/TargetQisMappingPass Files Name Passes/TargetQisMappingPass/Factory.cpp Passes/TargetQisMappingPass/Factory.hpp Passes/TargetQisMappingPass/TargetQisMappingPass.cpp Passes/TargetQisMappingPass/TargetQisMappingPass.hpp Passes/TargetQisMappingPass/TargetQisMappingPassConfiguration.hpp Passes/TargetQisMappingPass/TransformationRulesPassConfiguration.cpp Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/TargetQisMappingPass"},{"location":"Api/Files/dir_a1c5909b11c5c8bda254c1d4e660dcd9/#passestargetqismappingpass","text":"","title":"Passes/TargetQisMappingPass"},{"location":"Api/Files/dir_a1c5909b11c5c8bda254c1d4e660dcd9/#files","text":"Name Passes/TargetQisMappingPass/Factory.cpp Passes/TargetQisMappingPass/Factory.hpp Passes/TargetQisMappingPass/TargetQisMappingPass.cpp Passes/TargetQisMappingPass/TargetQisMappingPass.hpp Passes/TargetQisMappingPass/TargetQisMappingPassConfiguration.hpp Passes/TargetQisMappingPass/TransformationRulesPassConfiguration.cpp Updated on 28 October 2022 at 19:30:16 UTC","title":"Files"},{"location":"Api/Files/dir_a4492bc8c549baa5763ec9eeb7ca21d1/","text":"Passes/RemoveNonEntrypointFunctions Files Name Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPass.cpp Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPass.hpp Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPassConfiguration.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Passes/RemoveNonEntrypointFunctions"},{"location":"Api/Files/dir_a4492bc8c549baa5763ec9eeb7ca21d1/#passesremovenonentrypointfunctions","text":"","title":"Passes/RemoveNonEntrypointFunctions"},{"location":"Api/Files/dir_a4492bc8c549baa5763ec9eeb7ca21d1/#files","text":"Name Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPass.cpp Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPass.hpp Passes/RemoveNonEntrypointFunctions/RemoveNonEntrypointFunctionsPassConfiguration.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Files"},{"location":"Api/Files/dir_b392e36b8bc0ffd1fb6a4bd773438243/","text":"Rules/Notation Files Name Rules/Notation/BasicBlock.cpp Rules/Notation/BitCast.cpp Rules/Notation/Branch.cpp Rules/Notation/Call.hpp Rules/Notation/Call.ipp Rules/Notation/CallByNameOnly.cpp Rules/Notation/Capture.cpp Rules/Notation/ConstInt.cpp Rules/Notation/IntToPtr.cpp Rules/Notation/Load.cpp Rules/Notation/Notation.cpp Rules/Notation/Notation.hpp Rules/Notation/Phi.ipp Rules/Notation/Select.cpp Rules/Notation/Store.cpp Rules/Notation/Switch.cpp Rules/Notation/UnnamedInvoke.cpp Rules/Notation/ZExt.cpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Notation"},{"location":"Api/Files/dir_b392e36b8bc0ffd1fb6a4bd773438243/#rulesnotation","text":"","title":"Rules/Notation"},{"location":"Api/Files/dir_b392e36b8bc0ffd1fb6a4bd773438243/#files","text":"Name Rules/Notation/BasicBlock.cpp Rules/Notation/BitCast.cpp Rules/Notation/Branch.cpp Rules/Notation/Call.hpp Rules/Notation/Call.ipp Rules/Notation/CallByNameOnly.cpp Rules/Notation/Capture.cpp Rules/Notation/ConstInt.cpp Rules/Notation/IntToPtr.cpp Rules/Notation/Load.cpp Rules/Notation/Notation.cpp Rules/Notation/Notation.hpp Rules/Notation/Phi.ipp Rules/Notation/Select.cpp Rules/Notation/Store.cpp Rules/Notation/Switch.cpp Rules/Notation/UnnamedInvoke.cpp Rules/Notation/ZExt.cpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Files"},{"location":"Api/Files/dir_c088d9039decfcf39c85aae8d9153291/","text":"Version Files Name Version/Version.cpp Version/Version.tpl.hpp Version/version_builder.py Updated on 28 October 2022 at 19:30:15 UTC","title":"Version"},{"location":"Api/Files/dir_c088d9039decfcf39c85aae8d9153291/#version","text":"","title":"Version"},{"location":"Api/Files/dir_c088d9039decfcf39c85aae8d9153291/#files","text":"Name Version/Version.cpp Version/Version.tpl.hpp Version/version_builder.py Updated on 28 October 2022 at 19:30:15 UTC","title":"Files"},{"location":"Api/Files/dir_cb624db7cb615d447013f4d45a07ea78/","text":"Passes/ZExtTransformPass Files Name Passes/ZExtTransformPass/ZExtTransformPass.cpp Passes/ZExtTransformPass/ZExtTransformPass.hpp Updated on 28 October 2022 at 19:30:16 UTC","title":"Passes/ZExtTransformPass"},{"location":"Api/Files/dir_cb624db7cb615d447013f4d45a07ea78/#passeszexttransformpass","text":"","title":"Passes/ZExtTransformPass"},{"location":"Api/Files/dir_cb624db7cb615d447013f4d45a07ea78/#files","text":"Name Passes/ZExtTransformPass/ZExtTransformPass.cpp Passes/ZExtTransformPass/ZExtTransformPass.hpp Updated on 28 October 2022 at 19:30:16 UTC","title":"Files"},{"location":"Api/Files/dir_d31ef966b0cb1225b2b298e923bbc249/","text":"ModuleLoader Files Name ModuleLoader/DebugInfoUpdater.cpp ModuleLoader/DebugInfoUpdater.hpp ModuleLoader/InstructionLocationTable.cpp ModuleLoader/InstructionLocationTable.hpp ModuleLoader/ModuleLoader.hpp Updated on 28 October 2022 at 19:30:16 UTC","title":"ModuleLoader"},{"location":"Api/Files/dir_d31ef966b0cb1225b2b298e923bbc249/#moduleloader","text":"","title":"ModuleLoader"},{"location":"Api/Files/dir_d31ef966b0cb1225b2b298e923bbc249/#files","text":"Name ModuleLoader/DebugInfoUpdater.cpp ModuleLoader/DebugInfoUpdater.hpp ModuleLoader/InstructionLocationTable.cpp ModuleLoader/InstructionLocationTable.hpp ModuleLoader/ModuleLoader.hpp Updated on 28 October 2022 at 19:30:16 UTC","title":"Files"},{"location":"Api/Files/dir_d9949a2e036493f8647151a4ab6ee0ce/","text":"Logging Files Name Logging/CommentLogger.cpp Logging/CommentLogger.hpp Logging/ILogger.cpp Logging/ILogger.hpp Logging/LogCollection.cpp Logging/LogCollection.hpp Logging/SourceLocation.hpp Updated on 28 October 2022 at 19:30:16 UTC","title":"Logging"},{"location":"Api/Files/dir_d9949a2e036493f8647151a4ab6ee0ce/#logging","text":"","title":"Logging"},{"location":"Api/Files/dir_d9949a2e036493f8647151a4ab6ee0ce/#files","text":"Name Logging/CommentLogger.cpp Logging/CommentLogger.hpp Logging/ILogger.cpp Logging/ILogger.hpp Logging/LogCollection.cpp Logging/LogCollection.hpp Logging/SourceLocation.hpp Updated on 28 October 2022 at 19:30:16 UTC","title":"Files"},{"location":"Api/Files/dir_ed349e2d4b607ef61e27eb2c0c0c4b3d/","text":"Rules Directories Name Rules/Notation Rules/Patterns Files Name Rules/IOperandPrototype.cpp Rules/IOperandPrototype.hpp Rules/ReplacementRule.cpp Rules/ReplacementRule.hpp Rules/RuleSet.cpp Rules/RuleSet.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules"},{"location":"Api/Files/dir_ed349e2d4b607ef61e27eb2c0c0c4b3d/#rules","text":"","title":"Rules"},{"location":"Api/Files/dir_ed349e2d4b607ef61e27eb2c0c0c4b3d/#directories","text":"Name Rules/Notation Rules/Patterns","title":"Directories"},{"location":"Api/Files/dir_ed349e2d4b607ef61e27eb2c0c0c4b3d/#files","text":"Name Rules/IOperandPrototype.cpp Rules/IOperandPrototype.hpp Rules/ReplacementRule.cpp Rules/ReplacementRule.hpp Rules/RuleSet.cpp Rules/RuleSet.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Files"},{"location":"Api/Files/dir_f11d3c47e762e38fcdfbd4cfb049caab/","text":"Rules/Patterns Files Name Rules/Patterns/AnyPattern.cpp Rules/Patterns/AnyPattern.hpp Rules/Patterns/CallPattern.cpp Rules/Patterns/CallPattern.hpp Rules/Patterns/Instruction.cpp Rules/Patterns/Instruction.hpp Rules/Patterns/PhiPattern.cpp Rules/Patterns/PhiPattern.hpp Rules/Patterns/UnnamedInvokePattern.cpp Rules/Patterns/UnnamedInvokePattern.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Rules/Patterns"},{"location":"Api/Files/dir_f11d3c47e762e38fcdfbd4cfb049caab/#rulespatterns","text":"","title":"Rules/Patterns"},{"location":"Api/Files/dir_f11d3c47e762e38fcdfbd4cfb049caab/#files","text":"Name Rules/Patterns/AnyPattern.cpp Rules/Patterns/AnyPattern.hpp Rules/Patterns/CallPattern.cpp Rules/Patterns/CallPattern.hpp Rules/Patterns/Instruction.cpp Rules/Patterns/Instruction.hpp Rules/Patterns/PhiPattern.cpp Rules/Patterns/PhiPattern.hpp Rules/Patterns/UnnamedInvokePattern.cpp Rules/Patterns/UnnamedInvokePattern.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Files"},{"location":"Api/Files/dir_f32fa1f684a45b73f347439bab6df68d/","text":"Validator Files Name Validator/Validator.cpp Validator/Validator.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Validator"},{"location":"Api/Files/dir_f32fa1f684a45b73f347439bab6df68d/#validator","text":"","title":"Validator"},{"location":"Api/Files/dir_f32fa1f684a45b73f347439bab6df68d/#files","text":"Name Validator/Validator.cpp Validator/Validator.hpp Updated on 28 October 2022 at 19:30:15 UTC","title":"Files"},{"location":"Api/Files/version__builder_8py/","text":"Version/version_builder.py Namespaces Name version_builder Source code # Copyright (c) Microsoft Corporation. # Licensed under the MIT License. import sys from string import Template version_file, template, output = sys.argv[1:] with open(version_file, \"r\") as fb: values = [x.strip().split(\" \", 1) for x in fb.readlines() if \" \" in x.strip()] kwargs = dict(values) with open(template, \"r\") as fb: template = Template(fb.read()) with open(output, \"w\") as f: commit_hash = ( kwargs[\"STABLE_GIT_COMMIT_HASH\"] if \"STABLE_GIT_COMMIT_HASH\" in kwargs else \"unknown\" ) is_dirty = kwargs[\"STABLE_GIT_DIRTY\"].strip() == \"1\" major = kwargs[\"STABLE_GIT_MAJOR\"] minor = kwargs[\"STABLE_GIT_MINOR\"] revision = kwargs[\"STABLE_GIT_REVISION\"] channel = kwargs[\"STABLE_GIT_CHANNEL\"] patch = kwargs[\"STABLE_GIT_PATCH\"] full = kwargs[\"STABLE_FULL_VERSION\"] f.write( template.substitute( MICROSOFT_VERSION_COMMIT=commit_hash, MICROSOFT_VERSION_WIP=\"true\" if is_dirty else \"false\", MICROSOFT_VERSION_MAJOR=major, MICROSOFT_VERSION_MINOR=minor, MICROSOFT_VERSION_REVISION=revision, MICROSOFT_VERSION_CHANNEL=channel, MICROSOFT_VERSION_PATCH=patch, MICROSOFT_VERSION_FULL=full, ) ) Updated on 28 October 2022 at 19:30:15 UTC","title":"Version/version_builder.py"},{"location":"Api/Files/version__builder_8py/#versionversion_builderpy","text":"","title":"Version/version_builder.py"},{"location":"Api/Files/version__builder_8py/#namespaces","text":"Name version_builder","title":"Namespaces"},{"location":"Api/Files/version__builder_8py/#source-code","text":"# Copyright (c) Microsoft Corporation. # Licensed under the MIT License. import sys from string import Template version_file, template, output = sys.argv[1:] with open(version_file, \"r\") as fb: values = [x.strip().split(\" \", 1) for x in fb.readlines() if \" \" in x.strip()] kwargs = dict(values) with open(template, \"r\") as fb: template = Template(fb.read()) with open(output, \"w\") as f: commit_hash = ( kwargs[\"STABLE_GIT_COMMIT_HASH\"] if \"STABLE_GIT_COMMIT_HASH\" in kwargs else \"unknown\" ) is_dirty = kwargs[\"STABLE_GIT_DIRTY\"].strip() == \"1\" major = kwargs[\"STABLE_GIT_MAJOR\"] minor = kwargs[\"STABLE_GIT_MINOR\"] revision = kwargs[\"STABLE_GIT_REVISION\"] channel = kwargs[\"STABLE_GIT_CHANNEL\"] patch = kwargs[\"STABLE_GIT_PATCH\"] full = kwargs[\"STABLE_FULL_VERSION\"] f.write( template.substitute( MICROSOFT_VERSION_COMMIT=commit_hash, MICROSOFT_VERSION_WIP=\"true\" if is_dirty else \"false\", MICROSOFT_VERSION_MAJOR=major, MICROSOFT_VERSION_MINOR=minor, MICROSOFT_VERSION_REVISION=revision, MICROSOFT_VERSION_CHANNEL=channel, MICROSOFT_VERSION_PATCH=patch, MICROSOFT_VERSION_FULL=full, ) ) Updated on 28 October 2022 at 19:30:15 UTC","title":"Source code"},{"location":"Api/Modules/","text":"Modules group Shorthand Notation Updated on 28 October 2022 at 19:30:16 UTC","title":"Modules"},{"location":"Api/Modules/#modules","text":"group Shorthand Notation Updated on 28 October 2022 at 19:30:16 UTC","title":"Modules"},{"location":"Api/Modules/group__shorthand_notation/","text":"Shorthand Notation More... Functions Name Capture (std::string const & name) Explicit creation using string name constructor. IOperandPrototypePtr operator= (IOperandPrototypePtr const & other) template <typename... Args> IOperandPrototypePtr call (std::string const & name, Args... args) IOperandPrototypePtr unnamedInvoke () Matches a invoke instruction. template <typename... Args> IOperandPrototypePtr phi (Args... args) Matches a phi node with N arguments. IOperandPrototypePtr callByNameOnly (std::string const & name) IOperandPrototypePtr bitCast (IOperandPrototypePtr const & arg) Matches the llvm::BitCast instructruction. IOperandPrototypePtr intToPtr (IOperandPrototypePtr const & arg) Matches the llvm::IntToPtr instructruction. IOperandPrototypePtr constInt () Matches the llvm::ConstantInt instructruction. IOperandPrototypePtr branch (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a branch instruction given a condition and two arguments. IOperandPrototypePtr switchOp (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) IOperandPrototypePtr select (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a select instruction given a condition and two arguments. IOperandPrototypePtr load (IOperandPrototypePtr const & arg) Matches a load instruction with one argument. IOperandPrototypePtr zExt (IOperandPrototypePtr const & value) Matches a ZExt instruction with one argument. IOperandPrototypePtr store (IOperandPrototypePtr const & target, IOperandPrototypePtr const & value) IOperandPrototypePtr basicBlock () Matches a load instruction with one argument. ReplacerFunction deleteInstruction () ReplacerFunction deleteUnusedInstruction () Deletes an instruction if it is unused. Capture operator\"\"_cap (char const * name, std::size_t ) Attributes Name const std::shared_ptr< AnyPattern > _ Detailed Description Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern auto get_one = call(\"__quantum__rt__result_get_one\"); addRule( {branch(\"cond\"_cap = call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), _, _), replace_branch_positive}); which matches IRs of the form %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: cond , result and one each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function). The module further has shorthand notation for often encountered patterns such as any operand. The module also implements shorthand notation for common replacers. Literals which ease the burned of capturing values and increase readibility of the code. Functions Documentation function Capture explicit Capture( std::string const & name ) Explicit creation using string name constructor. function operator= IOperandPrototypePtr operator=( IOperandPrototypePtr const & other ) function call template <typename... Args> IOperandPrototypePtr call( std::string const & name, Args... args ) Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern auto get_one = call(\"__quantum__rt__result_get_one\"); addRule( {branch(\"cond\"_cap = call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), _, _), replace_branch_positive}); which matches IRs of the form %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: cond , result and one each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function). Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments. Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments. function unnamedInvoke IOperandPrototypePtr unnamedInvoke() Matches a invoke instruction. function phi template <typename... Args> IOperandPrototypePtr phi( Args... args ) Matches a phi node with N arguments. function callByNameOnly IOperandPrototypePtr callByNameOnly( std::string const & name ) Shorthand notation to match an instruction with a specified name. Unlike call, this pattern matches by name only and ignore the arguments. addRule({callByNameOnly(\"foo\"), deleteInstruction()}); matches calls to the function foo regardless of the number of arguments. function bitCast IOperandPrototypePtr bitCast( IOperandPrototypePtr const & arg ) Matches the llvm::BitCast instructruction. function intToPtr IOperandPrototypePtr intToPtr( IOperandPrototypePtr const & arg ) Matches the llvm::IntToPtr instructruction. function constInt IOperandPrototypePtr constInt() Matches the llvm::ConstantInt instructruction. function branch IOperandPrototypePtr branch( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a branch instruction given a condition and two arguments. function switchOp IOperandPrototypePtr switchOp( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) function select IOperandPrototypePtr select( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a select instruction given a condition and two arguments. function load IOperandPrototypePtr load( IOperandPrototypePtr const & arg ) Matches a load instruction with one argument. function zExt IOperandPrototypePtr zExt( IOperandPrototypePtr const & value ) Matches a ZExt instruction with one argument. function store IOperandPrototypePtr store( IOperandPrototypePtr const & target, IOperandPrototypePtr const & value ) Matches a store instruction with a target and a value. addRule({store(\"target\"_cap = _, \"value\"_cap = _), replaceConstExpr}); where we want to match all store instructions and do not really care about how the target or value came about. In this case, we may want to capture the values to, for instance, make assignment at compile time. function basicBlock IOperandPrototypePtr basicBlock() Matches a load instruction with one argument. function deleteInstruction ReplacerFunction deleteInstruction() Shorthand notation to delete an instruction. If passed as the replacement function, this function generates a replacer that deletes the instruction. This is a shorthand notation for deleting an instruction that can be used with a custom rule when building a ruleset. This function can be used with shorthand notation for patterns as follows: addRule({callByNameOnly(name), deleteInstruction()}); to delete the instructions that calls functions with the name name . function deleteUnusedInstruction ReplacerFunction deleteUnusedInstruction() Deletes an instruction if it is unused. function operator\"\"_cap Capture operator\"\"_cap( char const * name, std::size_t ) Literal for specifying the capture of a llvm::Value*. This literal calls the IOperandPrototype::enableCapture through the assignment of a IOperandPrototypePtr to the class Capture . As an example, one may want to match the pattern foo(bar(baz(x)), y) and extract the variable x to add meta data to it. The corresponding IR could look like: %1 = call %Type* @baz(%Type* %0) %2 = call %Type* @bar(%Type* %1) call void @foo(%Type* %2, %Type* %3) To match this pattern, one would create the pattern call(\"foo\", call(\"bar\", call(\"baz\", \"x\"_cap = _)), _) . This pattern would ensure that at the time where the replacer function is called, the value stored in %0 is captured under the name x . Attributes Documentation variable _ static const std::shared_ptr< AnyPattern > _ = std::make_shared<AnyPattern>(); Shorthand notation for a wildcard which matches anything. This value is useful when for instance capturing the arguments of a function call where the origin of the value does not matter to the pattern. Updated on 28 October 2022 at 19:30:15 UTC","title":"Shorthand Notation"},{"location":"Api/Modules/group__shorthand_notation/#shorthand-notation","text":"More...","title":"Shorthand Notation"},{"location":"Api/Modules/group__shorthand_notation/#functions","text":"Name Capture (std::string const & name) Explicit creation using string name constructor. IOperandPrototypePtr operator= (IOperandPrototypePtr const & other) template <typename... Args> IOperandPrototypePtr call (std::string const & name, Args... args) IOperandPrototypePtr unnamedInvoke () Matches a invoke instruction. template <typename... Args> IOperandPrototypePtr phi (Args... args) Matches a phi node with N arguments. IOperandPrototypePtr callByNameOnly (std::string const & name) IOperandPrototypePtr bitCast (IOperandPrototypePtr const & arg) Matches the llvm::BitCast instructruction. IOperandPrototypePtr intToPtr (IOperandPrototypePtr const & arg) Matches the llvm::IntToPtr instructruction. IOperandPrototypePtr constInt () Matches the llvm::ConstantInt instructruction. IOperandPrototypePtr branch (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a branch instruction given a condition and two arguments. IOperandPrototypePtr switchOp (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) IOperandPrototypePtr select (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a select instruction given a condition and two arguments. IOperandPrototypePtr load (IOperandPrototypePtr const & arg) Matches a load instruction with one argument. IOperandPrototypePtr zExt (IOperandPrototypePtr const & value) Matches a ZExt instruction with one argument. IOperandPrototypePtr store (IOperandPrototypePtr const & target, IOperandPrototypePtr const & value) IOperandPrototypePtr basicBlock () Matches a load instruction with one argument. ReplacerFunction deleteInstruction () ReplacerFunction deleteUnusedInstruction () Deletes an instruction if it is unused. Capture operator\"\"_cap (char const * name, std::size_t )","title":"Functions"},{"location":"Api/Modules/group__shorthand_notation/#attributes","text":"Name const std::shared_ptr< AnyPattern > _","title":"Attributes"},{"location":"Api/Modules/group__shorthand_notation/#detailed-description","text":"Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern auto get_one = call(\"__quantum__rt__result_get_one\"); addRule( {branch(\"cond\"_cap = call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), _, _), replace_branch_positive}); which matches IRs of the form %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: cond , result and one each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function). The module further has shorthand notation for often encountered patterns such as any operand. The module also implements shorthand notation for common replacers. Literals which ease the burned of capturing values and increase readibility of the code.","title":"Detailed Description"},{"location":"Api/Modules/group__shorthand_notation/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Modules/group__shorthand_notation/#function-capture","text":"explicit Capture( std::string const & name ) Explicit creation using string name constructor.","title":"function Capture"},{"location":"Api/Modules/group__shorthand_notation/#function-operator","text":"IOperandPrototypePtr operator=( IOperandPrototypePtr const & other )","title":"function operator="},{"location":"Api/Modules/group__shorthand_notation/#function-call","text":"template <typename... Args> IOperandPrototypePtr call( std::string const & name, Args... args ) Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern auto get_one = call(\"__quantum__rt__result_get_one\"); addRule( {branch(\"cond\"_cap = call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), _, _), replace_branch_positive}); which matches IRs of the form %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: cond , result and one each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function). Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments. Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments.","title":"function call"},{"location":"Api/Modules/group__shorthand_notation/#function-unnamedinvoke","text":"IOperandPrototypePtr unnamedInvoke() Matches a invoke instruction.","title":"function unnamedInvoke"},{"location":"Api/Modules/group__shorthand_notation/#function-phi","text":"template <typename... Args> IOperandPrototypePtr phi( Args... args ) Matches a phi node with N arguments.","title":"function phi"},{"location":"Api/Modules/group__shorthand_notation/#function-callbynameonly","text":"IOperandPrototypePtr callByNameOnly( std::string const & name ) Shorthand notation to match an instruction with a specified name. Unlike call, this pattern matches by name only and ignore the arguments. addRule({callByNameOnly(\"foo\"), deleteInstruction()}); matches calls to the function foo regardless of the number of arguments.","title":"function callByNameOnly"},{"location":"Api/Modules/group__shorthand_notation/#function-bitcast","text":"IOperandPrototypePtr bitCast( IOperandPrototypePtr const & arg ) Matches the llvm::BitCast instructruction.","title":"function bitCast"},{"location":"Api/Modules/group__shorthand_notation/#function-inttoptr","text":"IOperandPrototypePtr intToPtr( IOperandPrototypePtr const & arg ) Matches the llvm::IntToPtr instructruction.","title":"function intToPtr"},{"location":"Api/Modules/group__shorthand_notation/#function-constint","text":"IOperandPrototypePtr constInt() Matches the llvm::ConstantInt instructruction.","title":"function constInt"},{"location":"Api/Modules/group__shorthand_notation/#function-branch","text":"IOperandPrototypePtr branch( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a branch instruction given a condition and two arguments.","title":"function branch"},{"location":"Api/Modules/group__shorthand_notation/#function-switchop","text":"IOperandPrototypePtr switchOp( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 )","title":"function switchOp"},{"location":"Api/Modules/group__shorthand_notation/#function-select","text":"IOperandPrototypePtr select( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a select instruction given a condition and two arguments.","title":"function select"},{"location":"Api/Modules/group__shorthand_notation/#function-load","text":"IOperandPrototypePtr load( IOperandPrototypePtr const & arg ) Matches a load instruction with one argument.","title":"function load"},{"location":"Api/Modules/group__shorthand_notation/#function-zext","text":"IOperandPrototypePtr zExt( IOperandPrototypePtr const & value ) Matches a ZExt instruction with one argument.","title":"function zExt"},{"location":"Api/Modules/group__shorthand_notation/#function-store","text":"IOperandPrototypePtr store( IOperandPrototypePtr const & target, IOperandPrototypePtr const & value ) Matches a store instruction with a target and a value. addRule({store(\"target\"_cap = _, \"value\"_cap = _), replaceConstExpr}); where we want to match all store instructions and do not really care about how the target or value came about. In this case, we may want to capture the values to, for instance, make assignment at compile time.","title":"function store"},{"location":"Api/Modules/group__shorthand_notation/#function-basicblock","text":"IOperandPrototypePtr basicBlock() Matches a load instruction with one argument.","title":"function basicBlock"},{"location":"Api/Modules/group__shorthand_notation/#function-deleteinstruction","text":"ReplacerFunction deleteInstruction() Shorthand notation to delete an instruction. If passed as the replacement function, this function generates a replacer that deletes the instruction. This is a shorthand notation for deleting an instruction that can be used with a custom rule when building a ruleset. This function can be used with shorthand notation for patterns as follows: addRule({callByNameOnly(name), deleteInstruction()}); to delete the instructions that calls functions with the name name .","title":"function deleteInstruction"},{"location":"Api/Modules/group__shorthand_notation/#function-deleteunusedinstruction","text":"ReplacerFunction deleteUnusedInstruction() Deletes an instruction if it is unused.","title":"function deleteUnusedInstruction"},{"location":"Api/Modules/group__shorthand_notation/#function-operator_cap","text":"Capture operator\"\"_cap( char const * name, std::size_t ) Literal for specifying the capture of a llvm::Value*. This literal calls the IOperandPrototype::enableCapture through the assignment of a IOperandPrototypePtr to the class Capture . As an example, one may want to match the pattern foo(bar(baz(x)), y) and extract the variable x to add meta data to it. The corresponding IR could look like: %1 = call %Type* @baz(%Type* %0) %2 = call %Type* @bar(%Type* %1) call void @foo(%Type* %2, %Type* %3) To match this pattern, one would create the pattern call(\"foo\", call(\"bar\", call(\"baz\", \"x\"_cap = _)), _) . This pattern would ensure that at the time where the replacer function is called, the value stored in %0 is captured under the name x .","title":"function operator\"\"_cap"},{"location":"Api/Modules/group__shorthand_notation/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Api/Modules/group__shorthand_notation/#variable-_","text":"static const std::shared_ptr< AnyPattern > _ = std::make_shared<AnyPattern>(); Shorthand notation for a wildcard which matches anything. This value is useful when for instance capturing the arguments of a function call where the origin of the value does not matter to the pattern. Updated on 28 October 2022 at 19:30:15 UTC","title":"variable _"},{"location":"Api/Namespaces/","text":"Namespaces namespace microsoft namespace quantum namespace details namespace notation namespace version namespace microsoft::quantum::@65 namespace std namespace version_builder Updated on 28 October 2022 at 19:30:16 UTC","title":"Namespaces"},{"location":"Api/Namespaces/#namespaces","text":"namespace microsoft namespace quantum namespace details namespace notation namespace version namespace microsoft::quantum::@65 namespace std namespace version_builder Updated on 28 October 2022 at 19:30:16 UTC","title":"Namespaces"},{"location":"Api/Namespaces/namespacemicrosoft/","text":"microsoft Namespaces Name microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft"},{"location":"Api/Namespaces/namespacemicrosoft/#microsoft","text":"","title":"microsoft"},{"location":"Api/Namespaces/namespacemicrosoft/#namespaces","text":"Name microsoft::quantum Updated on 28 October 2022 at 19:30:15 UTC","title":"Namespaces"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/","text":"microsoft::quantum Namespaces Name microsoft::quantum::details microsoft::quantum::notation microsoft::quantum::version Classes Name struct microsoft::quantum::AllocationAnalysis class microsoft::quantum::AllocationAnalysisPass class microsoft::quantum::AllocationAnalysisPassPrinter class microsoft::quantum::AnyPattern Pattern that matches any operand. class microsoft::quantum::BasicAllocationManager class microsoft::quantum::BasicBlockPattern class microsoft::quantum::BitCastPattern class microsoft::quantum::BranchPattern class microsoft::quantum::CallPattern class microsoft::quantum::CommentLogger Concrete ILogger implementation that prints all messages as IR comments to llvm::errs(). class microsoft::quantum::ConfigBind class microsoft::quantum::ConfigurableQirAdaptorFactory class microsoft::quantum::ConfigurationManager class microsoft::quantum::ConstIntPattern class microsoft::quantum::DebugInfoUpdater class microsoft::quantum::DeferMeasurementPass class microsoft::quantum::DeferredValue class microsoft::quantum::DivisionByZeroPass class microsoft::quantum::FunctionAnnotatorPass struct microsoft::quantum::FunctionRegister class microsoft::quantum::FunctionReplacementAnalysisPass class microsoft::quantum::FunctionReplacementAnalysisPassPrinter class microsoft::quantum::FunctionReplacementConfiguration class microsoft::quantum::FunctionReplacementPass class microsoft::quantum::FunctionToModule class microsoft::quantum::FunctionValidationPass struct microsoft::quantum::GroupAnalysis class microsoft::quantum::GroupingAnalysisPass class microsoft::quantum::GroupingAnalysisPassPrinter class microsoft::quantum::GroupingPass class microsoft::quantum::GroupingPassConfiguration struct microsoft::quantum::HasQatSerializers class microsoft::quantum::IAllocationManager class microsoft::quantum::IConfigBind class microsoft::quantum::ILogger class microsoft::quantum::InstructionLocationTable class microsoft::quantum::IntToPtrPattern class microsoft::quantum::IOperandPrototype class microsoft::quantum::IrManipulationTestHelper class microsoft::quantum::LlvmPassesConfiguration class microsoft::quantum::LoadPattern class microsoft::quantum::LogCollection class microsoft::quantum::ModuleLoader class microsoft::quantum::OpcodeSet class microsoft::quantum::OpcodeValue class microsoft::quantum::ParameterParser class microsoft::quantum::PhiPattern class microsoft::quantum::PostTransformValidationPass class microsoft::quantum::PostTransformValidationPassConfiguration class microsoft::quantum::QirAdaptor class microsoft::quantum::QirAdaptorFactory class microsoft::quantum::QubitRemapPass class microsoft::quantum::RemoveDisallowedAttributesPass class microsoft::quantum::RemoveNonEntrypointFunctionsPass class microsoft::quantum::RemoveNonEntrypointFunctionsPassConfiguration class microsoft::quantum::ReplacementRule class microsoft::quantum::ReplaceQubitOnResetPass class microsoft::quantum::ResourceAnnotationPass class microsoft::quantum::RuleFactory class microsoft::quantum::RuleSet class microsoft::quantum::SelectPattern class microsoft::quantum::SourceLocation class microsoft::quantum::SpecConfiguration class microsoft::quantum::StaticResourceComponentConfiguration class microsoft::quantum::StorePattern class microsoft::quantum::SwitchPattern class microsoft::quantum::TargetProfileConfiguration struct microsoft::quantum::TargetProfileMappingConfiguration class microsoft::quantum::TargetQisConfiguration class microsoft::quantum::TargetQisMappingPass class microsoft::quantum::TargetQisMappingPassConfiguration Configuration class for the RuleTransformation pass. class microsoft::quantum::TestProgram class microsoft::quantum::TestVM class microsoft::quantum::UnnamedInvokePattern class microsoft::quantum::ValidationPass class microsoft::quantum::Validator class microsoft::quantum::ZExtPattern class microsoft::quantum::ZExtTransformPass Types Name using InstructionLocationTable::InstructionLocationTablePtr InstructionLocationTablePtr using RuleFactory::ReplacementRulePtr ReplacementRulePtr using std::string String using std::unordered_map< String, String > StringMap Functions Name void ltrim (std::string & str) void rtrim (std::string & str) void trim (std::string & s) void displayCliHeader (bool extended_info) Types Documentation using InstructionLocationTablePtr using microsoft::quantum::InstructionLocationTablePtr = typedef InstructionLocationTable::InstructionLocationTablePtr; using ReplacementRulePtr using microsoft::quantum::ReplacementRulePtr = typedef RuleFactory::ReplacementRulePtr; using String using microsoft::quantum::String = typedef std::string; using StringMap using microsoft::quantum::StringMap = typedef std::unordered_map<String, String>; Functions Documentation function ltrim inline void ltrim( std::string & str ) function rtrim inline void rtrim( std::string & str ) function trim inline void trim( std::string & s ) function displayCliHeader void displayCliHeader( bool extended_info ) Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#microsoftquantum","text":"","title":"microsoft::quantum"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#namespaces","text":"Name microsoft::quantum::details microsoft::quantum::notation microsoft::quantum::version","title":"Namespaces"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#classes","text":"Name struct microsoft::quantum::AllocationAnalysis class microsoft::quantum::AllocationAnalysisPass class microsoft::quantum::AllocationAnalysisPassPrinter class microsoft::quantum::AnyPattern Pattern that matches any operand. class microsoft::quantum::BasicAllocationManager class microsoft::quantum::BasicBlockPattern class microsoft::quantum::BitCastPattern class microsoft::quantum::BranchPattern class microsoft::quantum::CallPattern class microsoft::quantum::CommentLogger Concrete ILogger implementation that prints all messages as IR comments to llvm::errs(). class microsoft::quantum::ConfigBind class microsoft::quantum::ConfigurableQirAdaptorFactory class microsoft::quantum::ConfigurationManager class microsoft::quantum::ConstIntPattern class microsoft::quantum::DebugInfoUpdater class microsoft::quantum::DeferMeasurementPass class microsoft::quantum::DeferredValue class microsoft::quantum::DivisionByZeroPass class microsoft::quantum::FunctionAnnotatorPass struct microsoft::quantum::FunctionRegister class microsoft::quantum::FunctionReplacementAnalysisPass class microsoft::quantum::FunctionReplacementAnalysisPassPrinter class microsoft::quantum::FunctionReplacementConfiguration class microsoft::quantum::FunctionReplacementPass class microsoft::quantum::FunctionToModule class microsoft::quantum::FunctionValidationPass struct microsoft::quantum::GroupAnalysis class microsoft::quantum::GroupingAnalysisPass class microsoft::quantum::GroupingAnalysisPassPrinter class microsoft::quantum::GroupingPass class microsoft::quantum::GroupingPassConfiguration struct microsoft::quantum::HasQatSerializers class microsoft::quantum::IAllocationManager class microsoft::quantum::IConfigBind class microsoft::quantum::ILogger class microsoft::quantum::InstructionLocationTable class microsoft::quantum::IntToPtrPattern class microsoft::quantum::IOperandPrototype class microsoft::quantum::IrManipulationTestHelper class microsoft::quantum::LlvmPassesConfiguration class microsoft::quantum::LoadPattern class microsoft::quantum::LogCollection class microsoft::quantum::ModuleLoader class microsoft::quantum::OpcodeSet class microsoft::quantum::OpcodeValue class microsoft::quantum::ParameterParser class microsoft::quantum::PhiPattern class microsoft::quantum::PostTransformValidationPass class microsoft::quantum::PostTransformValidationPassConfiguration class microsoft::quantum::QirAdaptor class microsoft::quantum::QirAdaptorFactory class microsoft::quantum::QubitRemapPass class microsoft::quantum::RemoveDisallowedAttributesPass class microsoft::quantum::RemoveNonEntrypointFunctionsPass class microsoft::quantum::RemoveNonEntrypointFunctionsPassConfiguration class microsoft::quantum::ReplacementRule class microsoft::quantum::ReplaceQubitOnResetPass class microsoft::quantum::ResourceAnnotationPass class microsoft::quantum::RuleFactory class microsoft::quantum::RuleSet class microsoft::quantum::SelectPattern class microsoft::quantum::SourceLocation class microsoft::quantum::SpecConfiguration class microsoft::quantum::StaticResourceComponentConfiguration class microsoft::quantum::StorePattern class microsoft::quantum::SwitchPattern class microsoft::quantum::TargetProfileConfiguration struct microsoft::quantum::TargetProfileMappingConfiguration class microsoft::quantum::TargetQisConfiguration class microsoft::quantum::TargetQisMappingPass class microsoft::quantum::TargetQisMappingPassConfiguration Configuration class for the RuleTransformation pass. class microsoft::quantum::TestProgram class microsoft::quantum::TestVM class microsoft::quantum::UnnamedInvokePattern class microsoft::quantum::ValidationPass class microsoft::quantum::Validator class microsoft::quantum::ZExtPattern class microsoft::quantum::ZExtTransformPass","title":"Classes"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#types","text":"Name using InstructionLocationTable::InstructionLocationTablePtr InstructionLocationTablePtr using RuleFactory::ReplacementRulePtr ReplacementRulePtr using std::string String using std::unordered_map< String, String > StringMap","title":"Types"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#functions","text":"Name void ltrim (std::string & str) void rtrim (std::string & str) void trim (std::string & s) void displayCliHeader (bool extended_info)","title":"Functions"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#types-documentation","text":"","title":"Types Documentation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#using-instructionlocationtableptr","text":"using microsoft::quantum::InstructionLocationTablePtr = typedef InstructionLocationTable::InstructionLocationTablePtr;","title":"using InstructionLocationTablePtr"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#using-replacementruleptr","text":"using microsoft::quantum::ReplacementRulePtr = typedef RuleFactory::ReplacementRulePtr;","title":"using ReplacementRulePtr"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#using-string","text":"using microsoft::quantum::String = typedef std::string;","title":"using String"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#using-stringmap","text":"using microsoft::quantum::StringMap = typedef std::unordered_map<String, String>;","title":"using StringMap"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#function-ltrim","text":"inline void ltrim( std::string & str )","title":"function ltrim"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#function-rtrim","text":"inline void rtrim( std::string & str )","title":"function rtrim"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#function-trim","text":"inline void trim( std::string & s )","title":"function trim"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#function-displaycliheader","text":"void displayCliHeader( bool extended_info ) Updated on 28 October 2022 at 19:30:15 UTC","title":"function displayCliHeader"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1_0d65/","text":"microsoft::quantum::@65 Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::@65"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1_0d65/#microsoftquantum65","text":"Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::@65"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1details/","text":"microsoft::quantum::details Functions Name void initFramework () Functions Documentation function initFramework inline void initFramework() Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::details"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1details/#microsoftquantumdetails","text":"","title":"microsoft::quantum::details"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1details/#functions","text":"Name void initFramework ()","title":"Functions"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1details/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1details/#function-initframework","text":"inline void initFramework() Updated on 28 October 2022 at 19:30:15 UTC","title":"function initFramework"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/","text":"microsoft::quantum::notation More... Classes Name class microsoft::quantum::notation::Capture Types Name typedef std::shared_ptr< IOperandPrototype > IOperandPrototypePtr using std::function< bool( ReplacementRule::Builder &, ReplacementRule::Value *, ReplacementRule::Captures &, ReplacementRule::Replacements &)> ReplacerFunction Functions Name IOperandPrototypePtr basicBlock () Matches a load instruction with one argument. IOperandPrototypePtr bitCast (IOperandPrototypePtr const & arg) Matches the llvm::BitCast instructruction. IOperandPrototypePtr branch (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a branch instruction given a condition and two arguments. template <typename... Args> IOperandPrototypePtr call (std::string const & name, Args... args) IOperandPrototypePtr callByNameOnly (std::string const & name) Capture operator\"\"_cap (char const * name, std::size_t ) IOperandPrototypePtr constInt () Matches the llvm::ConstantInt instructruction. IOperandPrototypePtr intToPtr (IOperandPrototypePtr const & arg) Matches the llvm::IntToPtr instructruction. IOperandPrototypePtr load (IOperandPrototypePtr const & arg) Matches a load instruction with one argument. ReplacerFunction deleteInstruction () ReplacerFunction deleteUnusedInstruction () Deletes an instruction if it is unused. IOperandPrototypePtr unnamedInvoke () Matches a invoke instruction. template <typename... Args> IOperandPrototypePtr phi (Args... args) Matches a phi node with N arguments. IOperandPrototypePtr switchOp (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) IOperandPrototypePtr select (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a select instruction given a condition and two arguments. IOperandPrototypePtr zExt (IOperandPrototypePtr const & value) Matches a ZExt instruction with one argument. IOperandPrototypePtr store (IOperandPrototypePtr const & target, IOperandPrototypePtr const & value) Attributes Name const std::shared_ptr< AnyPattern > _ Detailed Description Shorthand notations to make it easy and readable to create patterns. Types Documentation typedef IOperandPrototypePtr typedef std::shared_ptr< IOperandPrototype > microsoft::quantum::notation::IOperandPrototypePtr; using ReplacerFunction using microsoft::quantum::notation::ReplacerFunction = typedef std::function<bool( ReplacementRule::Builder&, ReplacementRule::Value*, ReplacementRule::Captures&, ReplacementRule::Replacements&)>; Functions Documentation function basicBlock IOperandPrototypePtr basicBlock() Matches a load instruction with one argument. function bitCast IOperandPrototypePtr bitCast( IOperandPrototypePtr const & arg ) Matches the llvm::BitCast instructruction. function branch IOperandPrototypePtr branch( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a branch instruction given a condition and two arguments. function call template <typename... Args> IOperandPrototypePtr call( std::string const & name, Args... args ) Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern auto get_one = call(\"__quantum__rt__result_get_one\"); addRule( {branch(\"cond\"_cap = call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), _, _), replace_branch_positive}); which matches IRs of the form %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: cond , result and one each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function). Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments. Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments. function callByNameOnly IOperandPrototypePtr callByNameOnly( std::string const & name ) Shorthand notation to match an instruction with a specified name. Unlike call, this pattern matches by name only and ignore the arguments. addRule({callByNameOnly(\"foo\"), deleteInstruction()}); matches calls to the function foo regardless of the number of arguments. function operator\"\"_cap Capture operator\"\"_cap( char const * name, std::size_t ) Literal for specifying the capture of a llvm::Value*. This literal calls the IOperandPrototype::enableCapture through the assignment of a IOperandPrototypePtr to the class Capture . As an example, one may want to match the pattern foo(bar(baz(x)), y) and extract the variable x to add meta data to it. The corresponding IR could look like: %1 = call %Type* @baz(%Type* %0) %2 = call %Type* @bar(%Type* %1) call void @foo(%Type* %2, %Type* %3) To match this pattern, one would create the pattern call(\"foo\", call(\"bar\", call(\"baz\", \"x\"_cap = _)), _) . This pattern would ensure that at the time where the replacer function is called, the value stored in %0 is captured under the name x . function constInt IOperandPrototypePtr constInt() Matches the llvm::ConstantInt instructruction. function intToPtr IOperandPrototypePtr intToPtr( IOperandPrototypePtr const & arg ) Matches the llvm::IntToPtr instructruction. function load IOperandPrototypePtr load( IOperandPrototypePtr const & arg ) Matches a load instruction with one argument. function deleteInstruction ReplacerFunction deleteInstruction() Shorthand notation to delete an instruction. If passed as the replacement function, this function generates a replacer that deletes the instruction. This is a shorthand notation for deleting an instruction that can be used with a custom rule when building a ruleset. This function can be used with shorthand notation for patterns as follows: addRule({callByNameOnly(name), deleteInstruction()}); to delete the instructions that calls functions with the name name . function deleteUnusedInstruction ReplacerFunction deleteUnusedInstruction() Deletes an instruction if it is unused. function unnamedInvoke IOperandPrototypePtr unnamedInvoke() Matches a invoke instruction. function phi template <typename... Args> IOperandPrototypePtr phi( Args... args ) Matches a phi node with N arguments. function switchOp IOperandPrototypePtr switchOp( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) function select IOperandPrototypePtr select( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a select instruction given a condition and two arguments. function zExt IOperandPrototypePtr zExt( IOperandPrototypePtr const & value ) Matches a ZExt instruction with one argument. function store IOperandPrototypePtr store( IOperandPrototypePtr const & target, IOperandPrototypePtr const & value ) Matches a store instruction with a target and a value. addRule({store(\"target\"_cap = _, \"value\"_cap = _), replaceConstExpr}); where we want to match all store instructions and do not really care about how the target or value came about. In this case, we may want to capture the values to, for instance, make assignment at compile time. Attributes Documentation variable _ static const std::shared_ptr< AnyPattern > _ = std::make_shared<[AnyPattern](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/)>(); Shorthand notation for a wildcard which matches anything. This value is useful when for instance capturing the arguments of a function call where the origin of the value does not matter to the pattern. Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::notation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#microsoftquantumnotation","text":"More...","title":"microsoft::quantum::notation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#classes","text":"Name class microsoft::quantum::notation::Capture","title":"Classes"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#types","text":"Name typedef std::shared_ptr< IOperandPrototype > IOperandPrototypePtr using std::function< bool( ReplacementRule::Builder &, ReplacementRule::Value *, ReplacementRule::Captures &, ReplacementRule::Replacements &)> ReplacerFunction","title":"Types"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#functions","text":"Name IOperandPrototypePtr basicBlock () Matches a load instruction with one argument. IOperandPrototypePtr bitCast (IOperandPrototypePtr const & arg) Matches the llvm::BitCast instructruction. IOperandPrototypePtr branch (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a branch instruction given a condition and two arguments. template <typename... Args> IOperandPrototypePtr call (std::string const & name, Args... args) IOperandPrototypePtr callByNameOnly (std::string const & name) Capture operator\"\"_cap (char const * name, std::size_t ) IOperandPrototypePtr constInt () Matches the llvm::ConstantInt instructruction. IOperandPrototypePtr intToPtr (IOperandPrototypePtr const & arg) Matches the llvm::IntToPtr instructruction. IOperandPrototypePtr load (IOperandPrototypePtr const & arg) Matches a load instruction with one argument. ReplacerFunction deleteInstruction () ReplacerFunction deleteUnusedInstruction () Deletes an instruction if it is unused. IOperandPrototypePtr unnamedInvoke () Matches a invoke instruction. template <typename... Args> IOperandPrototypePtr phi (Args... args) Matches a phi node with N arguments. IOperandPrototypePtr switchOp (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) IOperandPrototypePtr select (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a select instruction given a condition and two arguments. IOperandPrototypePtr zExt (IOperandPrototypePtr const & value) Matches a ZExt instruction with one argument. IOperandPrototypePtr store (IOperandPrototypePtr const & target, IOperandPrototypePtr const & value)","title":"Functions"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#attributes","text":"Name const std::shared_ptr< AnyPattern > _","title":"Attributes"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#detailed-description","text":"Shorthand notations to make it easy and readable to create patterns.","title":"Detailed Description"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#types-documentation","text":"","title":"Types Documentation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#typedef-ioperandprototypeptr","text":"typedef std::shared_ptr< IOperandPrototype > microsoft::quantum::notation::IOperandPrototypePtr;","title":"typedef IOperandPrototypePtr"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#using-replacerfunction","text":"using microsoft::quantum::notation::ReplacerFunction = typedef std::function<bool( ReplacementRule::Builder&, ReplacementRule::Value*, ReplacementRule::Captures&, ReplacementRule::Replacements&)>;","title":"using ReplacerFunction"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-basicblock","text":"IOperandPrototypePtr basicBlock() Matches a load instruction with one argument.","title":"function basicBlock"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-bitcast","text":"IOperandPrototypePtr bitCast( IOperandPrototypePtr const & arg ) Matches the llvm::BitCast instructruction.","title":"function bitCast"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-branch","text":"IOperandPrototypePtr branch( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a branch instruction given a condition and two arguments.","title":"function branch"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-call","text":"template <typename... Args> IOperandPrototypePtr call( std::string const & name, Args... args ) Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern auto get_one = call(\"__quantum__rt__result_get_one\"); addRule( {branch(\"cond\"_cap = call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), _, _), replace_branch_positive}); which matches IRs of the form %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: cond , result and one each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function). Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments. Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments.","title":"function call"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-callbynameonly","text":"IOperandPrototypePtr callByNameOnly( std::string const & name ) Shorthand notation to match an instruction with a specified name. Unlike call, this pattern matches by name only and ignore the arguments. addRule({callByNameOnly(\"foo\"), deleteInstruction()}); matches calls to the function foo regardless of the number of arguments.","title":"function callByNameOnly"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-operator_cap","text":"Capture operator\"\"_cap( char const * name, std::size_t ) Literal for specifying the capture of a llvm::Value*. This literal calls the IOperandPrototype::enableCapture through the assignment of a IOperandPrototypePtr to the class Capture . As an example, one may want to match the pattern foo(bar(baz(x)), y) and extract the variable x to add meta data to it. The corresponding IR could look like: %1 = call %Type* @baz(%Type* %0) %2 = call %Type* @bar(%Type* %1) call void @foo(%Type* %2, %Type* %3) To match this pattern, one would create the pattern call(\"foo\", call(\"bar\", call(\"baz\", \"x\"_cap = _)), _) . This pattern would ensure that at the time where the replacer function is called, the value stored in %0 is captured under the name x .","title":"function operator\"\"_cap"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-constint","text":"IOperandPrototypePtr constInt() Matches the llvm::ConstantInt instructruction.","title":"function constInt"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-inttoptr","text":"IOperandPrototypePtr intToPtr( IOperandPrototypePtr const & arg ) Matches the llvm::IntToPtr instructruction.","title":"function intToPtr"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-load","text":"IOperandPrototypePtr load( IOperandPrototypePtr const & arg ) Matches a load instruction with one argument.","title":"function load"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-deleteinstruction","text":"ReplacerFunction deleteInstruction() Shorthand notation to delete an instruction. If passed as the replacement function, this function generates a replacer that deletes the instruction. This is a shorthand notation for deleting an instruction that can be used with a custom rule when building a ruleset. This function can be used with shorthand notation for patterns as follows: addRule({callByNameOnly(name), deleteInstruction()}); to delete the instructions that calls functions with the name name .","title":"function deleteInstruction"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-deleteunusedinstruction","text":"ReplacerFunction deleteUnusedInstruction() Deletes an instruction if it is unused.","title":"function deleteUnusedInstruction"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-unnamedinvoke","text":"IOperandPrototypePtr unnamedInvoke() Matches a invoke instruction.","title":"function unnamedInvoke"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-phi","text":"template <typename... Args> IOperandPrototypePtr phi( Args... args ) Matches a phi node with N arguments.","title":"function phi"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-switchop","text":"IOperandPrototypePtr switchOp( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 )","title":"function switchOp"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-select","text":"IOperandPrototypePtr select( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a select instruction given a condition and two arguments.","title":"function select"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-zext","text":"IOperandPrototypePtr zExt( IOperandPrototypePtr const & value ) Matches a ZExt instruction with one argument.","title":"function zExt"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-store","text":"IOperandPrototypePtr store( IOperandPrototypePtr const & target, IOperandPrototypePtr const & value ) Matches a store instruction with a target and a value. addRule({store(\"target\"_cap = _, \"value\"_cap = _), replaceConstExpr}); where we want to match all store instructions and do not really care about how the target or value came about. In this case, we may want to capture the values to, for instance, make assignment at compile time.","title":"function store"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#variable-_","text":"static const std::shared_ptr< AnyPattern > _ = std::make_shared<[AnyPattern](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/)>(); Shorthand notation for a wildcard which matches anything. This value is useful when for instance capturing the arguments of a function call where the origin of the value does not matter to the pattern. Updated on 28 October 2022 at 19:30:15 UTC","title":"variable _"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1version/","text":"microsoft::quantum::version Attributes Name constexpr char const *const FULL constexpr const uint32_t MAJOR constexpr const uint32_t MINOR constexpr const uint32_t REVISION constexpr char const *const CHANNEL constexpr const uint32_t PATCH constexpr char const *const COMMIT_HASH constexpr const bool WORK_IN_PROGRESS Attributes Documentation variable FULL constexpr char const *const FULL = \"${MICROSOFT_VERSION_FULL}\"; variable MAJOR constexpr const uint32_t MAJOR = ${MICROSOFT_VERSION_MAJOR}; variable MINOR constexpr const uint32_t MINOR = ${MICROSOFT_VERSION_MINOR}; variable REVISION constexpr const uint32_t REVISION = ${MICROSOFT_VERSION_REVISION}; variable CHANNEL constexpr char const *const CHANNEL = \"${MICROSOFT_VERSION_CHANNEL}\"; variable PATCH constexpr const uint32_t PATCH = ${MICROSOFT_VERSION_PATCH}; variable COMMIT_HASH constexpr char const *const COMMIT_HASH = \"${MICROSOFT_VERSION_COMMIT}\"; variable WORK_IN_PROGRESS constexpr const bool WORK_IN_PROGRESS = ${MICROSOFT_VERSION_WIP}; Updated on 28 October 2022 at 19:30:15 UTC","title":"microsoft::quantum::version"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1version/#microsoftquantumversion","text":"","title":"microsoft::quantum::version"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1version/#attributes","text":"Name constexpr char const *const FULL constexpr const uint32_t MAJOR constexpr const uint32_t MINOR constexpr const uint32_t REVISION constexpr char const *const CHANNEL constexpr const uint32_t PATCH constexpr char const *const COMMIT_HASH constexpr const bool WORK_IN_PROGRESS","title":"Attributes"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1version/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1version/#variable-full","text":"constexpr char const *const FULL = \"${MICROSOFT_VERSION_FULL}\";","title":"variable FULL"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1version/#variable-major","text":"constexpr const uint32_t MAJOR = ${MICROSOFT_VERSION_MAJOR};","title":"variable MAJOR"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1version/#variable-minor","text":"constexpr const uint32_t MINOR = ${MICROSOFT_VERSION_MINOR};","title":"variable MINOR"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1version/#variable-revision","text":"constexpr const uint32_t REVISION = ${MICROSOFT_VERSION_REVISION};","title":"variable REVISION"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1version/#variable-channel","text":"constexpr char const *const CHANNEL = \"${MICROSOFT_VERSION_CHANNEL}\";","title":"variable CHANNEL"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1version/#variable-patch","text":"constexpr const uint32_t PATCH = ${MICROSOFT_VERSION_PATCH};","title":"variable PATCH"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1version/#variable-commit_hash","text":"constexpr char const *const COMMIT_HASH = \"${MICROSOFT_VERSION_COMMIT}\";","title":"variable COMMIT_HASH"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1version/#variable-work_in_progress","text":"constexpr const bool WORK_IN_PROGRESS = ${MICROSOFT_VERSION_WIP}; Updated on 28 October 2022 at 19:30:15 UTC","title":"variable WORK_IN_PROGRESS"},{"location":"Api/Namespaces/namespacestd/","text":"std Classes Name struct std::hash< microsoft::quantum::OpcodeValue > Updated on 28 October 2022 at 19:30:15 UTC","title":"std"},{"location":"Api/Namespaces/namespacestd/#std","text":"","title":"std"},{"location":"Api/Namespaces/namespacestd/#classes","text":"Name struct std::hash< microsoft::quantum::OpcodeValue > Updated on 28 October 2022 at 19:30:15 UTC","title":"Classes"},{"location":"Api/Namespaces/namespaceversion__builder/","text":"version_builder Attributes Name version_file template output list values kwargs tuple commit_hash string is_dirty major minor revision channel patch full Attributes Documentation variable version_file version_file; variable template template = Template(fb.read()); variable output output; variable values list values = [x.strip().split(\" \", 1) for x in fb.readlines() if \" \" in x.strip()]; variable kwargs kwargs = dict(values); variable commit_hash tuple commit_hash = ( kwargs[\"STABLE_GIT_COMMIT_HASH\"] if \"STABLE_GIT_COMMIT_HASH\" in kwargs else \"unknown\" ); variable is_dirty string is_dirty = \"1\"; variable major major = kwargs[\"STABLE_GIT_MAJOR\"]; variable minor minor = kwargs[\"STABLE_GIT_MINOR\"]; variable revision revision = kwargs[\"STABLE_GIT_REVISION\"]; variable channel channel = kwargs[\"STABLE_GIT_CHANNEL\"]; variable patch patch = kwargs[\"STABLE_GIT_PATCH\"]; variable full full = kwargs[\"STABLE_FULL_VERSION\"]; Updated on 28 October 2022 at 19:30:15 UTC","title":"version_builder"},{"location":"Api/Namespaces/namespaceversion__builder/#version_builder","text":"","title":"version_builder"},{"location":"Api/Namespaces/namespaceversion__builder/#attributes","text":"Name version_file template output list values kwargs tuple commit_hash string is_dirty major minor revision channel patch full","title":"Attributes"},{"location":"Api/Namespaces/namespaceversion__builder/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Api/Namespaces/namespaceversion__builder/#variable-version_file","text":"version_file;","title":"variable version_file"},{"location":"Api/Namespaces/namespaceversion__builder/#variable-template","text":"template = Template(fb.read());","title":"variable template"},{"location":"Api/Namespaces/namespaceversion__builder/#variable-output","text":"output;","title":"variable output"},{"location":"Api/Namespaces/namespaceversion__builder/#variable-values","text":"list values = [x.strip().split(\" \", 1) for x in fb.readlines() if \" \" in x.strip()];","title":"variable values"},{"location":"Api/Namespaces/namespaceversion__builder/#variable-kwargs","text":"kwargs = dict(values);","title":"variable kwargs"},{"location":"Api/Namespaces/namespaceversion__builder/#variable-commit_hash","text":"tuple commit_hash = ( kwargs[\"STABLE_GIT_COMMIT_HASH\"] if \"STABLE_GIT_COMMIT_HASH\" in kwargs else \"unknown\" );","title":"variable commit_hash"},{"location":"Api/Namespaces/namespaceversion__builder/#variable-is_dirty","text":"string is_dirty = \"1\";","title":"variable is_dirty"},{"location":"Api/Namespaces/namespaceversion__builder/#variable-major","text":"major = kwargs[\"STABLE_GIT_MAJOR\"];","title":"variable major"},{"location":"Api/Namespaces/namespaceversion__builder/#variable-minor","text":"minor = kwargs[\"STABLE_GIT_MINOR\"];","title":"variable minor"},{"location":"Api/Namespaces/namespaceversion__builder/#variable-revision","text":"revision = kwargs[\"STABLE_GIT_REVISION\"];","title":"variable revision"},{"location":"Api/Namespaces/namespaceversion__builder/#variable-channel","text":"channel = kwargs[\"STABLE_GIT_CHANNEL\"];","title":"variable channel"},{"location":"Api/Namespaces/namespaceversion__builder/#variable-patch","text":"patch = kwargs[\"STABLE_GIT_PATCH\"];","title":"variable patch"},{"location":"Api/Namespaces/namespaceversion__builder/#variable-full","text":"full = kwargs[\"STABLE_FULL_VERSION\"]; Updated on 28 October 2022 at 19:30:15 UTC","title":"variable full"},{"location":"Api/Pages/","text":"Pages Updated on 28 October 2022 at 19:30:16 UTC","title":"Pages"},{"location":"Api/Pages/#pages","text":"Updated on 28 October 2022 at 19:30:16 UTC","title":"Pages"},{"location":"DeveloperGuide/ArchitectureOverview/","text":"Architecture Overview This document assumes familiarity with LLVM, LLVM intermediate representation (IR) , LLVM passes and the opt tool which is used to apply passes to IRs. We also assume that the reader is familiar with the QIR specification , the conventions used for functions and its opaque types. We further assume that the reader is familiar with basic C++. This is in particular true later on when we dig into the details of building pass components. Throughout this document we will assume that any reference to a QIR, is a valid within the specification requirements. The aim of this document is to walk the reader through the vision and architecture of the QIR adaptor tool (QAT). To this end, we will be discussing how QAT uses both built-in and custom written LLVM passes to transform generic QIRs into ones which are targeted specific platforms and/or capabilities. We refer to any generic QIR as just \"the QIR\" or the generic QIR where as those target for specific platforms and/or capabilities, we call specialised QIRs. The description of the requirements for the specialised QIR we call a QIR profile. When we talk about applying a profile to a generic QIR, we talk about the process which transform the generic QIR into the specialised one. Likewise, when we talk about validating that a specialised QIR fulfils the description of a profile. In building QAT, we note that there are two main challenges to overcome: Applying a profile to a generic QIR, and, Validating that a QIR is compliant with a profile specification. We may on occasion refer to the former as a transformation and the latter as an analysis to clarify the similarity to LLVM passes. The architecture described in this document attempts to address both of these challenges in way that we believe to be customisable and scalable in terms of profile requirements. Before digging into the details of the design of QAT, we first note that LLVM\u00f8s opt has many of the properties that we desire: Modularised, extendable in a non-invasive manner and differentiates between analysis and transformation. The downsides to opt is that we cannot pass a configuration to the individual passes, it is difficult to control which concrete passes are ran and, under the assumption that a profile is described by a collection of passes, there is no elegant way to bundle these into a single argument. In our design, it will be our goal to preserve the good aspects of opt while adding the capabilities we miss to make profile transformations and validation. Before spelling the system requirements out, we consider a couple of examples of what we may need for functionality. Example: Function inlining Let us first consider the case of quantum architecture that does not support classical function calls. That is, a valid program must be all inlined. This is a task that can be handled by opt by supplying the command line argument --always-inline . This flag turns the inline pipeline on and attempts to inline as many function calls as possible. For QAT to be a useful tool, we would want a similar mechanism that allows to activate or deactivate existing (and new) LLVM passes. We would thus need something like qat --always-inline --profile base --apply -S filename.ll where --apply tells the tool to apply the profile and -S tells the tool to emit human readable LLVM IR code. Furthermore, if the inline pass is provided as an external module, we would need to be able load it qat --always-inline --profile base --load path/to/lib.(dylib|so|dll) --apply -S filename.ll We note that from a developer point of view, the underlying code would also need a way to let QAT know that it expects a command line argument --always-inline/--no-always-inline . Example: Static qubit allocation To get a better understanding of the problem at hand, let us examine another example: Qubit allocation. As we run our quantum program, we may use a simulator or we may deploy it on one of the hardware providers. Depending on whether we are running in one environment or the other, qubits are different entities: In a computer simulation they are often objects. They could for instance be allocated on the heap in a non-sequential manner. In this context, it makes sense to talk about a qubits life time through instructions that allocates and releases them. On hardware, on the other hand, qubits are physical entities typically sequentially enumerated from 0 to N - 1. Physical qubits may (or may not) have the constraint some qubits are unavailable to the user. Though not always, hardware may further have the constraint that user can only perform a single measurement at the end of the program execution. This means that qubits cannot be reused within one program execution. This puts requirements on what we may need from static qubit allocation. For any static allocation, we would need at least following information: Whether or not to map qubits to fixed integers Reuse qubits or not List unavailable qubits It is not hard to imagine that this could be extended even further by imposing customised allocation schemes. In contrast to the previous example, this example requires a much more detailed configuration to define the mode of operation. One could for instance imagine something along the lines of qat --use-static-allocation --reuse-qubits --defect-qubits 3,7,9 --max-qubits 10 --apply -S filename.ll Hence, unlike normal LLVM passes, we will need a detailed configuration to be passed along with the transformation. Design requirements To distinguish between LLVM passes and QAT extensions, we will refer to QAT extensions as profile components. A profile component may consist of several passes and furthermore should be accompanied by a configuration to describe its behaviour. Like LLVM opt we require that QAT must be extensible through dynamic libraries. This allow third party to easily extend the tool to their needs while benefiting from the components that QAT ships with. Architecture description On a high level, the process of the IRs can be divided into three main tasks: 1) Loading the QIR, 2) creating a generator and validator and 3) transform and validate the QIR. We summarize this process in the diagram below, listing the components and settings used in the process and how they feed into one and another: \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2510 User input \u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u252c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2518 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Configuration and parameter parser \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 IR file list \u2502 \u2502 Profile config \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Module loader \u2502 \u2502 Profile Generator \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Single module \u2502 \u2502 Profile \u2502 \u2502 transformations \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 Adding debug symbols \u251c\u2500\u2500\u2500\u25b6 Generation \u251c\u2500\u253c\u25b6Validation \u251c\u2500\u2500\u2500\u2500\u2500\u2510 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 Logger \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u25bc \u25bc \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2510\u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2510 Standard error Standard Output: \u2502 or file: \u2502\u2502 Resulting IR \u2502 JSON Logs \u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2518\u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2518 The profile consists of a generator and a validator. The generator is responsible for performing as many transformations as possible to get the original QIR to be compliant with the selected profile. This is done by each of the components taking a configuration which then installs LLVM passes to execute said transactions. This is illustrated on the left hand-side in the following figure whereas the pass execution is illustrated on the right hand-side: \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2510 LLVM module \u250c\u2500\u2500\u2500\u2510 \u2514 \u2500 \u2500 \u2500\u2502\u2500 \u2500 \u2500 \u2500 \u2518 \u2502 \u2502 \u2502 Apply profile \u2502 C \u2502 \u2502 process \u2502 o \u2502 \u250c Generator \u2500 \u2500 \u2500\u2502\u2500 \u2500 \u2500 \u2500 \u2500 \u2502 n \u2502If \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 f \u2502component Install\u2502 \u2502 Inline pass \u2502 \u2502 i \u2502active: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510passes \u250c\u2500\u2500\u2500\u2510 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 g \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 LLVM passes \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u25b6 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 u \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 Unroll pass \u2502 \u2502 \u2502 r \u2502 \u2502 \u2502 P \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 a \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 t \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 Transformation \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u25b6 s \u2502 \u2502Transform pass \u2502 \u2502 i \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 s \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 o \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 n \u2502 \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2510 \u2502 m \u2502 \u2502 Inline pass \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 LLVM passes \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u25b6 a \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 m \u2502 \u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2518 \u2502 n \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 a \u2502 \u2502 \u2502 a \u2502 \u2502 Fold pass \u2502 \u2502 n \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 g \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 a \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 Grouping \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u25b6 e \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 g \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 r \u2502 \u2502 Group pass \u2502 \u2502 \u2502 e \u2502 \u2502 \u2502 s \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 r \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500\u2502\u2500 \u2500 \u2500 \u2500 \u2500 \u2502 \u250c \u2500 \u2500 \u2500 \u25bc \u2500 \u2500 \u2500 \u2510 Output module \u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2518 For each component available, QAT checks if the component is active and if it is, the components setup function is ran with its configuration class. This class can be configured from the command line or through the profile. We note that the figure does not contain a comprehensive list of passes that can be installed. Whether or not any of the listed passes is added to the pass managers is happening at the discretion of each of the components and is further subject to the configuration provided to these components. This means that depending on the profile configuration, the pass may perform one task or another. This is in particular true for the transformation pass which uses a set of rules to perform replacements in the IR. The transformation component is a highly configurable component that does replacements of pieces of the DAG in the IR with using a custom replacer function. The infrastructure is written such that it is possible to express a new pattern in just a couple of lines and the developer can focus on the replacement routine rather than the task of capturing the right segment of instructions.","title":"Architecture Overview"},{"location":"DeveloperGuide/ArchitectureOverview/#architecture-overview","text":"This document assumes familiarity with LLVM, LLVM intermediate representation (IR) , LLVM passes and the opt tool which is used to apply passes to IRs. We also assume that the reader is familiar with the QIR specification , the conventions used for functions and its opaque types. We further assume that the reader is familiar with basic C++. This is in particular true later on when we dig into the details of building pass components. Throughout this document we will assume that any reference to a QIR, is a valid within the specification requirements. The aim of this document is to walk the reader through the vision and architecture of the QIR adaptor tool (QAT). To this end, we will be discussing how QAT uses both built-in and custom written LLVM passes to transform generic QIRs into ones which are targeted specific platforms and/or capabilities. We refer to any generic QIR as just \"the QIR\" or the generic QIR where as those target for specific platforms and/or capabilities, we call specialised QIRs. The description of the requirements for the specialised QIR we call a QIR profile. When we talk about applying a profile to a generic QIR, we talk about the process which transform the generic QIR into the specialised one. Likewise, when we talk about validating that a specialised QIR fulfils the description of a profile. In building QAT, we note that there are two main challenges to overcome: Applying a profile to a generic QIR, and, Validating that a QIR is compliant with a profile specification. We may on occasion refer to the former as a transformation and the latter as an analysis to clarify the similarity to LLVM passes. The architecture described in this document attempts to address both of these challenges in way that we believe to be customisable and scalable in terms of profile requirements. Before digging into the details of the design of QAT, we first note that LLVM\u00f8s opt has many of the properties that we desire: Modularised, extendable in a non-invasive manner and differentiates between analysis and transformation. The downsides to opt is that we cannot pass a configuration to the individual passes, it is difficult to control which concrete passes are ran and, under the assumption that a profile is described by a collection of passes, there is no elegant way to bundle these into a single argument. In our design, it will be our goal to preserve the good aspects of opt while adding the capabilities we miss to make profile transformations and validation. Before spelling the system requirements out, we consider a couple of examples of what we may need for functionality.","title":"Architecture Overview"},{"location":"DeveloperGuide/ArchitectureOverview/#example-function-inlining","text":"Let us first consider the case of quantum architecture that does not support classical function calls. That is, a valid program must be all inlined. This is a task that can be handled by opt by supplying the command line argument --always-inline . This flag turns the inline pipeline on and attempts to inline as many function calls as possible. For QAT to be a useful tool, we would want a similar mechanism that allows to activate or deactivate existing (and new) LLVM passes. We would thus need something like qat --always-inline --profile base --apply -S filename.ll where --apply tells the tool to apply the profile and -S tells the tool to emit human readable LLVM IR code. Furthermore, if the inline pass is provided as an external module, we would need to be able load it qat --always-inline --profile base --load path/to/lib.(dylib|so|dll) --apply -S filename.ll We note that from a developer point of view, the underlying code would also need a way to let QAT know that it expects a command line argument --always-inline/--no-always-inline .","title":"Example: Function inlining"},{"location":"DeveloperGuide/ArchitectureOverview/#example-static-qubit-allocation","text":"To get a better understanding of the problem at hand, let us examine another example: Qubit allocation. As we run our quantum program, we may use a simulator or we may deploy it on one of the hardware providers. Depending on whether we are running in one environment or the other, qubits are different entities: In a computer simulation they are often objects. They could for instance be allocated on the heap in a non-sequential manner. In this context, it makes sense to talk about a qubits life time through instructions that allocates and releases them. On hardware, on the other hand, qubits are physical entities typically sequentially enumerated from 0 to N - 1. Physical qubits may (or may not) have the constraint some qubits are unavailable to the user. Though not always, hardware may further have the constraint that user can only perform a single measurement at the end of the program execution. This means that qubits cannot be reused within one program execution. This puts requirements on what we may need from static qubit allocation. For any static allocation, we would need at least following information: Whether or not to map qubits to fixed integers Reuse qubits or not List unavailable qubits It is not hard to imagine that this could be extended even further by imposing customised allocation schemes. In contrast to the previous example, this example requires a much more detailed configuration to define the mode of operation. One could for instance imagine something along the lines of qat --use-static-allocation --reuse-qubits --defect-qubits 3,7,9 --max-qubits 10 --apply -S filename.ll Hence, unlike normal LLVM passes, we will need a detailed configuration to be passed along with the transformation.","title":"Example: Static qubit allocation"},{"location":"DeveloperGuide/ArchitectureOverview/#design-requirements","text":"To distinguish between LLVM passes and QAT extensions, we will refer to QAT extensions as profile components. A profile component may consist of several passes and furthermore should be accompanied by a configuration to describe its behaviour. Like LLVM opt we require that QAT must be extensible through dynamic libraries. This allow third party to easily extend the tool to their needs while benefiting from the components that QAT ships with.","title":"Design requirements"},{"location":"DeveloperGuide/ArchitectureOverview/#architecture-description","text":"On a high level, the process of the IRs can be divided into three main tasks: 1) Loading the QIR, 2) creating a generator and validator and 3) transform and validate the QIR. We summarize this process in the diagram below, listing the components and settings used in the process and how they feed into one and another: \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2510 User input \u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u252c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2518 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Configuration and parameter parser \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 IR file list \u2502 \u2502 Profile config \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Module loader \u2502 \u2502 Profile Generator \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Single module \u2502 \u2502 Profile \u2502 \u2502 transformations \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 Adding debug symbols \u251c\u2500\u2500\u2500\u25b6 Generation \u251c\u2500\u253c\u25b6Validation \u251c\u2500\u2500\u2500\u2500\u2500\u2510 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 Logger \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u25bc \u25bc \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2510\u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2510 Standard error Standard Output: \u2502 or file: \u2502\u2502 Resulting IR \u2502 JSON Logs \u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2518\u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2518 The profile consists of a generator and a validator. The generator is responsible for performing as many transformations as possible to get the original QIR to be compliant with the selected profile. This is done by each of the components taking a configuration which then installs LLVM passes to execute said transactions. This is illustrated on the left hand-side in the following figure whereas the pass execution is illustrated on the right hand-side: \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2510 LLVM module \u250c\u2500\u2500\u2500\u2510 \u2514 \u2500 \u2500 \u2500\u2502\u2500 \u2500 \u2500 \u2500 \u2518 \u2502 \u2502 \u2502 Apply profile \u2502 C \u2502 \u2502 process \u2502 o \u2502 \u250c Generator \u2500 \u2500 \u2500\u2502\u2500 \u2500 \u2500 \u2500 \u2500 \u2502 n \u2502If \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 f \u2502component Install\u2502 \u2502 Inline pass \u2502 \u2502 i \u2502active: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510passes \u250c\u2500\u2500\u2500\u2510 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 g \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 LLVM passes \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u25b6 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 u \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 Unroll pass \u2502 \u2502 \u2502 r \u2502 \u2502 \u2502 P \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 a \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 t \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 Transformation \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u25b6 s \u2502 \u2502Transform pass \u2502 \u2502 i \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 s \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 o \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 n \u2502 \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2510 \u2502 m \u2502 \u2502 Inline pass \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 LLVM passes \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u25b6 a \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 m \u2502 \u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2518 \u2502 n \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 a \u2502 \u2502 \u2502 a \u2502 \u2502 Fold pass \u2502 \u2502 n \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 g \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 a \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 Grouping \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u25b6 e \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 g \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 r \u2502 \u2502 Group pass \u2502 \u2502 \u2502 e \u2502 \u2502 \u2502 s \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 r \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500\u2502\u2500 \u2500 \u2500 \u2500 \u2500 \u2502 \u250c \u2500 \u2500 \u2500 \u25bc \u2500 \u2500 \u2500 \u2510 Output module \u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2518 For each component available, QAT checks if the component is active and if it is, the components setup function is ran with its configuration class. This class can be configured from the command line or through the profile. We note that the figure does not contain a comprehensive list of passes that can be installed. Whether or not any of the listed passes is added to the pass managers is happening at the discretion of each of the components and is further subject to the configuration provided to these components. This means that depending on the profile configuration, the pass may perform one task or another. This is in particular true for the transformation pass which uses a set of rules to perform replacements in the IR. The transformation component is a highly configurable component that does replacements of pieces of the DAG in the IR with using a custom replacer function. The infrastructure is written such that it is possible to express a new pattern in just a couple of lines and the developer can focus on the replacement routine rather than the task of capturing the right segment of instructions.","title":"Architecture description"},{"location":"DeveloperGuide/CodeQuality/","text":"Code quality and continuous integration Using the manage tool Before making a pull request with changes to this library, please ensure that style checks passes, that the code compiles, unit test passes and that there are no erros found by the static analyser. For code formatting and linting, we use Trunk to manage this process. To install trunk run curl https://get.trunk.io -fsSL | bash In order for clang-tidy to work, you need to generate a compile_commands.json . To do this, run the first part of the CMake build process: mkdir Debug cd Debug cmake .. and then copy compile_commands.json into the root directory: cp compile_commands.json ../ To check the style, run trunk check To automatically format the code use trunk fmt Running tests In order to run the tests, you first need to build the library. Assuming that this is already done and the corresponding build is in Debug/ : cmake .. make and then running following command: ctest","title":"Code quality"},{"location":"DeveloperGuide/CodeQuality/#code-quality-and-continuous-integration","text":"","title":"Code quality and continuous integration"},{"location":"DeveloperGuide/CodeQuality/#using-the-manage-tool","text":"Before making a pull request with changes to this library, please ensure that style checks passes, that the code compiles, unit test passes and that there are no erros found by the static analyser. For code formatting and linting, we use Trunk to manage this process. To install trunk run curl https://get.trunk.io -fsSL | bash In order for clang-tidy to work, you need to generate a compile_commands.json . To do this, run the first part of the CMake build process: mkdir Debug cd Debug cmake .. and then copy compile_commands.json into the root directory: cp compile_commands.json ../ To check the style, run trunk check To automatically format the code use trunk fmt","title":"Using the manage tool"},{"location":"DeveloperGuide/CodeQuality/#running-tests","text":"In order to run the tests, you first need to build the library. Assuming that this is already done and the corresponding build is in Debug/ : cmake .. make and then running following command: ctest","title":"Running tests"},{"location":"DeveloperGuide/DeveloperFAQ/","text":"Developer FAQ Pass does not load One error that you may encounter is that an analysis pass does not load with output similar to this: opt -load-pass-plugin ../../Debug/libQSharpPasses.dylib -enable-debugify --passes=\"operation-counter\" -disable-output classical-program.bc Failed to load passes from '../../Debug/libQSharpPasses.dylib'. Request ignored. opt: unknown pass name 'operation-counter' This is likely becuase you have forgotten to instantiate static class members. For instance, in the case of an instance of llvm::AnalysisInfoMixin you are required to have a static member Key : class COpsCounterPass : public llvm::AnalysisInfoMixin<COpsCounterPass> { private: static llvm::AnalysisKey Key; //< REQUIRED by llvm registration friend struct llvm::AnalysisInfoMixin<COpsCounterPass>; }; If you forget to instantiate this variable in your corresponding .cpp file, // llvm::AnalysisKey COpsCounterPass::Key; //< Uncomment this line to make everything work everything will compile, but the pass will fail to load. There will be no linking errors either.","title":"Developer FAQ"},{"location":"DeveloperGuide/DeveloperFAQ/#developer-faq","text":"","title":"Developer FAQ"},{"location":"DeveloperGuide/DeveloperFAQ/#pass-does-not-load","text":"One error that you may encounter is that an analysis pass does not load with output similar to this: opt -load-pass-plugin ../../Debug/libQSharpPasses.dylib -enable-debugify --passes=\"operation-counter\" -disable-output classical-program.bc Failed to load passes from '../../Debug/libQSharpPasses.dylib'. Request ignored. opt: unknown pass name 'operation-counter' This is likely becuase you have forgotten to instantiate static class members. For instance, in the case of an instance of llvm::AnalysisInfoMixin you are required to have a static member Key : class COpsCounterPass : public llvm::AnalysisInfoMixin<COpsCounterPass> { private: static llvm::AnalysisKey Key; //< REQUIRED by llvm registration friend struct llvm::AnalysisInfoMixin<COpsCounterPass>; }; If you forget to instantiate this variable in your corresponding .cpp file, // llvm::AnalysisKey COpsCounterPass::Key; //< Uncomment this line to make everything work everything will compile, but the pass will fail to load. There will be no linking errors either.","title":"Pass does not load"},{"location":"DeveloperGuide/LogicSeparation/","text":"QAT Application: Logic separation Architecture considerations In this section, we will discuss some classical architectures and then make considerations regarding quantum architectures. Motivation: Classical co-processors Before diving into quantum architectures, we first make a brief note on classical architectures: For decades we have seen classical architectures composed of multiple processing units. For instance, in the nineties it was common to have a co-processor supporting the main x86 architecture with such tasks as floating point operations. Other co-processing architectures were built to enhance the computers sound capabilities and in 2001, we saw graphical processing units (GPUs) emerge. To this day, GPUs are still an essentially co-processor for many computing tasks including gaming, physics simulation, and graphics to mention a few. While floating point operation co-processors eventually became integrated into the CPU, other co-processors such as GPU remains stand-alone units today. On a high-level, the use of a GPU for simulation roughly follows this diagram: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 Programming \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 State preparation \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Primary \u2502 \u2502 Secondary \u2502 \u2502 processing \u2502 \u2502 processing \u2502 \u2502 unit \u2502 \u2502 unit \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 Result readout \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 First the secondary processing unit (SPU) is programmed and as a part of this process the initial state (i.e. registers and memory) is prepared. The SPU then executes the program and the results are read out by the primary processing unit (PPU). Classical-quantum processing architecture While one could imagine a quantum architecture in which everything is integrated into a single processing unit that both can process classical and quantum registers, it is unlikely that this kind of architecture will emerge in the near future due to the vastly different environments in which the two processes take place. Therefore, one feasible architecture is one in which we consider the quantum processing unit (QPU) as SPU and the CPU the PPU much like is the case for CPUs and GPUs today. Disregarding the more advanced scenarios where PPUs and SPUs work in parallel, the basic flow of a classical-quantum program execution follows a pattern as given below: Classical PPU-SPU Quantum processing unit \u2502 interface \u2502 processing unit \u2502 \u2502 \u2502 \u2502 \u2502 Classical program \u2502 \u2502 \u2502 execution \u2502 \u2502 \u2502 \u2502 \u2502 State preparation \u2502 \u25bc \u2502 Programming \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Quantum program \u2502 \u2502 \u2502 execution \u2502 Result readout \u2502 \u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u25bc \u2502 \u2502 \u2502 Classical program \u2502 \u2502 \u2502 execution \u2502 \u2502 State preparation \u2502 \u2502 \u2502 Programming \u2502 \u25bc \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Quantum program \u2502 \u2502 \u2502 execution \u2502 Result readout \u2502 \u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u25bc \u2502 \u2502 \u25bc \u25bc Time We note that in some cases, either the state programming or the readout process may be not contain instructions. In these cases, blocks with state programming and/or readout will simply be empty and therefore it has no influence on the general structure. Problem definition The QIR specification does not put any requirements for a generic QIR to provide a separation of instructions intended for the CPU and QPU. However, under the assumption that quantum architectures follow the PPU-SPU pattern described in the previous section such a separation is necessary to perform the program execution. Our aim in this document will be to define how the separation should be performed and what qualifies an entity to be a CPU or QPU element. We will assume that branching and jumping is not possible within the QPU since this is a classical phenomenon. The consequence is that CPU-QPU separation must happen at the level of BasicBlocks in LLVM rather than at a function or even program level. While it may be that some QPUs have basic branching support, we note that it will be manageable to identify multi-block segments which are compatible with a given QPU target after the separation. Definitions Registers For traditional PPU-SPU architectures, registers are limited in scope to the processing unit on which they reside. That is, a register on a CPU cannot be accessed from the GPU and vice versa. The value of a given register is only available through data transport through the two units. For CPU-QPU architectures, this limitation is the same. While the CPU may hold a reference to a qubit, the physical qubit itself resides on the QPU and can only be manipulated through the CPU-QPU interface. Quantum register types LLVM type name Description Qubit* Qubit register amounting to a physical qubit or simulation data type Result* Result register Classical register types LLVM type name Description i1 i2 i8 i16 i32 i64 struct On the CPU, Qubit* and Result* are treated as integers. This means that they should never be dereferenced nor should the \"memory address\" be written to. Instructions and instruction classification The QIR specification has two high-level classes of instructions: Those which are calls to functions with names starting with __quantum__ and all other instructions. Function calls to functions starting with __quantum__ are expected to follow the QIR specification and these calls are further divided into two groups: Intrinsic functions ( __quantum__qis__ ) and runtime functions ( __quantum__rt__ ). The latter are expected to be provided by the runtime library given by the frontend and/or the target machine, whereas the former are intrinsic functions. The intrinsic functions may either run on the CPU, the QPU or serve as instruction to transfer data between the two processing units. We classify __quantum__qis__ functions into four categories: Purely CPU, purely QPU, setup/transport from CPU to QPU and result/transport from QPU to CPU. The classification happens on the basis of the function signature: The function arguments together with the return result determine where the call will be executed according to following rules: Any void function location is purely determined by its arguments: Void functions that only have quantum register types as arguments are classified as pure QPU instructions Void functions that only have classical register types as arguments are classified as pure CPU instructions Void functions that takes a mixture are classified as CPU to QPU setup/transport instructions Any function that returns a quantum register is: A pure quantum instruction if all of the function arguments are quantum registers A CPU to QPU setup/transport instruction in any other case A function that returns a classical register is: A pure classical instruction if all of the arguments are classical registers A QPU to CPU result/transport instruction in any other case Pass definition As an example we will consider following code block: define i64 @LogicGrouping(i64 %z) local_unnamed_addr #0 { entry: %0 = icmp slt i64 %z, 0 %a1.i.i = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %a2.i.i = select i1 %0, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null tail call void @__quantum__qis__x__body(%Qubit* %a1.i.i) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %a1.i.i, %Qubit* %a2.i.i) tail call void @__quantum__qis__mz__body(%Qubit* %a2.i.i, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* %a2.i.i) %1 = tail call i1 @__quantum__qis__read_result__body(%Result* null) %2 = mul i64 %z, 45 %.op.op.i.i = add i64 %2, 13 %3 = select i1 %1, i64 -7, i64 %.op.op.i.i ret i64 %3 } In the above 2-qubit ( 0 and 1 ) circuit, we use a classical parameter to decide which qubit should be the control qubit ( a1 ) and which is the target ( a2 ). We apply an X gate to the control qubit and then apply a Z gate to the qubit with id 0 regardless of whether it is the control or target qubit. This is followed by a CNOT gate and finally a measurement. The result from the measurement is used to compute a classical result. Our goal is now to separate instructions into blocks of pure quantum instructions, pure classical instructions and data transfer. The data transfer blocks can be thought of as a mix of classical and quantum instructions as these may manipulate registers on either the CPU or QPU. For the above example code, we envision a separation similar to following code snippet: define i64 @LogicGrouping(i64 %z) local_unnamed_addr #0 { entry: %0 = icmp slt i64 %z, 0 %1 = mul i64 %z, 45 %2 = add i64 %1, 13 br label %load load: ; preds = %entry %3 = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %4 = select i1 %0, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null br label %quantum quantum: ; preds = %load tail call void @__quantum__qis__x__body(%Qubit* %3) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %3, %Qubit* %4) tail call void @__quantum__qis__mz__body(%Qubit* %4, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* %4) br label %readout readout: ; preds = %quantum %5 = tail call i1 @__quantum__qis__read_result__body(%Result* null) br label %post-classical post-classical: ; preds = %readout %6 = select i1 %5, i64 -7, i64 %2 br label %exit_quantum_grouping exit_quantum_grouping: ; preds = %post-classical ret i64 %6 } In the above program, the original instructions are rearranged into blocks following the pattern previously discussed with an entry block, a load block, a quantum program block, a readout block and a post-classical processing block. Visualized as above, the blocks are executed as follows: Classical PPU-SPU Quantum processing unit \u2502 interface \u2502 processing unit \u2502 \u2502 entry\u2502 \u2502 \u2502 \u25bc \u2502 load \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 readout \u2502 \u2502 quantum \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u25bc post-classical \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 exit-grouping \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 \u25bc \u25bc Time With this separation, it becomes straight-forward to execute the program parts in accordance with the required processing unit as well as to ensure that proper setup of the QPU was performed before initiating the quantum calculation. Block Separation Strategy Our block separation strategy follows a divide-and-conquer approach: First we sort instructions into new blocks according to the source processing. Each of these blocks are then sub-divided based on the destination processing unit. We illustrate this in the following diagram: 1st split 2nd split \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502Classical \u2502 entry \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u25b6\u2502 Dest \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502Classical \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u25b6\u2502 Source \u251c\u2500\u2524 \u2502 Quantum \u2502 load \u2502 \u2502 \u2502 \u2514\u2500\u25b6\u2502 Dest \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Quantum \u2502 quantum \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u25b6\u2502 Dest \u2502 \u2502 Original \u2502 \u2502 \u2502 Quantum \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 block \u2502\u2500\u2500\u253c\u2500\u25b6\u2502 Source \u251c\u2500\u2524 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502Classical \u2502 readout \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u25b6\u2502 Dest \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502Classical \u2502 post-classical \u2502 \u2502Classical \u2502 \u250c\u2500\u25b6\u2502 Dest \u2502 \u2514\u2500\u25b6\u2502 Source \u2502\u2500\u2524 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 Empty (QD)\u2502 \u2514\u2500\u25b6\u2502 \u2500 \u2500 \u2500 \u2500 \u2500 \u2518 We note the second split is reversed depending type of instructions it contains. We order instruction blocks (during the second split) such that instructions whose source and destination processing units are the same come first. We note that the second split is technically easier to make as the blocks processed in the first split already have certain guarantees provided: We are guaranteed that we only need to make one split We are guaranteed that the order of all dependencies is preserved when splitting instructions into the two blocks The first split is more involved as we need to identify dependencies between classical and quantum circuits and may end up with an output similar to: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502Classical \u2502 \u250c\u2500\u25b6\u2502 Source \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 Quantum \u2502 \u251c\u2500\u25b6\u2502 Source \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502Classical \u2502 \u251c\u2500\u25b6\u2502 Source \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Original \u2502 \u2502 \u2502 Quantum \u2502 \u2502 block \u2502\u2500\u2500\u253c\u2500\u25b6\u2502 Source \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502Classical \u2502 \u251c\u2500\u25b6\u2502 Source \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 . \u2502 . \u2502 . \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502Classical \u2502 \u2514\u2500\u25b6\u2502 Source \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 The main reason for this is that we may make a measurement and then use that measurement to decide what the next quantum circuit looks like. As an example, consider following circuit: define i64 @LogicGrouping(i64 %z) local_unnamed_addr #0 { entry: %0 = icmp slt i64 %z, 0 %a1.i.i = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %a2.i.i = select i1 %0, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null tail call void @__quantum__qis__x__body(%Qubit* %a1.i.i) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %a1.i.i, %Qubit* %a2.i.i) tail call void @__quantum__qis__mz__body(%Qubit* %a2.i.i, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* %a2.i.i) %1 = tail call i1 @__quantum__qis__read_result__body(%Result* null) %a3.i.i = select i1 %1, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null %2 = tail call i1 @__quantum__qis__read_result__body(%Result* null) %a4.i.i = select i1 %2, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) tail call void @__quantum__qis__x__body(%Qubit* %a3.i.i) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %a3.i.i, %Qubit* %a4.i.i) tail call void @__quantum__qis__mz__body(%Qubit* %a4.i.i, %Result* nonnull inttoptr (i64 1 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* %a4.i.i) %3 = tail call i1 @__quantum__qis__read_result__body(%Result* nonnull inttoptr (i64 1 to %Result*)) %4 = mul i64 %z, 9 %5 = shl i64 %z, 1 %val.i.i = select i1 %3, i64 %5, i64 %4 %6 = mul i64 %val.i.i, 5 %7 = add i64 %6, -7 ret i64 %7 } After grouping according to the source processing unit, we arrive at define i64 @LogicGrouping(i64 %z) local_unnamed_addr #0 { entry: %0 = icmp slt i64 %z, 0 %1 = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %2 = select i1 %0, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null br label %quantum quantum: ; preds = %entry tail call void @__quantum__qis__x__body(%Qubit* %1) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %1, %Qubit* %2) tail call void @__quantum__qis__mz__body(%Qubit* %2, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* %2) %3 = tail call i1 @__quantum__qis__read_result__body(%Result* null) %4 = tail call i1 @__quantum__qis__read_result__body(%Result* null) br label %post-classical post-classical: ; preds = %quantum %5 = select i1 %3, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null %6 = select i1 %4, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %7 = mul i64 %z, 9 %8 = shl i64 %z, 1 br label %quantum2 quantum2: ; preds = %post-classical tail call void @__quantum__qis__x__body(%Qubit* %5) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %5, %Qubit* %6) tail call void @__quantum__qis__mz__body(%Qubit* %6, %Result* nonnull inttoptr (i64 1 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* %6) %9 = tail call i1 @__quantum__qis__read_result__body(%Result* nonnull inttoptr (i64 1 to %Result*)) br label %post-classical1 post-classical1: ; preds = %quantum2 %10 = select i1 %9, i64 %8, i64 %7 %11 = mul i64 %10, 5 %12 = add i64 %11, -7 br label %exit_quantum_grouping exit_quantum_grouping: ; preds = %post-classical1 ret i64 %12 } which contains two quantum circuits where the second circuit depends on the first one. That is, in the block post-classical we select which qubits to use for the execute, and hence, we would not be able to run the second circuit prior to this classical calculation. Further expanding each of the source blocks, we get the load and readout blocks: define i64 @LogicGrouping(i64 %z) local_unnamed_addr #0 { entry: %0 = icmp slt i64 %z, 0 br label %load load: ; preds = %entry %1 = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %2 = select i1 %0, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null br label %quantum quantum: ; preds = %load tail call void @__quantum__qis__x__body(%Qubit* %1) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %1, %Qubit* %2) tail call void @__quantum__qis__mz__body(%Qubit* %2, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* %2) br label %readout readout: ; preds = %quantum %3 = tail call i1 @__quantum__qis__read_result__body(%Result* null) %4 = tail call i1 @__quantum__qis__read_result__body(%Result* null) br label %post-classical post-classical: ; preds = %readout %5 = mul i64 %z, 9 %6 = shl i64 %z, 1 br label %load4 load4: ; preds = %post-classical %7 = select i1 %3, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null %8 = select i1 %4, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) br label %quantum2 quantum2: ; preds = %load4 tail call void @__quantum__qis__x__body(%Qubit* %7) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %7, %Qubit* %8) tail call void @__quantum__qis__mz__body(%Qubit* %8, %Result* nonnull inttoptr (i64 1 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* %8) br label %readout3 readout3: ; preds = %quantum2 %9 = tail call i1 @__quantum__qis__read_result__body(%Result* nonnull inttoptr (i64 1 to %Result*)) br label %post-classical1 post-classical1: ; preds = %readout3 %10 = select i1 %9, i64 %6, i64 %5 %11 = mul i64 %10, 5 %12 = add i64 %11, -7 br label %exit_quantum_grouping exit_quantum_grouping: ; preds = %post-classical1 ret i64 %12 }","title":"Grouping QIS"},{"location":"DeveloperGuide/LogicSeparation/#qat-application-logic-separation","text":"","title":"QAT Application: Logic separation"},{"location":"DeveloperGuide/LogicSeparation/#architecture-considerations","text":"In this section, we will discuss some classical architectures and then make considerations regarding quantum architectures.","title":"Architecture considerations"},{"location":"DeveloperGuide/LogicSeparation/#motivation-classical-co-processors","text":"Before diving into quantum architectures, we first make a brief note on classical architectures: For decades we have seen classical architectures composed of multiple processing units. For instance, in the nineties it was common to have a co-processor supporting the main x86 architecture with such tasks as floating point operations. Other co-processing architectures were built to enhance the computers sound capabilities and in 2001, we saw graphical processing units (GPUs) emerge. To this day, GPUs are still an essentially co-processor for many computing tasks including gaming, physics simulation, and graphics to mention a few. While floating point operation co-processors eventually became integrated into the CPU, other co-processors such as GPU remains stand-alone units today. On a high-level, the use of a GPU for simulation roughly follows this diagram: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 Programming \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 State preparation \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Primary \u2502 \u2502 Secondary \u2502 \u2502 processing \u2502 \u2502 processing \u2502 \u2502 unit \u2502 \u2502 unit \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 Result readout \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 First the secondary processing unit (SPU) is programmed and as a part of this process the initial state (i.e. registers and memory) is prepared. The SPU then executes the program and the results are read out by the primary processing unit (PPU).","title":"Motivation: Classical co-processors"},{"location":"DeveloperGuide/LogicSeparation/#classical-quantum-processing-architecture","text":"While one could imagine a quantum architecture in which everything is integrated into a single processing unit that both can process classical and quantum registers, it is unlikely that this kind of architecture will emerge in the near future due to the vastly different environments in which the two processes take place. Therefore, one feasible architecture is one in which we consider the quantum processing unit (QPU) as SPU and the CPU the PPU much like is the case for CPUs and GPUs today. Disregarding the more advanced scenarios where PPUs and SPUs work in parallel, the basic flow of a classical-quantum program execution follows a pattern as given below: Classical PPU-SPU Quantum processing unit \u2502 interface \u2502 processing unit \u2502 \u2502 \u2502 \u2502 \u2502 Classical program \u2502 \u2502 \u2502 execution \u2502 \u2502 \u2502 \u2502 \u2502 State preparation \u2502 \u25bc \u2502 Programming \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Quantum program \u2502 \u2502 \u2502 execution \u2502 Result readout \u2502 \u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u25bc \u2502 \u2502 \u2502 Classical program \u2502 \u2502 \u2502 execution \u2502 \u2502 State preparation \u2502 \u2502 \u2502 Programming \u2502 \u25bc \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Quantum program \u2502 \u2502 \u2502 execution \u2502 Result readout \u2502 \u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u25bc \u2502 \u2502 \u25bc \u25bc Time We note that in some cases, either the state programming or the readout process may be not contain instructions. In these cases, blocks with state programming and/or readout will simply be empty and therefore it has no influence on the general structure.","title":"Classical-quantum processing architecture"},{"location":"DeveloperGuide/LogicSeparation/#problem-definition","text":"The QIR specification does not put any requirements for a generic QIR to provide a separation of instructions intended for the CPU and QPU. However, under the assumption that quantum architectures follow the PPU-SPU pattern described in the previous section such a separation is necessary to perform the program execution. Our aim in this document will be to define how the separation should be performed and what qualifies an entity to be a CPU or QPU element. We will assume that branching and jumping is not possible within the QPU since this is a classical phenomenon. The consequence is that CPU-QPU separation must happen at the level of BasicBlocks in LLVM rather than at a function or even program level. While it may be that some QPUs have basic branching support, we note that it will be manageable to identify multi-block segments which are compatible with a given QPU target after the separation.","title":"Problem definition"},{"location":"DeveloperGuide/LogicSeparation/#definitions","text":"","title":"Definitions"},{"location":"DeveloperGuide/LogicSeparation/#registers","text":"For traditional PPU-SPU architectures, registers are limited in scope to the processing unit on which they reside. That is, a register on a CPU cannot be accessed from the GPU and vice versa. The value of a given register is only available through data transport through the two units. For CPU-QPU architectures, this limitation is the same. While the CPU may hold a reference to a qubit, the physical qubit itself resides on the QPU and can only be manipulated through the CPU-QPU interface. Quantum register types LLVM type name Description Qubit* Qubit register amounting to a physical qubit or simulation data type Result* Result register Classical register types LLVM type name Description i1 i2 i8 i16 i32 i64 struct On the CPU, Qubit* and Result* are treated as integers. This means that they should never be dereferenced nor should the \"memory address\" be written to.","title":"Registers"},{"location":"DeveloperGuide/LogicSeparation/#instructions-and-instruction-classification","text":"The QIR specification has two high-level classes of instructions: Those which are calls to functions with names starting with __quantum__ and all other instructions. Function calls to functions starting with __quantum__ are expected to follow the QIR specification and these calls are further divided into two groups: Intrinsic functions ( __quantum__qis__ ) and runtime functions ( __quantum__rt__ ). The latter are expected to be provided by the runtime library given by the frontend and/or the target machine, whereas the former are intrinsic functions. The intrinsic functions may either run on the CPU, the QPU or serve as instruction to transfer data between the two processing units. We classify __quantum__qis__ functions into four categories: Purely CPU, purely QPU, setup/transport from CPU to QPU and result/transport from QPU to CPU. The classification happens on the basis of the function signature: The function arguments together with the return result determine where the call will be executed according to following rules: Any void function location is purely determined by its arguments: Void functions that only have quantum register types as arguments are classified as pure QPU instructions Void functions that only have classical register types as arguments are classified as pure CPU instructions Void functions that takes a mixture are classified as CPU to QPU setup/transport instructions Any function that returns a quantum register is: A pure quantum instruction if all of the function arguments are quantum registers A CPU to QPU setup/transport instruction in any other case A function that returns a classical register is: A pure classical instruction if all of the arguments are classical registers A QPU to CPU result/transport instruction in any other case","title":"Instructions and instruction classification"},{"location":"DeveloperGuide/LogicSeparation/#pass-definition","text":"As an example we will consider following code block: define i64 @LogicGrouping(i64 %z) local_unnamed_addr #0 { entry: %0 = icmp slt i64 %z, 0 %a1.i.i = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %a2.i.i = select i1 %0, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null tail call void @__quantum__qis__x__body(%Qubit* %a1.i.i) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %a1.i.i, %Qubit* %a2.i.i) tail call void @__quantum__qis__mz__body(%Qubit* %a2.i.i, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* %a2.i.i) %1 = tail call i1 @__quantum__qis__read_result__body(%Result* null) %2 = mul i64 %z, 45 %.op.op.i.i = add i64 %2, 13 %3 = select i1 %1, i64 -7, i64 %.op.op.i.i ret i64 %3 } In the above 2-qubit ( 0 and 1 ) circuit, we use a classical parameter to decide which qubit should be the control qubit ( a1 ) and which is the target ( a2 ). We apply an X gate to the control qubit and then apply a Z gate to the qubit with id 0 regardless of whether it is the control or target qubit. This is followed by a CNOT gate and finally a measurement. The result from the measurement is used to compute a classical result. Our goal is now to separate instructions into blocks of pure quantum instructions, pure classical instructions and data transfer. The data transfer blocks can be thought of as a mix of classical and quantum instructions as these may manipulate registers on either the CPU or QPU. For the above example code, we envision a separation similar to following code snippet: define i64 @LogicGrouping(i64 %z) local_unnamed_addr #0 { entry: %0 = icmp slt i64 %z, 0 %1 = mul i64 %z, 45 %2 = add i64 %1, 13 br label %load load: ; preds = %entry %3 = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %4 = select i1 %0, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null br label %quantum quantum: ; preds = %load tail call void @__quantum__qis__x__body(%Qubit* %3) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %3, %Qubit* %4) tail call void @__quantum__qis__mz__body(%Qubit* %4, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* %4) br label %readout readout: ; preds = %quantum %5 = tail call i1 @__quantum__qis__read_result__body(%Result* null) br label %post-classical post-classical: ; preds = %readout %6 = select i1 %5, i64 -7, i64 %2 br label %exit_quantum_grouping exit_quantum_grouping: ; preds = %post-classical ret i64 %6 } In the above program, the original instructions are rearranged into blocks following the pattern previously discussed with an entry block, a load block, a quantum program block, a readout block and a post-classical processing block. Visualized as above, the blocks are executed as follows: Classical PPU-SPU Quantum processing unit \u2502 interface \u2502 processing unit \u2502 \u2502 entry\u2502 \u2502 \u2502 \u25bc \u2502 load \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 readout \u2502 \u2502 quantum \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u25bc post-classical \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 exit-grouping \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 \u25bc \u25bc Time With this separation, it becomes straight-forward to execute the program parts in accordance with the required processing unit as well as to ensure that proper setup of the QPU was performed before initiating the quantum calculation.","title":"Pass definition"},{"location":"DeveloperGuide/LogicSeparation/#block-separation-strategy","text":"Our block separation strategy follows a divide-and-conquer approach: First we sort instructions into new blocks according to the source processing. Each of these blocks are then sub-divided based on the destination processing unit. We illustrate this in the following diagram: 1st split 2nd split \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502Classical \u2502 entry \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u25b6\u2502 Dest \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502Classical \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u25b6\u2502 Source \u251c\u2500\u2524 \u2502 Quantum \u2502 load \u2502 \u2502 \u2502 \u2514\u2500\u25b6\u2502 Dest \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Quantum \u2502 quantum \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u25b6\u2502 Dest \u2502 \u2502 Original \u2502 \u2502 \u2502 Quantum \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 block \u2502\u2500\u2500\u253c\u2500\u25b6\u2502 Source \u251c\u2500\u2524 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502Classical \u2502 readout \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u25b6\u2502 Dest \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502Classical \u2502 post-classical \u2502 \u2502Classical \u2502 \u250c\u2500\u25b6\u2502 Dest \u2502 \u2514\u2500\u25b6\u2502 Source \u2502\u2500\u2524 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 Empty (QD)\u2502 \u2514\u2500\u25b6\u2502 \u2500 \u2500 \u2500 \u2500 \u2500 \u2518 We note the second split is reversed depending type of instructions it contains. We order instruction blocks (during the second split) such that instructions whose source and destination processing units are the same come first. We note that the second split is technically easier to make as the blocks processed in the first split already have certain guarantees provided: We are guaranteed that we only need to make one split We are guaranteed that the order of all dependencies is preserved when splitting instructions into the two blocks The first split is more involved as we need to identify dependencies between classical and quantum circuits and may end up with an output similar to: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502Classical \u2502 \u250c\u2500\u25b6\u2502 Source \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 Quantum \u2502 \u251c\u2500\u25b6\u2502 Source \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502Classical \u2502 \u251c\u2500\u25b6\u2502 Source \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Original \u2502 \u2502 \u2502 Quantum \u2502 \u2502 block \u2502\u2500\u2500\u253c\u2500\u25b6\u2502 Source \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502Classical \u2502 \u251c\u2500\u25b6\u2502 Source \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 . \u2502 . \u2502 . \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502Classical \u2502 \u2514\u2500\u25b6\u2502 Source \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 The main reason for this is that we may make a measurement and then use that measurement to decide what the next quantum circuit looks like. As an example, consider following circuit: define i64 @LogicGrouping(i64 %z) local_unnamed_addr #0 { entry: %0 = icmp slt i64 %z, 0 %a1.i.i = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %a2.i.i = select i1 %0, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null tail call void @__quantum__qis__x__body(%Qubit* %a1.i.i) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %a1.i.i, %Qubit* %a2.i.i) tail call void @__quantum__qis__mz__body(%Qubit* %a2.i.i, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* %a2.i.i) %1 = tail call i1 @__quantum__qis__read_result__body(%Result* null) %a3.i.i = select i1 %1, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null %2 = tail call i1 @__quantum__qis__read_result__body(%Result* null) %a4.i.i = select i1 %2, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) tail call void @__quantum__qis__x__body(%Qubit* %a3.i.i) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %a3.i.i, %Qubit* %a4.i.i) tail call void @__quantum__qis__mz__body(%Qubit* %a4.i.i, %Result* nonnull inttoptr (i64 1 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* %a4.i.i) %3 = tail call i1 @__quantum__qis__read_result__body(%Result* nonnull inttoptr (i64 1 to %Result*)) %4 = mul i64 %z, 9 %5 = shl i64 %z, 1 %val.i.i = select i1 %3, i64 %5, i64 %4 %6 = mul i64 %val.i.i, 5 %7 = add i64 %6, -7 ret i64 %7 } After grouping according to the source processing unit, we arrive at define i64 @LogicGrouping(i64 %z) local_unnamed_addr #0 { entry: %0 = icmp slt i64 %z, 0 %1 = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %2 = select i1 %0, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null br label %quantum quantum: ; preds = %entry tail call void @__quantum__qis__x__body(%Qubit* %1) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %1, %Qubit* %2) tail call void @__quantum__qis__mz__body(%Qubit* %2, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* %2) %3 = tail call i1 @__quantum__qis__read_result__body(%Result* null) %4 = tail call i1 @__quantum__qis__read_result__body(%Result* null) br label %post-classical post-classical: ; preds = %quantum %5 = select i1 %3, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null %6 = select i1 %4, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %7 = mul i64 %z, 9 %8 = shl i64 %z, 1 br label %quantum2 quantum2: ; preds = %post-classical tail call void @__quantum__qis__x__body(%Qubit* %5) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %5, %Qubit* %6) tail call void @__quantum__qis__mz__body(%Qubit* %6, %Result* nonnull inttoptr (i64 1 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* %6) %9 = tail call i1 @__quantum__qis__read_result__body(%Result* nonnull inttoptr (i64 1 to %Result*)) br label %post-classical1 post-classical1: ; preds = %quantum2 %10 = select i1 %9, i64 %8, i64 %7 %11 = mul i64 %10, 5 %12 = add i64 %11, -7 br label %exit_quantum_grouping exit_quantum_grouping: ; preds = %post-classical1 ret i64 %12 } which contains two quantum circuits where the second circuit depends on the first one. That is, in the block post-classical we select which qubits to use for the execute, and hence, we would not be able to run the second circuit prior to this classical calculation. Further expanding each of the source blocks, we get the load and readout blocks: define i64 @LogicGrouping(i64 %z) local_unnamed_addr #0 { entry: %0 = icmp slt i64 %z, 0 br label %load load: ; preds = %entry %1 = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %2 = select i1 %0, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null br label %quantum quantum: ; preds = %load tail call void @__quantum__qis__x__body(%Qubit* %1) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %1, %Qubit* %2) tail call void @__quantum__qis__mz__body(%Qubit* %2, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* %2) br label %readout readout: ; preds = %quantum %3 = tail call i1 @__quantum__qis__read_result__body(%Result* null) %4 = tail call i1 @__quantum__qis__read_result__body(%Result* null) br label %post-classical post-classical: ; preds = %readout %5 = mul i64 %z, 9 %6 = shl i64 %z, 1 br label %load4 load4: ; preds = %post-classical %7 = select i1 %3, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null %8 = select i1 %4, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) br label %quantum2 quantum2: ; preds = %load4 tail call void @__quantum__qis__x__body(%Qubit* %7) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %7, %Qubit* %8) tail call void @__quantum__qis__mz__body(%Qubit* %8, %Result* nonnull inttoptr (i64 1 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* %8) br label %readout3 readout3: ; preds = %quantum2 %9 = tail call i1 @__quantum__qis__read_result__body(%Result* nonnull inttoptr (i64 1 to %Result*)) br label %post-classical1 post-classical1: ; preds = %readout3 %10 = select i1 %9, i64 %6, i64 %5 %11 = mul i64 %10, 5 %12 = add i64 %11, -7 br label %exit_quantum_grouping exit_quantum_grouping: ; preds = %post-classical1 ret i64 %12 }","title":"Block Separation Strategy"},{"location":"DeveloperGuide/WritingAdaptor/","text":"Tutorial: Writing a new adaptor In this tutorial we will develop a new QAT profile adaptor. We will make the adaptor a separate library which is dynamically loaded through the command line interface. All examples in this tutorial can be found in AdaptorExamples . This tutorial is outlined as follows: Write an adaptor that just loads a configuration file Write an adaptor that adds passes to the adaptor Integrating the new adaptor into the QAT core Our first \"adaptor\" will be a \"hello world\" boilerplate which serves the purpose of giving the reader an understanding of how to define configurations for our adaptor. We will demonstrate how to use this adaptor from the command line. For our second adaptor, we will use a standard LLVM pass to demonstrate how to load these. We will show how the registered configuration can be used to enable or disable the pass. To show that the effect of the pass, we use the inliner pipeline. We will see how enabling the pass results in inlining all the function calls. Hello world Our first adaptor will not do anything except for printing out a custom message upon configuring the profile. To this end, we need a configuration which allows the user to specify the message and we capture this configuration in a class which we name HelloWorldConfig : using String = std::string; class HelloWorldConfig { public: // ... private: String message_{\"Hello world\"}; }; We note the default value of our configuration is captured through the initialization of the class member. That is, if not overridden by the command line arguments, the message will be \"Hello world\" . To fulfil the concept of being a configuration, a configuration must implement a setup function taking a reference to a ConfigurationManager as its only argument. For our configuration, this looks like class HelloWorldConfig { public: void setup(ConfigurationManager &config) { config.setSectionName(\"Hello world configuration\", \"Demonstrating how configuration works.\"); config.addParameter(message_, \"message\", \"Message which is printed when setting the adaptor up.\"); } // ... }; The purpose of the setup(config) function is to inform the configuration manager about what the name of the configuration section and its description is as well as defining all settings and bind them to C++ variables. The benefit of this approach is that all configuration parameters for the adaptor will be available immediately after the adaptor is loaded by the tool. The final code to manage the configuration reads: class HelloWorldConfig { public: using String = std::string; void setup(ConfigurationManager &config) { config.setSectionName(\"Hello world configuration\", \"Demonstrating how configuration works.\"); config.addParameter(message_, \"message\", \"Message which is printed when setting the adaptor up.\"); } String const& message() const { return message_; } private: String message_{\"Hello world\"}; }; With the configuration in place, the next thing we concern ourselves with is loading the adaptor. This is the functionality that registers the configuration together with an ID and a profile setup function. In our case, the setup function should just print a message given a HelloWorldConfig instance. The corresponding adaptor registration reads: extern \"C\" void loadAdaptor(IQirAdaptorFactory *factory) { factory->registerAdaptorComponent<HelloWorldConfig>( \"adaptor.hello-world\", [](HelloWorldConfig const &cfg, IQirAdaptorFactory * /*factory*/, Profile & /*profile*/) { std::cout << \"Message: \" << cfg.message() << std::endl; }); } In this example, we will only concern ourselves with how to use the configuration and we will ignore factory and profile for now. These will be covered in the later sections. The full source code to this example can be found in AdaptorExamples/HelloWorld and it can be compiled through following steps (startig from the Passes root folder): mkdir Debug cd Debug cmake .. make HelloWorld This will generate a HelloWorld dynamic library with path ./AdaptorExamples/libHelloWorld.(dylib|so|dll) . Loading the adaptor Executing qat and loading the libHelloWorld library, we see that our new settings are added to help page: % ./qir/qat/Apps/qat --load ./AdaptorExamples/libHelloWorld.dylib -h Usage: ./qir/qat/Apps/qat [options] filename ... Hello world configuration - Demonstration configuration for building a adaptor boilerplate. --message Message which is printed when setting the adaptor up. Default: Hello world ... For the next part, we assume that you have a QIR located in ../qir/qir-tests/reduction_tests/inlining-input.ll . To test that the setup function is invoked upon setting the profile up, we run ./qir/qat/Apps/qat -S --adaptor-pipeline hello-world --load ./AdaptorExamples/libHelloWorld.dylib ../qir/qir-tests/reduction_tests/inlining-input.ll Message: Hello world We note that in order for our new component to be loaded we need to add it to the adaptor pipeline by using adding --adaptor-pipeline hello-world to the commandline arguments. Creating a Pass Component Next, we make an adaptor that just runs a single LLVM pass. We we will use the inline pipeline to this end. We create a single option for activating the pass: class InlinerConfig { public: using String = std::string; void setup(ConfigurationManager &config) { config.setSectionName(\"Inliner adaptor\", \"Adds the LLVM Always Inline Pass to the profile\"); config.addParameter(inline_, \"custom-inliner\", \"Activating the custom inliner.\"); } bool shouldInline() const { return inline_; } private: bool inline_{false}; ///< Default behaviour is that we do not add the inliner pass }; The implementation itself is extern \"C\" void loadAdaptor(IQirAdaptorFactory *factory) { factory->registerAdaptorComponent<InlinerConfig>( \"adaptor.inliner\", [](InlinerConfig const &cfg, IQirAdaptorFactory *factory, Profile & /*profile*/) { if (cfg.shouldInline()) { auto &module_pass_manager = factory->modulePassManager(); // Adds the inline pipeline auto &pass_builder = factory->passBuilder(); auto inliner_pass = pass_builder.buildInlinerPipeline( factory->optimizationLevel(), llvm::PassBuilder::ThinLTOPhase::None, ptr->debug()); module_pass_manager.addPass(std::move(inliner_pass)); } }); } To build this pass run make InlinePassAdaptor To run this pass, ./qir/qat/Apps/qat -S --adaptor-pipeline inliner --custom-inliner --load ./AdaptorExamples/libInlinePassAdaptor.dylib --apply ../qir/qir-tests/reduction_tests/inlining-input.ll With --adaptor-pipeline inliner we load the inliner adaptor and adding --custom-inliner activates the inliner as per the code above. To verify that the adaptor does its job, compare the output against the output of ./qir/qat/Apps/qat -S --adaptor-pipeline inliner --load ./AdaptorExamples/libInlinePassAdaptor.dylib --apply ../qir/qir-tests/reduction_tests/inlining-input.ll where we have removed the flag --custom-inliner . QAT native adaptor Up until now we have built our adaptor as an external component without making any changes to the QAT source code. The last step we will touch in this section is how to integrate the adaptor as a permanent part of QAT. We will assume that we are moving inliner adaptor described above. The following does not have corresponding example source code as this would be intrusive. As the first step, we create a new folder to contain sources related to our adaptor: qir/qat/InlinerAdaptor . We then create qir/qat/InlinerAdaptor/InlinerConfig.hpp and copy the InlinerConfig class into this file. Remember to add a #pragma once in the top of the file. Next, we open qir/qat/AdapatorFactory/QirAdaptorFactor.cpp . First we include the InlinerConfig.hpp and then we locate the function setupDefaultComponentPipeline . Inside this function, we add following code: registerAdaptorComponent<InlinerConfig>( \"adaptor.inliner\", [](InlinerConfig const &cfg, IQirAdaptorFactory *ptr, Profile & /*profile*/) { if (cfg.shouldInline()) { auto &module_pass_manager = ptr->modulePassManager(); // Adds the inline pipeline auto &pass_builder = ptr->passBuilder(); auto inliner_pass = pass_builder.buildInlinerPipeline( ptr->optimizationLevel(), llvm::PassBuilder::ThinLTOPhase::None, ptr->debug()); module_pass_manager.addPass(std::move(inliner_pass)); } }); Recompile QAT and the adaptor is now QAT native. The final step is adding the adaptor to the pipeline: Open qat/qir/Apps/Qat/QatConfig.cpp and locate the line starting with config.addParameter(adapter_pipeline_, . Add the adaptor at the apppropriate place. This will make the adaptor loaded by default.","title":"Writing an adaptor"},{"location":"DeveloperGuide/WritingAdaptor/#tutorial-writing-a-new-adaptor","text":"In this tutorial we will develop a new QAT profile adaptor. We will make the adaptor a separate library which is dynamically loaded through the command line interface. All examples in this tutorial can be found in AdaptorExamples . This tutorial is outlined as follows: Write an adaptor that just loads a configuration file Write an adaptor that adds passes to the adaptor Integrating the new adaptor into the QAT core Our first \"adaptor\" will be a \"hello world\" boilerplate which serves the purpose of giving the reader an understanding of how to define configurations for our adaptor. We will demonstrate how to use this adaptor from the command line. For our second adaptor, we will use a standard LLVM pass to demonstrate how to load these. We will show how the registered configuration can be used to enable or disable the pass. To show that the effect of the pass, we use the inliner pipeline. We will see how enabling the pass results in inlining all the function calls.","title":"Tutorial: Writing a new adaptor"},{"location":"DeveloperGuide/WritingAdaptor/#hello-world","text":"Our first adaptor will not do anything except for printing out a custom message upon configuring the profile. To this end, we need a configuration which allows the user to specify the message and we capture this configuration in a class which we name HelloWorldConfig : using String = std::string; class HelloWorldConfig { public: // ... private: String message_{\"Hello world\"}; }; We note the default value of our configuration is captured through the initialization of the class member. That is, if not overridden by the command line arguments, the message will be \"Hello world\" . To fulfil the concept of being a configuration, a configuration must implement a setup function taking a reference to a ConfigurationManager as its only argument. For our configuration, this looks like class HelloWorldConfig { public: void setup(ConfigurationManager &config) { config.setSectionName(\"Hello world configuration\", \"Demonstrating how configuration works.\"); config.addParameter(message_, \"message\", \"Message which is printed when setting the adaptor up.\"); } // ... }; The purpose of the setup(config) function is to inform the configuration manager about what the name of the configuration section and its description is as well as defining all settings and bind them to C++ variables. The benefit of this approach is that all configuration parameters for the adaptor will be available immediately after the adaptor is loaded by the tool. The final code to manage the configuration reads: class HelloWorldConfig { public: using String = std::string; void setup(ConfigurationManager &config) { config.setSectionName(\"Hello world configuration\", \"Demonstrating how configuration works.\"); config.addParameter(message_, \"message\", \"Message which is printed when setting the adaptor up.\"); } String const& message() const { return message_; } private: String message_{\"Hello world\"}; }; With the configuration in place, the next thing we concern ourselves with is loading the adaptor. This is the functionality that registers the configuration together with an ID and a profile setup function. In our case, the setup function should just print a message given a HelloWorldConfig instance. The corresponding adaptor registration reads: extern \"C\" void loadAdaptor(IQirAdaptorFactory *factory) { factory->registerAdaptorComponent<HelloWorldConfig>( \"adaptor.hello-world\", [](HelloWorldConfig const &cfg, IQirAdaptorFactory * /*factory*/, Profile & /*profile*/) { std::cout << \"Message: \" << cfg.message() << std::endl; }); } In this example, we will only concern ourselves with how to use the configuration and we will ignore factory and profile for now. These will be covered in the later sections. The full source code to this example can be found in AdaptorExamples/HelloWorld and it can be compiled through following steps (startig from the Passes root folder): mkdir Debug cd Debug cmake .. make HelloWorld This will generate a HelloWorld dynamic library with path ./AdaptorExamples/libHelloWorld.(dylib|so|dll) .","title":"Hello world"},{"location":"DeveloperGuide/WritingAdaptor/#loading-the-adaptor","text":"Executing qat and loading the libHelloWorld library, we see that our new settings are added to help page: % ./qir/qat/Apps/qat --load ./AdaptorExamples/libHelloWorld.dylib -h Usage: ./qir/qat/Apps/qat [options] filename ... Hello world configuration - Demonstration configuration for building a adaptor boilerplate. --message Message which is printed when setting the adaptor up. Default: Hello world ... For the next part, we assume that you have a QIR located in ../qir/qir-tests/reduction_tests/inlining-input.ll . To test that the setup function is invoked upon setting the profile up, we run ./qir/qat/Apps/qat -S --adaptor-pipeline hello-world --load ./AdaptorExamples/libHelloWorld.dylib ../qir/qir-tests/reduction_tests/inlining-input.ll Message: Hello world We note that in order for our new component to be loaded we need to add it to the adaptor pipeline by using adding --adaptor-pipeline hello-world to the commandline arguments.","title":"Loading the adaptor"},{"location":"DeveloperGuide/WritingAdaptor/#creating-a-pass-component","text":"Next, we make an adaptor that just runs a single LLVM pass. We we will use the inline pipeline to this end. We create a single option for activating the pass: class InlinerConfig { public: using String = std::string; void setup(ConfigurationManager &config) { config.setSectionName(\"Inliner adaptor\", \"Adds the LLVM Always Inline Pass to the profile\"); config.addParameter(inline_, \"custom-inliner\", \"Activating the custom inliner.\"); } bool shouldInline() const { return inline_; } private: bool inline_{false}; ///< Default behaviour is that we do not add the inliner pass }; The implementation itself is extern \"C\" void loadAdaptor(IQirAdaptorFactory *factory) { factory->registerAdaptorComponent<InlinerConfig>( \"adaptor.inliner\", [](InlinerConfig const &cfg, IQirAdaptorFactory *factory, Profile & /*profile*/) { if (cfg.shouldInline()) { auto &module_pass_manager = factory->modulePassManager(); // Adds the inline pipeline auto &pass_builder = factory->passBuilder(); auto inliner_pass = pass_builder.buildInlinerPipeline( factory->optimizationLevel(), llvm::PassBuilder::ThinLTOPhase::None, ptr->debug()); module_pass_manager.addPass(std::move(inliner_pass)); } }); } To build this pass run make InlinePassAdaptor To run this pass, ./qir/qat/Apps/qat -S --adaptor-pipeline inliner --custom-inliner --load ./AdaptorExamples/libInlinePassAdaptor.dylib --apply ../qir/qir-tests/reduction_tests/inlining-input.ll With --adaptor-pipeline inliner we load the inliner adaptor and adding --custom-inliner activates the inliner as per the code above. To verify that the adaptor does its job, compare the output against the output of ./qir/qat/Apps/qat -S --adaptor-pipeline inliner --load ./AdaptorExamples/libInlinePassAdaptor.dylib --apply ../qir/qir-tests/reduction_tests/inlining-input.ll where we have removed the flag --custom-inliner .","title":"Creating a Pass Component"},{"location":"DeveloperGuide/WritingAdaptor/#qat-native-adaptor","text":"Up until now we have built our adaptor as an external component without making any changes to the QAT source code. The last step we will touch in this section is how to integrate the adaptor as a permanent part of QAT. We will assume that we are moving inliner adaptor described above. The following does not have corresponding example source code as this would be intrusive. As the first step, we create a new folder to contain sources related to our adaptor: qir/qat/InlinerAdaptor . We then create qir/qat/InlinerAdaptor/InlinerConfig.hpp and copy the InlinerConfig class into this file. Remember to add a #pragma once in the top of the file. Next, we open qir/qat/AdapatorFactory/QirAdaptorFactor.cpp . First we include the InlinerConfig.hpp and then we locate the function setupDefaultComponentPipeline . Inside this function, we add following code: registerAdaptorComponent<InlinerConfig>( \"adaptor.inliner\", [](InlinerConfig const &cfg, IQirAdaptorFactory *ptr, Profile & /*profile*/) { if (cfg.shouldInline()) { auto &module_pass_manager = ptr->modulePassManager(); // Adds the inline pipeline auto &pass_builder = ptr->passBuilder(); auto inliner_pass = pass_builder.buildInlinerPipeline( ptr->optimizationLevel(), llvm::PassBuilder::ThinLTOPhase::None, ptr->debug()); module_pass_manager.addPass(std::move(inliner_pass)); } }); Recompile QAT and the adaptor is now QAT native. The final step is adding the adaptor to the pipeline: Open qat/qir/Apps/Qat/QatConfig.cpp and locate the line starting with config.addParameter(adapter_pipeline_, . Add the adaptor at the apppropriate place. This will make the adaptor loaded by default.","title":"QAT native adaptor"},{"location":"DeveloperGuide/WritingRuleTests/","text":"Writing rule tests To make it easy to write tests for transformation rules, we have created two components to ease the burden of writing tests: ConfigurableQirAdaptorFactory and IrManipulationTestHelper . The ConfigurableQirAdaptorFactory is a profile that is dynamically defined when instatiated through a configuration lambda function. Creating the profile Creating the profile using the ConfigurableQirAdaptorFactory is done by first defining the lambda function and then instantiating the ConfigurableQirAdaptorFactory with the lambda function to define the profile. Using the RuleFactory , a profile for transforming the single qubit allocations is created as follows: auto configure_profile = [](RuleSet &rule_set) { auto factory = RuleFactory(rule_set); factory.useStaticQubitAllocation(); } auto profile = std::make_shared<ConfigurableQirAdaptorFactory>(std::move(configure_profile)); This profile is intended to transform %qubit = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %qubit) call void @__quantum__rt__qubit_release(%Qubit* %qubit) ret i8 0 by replacing all allocations with integers and stripping all release calls %qubit = inttoptr i64 0 to %Qubit* tail call void @__quantum__qis__h__body(%Qubit* %qubit) ret i8 0 Creating the IR In order to assist the testing of the above profile, we create a helper class which defines the IR we want to work on. To this end we make use of IrManipulationTestHelper which provides a number of shorthand functions to generate and test IR transformations. We start by defining the IR: auto ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareFunction(\"%Qubit* @__quantum__rt__qubit_allocate()\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); std::string script = R\"script( %qubit = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %qubit) call void @__quantum__rt__qubit_release(%Qubit* %qubit) )script\"; assert(ir_manip->fromBodyString(script)); // Will fail if the IR is invalid If we wish to verify the IR, we can print it by using the member function toString or by accessing the module directly: std::cout << ir_manip->toString() << std::endl; // OR llvm::errs() << *ir_manip->module() << \"\\n\"; Applying the profile to the IR The IrManipulationTestHelper contains a member function to run the profile on the IR to transform the module. The default behaviour of this helper function is to run without debug output at a O0 level to ensure that LLVM does not interfere with the intended test. The optimization level and debug mode can be changed through the function calls second and third argument, but for the sake of simplicity, we will assume we are using O0 here: ir_manip->applyProfile(profile); This will run the above generated rule set on the IR we have supplied. At this point, we could print the IR to the screen and use LIT to perform that actually transformation test. However, to keep this test framework self-contained and easy to use, we supply LIT-like functionality. This has the benefit that the tests do not rely on Python and the LIT framework and that the tooling around the test is substantially simpler. Testing the modified IR Like before, we can investigate the IR by printing it and as such we could write a test that compared the full IR against an expected string. However, even minor changes in the IR (such as interchanged declarations) would break the test even if the changes would not change the semantics of the code. Instead, the IrManipulationTestHelper has another helper function hasInstructionSequence which allow us to scan for a sequence of instructions in the body of the main function. In our case, we expect following two instructions (in order): %qubit = inttoptr i64 0 to %Qubit* tail call void @__quantum__qis__h__body(%Qubit* %qubit) The corresponding test code is as follows: EXPECT_TRUE(ir_manip->hasInstructionSequence({ \"%qubit = inttoptr i64 0 to %Qubit*\", \"tail call void @__quantum__qis__h__body(%Qubit* %qubit)\" })); By design, the test would pass as long as these two instructions are found (in order) within the full set of instructions of the function body. For instance, a valid IR for this test is call void printHelloWorld() %qubit = inttoptr i64 0 to %Qubit* %q2 = inttoptr i64 1 to %Qubit* %q3 = inttoptr i64 2 to %Qubit* tail call void @__quantum__qis__h__body(%Qubit* %q3) tail call void @__quantum__qis__h__body(%Qubit* %qubit) tail call void @__quantum__qis__h__body(%Qubit* %q2) but would fail tail call void @__quantum__qis__h__body(%Qubit* %qubit) %qubit = inttoptr i64 0 to %Qubit* and %qubit = inttoptr i64 0 to %Qubit* as the first has the wrong order of the calls and the second is missing one instruction.","title":"Rule based extensions"},{"location":"DeveloperGuide/WritingRuleTests/#writing-rule-tests","text":"To make it easy to write tests for transformation rules, we have created two components to ease the burden of writing tests: ConfigurableQirAdaptorFactory and IrManipulationTestHelper . The ConfigurableQirAdaptorFactory is a profile that is dynamically defined when instatiated through a configuration lambda function.","title":"Writing rule tests"},{"location":"DeveloperGuide/WritingRuleTests/#creating-the-profile","text":"Creating the profile using the ConfigurableQirAdaptorFactory is done by first defining the lambda function and then instantiating the ConfigurableQirAdaptorFactory with the lambda function to define the profile. Using the RuleFactory , a profile for transforming the single qubit allocations is created as follows: auto configure_profile = [](RuleSet &rule_set) { auto factory = RuleFactory(rule_set); factory.useStaticQubitAllocation(); } auto profile = std::make_shared<ConfigurableQirAdaptorFactory>(std::move(configure_profile)); This profile is intended to transform %qubit = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %qubit) call void @__quantum__rt__qubit_release(%Qubit* %qubit) ret i8 0 by replacing all allocations with integers and stripping all release calls %qubit = inttoptr i64 0 to %Qubit* tail call void @__quantum__qis__h__body(%Qubit* %qubit) ret i8 0","title":"Creating the profile"},{"location":"DeveloperGuide/WritingRuleTests/#creating-the-ir","text":"In order to assist the testing of the above profile, we create a helper class which defines the IR we want to work on. To this end we make use of IrManipulationTestHelper which provides a number of shorthand functions to generate and test IR transformations. We start by defining the IR: auto ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareFunction(\"%Qubit* @__quantum__rt__qubit_allocate()\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); std::string script = R\"script( %qubit = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %qubit) call void @__quantum__rt__qubit_release(%Qubit* %qubit) )script\"; assert(ir_manip->fromBodyString(script)); // Will fail if the IR is invalid If we wish to verify the IR, we can print it by using the member function toString or by accessing the module directly: std::cout << ir_manip->toString() << std::endl; // OR llvm::errs() << *ir_manip->module() << \"\\n\";","title":"Creating the IR"},{"location":"DeveloperGuide/WritingRuleTests/#applying-the-profile-to-the-ir","text":"The IrManipulationTestHelper contains a member function to run the profile on the IR to transform the module. The default behaviour of this helper function is to run without debug output at a O0 level to ensure that LLVM does not interfere with the intended test. The optimization level and debug mode can be changed through the function calls second and third argument, but for the sake of simplicity, we will assume we are using O0 here: ir_manip->applyProfile(profile); This will run the above generated rule set on the IR we have supplied. At this point, we could print the IR to the screen and use LIT to perform that actually transformation test. However, to keep this test framework self-contained and easy to use, we supply LIT-like functionality. This has the benefit that the tests do not rely on Python and the LIT framework and that the tooling around the test is substantially simpler.","title":"Applying the profile to the IR"},{"location":"DeveloperGuide/WritingRuleTests/#testing-the-modified-ir","text":"Like before, we can investigate the IR by printing it and as such we could write a test that compared the full IR against an expected string. However, even minor changes in the IR (such as interchanged declarations) would break the test even if the changes would not change the semantics of the code. Instead, the IrManipulationTestHelper has another helper function hasInstructionSequence which allow us to scan for a sequence of instructions in the body of the main function. In our case, we expect following two instructions (in order): %qubit = inttoptr i64 0 to %Qubit* tail call void @__quantum__qis__h__body(%Qubit* %qubit) The corresponding test code is as follows: EXPECT_TRUE(ir_manip->hasInstructionSequence({ \"%qubit = inttoptr i64 0 to %Qubit*\", \"tail call void @__quantum__qis__h__body(%Qubit* %qubit)\" })); By design, the test would pass as long as these two instructions are found (in order) within the full set of instructions of the function body. For instance, a valid IR for this test is call void printHelloWorld() %qubit = inttoptr i64 0 to %Qubit* %q2 = inttoptr i64 1 to %Qubit* %q3 = inttoptr i64 2 to %Qubit* tail call void @__quantum__qis__h__body(%Qubit* %q3) tail call void @__quantum__qis__h__body(%Qubit* %qubit) tail call void @__quantum__qis__h__body(%Qubit* %q2) but would fail tail call void @__quantum__qis__h__body(%Qubit* %qubit) %qubit = inttoptr i64 0 to %Qubit* and %qubit = inttoptr i64 0 to %Qubit* as the first has the wrong order of the calls and the second is missing one instruction.","title":"Testing the modified IR"},{"location":"QuickStart/","text":"Quick start This document will guide you through all the requirements and steps that you need to follow to build the QIR adaptor tool (QAT). QAT can be built either using Bazel or CMake. In the following two sections, we discuss how to build QAT using either of these tools. Building on Windows is currently only supported using Bazel . The detailed decription of building with Bazel outlines how to install bazelisk and discusses configuration flags. If you already have bazelisk installed, simply run bazelisk build //qir/qat:qat --config [compiler] --config release to build qat where compiler should be substituted with clang on Linux and macOS, and msvc on Windows. If you prefer CMake, please see the detailed instructions here . Supported systems In the table below, we summarize the systems currently supported. Operating system Architecture Version Bazel CMake Notes Windows x86_64, Arm 2019 Yes No Docker images through Bazel are not supported Ubuntu x86_64, Arm 22.04 Yes Yes x86_64, Arm 24.04 Yes Yes macOS x86_64, Arm Yes Yes Some tests fail on Arm due to issues in Bazel configuration of LLVM At the moment, we support clang and msvc to compile QAT. While gcc might work, it is untested and not supported at the moment. Additionally, the QAT supports experimental cross-compilation for Linux and macOS. This is useful in order to create Docker images with x86 architecture on arm platforms.","title":"Quick start"},{"location":"QuickStart/#quick-start","text":"This document will guide you through all the requirements and steps that you need to follow to build the QIR adaptor tool (QAT). QAT can be built either using Bazel or CMake. In the following two sections, we discuss how to build QAT using either of these tools. Building on Windows is currently only supported using Bazel . The detailed decription of building with Bazel outlines how to install bazelisk and discusses configuration flags. If you already have bazelisk installed, simply run bazelisk build //qir/qat:qat --config [compiler] --config release to build qat where compiler should be substituted with clang on Linux and macOS, and msvc on Windows. If you prefer CMake, please see the detailed instructions here .","title":"Quick start"},{"location":"QuickStart/#supported-systems","text":"In the table below, we summarize the systems currently supported. Operating system Architecture Version Bazel CMake Notes Windows x86_64, Arm 2019 Yes No Docker images through Bazel are not supported Ubuntu x86_64, Arm 22.04 Yes Yes x86_64, Arm 24.04 Yes Yes macOS x86_64, Arm Yes Yes Some tests fail on Arm due to issues in Bazel configuration of LLVM At the moment, we support clang and msvc to compile QAT. While gcc might work, it is untested and not supported at the moment. Additionally, the QAT supports experimental cross-compilation for Linux and macOS. This is useful in order to create Docker images with x86 architecture on arm platforms.","title":"Supported systems"},{"location":"QuickStart/building-with-bazel/","text":"Building with Bazel Prerequisites Building with Bazel is mostly self-contained meaning that Bazel will download most of the dependencies and arrange them in you workspace such that you do not need to checkout submodules or install extra packages. However, following external dependencies needs installing in order to use Bazel for building: C++ compiler (Clang 13/14 or MSVC 14.20) Bazelisk (or Bazel 5.0) We recommend the usage of Bazelisk as it is a wrapper that automatically downloads the correct version of Bazel for your project. The details of installing Bazelisk can be found here . You can also use Bazel without the wrapper. To do this, you need to install Bazel with the exact version specified in the .bazelversion file and in the subsequent sections replace bazelisk with bazel . To install on macOS use brew : brew install bazelisk To install on Windows use choco : choco install bazelisk On any other platform, we suggest you use npm . Note that npm also works with macOS and Windows npm install -g @bazel/bazelisk Once installed, verify that Bazelisk is correctly installed by running bazelisk --help If you experience any trouble with this step, please refer to the official documentation . Building QAT using Bazel Before building, decide whether you are building with clang or msvc as well as whether you wish to make a release build or a debug build. On all operating systems, Bazelisk follows the pattern bazelisk build [target] --config [clang/msvc] --config [debug/release] On macOS and Ubuntu, you can build QAT as bazelisk build //qir/qat:qat --config clang --config release On Windows, you would use the msvc compiler bazelisk build //qir/qat:qat --config msvc --config release You will note that you do not need to checkout submodules and/or install LLVM locally on your machine. Bazel will download all dependencies and compile them from scratch. The benefit of this is that builds are much more reproducible and less dependent on you local system settings. The downside is that build times can be longer since everything is compiled from scratch. You will note that you can run QAT directly using Bazel by bazelisk run //qir/qat:qat --config msvc --config release -- [qat arguments] In the subsequent sections feel free to substitute the QAT binary with this command.","title":"Building with Bazel"},{"location":"QuickStart/building-with-bazel/#building-with-bazel","text":"","title":"Building with Bazel"},{"location":"QuickStart/building-with-bazel/#prerequisites","text":"Building with Bazel is mostly self-contained meaning that Bazel will download most of the dependencies and arrange them in you workspace such that you do not need to checkout submodules or install extra packages. However, following external dependencies needs installing in order to use Bazel for building: C++ compiler (Clang 13/14 or MSVC 14.20) Bazelisk (or Bazel 5.0) We recommend the usage of Bazelisk as it is a wrapper that automatically downloads the correct version of Bazel for your project. The details of installing Bazelisk can be found here . You can also use Bazel without the wrapper. To do this, you need to install Bazel with the exact version specified in the .bazelversion file and in the subsequent sections replace bazelisk with bazel . To install on macOS use brew : brew install bazelisk To install on Windows use choco : choco install bazelisk On any other platform, we suggest you use npm . Note that npm also works with macOS and Windows npm install -g @bazel/bazelisk Once installed, verify that Bazelisk is correctly installed by running bazelisk --help If you experience any trouble with this step, please refer to the official documentation .","title":"Prerequisites"},{"location":"QuickStart/building-with-bazel/#building-qat-using-bazel","text":"Before building, decide whether you are building with clang or msvc as well as whether you wish to make a release build or a debug build. On all operating systems, Bazelisk follows the pattern bazelisk build [target] --config [clang/msvc] --config [debug/release] On macOS and Ubuntu, you can build QAT as bazelisk build //qir/qat:qat --config clang --config release On Windows, you would use the msvc compiler bazelisk build //qir/qat:qat --config msvc --config release You will note that you do not need to checkout submodules and/or install LLVM locally on your machine. Bazel will download all dependencies and compile them from scratch. The benefit of this is that builds are much more reproducible and less dependent on you local system settings. The downside is that build times can be longer since everything is compiled from scratch. You will note that you can run QAT directly using Bazel by bazelisk run //qir/qat:qat --config msvc --config release -- [qat arguments] In the subsequent sections feel free to substitute the QAT binary with this command.","title":"Building QAT using Bazel"},{"location":"QuickStart/building-with-cmake/","text":"Building with CMake Prerequisites It is necessary for you to have the following tools before you get started on making a new build from this project: C++ compiler (Clang 13 or MSVC) CMake LLVM 13 If you are compiling and using the command-line tool, these are necessary tools regardless of whether you plan to develop the library itself. The build configuration is handled by CMake, which informs you if a compiler needs to be installed. On all systems, you will additionally need to check the submodules out. From the root of the repository, run git submodule update --init --recursive Prerequisites on Windows Currently CMake builds are not supported on Windows using PowerShell. Building with CMake on Windows Subsystem for Linux follows the steps outlined for Ubuntu. It is possible to build QAT on Windows Linux Subsystem. Please refer to the Linux build instructions. Prerequisites on macOS Those using macOS can install CMake and LLVM 13 through the use of a command-line tool called brew , as follows: brew install cmake llvm@13 It should not be necessary to install anything else on top of macOS, since the compiler comes preinstalled. Prerequisites on Ubuntu 20.04 Additionally to CMake, you will also require Clang in order to build on Ubuntu 20.04. You can accomplish this by following the steps below: wget -O - https://apt.llvm.org/llvm.sh | bash -s 13 apt install cmake Prerequisites on Ubuntu 22.04 On Ubuntu 22.04, you may need to remove llvm-14 . If you prefer minimal change to your machines configuration, we recommend building with Bazel . To prepare your system with the relevant build tools, install clang , cmake and llvm apt install -y clang-13 cmake llvm-13 llvm-13-dev llvm-13-runtime Building QAT using CMake Once LLVM is installed and you have checkout the submodules, create a build folder. We suggest you use either Debug or Release to indicate what kind of build you wish to perform: mkdir [Debug/Release] cd [Debug/Release] Next, initiate the build directory by running cmake .. and finally, build using make make qat Once qat is compiled, you find it in the folder qir/qat/Apps/ .","title":"Building with CMake"},{"location":"QuickStart/building-with-cmake/#building-with-cmake","text":"","title":"Building with CMake"},{"location":"QuickStart/building-with-cmake/#prerequisites","text":"It is necessary for you to have the following tools before you get started on making a new build from this project: C++ compiler (Clang 13 or MSVC) CMake LLVM 13 If you are compiling and using the command-line tool, these are necessary tools regardless of whether you plan to develop the library itself. The build configuration is handled by CMake, which informs you if a compiler needs to be installed. On all systems, you will additionally need to check the submodules out. From the root of the repository, run git submodule update --init --recursive","title":"Prerequisites"},{"location":"QuickStart/building-with-cmake/#prerequisites-on-windows","text":"Currently CMake builds are not supported on Windows using PowerShell. Building with CMake on Windows Subsystem for Linux follows the steps outlined for Ubuntu. It is possible to build QAT on Windows Linux Subsystem. Please refer to the Linux build instructions.","title":"Prerequisites on Windows"},{"location":"QuickStart/building-with-cmake/#prerequisites-on-macos","text":"Those using macOS can install CMake and LLVM 13 through the use of a command-line tool called brew , as follows: brew install cmake llvm@13 It should not be necessary to install anything else on top of macOS, since the compiler comes preinstalled.","title":"Prerequisites on macOS"},{"location":"QuickStart/building-with-cmake/#prerequisites-on-ubuntu-2004","text":"Additionally to CMake, you will also require Clang in order to build on Ubuntu 20.04. You can accomplish this by following the steps below: wget -O - https://apt.llvm.org/llvm.sh | bash -s 13 apt install cmake","title":"Prerequisites on Ubuntu 20.04"},{"location":"QuickStart/building-with-cmake/#prerequisites-on-ubuntu-2204","text":"On Ubuntu 22.04, you may need to remove llvm-14 . If you prefer minimal change to your machines configuration, we recommend building with Bazel . To prepare your system with the relevant build tools, install clang , cmake and llvm apt install -y clang-13 cmake llvm-13 llvm-13-dev llvm-13-runtime","title":"Prerequisites on Ubuntu 22.04"},{"location":"QuickStart/building-with-cmake/#building-qat-using-cmake","text":"Once LLVM is installed and you have checkout the submodules, create a build folder. We suggest you use either Debug or Release to indicate what kind of build you wish to perform: mkdir [Debug/Release] cd [Debug/Release] Next, initiate the build directory by running cmake .. and finally, build using make make qat Once qat is compiled, you find it in the folder qir/qat/Apps/ .","title":"Building QAT using CMake"},{"location":"QuickStart/running-qat/","text":"Running QAT In the section on targeting QIR we will discuss the individual validators and adaptors. However, for the sake of getting started quickly, in this section, we will take the reader through the basic usage of QAT, its configuration and how to use selected adaptors using examples. Basic usage The easiest way to use QAT is by running it with a target configuration: qat --target-def path/to/target-def.yaml -S -o output.ll input.ll The file target-def.yaml sets the behaviour of QAT, whereas -S tells QAT to emit human readable LLVM code (as opposed to the binary format). The output file is specified by -o and finally, a list of one or more input files is given for QAT to process. Providing more than a single input file, QAT will link these into a single intermediate representation. To get a full list of the commandline arguments and flags, run qat -h or qat --help . Target configuration The target QIR is defined through the target configuration provided as a YAML configuration file. Note that it is possible to configure QAT entirely through the commandline, we recommend the use of YAML configurations as the overall number configurable settings is pretty large. On a high level, the configuration is divided into three sections: qat , adaptor and target . The first section qat is highlevel configuration of QAT and defines things such as whether the target requires adaption, validation and what the adaptor pipeline looks like. The second section adaptor defines the configuration for each of the adaptor components. The third section target defines requirements for the target which QAT will use to validate that the final result really is compliant with the desired target. QAT configuration Before demonstrating how adaptors and target validation can be used, we will briefly examine a few useful settings in the qat section. First and foremost, dump-config is a useful setting that allows the user to dump the current configuration. To provide compatibility with the human readable IR, the config is dumped as comments. This feature is in particular useful as a commandline flag qat --target-def path/to/target-def.yaml -S --dump-config input.ll > output.ll Note that rather than using the -o option, we redirect the output into the output file. This is capture the configuration together with the resulting output of QAT and ensure that the two are kept together for reproducibility. Another couple of useful features are strip-exisiting-dbg and add-ir-debug . These two can be set from the command line using --strip-exisiting-dbg and --add-ir-debug , respectively. The first, strip-exisiting-dbg , removes all existing debug information from the loaded modules. The other add-ir-debug adds debug symbols referring to the LL file itself. This is discussed in detail here . Adaptor examples In this section we will demonstrate some of the adaptor examples which manipulate the IR to conform to target specification. In many of the sections below, we will refer to demos. From the repository root, these can be found in the folder qir/demos . A prerequisite to running the demos is to have an environment variable QAT_BINARY containing the path to the QAT binary. In each demo directory there is a Makefile with suggested commands to run. Inlining One of the first important examples of QAT is replication of some of the LLVM functionality. In this and the next section, we will demonstrate some aspects of this as we discuss the LLVM adaptor. This adaptor provides capabilities for function inlining, loop unrolling, dead code elimination. In this first example, we dicuss inlining and its relevance in construction of quantum programs. Consider a Q# program that has a MiniCircuit which we want to use at two distinct places, such as operation MiniCircuit(q1: Qubit,q2: Qubit): Unit { H(q1); H(q2); CNOT(q1, q2); } operation Main(): Unit { use q1 = Qubit(); use q2 = Qubit(); MiniCircuit(q1, q2); MiniCircuit(q1, q2); } This program produces IR similar to define internal void @InlineExample__Main__body() { entry: call void @InlineExample__MiniCircuit__body(%Qubit* null, %Qubit* nonnull inttoptr (i64 1 to %Qubit*)) call void @InlineExample__MiniCircuit__body(%Qubit* null, %Qubit* nonnull inttoptr (i64 1 to %Qubit*)) ret void } define internal void @InlineExample__MiniCircuit__body(%Qubit* %q1, %Qubit* %q2) { entry: call void @Microsoft__Quantum__Intrinsic__H__body(%Qubit* %q1) call void @Microsoft__Quantum__Intrinsic__H__body(%Qubit* %q2) call void @Microsoft__Quantum__Intrinsic__CNOT__body(%Qubit* %q1, %Qubit* %q2) ret void } Any backend without support for function calls would not be able to run this program. However, if we would inline the functions to the place where they are called, we would not need function call as a requirement for the backend. Function inlining is used classically and LLVM provides a ready made inliner pass that we can use. This integrated into QAT and can be ran as follows: qat --always-inline -S --apply -o output.ll input.ll The resulting IR becomes: define void @ InlineExample__Main() #0 { entry: call void @__quantum__qis__h__body(%Qubit* null) call void @__quantum__qis__h__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*)) call void @__quantum__qis__cnot__body(%Qubit* null, %Qubit* nonnull inttoptr (i64 1 to %Qubit*)) call void @__quantum__qis__h__body(%Qubit* null) call void @__quantum__qis__h__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*)) call void @__quantum__qis__cnot__body(%Qubit* null, %Qubit* nonnull inttoptr (i64 1 to %Qubit*)) ret void } The LLVM optimisation adaptor exposes the inlining configuration thereby providing some control over the behaviour. A similar example can be found in qir/demos/Inlining . The key benefit is that we can write programs where subcircuits are separated in to functions without having to rely on the backend supporting function calls. This is one important aspect of writing parameterised quantum programs. The other aspect is loop unrolling which we will touch upon in the next section. Loop unrolling Another important LLVM pass is the loop unrolling pass. Loop unrolling in combination with inlining allows to fully parameterize subcircuits. In our example from before, we could imagine a scenario where the function MiniCircuit would take an extra integer N parameter and apply an H-gate N times. With loop unrolling this would become a series of H gates with no additional control or need for branching, and using inlining, subcircuits would be placed directly in the main program. OPENQASM 3; int n_iterations = 5; int iteration = 0; qubit q; while (iteration < n_iterations) { h q; iteration += 1; } The above OpenQASM program can be translated into a QIR similar to: define internal void @loop_unrolling() { entry: br label %header__1 header__1: %0 = phi i64 [ 1, %entry ], [ %2, %body__1 ] %1 = icmp slt i64 %0, 6 br i1 %1, label %body__1, label %exit__1 body__1: call void @__quantum__qis__h__body(%Qubit* null) %2 = add i64 %0, 1 br label %header__1 exit__1: ret void } The control logic associated with the loop gives rise to a phi node which most of todays hardware backends would not be able to handle. However, since hte loop is constant in length, we can unroll the loop by using the unroll-loop parameter: qat --apply -S --unroll-loops input.ll This simplifies the code to a series of H gates applied to the zero'th qubit: define internal void @loop_unrolling() { entry: call void @__quantum__qis__h__body(%Qubit* null) call void @__quantum__qis__h__body(%Qubit* null) call void @__quantum__qis__h__body(%Qubit* null) call void @__quantum__qis__h__body(%Qubit* null) call void @__quantum__qis__h__body(%Qubit* null) ret void } The inlining and loop unrolling passes are the most significant passes used from the LLVM framework. The LLVM adaptor also have a few other passes. The details of these are described briefly in the commandline help page which can be found by running qat -h . Static resource allocation The generic QIR allows for dynamic qubit allocation as the default way to allocate qubits. One of the core differences between simulators and hardware backends is how qubits are allocated: While simulators, in theory, can allocate as many qubits as need dynamically, hardware backends has a hard limit on the number of qubits and futher more, does not implement the necessary logic to perform dynamic management. For this reason, it is necessary to transform dynamic qubit management into static allocation in order to make certain QIRs compatible with backends that does not implement qubit management. In this example, we demonstrate the \"Target QIS mapping\" adaptor and how it can be used to transform dynamic qubit management into static allocations. Consider the program OPENQASM 3; qubit q; h q; The equivalent generic QIR is define void @example() #0 { entry: %q = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %q) call void @__quantum__rt__qubit_release(%Qubit* %q) ret void } We note that the use of __quantum__rt__qubit_allocate and __quantum__rt__qubit_release which are the functions that can be problematic for hardware backends. Running qat --use-static-qubit-allocation --apply -S input.ll will transform the input to define void @example() #0 { entry: call void @__quantum__qis__h__body(%Qubit* null) ret void } This demo is found in qir/demo/QubitAllocation . Note that static qubit allocation is not a straight forward task and there are many corner cases for which it simply will not work. For instance, recusively allocating qubit where recursion stops on a runtime parameter is one case that cannot be mapped. QAT does a best effort, but at this point there is no garantuee of correctness. Advanced experimental features are available by adding the flag --experimental to the command line arguments. Run qat --experimental -h to see these parameters and their description. Replacement linking In this example we consider two quantum computers. The first computer implements z and cnot . The second computer implements x , h and cnot . OPENQASM 3; qubit a; qubit b; z a; cnot a b; After compiling to QIR we get ( main.ll ), define void @example() #0 { entry: %a = call %Qubit* @__quantum__rt__qubit_allocate() %b = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__z__body(%Qubit* %a) call void @__quantum__qis__cnot__body(%Qubit* %a, %Qubit* %b) call void @__quantum__rt__qubit_release(%Qubit* %b) call void @__quantum__rt__qubit_release(%Qubit* %a) ret void } Obviously, this code will not run on the second computer since that machine does it makes use of a z gate. While we could rewrite the frontend code, the beauti of an intermediate represenation is that such tasks can be performed at this level and hence, the user does not need to worry about hardware compatibility of the frontend code. QAT allows to address this issue by using a concept known as replacement linking. Replacement linking is linking process by which one function call is replaced by another if the and only if the other function is present in the IR. To facilitate this, we annotate the function __quantum__qis__z__body as follows: declare void @__quantum__qis__z__body(%Qubit*) #1 attributes #1 = { \"replaceWith\"=\"soft_z\" } This states taht if the function soft_z is available, replace all calls to __quantum__qis__z__body with soft_z . Passing the main.ll through QAT does not result in any changes. However, adding a lib.ll with following code: define void @soft_z(%Qubit* %q) { entry: call void @__quantum__qis__h__body(%Qubit* %q) call void @__quantum__qis__x__body(%Qubit* %q) call void @__quantum__qis__h__body(%Qubit* %q) ret void } will replace the calls __quantum__qis__z__body in main.ll . This is done by invoking QAT as follows: qat --apply -S --target-def target.yaml --validate main.ll lib.ll From the repository root, the code for this example can be found in qat/demos/ReplaceLinking . In this concrete demo, calling qat --apply -S --target-def target.yaml --no-always-inline --validate main.ll lib.ll produces ; ModuleID = 'qat-link' source_filename = \"qat-link\" %Qubit = type opaque define void @example() #0 { entry: call void @soft_z(%Qubit* null) call void @__quantum__qis__cnot__body(%Qubit* null, %Qubit* nonnull inttoptr (i64 1 to %Qubit*)) ret void } declare %Qubit* @__quantum__rt__qubit_allocate() declare void @__quantum__qis__cnot__body(%Qubit*, %Qubit*) declare void @__quantum__rt__qubit_release(%Qubit*) define void @soft_z(%Qubit* %q) #1 { entry: call void @__quantum__qis__h__body(%Qubit* %q) call void @__quantum__qis__x__body(%Qubit* %q) call void @__quantum__qis__h__body(%Qubit* %q) ret void } declare void @__quantum__qis__h__body(%Qubit*) declare void @__quantum__qis__x__body(%Qubit*) attributes #0 = { \"EntryPoint\" \"maxQubitIndex\"=\"1\" \"maxResultIndex\"=\"0\" \"requiredQubits\"=\"2\" \"requiredResults\"=\"0\" } attributes #1 = { \"maxQubitIndex\"=\"0\" \"maxResultIndex\"=\"0\" \"requiredQubits\"=\"0\" \"requiredResults\"=\"0\" } as would be expected. We note that we have disabled inlining as to maintain the function soft_z . Each backend can now provide a library that makes software implementations of the gates that are not supported natively by the system. Grouping QIS Grouping QIS is an experimental adaptor that allows separation of the classical operations and pure quantum circuits. In this section we will concentrate on showing how to use this feature. If you are interested in the TODO(tfr): Write this section once the cicruit separation has been revised.","title":"Running QAT"},{"location":"QuickStart/running-qat/#running-qat","text":"In the section on targeting QIR we will discuss the individual validators and adaptors. However, for the sake of getting started quickly, in this section, we will take the reader through the basic usage of QAT, its configuration and how to use selected adaptors using examples.","title":"Running QAT"},{"location":"QuickStart/running-qat/#basic-usage","text":"The easiest way to use QAT is by running it with a target configuration: qat --target-def path/to/target-def.yaml -S -o output.ll input.ll The file target-def.yaml sets the behaviour of QAT, whereas -S tells QAT to emit human readable LLVM code (as opposed to the binary format). The output file is specified by -o and finally, a list of one or more input files is given for QAT to process. Providing more than a single input file, QAT will link these into a single intermediate representation. To get a full list of the commandline arguments and flags, run qat -h or qat --help .","title":"Basic usage"},{"location":"QuickStart/running-qat/#target-configuration","text":"The target QIR is defined through the target configuration provided as a YAML configuration file. Note that it is possible to configure QAT entirely through the commandline, we recommend the use of YAML configurations as the overall number configurable settings is pretty large. On a high level, the configuration is divided into three sections: qat , adaptor and target . The first section qat is highlevel configuration of QAT and defines things such as whether the target requires adaption, validation and what the adaptor pipeline looks like. The second section adaptor defines the configuration for each of the adaptor components. The third section target defines requirements for the target which QAT will use to validate that the final result really is compliant with the desired target.","title":"Target configuration"},{"location":"QuickStart/running-qat/#qat-configuration","text":"Before demonstrating how adaptors and target validation can be used, we will briefly examine a few useful settings in the qat section. First and foremost, dump-config is a useful setting that allows the user to dump the current configuration. To provide compatibility with the human readable IR, the config is dumped as comments. This feature is in particular useful as a commandline flag qat --target-def path/to/target-def.yaml -S --dump-config input.ll > output.ll Note that rather than using the -o option, we redirect the output into the output file. This is capture the configuration together with the resulting output of QAT and ensure that the two are kept together for reproducibility. Another couple of useful features are strip-exisiting-dbg and add-ir-debug . These two can be set from the command line using --strip-exisiting-dbg and --add-ir-debug , respectively. The first, strip-exisiting-dbg , removes all existing debug information from the loaded modules. The other add-ir-debug adds debug symbols referring to the LL file itself. This is discussed in detail here .","title":"QAT configuration"},{"location":"QuickStart/running-qat/#adaptor-examples","text":"In this section we will demonstrate some of the adaptor examples which manipulate the IR to conform to target specification. In many of the sections below, we will refer to demos. From the repository root, these can be found in the folder qir/demos . A prerequisite to running the demos is to have an environment variable QAT_BINARY containing the path to the QAT binary. In each demo directory there is a Makefile with suggested commands to run.","title":"Adaptor examples"},{"location":"QuickStart/running-qat/#inlining","text":"One of the first important examples of QAT is replication of some of the LLVM functionality. In this and the next section, we will demonstrate some aspects of this as we discuss the LLVM adaptor. This adaptor provides capabilities for function inlining, loop unrolling, dead code elimination. In this first example, we dicuss inlining and its relevance in construction of quantum programs. Consider a Q# program that has a MiniCircuit which we want to use at two distinct places, such as operation MiniCircuit(q1: Qubit,q2: Qubit): Unit { H(q1); H(q2); CNOT(q1, q2); } operation Main(): Unit { use q1 = Qubit(); use q2 = Qubit(); MiniCircuit(q1, q2); MiniCircuit(q1, q2); } This program produces IR similar to define internal void @InlineExample__Main__body() { entry: call void @InlineExample__MiniCircuit__body(%Qubit* null, %Qubit* nonnull inttoptr (i64 1 to %Qubit*)) call void @InlineExample__MiniCircuit__body(%Qubit* null, %Qubit* nonnull inttoptr (i64 1 to %Qubit*)) ret void } define internal void @InlineExample__MiniCircuit__body(%Qubit* %q1, %Qubit* %q2) { entry: call void @Microsoft__Quantum__Intrinsic__H__body(%Qubit* %q1) call void @Microsoft__Quantum__Intrinsic__H__body(%Qubit* %q2) call void @Microsoft__Quantum__Intrinsic__CNOT__body(%Qubit* %q1, %Qubit* %q2) ret void } Any backend without support for function calls would not be able to run this program. However, if we would inline the functions to the place where they are called, we would not need function call as a requirement for the backend. Function inlining is used classically and LLVM provides a ready made inliner pass that we can use. This integrated into QAT and can be ran as follows: qat --always-inline -S --apply -o output.ll input.ll The resulting IR becomes: define void @ InlineExample__Main() #0 { entry: call void @__quantum__qis__h__body(%Qubit* null) call void @__quantum__qis__h__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*)) call void @__quantum__qis__cnot__body(%Qubit* null, %Qubit* nonnull inttoptr (i64 1 to %Qubit*)) call void @__quantum__qis__h__body(%Qubit* null) call void @__quantum__qis__h__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*)) call void @__quantum__qis__cnot__body(%Qubit* null, %Qubit* nonnull inttoptr (i64 1 to %Qubit*)) ret void } The LLVM optimisation adaptor exposes the inlining configuration thereby providing some control over the behaviour. A similar example can be found in qir/demos/Inlining . The key benefit is that we can write programs where subcircuits are separated in to functions without having to rely on the backend supporting function calls. This is one important aspect of writing parameterised quantum programs. The other aspect is loop unrolling which we will touch upon in the next section.","title":"Inlining"},{"location":"QuickStart/running-qat/#loop-unrolling","text":"Another important LLVM pass is the loop unrolling pass. Loop unrolling in combination with inlining allows to fully parameterize subcircuits. In our example from before, we could imagine a scenario where the function MiniCircuit would take an extra integer N parameter and apply an H-gate N times. With loop unrolling this would become a series of H gates with no additional control or need for branching, and using inlining, subcircuits would be placed directly in the main program. OPENQASM 3; int n_iterations = 5; int iteration = 0; qubit q; while (iteration < n_iterations) { h q; iteration += 1; } The above OpenQASM program can be translated into a QIR similar to: define internal void @loop_unrolling() { entry: br label %header__1 header__1: %0 = phi i64 [ 1, %entry ], [ %2, %body__1 ] %1 = icmp slt i64 %0, 6 br i1 %1, label %body__1, label %exit__1 body__1: call void @__quantum__qis__h__body(%Qubit* null) %2 = add i64 %0, 1 br label %header__1 exit__1: ret void } The control logic associated with the loop gives rise to a phi node which most of todays hardware backends would not be able to handle. However, since hte loop is constant in length, we can unroll the loop by using the unroll-loop parameter: qat --apply -S --unroll-loops input.ll This simplifies the code to a series of H gates applied to the zero'th qubit: define internal void @loop_unrolling() { entry: call void @__quantum__qis__h__body(%Qubit* null) call void @__quantum__qis__h__body(%Qubit* null) call void @__quantum__qis__h__body(%Qubit* null) call void @__quantum__qis__h__body(%Qubit* null) call void @__quantum__qis__h__body(%Qubit* null) ret void } The inlining and loop unrolling passes are the most significant passes used from the LLVM framework. The LLVM adaptor also have a few other passes. The details of these are described briefly in the commandline help page which can be found by running qat -h .","title":"Loop unrolling"},{"location":"QuickStart/running-qat/#static-resource-allocation","text":"The generic QIR allows for dynamic qubit allocation as the default way to allocate qubits. One of the core differences between simulators and hardware backends is how qubits are allocated: While simulators, in theory, can allocate as many qubits as need dynamically, hardware backends has a hard limit on the number of qubits and futher more, does not implement the necessary logic to perform dynamic management. For this reason, it is necessary to transform dynamic qubit management into static allocation in order to make certain QIRs compatible with backends that does not implement qubit management. In this example, we demonstrate the \"Target QIS mapping\" adaptor and how it can be used to transform dynamic qubit management into static allocations. Consider the program OPENQASM 3; qubit q; h q; The equivalent generic QIR is define void @example() #0 { entry: %q = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %q) call void @__quantum__rt__qubit_release(%Qubit* %q) ret void } We note that the use of __quantum__rt__qubit_allocate and __quantum__rt__qubit_release which are the functions that can be problematic for hardware backends. Running qat --use-static-qubit-allocation --apply -S input.ll will transform the input to define void @example() #0 { entry: call void @__quantum__qis__h__body(%Qubit* null) ret void } This demo is found in qir/demo/QubitAllocation . Note that static qubit allocation is not a straight forward task and there are many corner cases for which it simply will not work. For instance, recusively allocating qubit where recursion stops on a runtime parameter is one case that cannot be mapped. QAT does a best effort, but at this point there is no garantuee of correctness. Advanced experimental features are available by adding the flag --experimental to the command line arguments. Run qat --experimental -h to see these parameters and their description.","title":"Static resource allocation"},{"location":"QuickStart/running-qat/#replacement-linking","text":"In this example we consider two quantum computers. The first computer implements z and cnot . The second computer implements x , h and cnot . OPENQASM 3; qubit a; qubit b; z a; cnot a b; After compiling to QIR we get ( main.ll ), define void @example() #0 { entry: %a = call %Qubit* @__quantum__rt__qubit_allocate() %b = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__z__body(%Qubit* %a) call void @__quantum__qis__cnot__body(%Qubit* %a, %Qubit* %b) call void @__quantum__rt__qubit_release(%Qubit* %b) call void @__quantum__rt__qubit_release(%Qubit* %a) ret void } Obviously, this code will not run on the second computer since that machine does it makes use of a z gate. While we could rewrite the frontend code, the beauti of an intermediate represenation is that such tasks can be performed at this level and hence, the user does not need to worry about hardware compatibility of the frontend code. QAT allows to address this issue by using a concept known as replacement linking. Replacement linking is linking process by which one function call is replaced by another if the and only if the other function is present in the IR. To facilitate this, we annotate the function __quantum__qis__z__body as follows: declare void @__quantum__qis__z__body(%Qubit*) #1 attributes #1 = { \"replaceWith\"=\"soft_z\" } This states taht if the function soft_z is available, replace all calls to __quantum__qis__z__body with soft_z . Passing the main.ll through QAT does not result in any changes. However, adding a lib.ll with following code: define void @soft_z(%Qubit* %q) { entry: call void @__quantum__qis__h__body(%Qubit* %q) call void @__quantum__qis__x__body(%Qubit* %q) call void @__quantum__qis__h__body(%Qubit* %q) ret void } will replace the calls __quantum__qis__z__body in main.ll . This is done by invoking QAT as follows: qat --apply -S --target-def target.yaml --validate main.ll lib.ll From the repository root, the code for this example can be found in qat/demos/ReplaceLinking . In this concrete demo, calling qat --apply -S --target-def target.yaml --no-always-inline --validate main.ll lib.ll produces ; ModuleID = 'qat-link' source_filename = \"qat-link\" %Qubit = type opaque define void @example() #0 { entry: call void @soft_z(%Qubit* null) call void @__quantum__qis__cnot__body(%Qubit* null, %Qubit* nonnull inttoptr (i64 1 to %Qubit*)) ret void } declare %Qubit* @__quantum__rt__qubit_allocate() declare void @__quantum__qis__cnot__body(%Qubit*, %Qubit*) declare void @__quantum__rt__qubit_release(%Qubit*) define void @soft_z(%Qubit* %q) #1 { entry: call void @__quantum__qis__h__body(%Qubit* %q) call void @__quantum__qis__x__body(%Qubit* %q) call void @__quantum__qis__h__body(%Qubit* %q) ret void } declare void @__quantum__qis__h__body(%Qubit*) declare void @__quantum__qis__x__body(%Qubit*) attributes #0 = { \"EntryPoint\" \"maxQubitIndex\"=\"1\" \"maxResultIndex\"=\"0\" \"requiredQubits\"=\"2\" \"requiredResults\"=\"0\" } attributes #1 = { \"maxQubitIndex\"=\"0\" \"maxResultIndex\"=\"0\" \"requiredQubits\"=\"0\" \"requiredResults\"=\"0\" } as would be expected. We note that we have disabled inlining as to maintain the function soft_z . Each backend can now provide a library that makes software implementations of the gates that are not supported natively by the system.","title":"Replacement linking"},{"location":"QuickStart/running-qat/#grouping-qis","text":"Grouping QIS is an experimental adaptor that allows separation of the classical operations and pure quantum circuits. In this section we will concentrate on showing how to use this feature. If you are interested in the TODO(tfr): Write this section once the cicruit separation has been revised.","title":"Grouping QIS"},{"location":"UsingQAT/DebuggingIR/","text":"Debugging an LLVM IR Quick start with basic example Assuming that you have compiled qat and have its location in your PATH environment variable, create a C++ file called segfault.cpp with following contents: int main() { int *ptr = nullptr; ptr[10299] = ptr[10299 * 2777] + 2; return ptr[99]; } Then run following commands clang++ -O3 -c -S -emit-llvm segfault.cpp qat -S segfault.ll > with_debug.ll mkdir -p bin llc -filetype=obj -o bin/segfault.o with_debug.ll clang++ -g -O1 bin/segfault.o -o bin/segfault lldb bin/segfault Running the program in lldb should now create a stack trace that refers to the segfault.ll file rather than the original segfault.cpp file: (lldb) target create \"bin/segfault\" Current executable set to '/path/to/test/bin/segfault' (x86_64). (lldb) r Process 25334 launched: '/path/to/test/bin/segfault' (x86_64) Process 25334 stopped * thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x6d1a00c) frame #0: 0x0000000100003f60 segfault`main at segfault.ll:8:74 5 6 ; Function Attrs: nofree norecurse nounwind ssp uwtable 7 define i32 @main() local_unnamed_addr #0 { -> 8 %1 = load i32, i32* inttoptr (i64 114401292 to i32*), align 4, !tbaa !3 9 %2 = add nsw i32 %1, 2 10 store i32 %2, i32* inttoptr (i64 41196 to i32*), align 4, !tbaa !3 11 %3 = load i32, i32* inttoptr (i64 396 to i32*), align 4, !tbaa !3 Detailed basic example In this example, we generate a simple program that will cause a segmentation fault. The main program int main() { int *ptr = nullptr; ptr[10299] = ptr[10299 * 2777] + 2; return ptr[99]; } To generate the IR, we use clang with -emit-llvm clang++ -O3 -c -S -emit-llvm segfault.cpp which generates a file called segfault.ll . The main content of this file should be similar to: define i32 @main() local_unnamed_addr #0 { %1 = load i32, i32* inttoptr (i64 114401292 to i32*), align 4, !tbaa !3 %2 = add nsw i32 %1, 2 store i32 %2, i32* inttoptr (i64 41196 to i32*), align 4, !tbaa !3 %3 = load i32, i32* inttoptr (i64 396 to i32*), align 4, !tbaa !3 ret i32 %3 } We would expect that the program would segfault at the line starting with %1 as we have not allocated any memory. To create an IR with debug information, we use qat as follows: qat -S --add-ir-debug segfault.ll > segfault.dbg.ll This command will add debug information referring to the original segfault.ll places where no debug information is present. In case that the .ll file already have debug information, we can strip that using --strip-existing-dbg : qat -S --strip-existing-dbg --add-ir-debug segfault.ll > segfault.dbg.ll Next we transform the new .ll file into an executable: mkdir -p bin llc -filetype=obj -o bin/segfault.o segfault.dbg.ll clang++ -g -O1 bin/segfault.o -o bin/segfault Running this program in lldb , we will now get stack traces that refer to the .ll file rather than than .cpp file: % lldb bin/segfault (lldb) target create \"bin/segfault\" Current executable set to '/path/to/test/bin/segfault' (x86_64). (lldb) r Process 25334 launched: '/path/to/test/bin/segfault' (x86_64) Process 25334 stopped * thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x6d1a00c) frame #0: 0x0000000100003f60 segfault`main at segfault.ll:8:74 5 6 ; Function Attrs: nofree norecurse nounwind ssp uwtable 7 define i32 @main() local_unnamed_addr #0 { -> 8 %1 = load i32, i32* inttoptr (i64 114401292 to i32*), align 4, !tbaa !3 9 %2 = add nsw i32 %1, 2 10 store i32 %2, i32* inttoptr (i64 41196 to i32*), align 4, !tbaa !3 11 %3 = load i32, i32* inttoptr (i64 396 to i32*), align 4, !tbaa !3 In this way, we can now trace the origin of an issue to the LLVM IR rather than the original source file. Mixing IR with runtime In this section we consider a slightly more complicated example where we want to debug an IR combined with a runtime. Our runtime looks as follows: int foo(); int ir_recurse(int); int standard_recurse(int n) { if (n <= 0) { return foo(); } return ir_recurse(n - 1); } int main() { int x = 2; return standard_recurse(20) + 2 * x; } As in the previous example, our IR will produce a segmentation fault. To ensure that we get a stack trace containing traces of both the runtime and the IR, we use a recursive function that alternates between using functionality in the runtime and the main IR itself: int standard_recurse(int); int foo() { int *ptr = nullptr; ptr[10299] = ptr[10299 * 2777] + 2; return ptr[99]; } int ir_recurse(int n) { if (n <= 0) { return foo(); } return standard_recurse(n - 1); } As in the previous example, we annotate foo.ll with debug information using QAT before creating the object file and linking: clang++ -c -g -o bin/runtime.o runtime.cpp clang++ -c -S -emit-llvm foo.cpp qat -S --add-ir-debug foo.ll > foo.dbg.ll mkdir -p bin llc -filetype=obj -o bin/foo.dbg.o foo.dbg.ll clang++ -g bin/foo.dbg.o bin/runtime.o -o bin/qir_program Running the debugger, we can now execute the program and produce a stack trace as in the previous examples: Current executable set to '/path/to/test/bin/qir_program' (x86_64). (lldb) r Process 54371 launched: '/path/to/test/bin/qir_program' (x86_64) Process 54371 stopped * thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x6d1a00c) frame #0: 0x0000000100003e89 qir_program`_Z3foov at foo.ll:12:34 9 store i32* null, i32** %1, align 8 10 %2 = load i32*, i32** %1, align 8 11 %3 = getelementptr inbounds i32, i32* %2, i64 28600323 -> 12 %4 = load i32, i32* %3, align 4 13 %5 = add nsw i32 %4, 2 14 %6 = load i32*, i32** %1, align 8 15 %7 = getelementptr inbounds i32, i32* %6, i64 10299 (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x6d1a00c) * frame #0: 0x0000000100003e89 qir_program`_Z3foov at foo.ll:12:34 frame #1: 0x0000000100003efa qir_program`standard_recurse(n=0) at runtime.cpp:9:12 frame #2: 0x0000000100003ecb qir_program`_Z10ir_recursei at foo.ll:40:49 frame #3: 0x0000000100003f0f qir_program`standard_recurse(n=2) at runtime.cpp:11:10 frame #4: 0x0000000100003ecb qir_program`_Z10ir_recursei at foo.ll:40:49 frame #5: 0x0000000100003f0f qir_program`standard_recurse(n=4) at runtime.cpp:11:10 frame #6: 0x0000000100003ecb qir_program`_Z10ir_recursei at foo.ll:40:49 frame #7: 0x0000000100003f0f qir_program`standard_recurse(n=6) at runtime.cpp:11:10 frame #8: 0x0000000100003ecb qir_program`_Z10ir_recursei at foo.ll:40:49 frame #9: 0x0000000100003f0f qir_program`standard_recurse(n=8) at runtime.cpp:11:10 frame #10: 0x0000000100003ecb qir_program`_Z10ir_recursei at foo.ll:40:49 frame #11: 0x0000000100003f0f qir_program`standard_recurse(n=10) at runtime.cpp:11:10 frame #12: 0x0000000100003ecb qir_program`_Z10ir_recursei at foo.ll:40:49 frame #13: 0x0000000100003f0f qir_program`standard_recurse(n=12) at runtime.cpp:11:10 frame #14: 0x0000000100003ecb qir_program`_Z10ir_recursei at foo.ll:40:49 frame #15: 0x0000000100003f0f qir_program`standard_recurse(n=14) at runtime.cpp:11:10 frame #16: 0x0000000100003ecb qir_program`_Z10ir_recursei at foo.ll:40:49 frame #17: 0x0000000100003f0f qir_program`standard_recurse(n=16) at runtime.cpp:11:10 frame #18: 0x0000000100003ecb qir_program`_Z10ir_recursei at foo.ll:40:49 frame #19: 0x0000000100003f0f qir_program`standard_recurse(n=18) at runtime.cpp:11:10 frame #20: 0x0000000100003ecb qir_program`_Z10ir_recursei at foo.ll:40:49 frame #21: 0x0000000100003f0f qir_program`standard_recurse(n=20) at runtime.cpp:11:10 frame #22: 0x0000000100003f40 qir_program`main at runtime.cpp:17:10 frame #23: 0x000000010000d51e dyld`start + 462 (lldb) f 1 frame #1: 0x0000000100003efa qir_program`standard_recurse(n=0) at runtime.cpp:9:12 6 { 7 if (n <= 0) 8 { -> 9 return foo(); 10 } 11 return ir_recurse(n - 1); 12 } (lldb) We note how this incorporates traces from both runtime.cpp and foo.ll with exact line reference. In this way, it is possible to debug in a similar manner to what we are used to from classical computing. Multi-IR projects Occasionally, we may want combine multiple IRs to produce one debuggable executable. We note that we can choose two paths: Either we link at the IR level, or we link at the object level. Unfortunately, LLVM does not produce adequate debug symbols when multiple compilation units are defined in the same IR. Hence, if we wish to follow the path of the former, we first need to combine the IRs and then add debug information with reference to the one combined file : qat -S foo.ll bar.ll > combined.ll qat -S --strip-existing-dbg --add-ir-debug combined.ll > combined.dbg.ll However, this approach looses the information about the location of the original files foo.ll and bar.ll : * thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x6d1a00c) * frame #0: 0x0000000100003ec9 combined_example`_Z3foov at combined.ll:11:34 frame #1: 0x0000000100003f2e combined_example`_Z16standard_recursei at combined.ll:57:37 frame #2: 0x0000000100003f0b combined_example`_Z10ir_recursei at combined.ll:38:49 frame #3: 0x0000000100003f3b combined_example`_Z16standard_recursei at combined.ll:64:53 frame #4: 0x0000000100003f0b combined_example`_Z10ir_recursei at combined.ll:38:49 frame #5: 0x0000000100003f3b combined_example`_Z16standard_recursei at combined.ll:64:53 frame #6: 0x0000000100003f0b combined_example`_Z10ir_recursei at combined.ll:38:49 frame #7: 0x0000000100003f3b combined_example`_Z16standard_recursei at combined.ll:64:53 frame #8: 0x0000000100003f0b combined_example`_Z10ir_recursei at combined.ll:38:49 frame #9: 0x0000000100003f3b combined_example`_Z16standard_recursei at combined.ll:64:53 frame #10: 0x0000000100003f0b combined_example`_Z10ir_recursei at combined.ll:38:49 frame #11: 0x0000000100003f3b combined_example`_Z16standard_recursei at combined.ll:64:53 frame #12: 0x0000000100003f0b combined_example`_Z10ir_recursei at combined.ll:38:49 frame #13: 0x0000000100003f3b combined_example`_Z16standard_recursei at combined.ll:64:53 frame #14: 0x0000000100003f0b combined_example`_Z10ir_recursei at combined.ll:38:49 frame #15: 0x0000000100003f3b combined_example`_Z16standard_recursei at combined.ll:64:53 frame #16: 0x0000000100003f0b combined_example`_Z10ir_recursei at combined.ll:38:49 frame #17: 0x0000000100003f3b combined_example`_Z16standard_recursei at combined.ll:64:53 frame #18: 0x0000000100003f0b combined_example`_Z10ir_recursei at combined.ll:38:49 frame #19: 0x0000000100003f3b combined_example`_Z16standard_recursei at combined.ll:64:53 frame #20: 0x0000000100003f0b combined_example`_Z10ir_recursei at combined.ll:38:49 frame #21: 0x0000000100003f3b combined_example`_Z16standard_recursei at combined.ll:64:53 frame #22: 0x0000000100003f6a combined_example`main at combined.ll:82:57 frame #23: 0x000000010000d51e dyld`start + 462 To keep information about the original files, we have to turn to the second approach where we create separate object files. This will prevent some optimisations such as inlining, but will ensure that we can trace locations in the individual files: clang++ -c -S -emit-llvm foo.cpp clang++ -c -S -emit-llvm bar.cpp qat -S --add-ir-debug foo.ll > foo.dbg.ll qat -S --add-ir-debug bar.ll > bar.dbg.ll mkdir -p bin llc -filetype=obj -o bin/foo.dbg.o foo.dbg.ll llc -filetype=obj -o bin/bar.dbg.o bar.dbg.ll clang++ -g bin/foo.dbg.o bin/bar.dbg.o -o bin/foo_bar_example The executable will now contain debug symbols referring to foo.ll and bar.ll .","title":"Debugging a QIR"},{"location":"UsingQAT/DebuggingIR/#debugging-an-llvm-ir","text":"","title":"Debugging an LLVM IR"},{"location":"UsingQAT/DebuggingIR/#quick-start-with-basic-example","text":"Assuming that you have compiled qat and have its location in your PATH environment variable, create a C++ file called segfault.cpp with following contents: int main() { int *ptr = nullptr; ptr[10299] = ptr[10299 * 2777] + 2; return ptr[99]; } Then run following commands clang++ -O3 -c -S -emit-llvm segfault.cpp qat -S segfault.ll > with_debug.ll mkdir -p bin llc -filetype=obj -o bin/segfault.o with_debug.ll clang++ -g -O1 bin/segfault.o -o bin/segfault lldb bin/segfault Running the program in lldb should now create a stack trace that refers to the segfault.ll file rather than the original segfault.cpp file: (lldb) target create \"bin/segfault\" Current executable set to '/path/to/test/bin/segfault' (x86_64). (lldb) r Process 25334 launched: '/path/to/test/bin/segfault' (x86_64) Process 25334 stopped * thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x6d1a00c) frame #0: 0x0000000100003f60 segfault`main at segfault.ll:8:74 5 6 ; Function Attrs: nofree norecurse nounwind ssp uwtable 7 define i32 @main() local_unnamed_addr #0 { -> 8 %1 = load i32, i32* inttoptr (i64 114401292 to i32*), align 4, !tbaa !3 9 %2 = add nsw i32 %1, 2 10 store i32 %2, i32* inttoptr (i64 41196 to i32*), align 4, !tbaa !3 11 %3 = load i32, i32* inttoptr (i64 396 to i32*), align 4, !tbaa !3","title":"Quick start with basic example"},{"location":"UsingQAT/DebuggingIR/#detailed-basic-example","text":"In this example, we generate a simple program that will cause a segmentation fault. The main program int main() { int *ptr = nullptr; ptr[10299] = ptr[10299 * 2777] + 2; return ptr[99]; } To generate the IR, we use clang with -emit-llvm clang++ -O3 -c -S -emit-llvm segfault.cpp which generates a file called segfault.ll . The main content of this file should be similar to: define i32 @main() local_unnamed_addr #0 { %1 = load i32, i32* inttoptr (i64 114401292 to i32*), align 4, !tbaa !3 %2 = add nsw i32 %1, 2 store i32 %2, i32* inttoptr (i64 41196 to i32*), align 4, !tbaa !3 %3 = load i32, i32* inttoptr (i64 396 to i32*), align 4, !tbaa !3 ret i32 %3 } We would expect that the program would segfault at the line starting with %1 as we have not allocated any memory. To create an IR with debug information, we use qat as follows: qat -S --add-ir-debug segfault.ll > segfault.dbg.ll This command will add debug information referring to the original segfault.ll places where no debug information is present. In case that the .ll file already have debug information, we can strip that using --strip-existing-dbg : qat -S --strip-existing-dbg --add-ir-debug segfault.ll > segfault.dbg.ll Next we transform the new .ll file into an executable: mkdir -p bin llc -filetype=obj -o bin/segfault.o segfault.dbg.ll clang++ -g -O1 bin/segfault.o -o bin/segfault Running this program in lldb , we will now get stack traces that refer to the .ll file rather than than .cpp file: % lldb bin/segfault (lldb) target create \"bin/segfault\" Current executable set to '/path/to/test/bin/segfault' (x86_64). (lldb) r Process 25334 launched: '/path/to/test/bin/segfault' (x86_64) Process 25334 stopped * thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x6d1a00c) frame #0: 0x0000000100003f60 segfault`main at segfault.ll:8:74 5 6 ; Function Attrs: nofree norecurse nounwind ssp uwtable 7 define i32 @main() local_unnamed_addr #0 { -> 8 %1 = load i32, i32* inttoptr (i64 114401292 to i32*), align 4, !tbaa !3 9 %2 = add nsw i32 %1, 2 10 store i32 %2, i32* inttoptr (i64 41196 to i32*), align 4, !tbaa !3 11 %3 = load i32, i32* inttoptr (i64 396 to i32*), align 4, !tbaa !3 In this way, we can now trace the origin of an issue to the LLVM IR rather than the original source file.","title":"Detailed basic example"},{"location":"UsingQAT/DebuggingIR/#mixing-ir-with-runtime","text":"In this section we consider a slightly more complicated example where we want to debug an IR combined with a runtime. Our runtime looks as follows: int foo(); int ir_recurse(int); int standard_recurse(int n) { if (n <= 0) { return foo(); } return ir_recurse(n - 1); } int main() { int x = 2; return standard_recurse(20) + 2 * x; } As in the previous example, our IR will produce a segmentation fault. To ensure that we get a stack trace containing traces of both the runtime and the IR, we use a recursive function that alternates between using functionality in the runtime and the main IR itself: int standard_recurse(int); int foo() { int *ptr = nullptr; ptr[10299] = ptr[10299 * 2777] + 2; return ptr[99]; } int ir_recurse(int n) { if (n <= 0) { return foo(); } return standard_recurse(n - 1); } As in the previous example, we annotate foo.ll with debug information using QAT before creating the object file and linking: clang++ -c -g -o bin/runtime.o runtime.cpp clang++ -c -S -emit-llvm foo.cpp qat -S --add-ir-debug foo.ll > foo.dbg.ll mkdir -p bin llc -filetype=obj -o bin/foo.dbg.o foo.dbg.ll clang++ -g bin/foo.dbg.o bin/runtime.o -o bin/qir_program Running the debugger, we can now execute the program and produce a stack trace as in the previous examples: Current executable set to '/path/to/test/bin/qir_program' (x86_64). (lldb) r Process 54371 launched: '/path/to/test/bin/qir_program' (x86_64) Process 54371 stopped * thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x6d1a00c) frame #0: 0x0000000100003e89 qir_program`_Z3foov at foo.ll:12:34 9 store i32* null, i32** %1, align 8 10 %2 = load i32*, i32** %1, align 8 11 %3 = getelementptr inbounds i32, i32* %2, i64 28600323 -> 12 %4 = load i32, i32* %3, align 4 13 %5 = add nsw i32 %4, 2 14 %6 = load i32*, i32** %1, align 8 15 %7 = getelementptr inbounds i32, i32* %6, i64 10299 (lldb) bt * thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x6d1a00c) * frame #0: 0x0000000100003e89 qir_program`_Z3foov at foo.ll:12:34 frame #1: 0x0000000100003efa qir_program`standard_recurse(n=0) at runtime.cpp:9:12 frame #2: 0x0000000100003ecb qir_program`_Z10ir_recursei at foo.ll:40:49 frame #3: 0x0000000100003f0f qir_program`standard_recurse(n=2) at runtime.cpp:11:10 frame #4: 0x0000000100003ecb qir_program`_Z10ir_recursei at foo.ll:40:49 frame #5: 0x0000000100003f0f qir_program`standard_recurse(n=4) at runtime.cpp:11:10 frame #6: 0x0000000100003ecb qir_program`_Z10ir_recursei at foo.ll:40:49 frame #7: 0x0000000100003f0f qir_program`standard_recurse(n=6) at runtime.cpp:11:10 frame #8: 0x0000000100003ecb qir_program`_Z10ir_recursei at foo.ll:40:49 frame #9: 0x0000000100003f0f qir_program`standard_recurse(n=8) at runtime.cpp:11:10 frame #10: 0x0000000100003ecb qir_program`_Z10ir_recursei at foo.ll:40:49 frame #11: 0x0000000100003f0f qir_program`standard_recurse(n=10) at runtime.cpp:11:10 frame #12: 0x0000000100003ecb qir_program`_Z10ir_recursei at foo.ll:40:49 frame #13: 0x0000000100003f0f qir_program`standard_recurse(n=12) at runtime.cpp:11:10 frame #14: 0x0000000100003ecb qir_program`_Z10ir_recursei at foo.ll:40:49 frame #15: 0x0000000100003f0f qir_program`standard_recurse(n=14) at runtime.cpp:11:10 frame #16: 0x0000000100003ecb qir_program`_Z10ir_recursei at foo.ll:40:49 frame #17: 0x0000000100003f0f qir_program`standard_recurse(n=16) at runtime.cpp:11:10 frame #18: 0x0000000100003ecb qir_program`_Z10ir_recursei at foo.ll:40:49 frame #19: 0x0000000100003f0f qir_program`standard_recurse(n=18) at runtime.cpp:11:10 frame #20: 0x0000000100003ecb qir_program`_Z10ir_recursei at foo.ll:40:49 frame #21: 0x0000000100003f0f qir_program`standard_recurse(n=20) at runtime.cpp:11:10 frame #22: 0x0000000100003f40 qir_program`main at runtime.cpp:17:10 frame #23: 0x000000010000d51e dyld`start + 462 (lldb) f 1 frame #1: 0x0000000100003efa qir_program`standard_recurse(n=0) at runtime.cpp:9:12 6 { 7 if (n <= 0) 8 { -> 9 return foo(); 10 } 11 return ir_recurse(n - 1); 12 } (lldb) We note how this incorporates traces from both runtime.cpp and foo.ll with exact line reference. In this way, it is possible to debug in a similar manner to what we are used to from classical computing.","title":"Mixing IR with runtime"},{"location":"UsingQAT/DebuggingIR/#multi-ir-projects","text":"Occasionally, we may want combine multiple IRs to produce one debuggable executable. We note that we can choose two paths: Either we link at the IR level, or we link at the object level. Unfortunately, LLVM does not produce adequate debug symbols when multiple compilation units are defined in the same IR. Hence, if we wish to follow the path of the former, we first need to combine the IRs and then add debug information with reference to the one combined file : qat -S foo.ll bar.ll > combined.ll qat -S --strip-existing-dbg --add-ir-debug combined.ll > combined.dbg.ll However, this approach looses the information about the location of the original files foo.ll and bar.ll : * thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x6d1a00c) * frame #0: 0x0000000100003ec9 combined_example`_Z3foov at combined.ll:11:34 frame #1: 0x0000000100003f2e combined_example`_Z16standard_recursei at combined.ll:57:37 frame #2: 0x0000000100003f0b combined_example`_Z10ir_recursei at combined.ll:38:49 frame #3: 0x0000000100003f3b combined_example`_Z16standard_recursei at combined.ll:64:53 frame #4: 0x0000000100003f0b combined_example`_Z10ir_recursei at combined.ll:38:49 frame #5: 0x0000000100003f3b combined_example`_Z16standard_recursei at combined.ll:64:53 frame #6: 0x0000000100003f0b combined_example`_Z10ir_recursei at combined.ll:38:49 frame #7: 0x0000000100003f3b combined_example`_Z16standard_recursei at combined.ll:64:53 frame #8: 0x0000000100003f0b combined_example`_Z10ir_recursei at combined.ll:38:49 frame #9: 0x0000000100003f3b combined_example`_Z16standard_recursei at combined.ll:64:53 frame #10: 0x0000000100003f0b combined_example`_Z10ir_recursei at combined.ll:38:49 frame #11: 0x0000000100003f3b combined_example`_Z16standard_recursei at combined.ll:64:53 frame #12: 0x0000000100003f0b combined_example`_Z10ir_recursei at combined.ll:38:49 frame #13: 0x0000000100003f3b combined_example`_Z16standard_recursei at combined.ll:64:53 frame #14: 0x0000000100003f0b combined_example`_Z10ir_recursei at combined.ll:38:49 frame #15: 0x0000000100003f3b combined_example`_Z16standard_recursei at combined.ll:64:53 frame #16: 0x0000000100003f0b combined_example`_Z10ir_recursei at combined.ll:38:49 frame #17: 0x0000000100003f3b combined_example`_Z16standard_recursei at combined.ll:64:53 frame #18: 0x0000000100003f0b combined_example`_Z10ir_recursei at combined.ll:38:49 frame #19: 0x0000000100003f3b combined_example`_Z16standard_recursei at combined.ll:64:53 frame #20: 0x0000000100003f0b combined_example`_Z10ir_recursei at combined.ll:38:49 frame #21: 0x0000000100003f3b combined_example`_Z16standard_recursei at combined.ll:64:53 frame #22: 0x0000000100003f6a combined_example`main at combined.ll:82:57 frame #23: 0x000000010000d51e dyld`start + 462 To keep information about the original files, we have to turn to the second approach where we create separate object files. This will prevent some optimisations such as inlining, but will ensure that we can trace locations in the individual files: clang++ -c -S -emit-llvm foo.cpp clang++ -c -S -emit-llvm bar.cpp qat -S --add-ir-debug foo.ll > foo.dbg.ll qat -S --add-ir-debug bar.ll > bar.dbg.ll mkdir -p bin llc -filetype=obj -o bin/foo.dbg.o foo.dbg.ll llc -filetype=obj -o bin/bar.dbg.o bar.dbg.ll clang++ -g bin/foo.dbg.o bin/bar.dbg.o -o bin/foo_bar_example The executable will now contain debug symbols referring to foo.ll and bar.ll .","title":"Multi-IR projects"},{"location":"UsingQAT/GoalsAndAssumptions/","text":"QAT: Goals, assumptions and limitations Goals QAT primary purpose is to manipulate and validate QIR via a command-line interface. Concretely, QAT aims at performing following tasks: Simplifying logic Transforming logic Adding debugging using LLVM IRs as the source Validating the logic compatibility with a specific profile One of the biggest strength of the LLVM infrastructure is the large amount of optimizations available. For instance, the LLVM optimization tool opt allows constant folding, unrolling of loops, inlining of functions and branch elimination amongst others. These optimizations are useful in order to simplify complicated programs to something that can be ran on processors with a limited classical instruction set. Transforming logic involves transforming qubit allocations into static allocations, separating logic and removing unwanted logic. In case of qubit allocations, the generic method to acquire a qubit resource is through __quantum__rt__qubit_allocate and release again through __quantum__rt__qubit_release . Such runtime functions are not currently supported by available hardware. More generally, available hardware does not have support for any runtime functions which makes it inadequate way to express quantum programs. While we expect that runtime libraries will become increasingly available as the industry develops, it is an immediate need to eliminate these from the QIR. QAT is capable of solving this problem in a multitude of ways. In case of __quantum__rt__qubit_allocate , QAT has a pass which allows to replace these with static qubit numbers under certain conditions. Another example of a QAT transformation is the ability to separate classical driver logic from the quantum programs in mixed quantum-classical programs. The third goal of QAT is to allow QIRs to be annotate with debug information based on an input LLVM IR as the source file. The intend is to provide functionality to help developers to debug at an IR level by incorporating means to annotating debug information referring to the .ll file. This functionality complements existing debug information and can, optionally, override it if needed. The fourth goal of QAT is to validate whether or not a QIR is compliant with the capabilities of a specific quantum system. This is done through profiles which are configurations describing allowing types, instructions, functions and modes of operating. Assumptions & limitations In the following subsections we will outline some of the assumptions and limitations of the current implementation of algorithms addressing the previous listed tasks. This document does not discuss the assumptions and limitations of experimental features such as recursion unfolding, but limits itself to what we consider stable in the latest release. Simplifying logic through LLVM passes For logic simplification, it is an assumption that the passes used will not perform any transformation causing unsupported instructions. This is a strong assumption as LLVM, for instance, may attempt to vectorize loops thereby making use of vector registers and corresponding instructions. To mitigate this, we have limit the LLVM passes available to a handful and parametrized the configuration of them. This serves to increase reproducibility across platforms as well as to provide control over the pass behaviour. However, it does not provide a strict guarantee that these types of transformations will not occur. We therefore rely on the validation functionality to ensure that the final program is compliant with the targeted architecture. Transforming abstractions Transformations to replace dynamic qubit allocation with static qubit allocation relies on a strong assumption that no subcircuit rely on recursion. The core issue that gives rise to this assumption is that it is not possible to replace a dynamic qubit allocation with a static one inside a program unless there is strict guarantees that 1) the function does not call itself and 2) that the acquisition time of the qubit is restricted to the life time of the function scope. Transformations that remove reference counting relies on an assumption that all arrays and other ADTs are successfully removed. This assumption may not be true and would under normal circumstances be caught be the validation step assuming an appropriate profile is used. Transformations that remove strings, assumes that strings and functions consuming or producing strings can be treated as \"debug\" statements which has no other side effect than to output the string content to the screen. Such an assumption may not hold true for frontends that uses dictionaries with strings as key for instance. Annotating QIR with Debug information A core assumption related to annotating the QIR with debug information is that the human readable version of the IR (the .ll -file) is the source of truth and can be referred to by line and column numbers rather than the bitcode. This assumption may not hold true as the different versions of LLVM may produce different .ll files which are not necessarily compatible with one and another. Therefore, if the bitcode file is used as input in a cloud service, the referred to line and column numbers may differ from those produced locally. Logic separation The logic separation functionality assumes that instructions belonging to the primary (CPU) and secondary (QPU) processing units can be distinguished solely by its operation signatures. That is, void function calls which only takes Qubit* and Result* as arguments are pure quantum instructions whereas function calls that returns classical entities (such as i8 , i64 etc.) but take Qubit* and Result* as arguments are read out functions. This puts a natural limit to what can be executed on the QPU since this approach does not allow it for any classical instruction to make its way to the QPU. Another assumption is that QPU is performing a single run with multiple quantum programs to be loaded and executed. Subsequently, it is the assumption that the machine stays coherent throughout the full program execution which is not necessarily the case.","title":"Assumptions and restrictions"},{"location":"UsingQAT/GoalsAndAssumptions/#qat-goals-assumptions-and-limitations","text":"","title":"QAT: Goals, assumptions and limitations"},{"location":"UsingQAT/GoalsAndAssumptions/#goals","text":"QAT primary purpose is to manipulate and validate QIR via a command-line interface. Concretely, QAT aims at performing following tasks: Simplifying logic Transforming logic Adding debugging using LLVM IRs as the source Validating the logic compatibility with a specific profile One of the biggest strength of the LLVM infrastructure is the large amount of optimizations available. For instance, the LLVM optimization tool opt allows constant folding, unrolling of loops, inlining of functions and branch elimination amongst others. These optimizations are useful in order to simplify complicated programs to something that can be ran on processors with a limited classical instruction set. Transforming logic involves transforming qubit allocations into static allocations, separating logic and removing unwanted logic. In case of qubit allocations, the generic method to acquire a qubit resource is through __quantum__rt__qubit_allocate and release again through __quantum__rt__qubit_release . Such runtime functions are not currently supported by available hardware. More generally, available hardware does not have support for any runtime functions which makes it inadequate way to express quantum programs. While we expect that runtime libraries will become increasingly available as the industry develops, it is an immediate need to eliminate these from the QIR. QAT is capable of solving this problem in a multitude of ways. In case of __quantum__rt__qubit_allocate , QAT has a pass which allows to replace these with static qubit numbers under certain conditions. Another example of a QAT transformation is the ability to separate classical driver logic from the quantum programs in mixed quantum-classical programs. The third goal of QAT is to allow QIRs to be annotate with debug information based on an input LLVM IR as the source file. The intend is to provide functionality to help developers to debug at an IR level by incorporating means to annotating debug information referring to the .ll file. This functionality complements existing debug information and can, optionally, override it if needed. The fourth goal of QAT is to validate whether or not a QIR is compliant with the capabilities of a specific quantum system. This is done through profiles which are configurations describing allowing types, instructions, functions and modes of operating.","title":"Goals"},{"location":"UsingQAT/GoalsAndAssumptions/#assumptions-limitations","text":"In the following subsections we will outline some of the assumptions and limitations of the current implementation of algorithms addressing the previous listed tasks. This document does not discuss the assumptions and limitations of experimental features such as recursion unfolding, but limits itself to what we consider stable in the latest release.","title":"Assumptions &amp; limitations"},{"location":"UsingQAT/GoalsAndAssumptions/#simplifying-logic-through-llvm-passes","text":"For logic simplification, it is an assumption that the passes used will not perform any transformation causing unsupported instructions. This is a strong assumption as LLVM, for instance, may attempt to vectorize loops thereby making use of vector registers and corresponding instructions. To mitigate this, we have limit the LLVM passes available to a handful and parametrized the configuration of them. This serves to increase reproducibility across platforms as well as to provide control over the pass behaviour. However, it does not provide a strict guarantee that these types of transformations will not occur. We therefore rely on the validation functionality to ensure that the final program is compliant with the targeted architecture.","title":"Simplifying logic through LLVM passes"},{"location":"UsingQAT/GoalsAndAssumptions/#transforming-abstractions","text":"Transformations to replace dynamic qubit allocation with static qubit allocation relies on a strong assumption that no subcircuit rely on recursion. The core issue that gives rise to this assumption is that it is not possible to replace a dynamic qubit allocation with a static one inside a program unless there is strict guarantees that 1) the function does not call itself and 2) that the acquisition time of the qubit is restricted to the life time of the function scope. Transformations that remove reference counting relies on an assumption that all arrays and other ADTs are successfully removed. This assumption may not be true and would under normal circumstances be caught be the validation step assuming an appropriate profile is used. Transformations that remove strings, assumes that strings and functions consuming or producing strings can be treated as \"debug\" statements which has no other side effect than to output the string content to the screen. Such an assumption may not hold true for frontends that uses dictionaries with strings as key for instance.","title":"Transforming abstractions"},{"location":"UsingQAT/GoalsAndAssumptions/#annotating-qir-with-debug-information","text":"A core assumption related to annotating the QIR with debug information is that the human readable version of the IR (the .ll -file) is the source of truth and can be referred to by line and column numbers rather than the bitcode. This assumption may not hold true as the different versions of LLVM may produce different .ll files which are not necessarily compatible with one and another. Therefore, if the bitcode file is used as input in a cloud service, the referred to line and column numbers may differ from those produced locally.","title":"Annotating QIR with Debug information"},{"location":"UsingQAT/GoalsAndAssumptions/#logic-separation","text":"The logic separation functionality assumes that instructions belonging to the primary (CPU) and secondary (QPU) processing units can be distinguished solely by its operation signatures. That is, void function calls which only takes Qubit* and Result* as arguments are pure quantum instructions whereas function calls that returns classical entities (such as i8 , i64 etc.) but take Qubit* and Result* as arguments are read out functions. This puts a natural limit to what can be executed on the QPU since this approach does not allow it for any classical instruction to make its way to the QPU. Another assumption is that QPU is performing a single run with multiple quantum programs to be loaded and executed. Subsequently, it is the assumption that the machine stays coherent throughout the full program execution which is not necessarily the case.","title":"Logic separation"},{"location":"UsingQAT/TargetingQIR/","text":"Targeting QIR QAT Configuration QAT has some high level configuration that dictates what tasks QAT should do and how it should do it. For instance, the QAT configuration will determine whether or not QAT will adapt the QIR to become compliant with a target QIR, what the adaptor pipeline looks like and whether or not it should validate target compliance afterwards. Below we list all settings that are used to configure how QAT is running: Name Description Default value apply Applies a adaptor to transform the IR in correspondence with the adaptor. false validate Executes the validation procedure. false adaptor-pipeline Overrides the adaptor pipleline. emit-human-readable-llvm Emits LLVM IR to the standard output. false target-def YAML file containing the definition for the target. save-config YAML file to which the config will be save. verify-module Verifies the module after transformation. false experimental Enables experimental features. false dump-config Prints the configuration to the standard output. false add-ir-debug Annotates the IR with debug information. false strip-existing-dbg Strips existing debug symbols. false output Output file. If empty, the output is sent to stdout. save-logs Saves the logs report to specified filename in JSON format. version Shows the version of QAT. false help Show help page. false The flags apply and validate are used to specify whether QAT should apply adaptors and validate the resulting QIR, respectively. These flags can be applied independently of one and another. Hence, it is possible to validate a QIR without first transforming it as well as transforming it without the need of validating it. The QIR transformation process is dictated by the adapator-pipeline which determines which adaptors QAT will use and in which order. The default pipeline is replacement-linking , llvm-optimization , remove-non-entrypoint-functions , target-qis-mapping , target-profile-mapping , straightline-code-requirement , static-resources , grouping . Each of these adaptors are discussed in detail below. The parameter target-def is used to load configuration of QAT including all adaptors and validations settings. This parameter is usful to create definitions that can be used to target specific hardware without the need of providing an exhaustive list of commandline arguments. Validating a QIR Validating the QIR consists of two separate tasks: Validating that the QIR is compliant with the profile specification and validating that the QIR only uses the specified quantum instruction set. Target profile validation - Configuration for profile validation Profile validation consists of confirming the compliance with required classical behaviour. This includes options to define specific behaviours such as which types are allowed, externally callable functions and use of poison and undef: Name Description Default value CLI allow-internal-calls Whether or not internal calls are allowed. true Yes allow-poison Whether or not poison values are allowed. true Yes allow-undef Whether or not undef values are allowed. true Yes opcodes List of allowed opcodes No allowlist-opcodes Whether or not to use allow list for op-codes. No allowlist-external-calls Whether or not to use allow list external calls. No allowlist-pointer-types Whether or not to use allow list pointer types. No allow-primitive-return Whether or not primitive return types are allowed. No allow-struct-return Whether or not struct return types are allowed. No allow-pointer-return Whether or not pointer return types are allowed. No external-calls Allowed external calls. No allowed-pointer-types Allowed pointer types. No Not all of these are available through the CLI since they require a lot of data. For instance, opcodes is only allowed to be specified through the config file, since this is a list of objects. Target QIS validation - Configuration for QIS validation Similar to the target profile validation, the target QIS validation deals with the validation of the quantum instruction set (QIS). Specifically, these settings are used to specify whether or not we require qubits and/or results to be present in the IR and whether we allow all QIS, or only those which were allowed listed: Name Description Default value CLI allowed-any-qis Whether or not to allow any quantum instruction. true Yes requires-qubits Whether or not qubits are required in the IR. false Yes requires-results Whether or not results are required in the IR. false Yes allowed-qis List of allowed QIS signatures No Like the target profile validator, the allowed-qis is only available through the configuration file. Adaptors In this section we discuss configuration of the available adaptors. Adaptor deactivation - Used to disable or enable adaptors This configuration section allows the user to disable one or more adaptors. By default all adaptors are activated. While this does not mean that they actively perform any transformation of the IR, it does mean that the adaptor code is loaded and that the adaptor will be operating in accordance with its settings. The indiidual adaptors that can be disabled are listed here: Name Description Default value disable-replacement-linking Disables Replacement linking. false disable-llvm-optimization Disables LLVM optimizations. false disable-remove-non-entrypoint-functions Disables Remove Non-Entrypoint Functions. false disable-target-qis-mapping Disables Pass configuration. false disable-target-profile-mapping Disables Post-transform optimisation. false disable-straightline-code-requirement Disables Pre-transform validation. false disable-static-resources Disables Static resource manipulation. false disable-grouping Disables QIS Grouping. false Note that some of these adaptors are not configurable. One such example is the remove-non-entrypoint-functions which either is there or not. This particular adaptor works is just a traditional LLVM pass, but is delivered as an adaptor since QAT does not allow single passes to be added to the pipeline without an adaptor to manage its configuration. Moreover, since the pass does not require any configuration, its configuration section is empty. LLVM optimizations - Enables specific LLVM optimizations before and after transformation The LLVM optimization adaptor runs provides selected LLVM passes to perform tranditional optimization tasks such as function inlining, loop unrolling, dead code elimination, memory elimination and constant elimination. For each of these passes, we provide a number of parameters that allows tuning of the individual passes to the extend possible: Name Description Default value unroll-loops Aggressively unroll loops. false allow-partial Enables or disables partial unrolling. When disabled only full unrolling is allowed. true allow-peeling Enables or disables loop peeling. true allow-runtime Enables or disables unrolling of loops with runtime trip count. true allow-upper-bound Enables or disables the use of trip count upper bound in loop unrolling. true allow-profile-based-peeling Enables or disables loop peeling basing on profile. true full-unroll-count Sets the max full unroll count. 1024 unroll-opt-level Sets the optimization level for loop unrolling. 3 only-when-forced If true, only loops that explicitly request unrolling via metadata are considered. false forget-scev If true, forget all loops when unrolling. If false, forget top-most loop of the currently processed loops. false always-inline Aggressively inline function calls. false inlining-parameter Number of code lines acceptable when inlining. 2147483647 eliminate-constants Uses LLVM pass to eliminate constants. true eliminate-dead-code Uses LLVMs aggressive dead code elimination. true eliminate-memory Maps memory into registers where feasible. true The purpose of this adaptor is to simplify the IR as much as possible prior to targeting the IR. While we have taken great care to ensure that these passes act predictably, note that there may be occassions where they produce a different IR than that desired. One such example is promoting if-else statements to switch statements where applicable. This is not always desirable since not all backends has support for this. Target QIS mapping - Rules used to transform instruction sequences in the QIR This adaptor transforms the QIR into a QIR that is targeted with respect to the quantum instruction set. The adaptor provides a number of different transformations including mapping dynamic qubit/result allocation into static qubit/result allocation and optimize comparisons against constant quantum results Zero and One : Name Description Default value optimize-result-one Maps branching based on quantum measurements compared to one to base adaptor type measurement. true optimize-result-zero Maps branching based on quantum measurements compared to zero to base adaptor type measurement. true optimize-result-comparison Maps branching based on quantum measurements compared to each other to base adaptor type measurement. true use-static-qubit-array-allocation Maps allocation of qubit arrays to static array allocation. true use-static-qubit-allocation Maps qubit allocation to static allocation. true use-static-result-allocation Maps result allocation to static allocation. true disable-reference-counting Disables reference counting by instruction removal. true disable-alias-counting Disables alias counting by instruction removal. true disable-string-support Disables string support by instruction removal. true disable-record-output-support Disables record output support by instruction removal. true reuse-qubits Use to define whether or not to reuse qubits. false reuse-results Use to define whether or not to reuse results. false entry-point-attr Specifies the attribute indicating the entry point. EntryPoint It is worth noting that the mapping of dynamic qubits to static qubits is limited in scope and done as a best-effort. The reason for this limitation is that there exists scenarios in which this mapping simply is not possible. One such example is a recursive function that allocates one qubit for every recursion and terminates at runtime given depth N . There are a number of experimental features in this adaptor. To list these use qat -h --experimental . Target profile mapping - Optimisations performed after Like target QIS mapping, the target profile mapping maps known IR patterns into other patterns. This adaptor only uses LLVM passes at the moment, but could be extended using our pattern matching pass to accommodate special requirements. Options as the moment are: Name Description Default value lower-switch Lower switch statements. true should-eleminate-zext-i1 Replace zext instruction for i1 with select. true defer-measurements Wether or not measurement and recording functions should be moved to the end of the program. false We note that deferred measurements should be moved to the circuit separation pass. Replacement linking - Conditionally replaces function calls Replacement linking is an adaptor that enables replacement of functions subject to the replacing function being present in the IR. As an example, imagine a backend that implements an X gate but not a Z gate. A QIR that makes use of Z gates would not run on said hardware unless we would map Z into the sequence HXH where H is the Hadamard gate. The replacement linking adaptor allows us to define a software implemention of Z in a separate library and use annotattions on the Z gate function to replace the gate if a software implementation is provided. Name Description Default value replace-functions Functions to be replaced. remove-call-attributes Discard all call attributes false Static resource adaptor - Manipulates statically allocated qubits and results In case of a QIR that uses statically allocated qubits and/or results, the static resource adaptor allows manipulation to archieve certain properties. One such property is enforcing consecutive indexing starting 0 and another is the ability to ensure that a new qubit is used whenever a reset occurs. The latter garantuees that qubits are not reused within the lifetime of the program and is a prerequisite for measurement at the end of the program execution. Name Description Default value annotate-qubit-use Annotate the number of qubits used true annotate-result-use Annotate the number of results used true annotate-max-qubit-index Annotate the maximum qubit index used true annotate-max-result-index Annotate the maximum result index used true reindex-qubits Re-indexes statically allocated qubits with sequential ids starting from 0 false replace-qubit-on-reset Replaces a qubit with new qubit if the qubit is reset false inline-after-id-change Inlines instructions after id was changed true","title":"Targeting a QIR"},{"location":"UsingQAT/TargetingQIR/#targeting-qir","text":"","title":"Targeting QIR"},{"location":"UsingQAT/TargetingQIR/#qat-configuration","text":"QAT has some high level configuration that dictates what tasks QAT should do and how it should do it. For instance, the QAT configuration will determine whether or not QAT will adapt the QIR to become compliant with a target QIR, what the adaptor pipeline looks like and whether or not it should validate target compliance afterwards. Below we list all settings that are used to configure how QAT is running: Name Description Default value apply Applies a adaptor to transform the IR in correspondence with the adaptor. false validate Executes the validation procedure. false adaptor-pipeline Overrides the adaptor pipleline. emit-human-readable-llvm Emits LLVM IR to the standard output. false target-def YAML file containing the definition for the target. save-config YAML file to which the config will be save. verify-module Verifies the module after transformation. false experimental Enables experimental features. false dump-config Prints the configuration to the standard output. false add-ir-debug Annotates the IR with debug information. false strip-existing-dbg Strips existing debug symbols. false output Output file. If empty, the output is sent to stdout. save-logs Saves the logs report to specified filename in JSON format. version Shows the version of QAT. false help Show help page. false The flags apply and validate are used to specify whether QAT should apply adaptors and validate the resulting QIR, respectively. These flags can be applied independently of one and another. Hence, it is possible to validate a QIR without first transforming it as well as transforming it without the need of validating it. The QIR transformation process is dictated by the adapator-pipeline which determines which adaptors QAT will use and in which order. The default pipeline is replacement-linking , llvm-optimization , remove-non-entrypoint-functions , target-qis-mapping , target-profile-mapping , straightline-code-requirement , static-resources , grouping . Each of these adaptors are discussed in detail below. The parameter target-def is used to load configuration of QAT including all adaptors and validations settings. This parameter is usful to create definitions that can be used to target specific hardware without the need of providing an exhaustive list of commandline arguments.","title":"QAT Configuration"},{"location":"UsingQAT/TargetingQIR/#validating-a-qir","text":"Validating the QIR consists of two separate tasks: Validating that the QIR is compliant with the profile specification and validating that the QIR only uses the specified quantum instruction set.","title":"Validating a QIR"},{"location":"UsingQAT/TargetingQIR/#target-profile-validation-configuration-for-profile-validation","text":"Profile validation consists of confirming the compliance with required classical behaviour. This includes options to define specific behaviours such as which types are allowed, externally callable functions and use of poison and undef: Name Description Default value CLI allow-internal-calls Whether or not internal calls are allowed. true Yes allow-poison Whether or not poison values are allowed. true Yes allow-undef Whether or not undef values are allowed. true Yes opcodes List of allowed opcodes No allowlist-opcodes Whether or not to use allow list for op-codes. No allowlist-external-calls Whether or not to use allow list external calls. No allowlist-pointer-types Whether or not to use allow list pointer types. No allow-primitive-return Whether or not primitive return types are allowed. No allow-struct-return Whether or not struct return types are allowed. No allow-pointer-return Whether or not pointer return types are allowed. No external-calls Allowed external calls. No allowed-pointer-types Allowed pointer types. No Not all of these are available through the CLI since they require a lot of data. For instance, opcodes is only allowed to be specified through the config file, since this is a list of objects.","title":"Target profile validation - Configuration for profile validation"},{"location":"UsingQAT/TargetingQIR/#target-qis-validation-configuration-for-qis-validation","text":"Similar to the target profile validation, the target QIS validation deals with the validation of the quantum instruction set (QIS). Specifically, these settings are used to specify whether or not we require qubits and/or results to be present in the IR and whether we allow all QIS, or only those which were allowed listed: Name Description Default value CLI allowed-any-qis Whether or not to allow any quantum instruction. true Yes requires-qubits Whether or not qubits are required in the IR. false Yes requires-results Whether or not results are required in the IR. false Yes allowed-qis List of allowed QIS signatures No Like the target profile validator, the allowed-qis is only available through the configuration file.","title":"Target QIS validation - Configuration for QIS validation"},{"location":"UsingQAT/TargetingQIR/#adaptors","text":"In this section we discuss configuration of the available adaptors.","title":"Adaptors"},{"location":"UsingQAT/TargetingQIR/#adaptor-deactivation-used-to-disable-or-enable-adaptors","text":"This configuration section allows the user to disable one or more adaptors. By default all adaptors are activated. While this does not mean that they actively perform any transformation of the IR, it does mean that the adaptor code is loaded and that the adaptor will be operating in accordance with its settings. The indiidual adaptors that can be disabled are listed here: Name Description Default value disable-replacement-linking Disables Replacement linking. false disable-llvm-optimization Disables LLVM optimizations. false disable-remove-non-entrypoint-functions Disables Remove Non-Entrypoint Functions. false disable-target-qis-mapping Disables Pass configuration. false disable-target-profile-mapping Disables Post-transform optimisation. false disable-straightline-code-requirement Disables Pre-transform validation. false disable-static-resources Disables Static resource manipulation. false disable-grouping Disables QIS Grouping. false Note that some of these adaptors are not configurable. One such example is the remove-non-entrypoint-functions which either is there or not. This particular adaptor works is just a traditional LLVM pass, but is delivered as an adaptor since QAT does not allow single passes to be added to the pipeline without an adaptor to manage its configuration. Moreover, since the pass does not require any configuration, its configuration section is empty.","title":"Adaptor deactivation - Used to disable or enable adaptors"},{"location":"UsingQAT/TargetingQIR/#llvm-optimizations-enables-specific-llvm-optimizations-before-and-after-transformation","text":"The LLVM optimization adaptor runs provides selected LLVM passes to perform tranditional optimization tasks such as function inlining, loop unrolling, dead code elimination, memory elimination and constant elimination. For each of these passes, we provide a number of parameters that allows tuning of the individual passes to the extend possible: Name Description Default value unroll-loops Aggressively unroll loops. false allow-partial Enables or disables partial unrolling. When disabled only full unrolling is allowed. true allow-peeling Enables or disables loop peeling. true allow-runtime Enables or disables unrolling of loops with runtime trip count. true allow-upper-bound Enables or disables the use of trip count upper bound in loop unrolling. true allow-profile-based-peeling Enables or disables loop peeling basing on profile. true full-unroll-count Sets the max full unroll count. 1024 unroll-opt-level Sets the optimization level for loop unrolling. 3 only-when-forced If true, only loops that explicitly request unrolling via metadata are considered. false forget-scev If true, forget all loops when unrolling. If false, forget top-most loop of the currently processed loops. false always-inline Aggressively inline function calls. false inlining-parameter Number of code lines acceptable when inlining. 2147483647 eliminate-constants Uses LLVM pass to eliminate constants. true eliminate-dead-code Uses LLVMs aggressive dead code elimination. true eliminate-memory Maps memory into registers where feasible. true The purpose of this adaptor is to simplify the IR as much as possible prior to targeting the IR. While we have taken great care to ensure that these passes act predictably, note that there may be occassions where they produce a different IR than that desired. One such example is promoting if-else statements to switch statements where applicable. This is not always desirable since not all backends has support for this.","title":"LLVM optimizations - Enables specific LLVM optimizations before and after transformation"},{"location":"UsingQAT/TargetingQIR/#target-qis-mapping-rules-used-to-transform-instruction-sequences-in-the-qir","text":"This adaptor transforms the QIR into a QIR that is targeted with respect to the quantum instruction set. The adaptor provides a number of different transformations including mapping dynamic qubit/result allocation into static qubit/result allocation and optimize comparisons against constant quantum results Zero and One : Name Description Default value optimize-result-one Maps branching based on quantum measurements compared to one to base adaptor type measurement. true optimize-result-zero Maps branching based on quantum measurements compared to zero to base adaptor type measurement. true optimize-result-comparison Maps branching based on quantum measurements compared to each other to base adaptor type measurement. true use-static-qubit-array-allocation Maps allocation of qubit arrays to static array allocation. true use-static-qubit-allocation Maps qubit allocation to static allocation. true use-static-result-allocation Maps result allocation to static allocation. true disable-reference-counting Disables reference counting by instruction removal. true disable-alias-counting Disables alias counting by instruction removal. true disable-string-support Disables string support by instruction removal. true disable-record-output-support Disables record output support by instruction removal. true reuse-qubits Use to define whether or not to reuse qubits. false reuse-results Use to define whether or not to reuse results. false entry-point-attr Specifies the attribute indicating the entry point. EntryPoint It is worth noting that the mapping of dynamic qubits to static qubits is limited in scope and done as a best-effort. The reason for this limitation is that there exists scenarios in which this mapping simply is not possible. One such example is a recursive function that allocates one qubit for every recursion and terminates at runtime given depth N . There are a number of experimental features in this adaptor. To list these use qat -h --experimental .","title":"Target QIS mapping - Rules used to transform instruction sequences in the QIR"},{"location":"UsingQAT/TargetingQIR/#target-profile-mapping-optimisations-performed-after","text":"Like target QIS mapping, the target profile mapping maps known IR patterns into other patterns. This adaptor only uses LLVM passes at the moment, but could be extended using our pattern matching pass to accommodate special requirements. Options as the moment are: Name Description Default value lower-switch Lower switch statements. true should-eleminate-zext-i1 Replace zext instruction for i1 with select. true defer-measurements Wether or not measurement and recording functions should be moved to the end of the program. false We note that deferred measurements should be moved to the circuit separation pass.","title":"Target profile mapping - Optimisations performed after"},{"location":"UsingQAT/TargetingQIR/#replacement-linking-conditionally-replaces-function-calls","text":"Replacement linking is an adaptor that enables replacement of functions subject to the replacing function being present in the IR. As an example, imagine a backend that implements an X gate but not a Z gate. A QIR that makes use of Z gates would not run on said hardware unless we would map Z into the sequence HXH where H is the Hadamard gate. The replacement linking adaptor allows us to define a software implemention of Z in a separate library and use annotattions on the Z gate function to replace the gate if a software implementation is provided. Name Description Default value replace-functions Functions to be replaced. remove-call-attributes Discard all call attributes false","title":"Replacement linking - Conditionally replaces function calls"},{"location":"UsingQAT/TargetingQIR/#static-resource-adaptor-manipulates-statically-allocated-qubits-and-results","text":"In case of a QIR that uses statically allocated qubits and/or results, the static resource adaptor allows manipulation to archieve certain properties. One such property is enforcing consecutive indexing starting 0 and another is the ability to ensure that a new qubit is used whenever a reset occurs. The latter garantuees that qubits are not reused within the lifetime of the program and is a prerequisite for measurement at the end of the program execution. Name Description Default value annotate-qubit-use Annotate the number of qubits used true annotate-result-use Annotate the number of results used true annotate-max-qubit-index Annotate the maximum qubit index used true annotate-max-result-index Annotate the maximum result index used true reindex-qubits Re-indexes statically allocated qubits with sequential ids starting from 0 false replace-qubit-on-reset Replaces a qubit with new qubit if the qubit is reset false inline-after-id-change Inlines instructions after id was changed true","title":"Static resource adaptor - Manipulates statically allocated qubits and results"}]}