{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"QIR Adaptor Tool Welcome to the QIR Adaptor Tool, a tool to manipulate QIR into specific profiles. The goal of this framework is to create tools that allow quantum hardware vendors to adapt a generic QIR to their specific hardware profile. User guide: Quick start Building the library Introduction to profiles Applying a profile (TODO(issue-8): Yet to be written) Developer guide: Architecture Overview Writing a Component Configuration Library Rule based extensions Additional developer info: Code quality Developer FAQ","title":"QIR Adaptor Tool"},{"location":"#qir-adaptor-tool","text":"Welcome to the QIR Adaptor Tool, a tool to manipulate QIR into specific profiles. The goal of this framework is to create tools that allow quantum hardware vendors to adapt a generic QIR to their specific hardware profile. User guide: Quick start Building the library Introduction to profiles Applying a profile (TODO(issue-8): Yet to be written) Developer guide: Architecture Overview Writing a Component Configuration Library Rule based extensions Additional developer info: Code quality Developer FAQ","title":"QIR Adaptor Tool"},{"location":"base-profile-transformations/","text":"Proposal: QIR Adaptor Tool Specification Considerations This document discusses a tool that transforms QIR into a restricted version of the QIR (known as a profile). We aim to make a specification for a generic tool that allows the user to: Create or use an existing profile without the need of writing code. Validate that a QIR is compliant with the specific profile. Generate a profile compliant QIR from a generic unconstrained QIR (if possible). This document sets out to motivate and demonstrate feasibility of building such a tool. Motivation It is anticipated that most usages of the QIR specification will need to only use a subset of it. These subsets may further be subject to constraints such as how one allocates or acquire a qubit handle. We refer to such a subset with constraints as a profile. For instance, it is likely that early versions of quantum hardware will have a limited set of classical instructions available. With this in mind, the vendor or user of said hardware would define a profile that only contains a specified subset. One example of such a profile is the base profile, which only allows function calls and branching, but no arithmetic, classical memory, or classical registers. The generation of QIR according to the spec with no constraints would typically be performed by the frontend. A couple of examples are Q# or OpenQASM 3.0. However, for the generated QIR to be practical it is necessary to reduce it using a profile which is compatible with the target platform: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Frontend \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 QIR \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 QIR Adaptor Tool \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Restricted QIR \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 We propose that such a reduction could be done using the LLVM passes infrastructure to compose a profile which would map the QIR to a subset of the available instructions with any required constraints. Feasibility Study In order to demonstrate feasibility of this proposal, we have built a proof-of-concept prototype based on LLVM passes which allows transformation from a generic QIR into one which does not have support for dynamic qubit allocation. This transformation is considered to be the smallest, non-trivial case of QIR transformation we can perform which demonstrates the feasibility of this proposal. To demonstrate the feasibility of this proposal, we use Q# as a frontend and will attempt to map the following code namespace Feasibility { open Microsoft.Quantum.Intrinsic; @EntryPoint() operation Run() : Unit { use qs = Qubit[3]; for q in 8..10 { X(qs[q - 8]); } } } to the base profile. We will do so using a combination of existing LLVM passes and custom written passes which are specific to the QIR. The above code is interesting as it is not base profile compliant with regards to two aspects: 1) Qubit allocation is not allowed and 2) arithmetic operations are not supported. Using the Q# QIR generator, the Run functions body becomes: define internal void @Feasibility__Run__body() { entry: %qs = call %Array* @__quantum__rt__qubit_allocate_array(i64 3) call void @__quantum__rt__array_update_alias_count(%Array* %qs, i32 1) br label %header__1 header__1: ; preds = %exiting__1, %entry %q = phi i64 [ 8, %entry ], [ %4, %exiting__1 ] %0 = icmp sle i64 %q, 10 br i1 %0, label %body__1, label %exit__1 body__1: ; preds = %header__1 %1 = sub i64 %q, 8 %2 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %qs, i64 %1) %3 = bitcast i8* %2 to %Qubit** %qubit = load %Qubit*, %Qubit** %3, align 8 call void @__quantum__qis__x__body(%Qubit* %qubit) br label %exiting__1 exiting__1: ; preds = %body__1 %4 = add i64 %q, 1 br label %header__1 exit__1: ; preds = %header__1 call void @__quantum__rt__array_update_alias_count(%Array* %qs, i32 -1) call void @__quantum__rt__qubit_release_array(%Array* %qs) ret void } After applying the our demo profile transformation, the QIR is reduced to: define void @Feasibility__Run__Interop() local_unnamed_addr #0 { entry: call void @__quantum__qis__x__body(%Qubit* null) call void @__quantum__qis__x__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*)) call void @__quantum__qis__x__body(%Qubit* nonnull inttoptr (i64 2 to %Qubit*)) ret void } We note that we successfully have eliminated loops, arithmetic operations, dynamic qubit allocation and alias counting - all operations which are not supported by the base profile. Goal We envision the tool to work as a stand-alone command line tool which can either validate or generate a QIR in accordance with a given profile. To validate, one would run: qat -p profile.yaml --validate unvalidated-qir.ll In a similar fashion, generation is performed by adding --apply to the command line: qat -p profile.yaml --apply qir.ll > qir-profile.ll Default behaviour of the tool is that it always validates the generated profile. This behaviour can be disabled by qat -p profile.yaml --apply --no-validate qir.ll > qir-profile.ll Profile Specification Every profile is specified through a YAML file which defines an object at the top-level. This object must contain the fields name and displayName : name: profile-name displayName: Profile Name # ... Additionally, top level also contains the fields version and mode . The version refers to the QIR version which forms the basis for the specification and mode explains how the profile is defined. The final two top level fields are lists named specification and generation . These contains the specification and generation procedure, respectively. Specification The default mode of specification is by feature which means that specification describes the feature set available. Alternatively, one can specify a profile by limitation . As an example profile for name: profile-name displayName: Profile Name version: 1.0 mode: feature specification: functions: - __quantum__qis__toffoli__body - __quantum__qis__cnot__body - __quantum__qis__cz__body - __quantum__qis__h__body - __quantum__qis__mz__body - __quantum__qis__reset__body - __quantum__qis__rx__body - __quantum__qis__ry__body - __quantum__qis__rz__body - __quantum__qis__s__body - __quantum__qis__s__adj - __quantum__qis__t__body - __quantum__qis__t__adj - __quantum__qis__x__body - __quantum__qis__y__body - __quantum__qis__z__body instructions: - call - br - ret - inttoptr # ... This specification describes that 16 quantum instructions are available and 4 classical operations of the full QIR spec. Contrary, a specification by limitation could be as follows: name: profile-name displayName: Profile Name version: 1.0 mode: limitation specification: functions: - __quantum__rt__array_update_alias_count - __quantum__rt__array_update_reference_count instructions: - br # ... This profile specifies a system that does not allow reference and alias counting and neither have support for branching, but otherwise has the full QIR vesion 1.0 available. Generation specification To achieve the QIR generation in the feasibility section we made use of a number of different passes in order fold constants, unroll loops and map qubit allocations to static allocations. Based on this, we propose that generators are specified by creating a pipeline of LLVM passes to analyse and transform the QIR: name: profile-name displayName: Profile Name # ... generation: - passName: loopUnroll - passName: functionInline - passName: useStaticQubitAllocation - passName: eliminateClassicalMemoryUsage - passName: ignoreCall config: names: - __quantum__rt__array_update_alias_count - __quantum__rt__array_update_reference_count For those passes which are defined specifically for QIR we we allow configuration to be passed to them. This will allow the end-user to fine-tune the behaviour of profile generator. Library outline This is a placeholder for describing the outline of the QAT library. The aim is to create a dynamic library where we can add new components that allow to extend the QIR profile generation components with more passes and/or spefication options.","title":"Proposal: QIR Adaptor Tool Specification"},{"location":"base-profile-transformations/#proposal-qir-adaptor-tool-specification","text":"","title":"Proposal: QIR Adaptor Tool Specification"},{"location":"base-profile-transformations/#considerations","text":"This document discusses a tool that transforms QIR into a restricted version of the QIR (known as a profile). We aim to make a specification for a generic tool that allows the user to: Create or use an existing profile without the need of writing code. Validate that a QIR is compliant with the specific profile. Generate a profile compliant QIR from a generic unconstrained QIR (if possible). This document sets out to motivate and demonstrate feasibility of building such a tool.","title":"Considerations"},{"location":"base-profile-transformations/#motivation","text":"It is anticipated that most usages of the QIR specification will need to only use a subset of it. These subsets may further be subject to constraints such as how one allocates or acquire a qubit handle. We refer to such a subset with constraints as a profile. For instance, it is likely that early versions of quantum hardware will have a limited set of classical instructions available. With this in mind, the vendor or user of said hardware would define a profile that only contains a specified subset. One example of such a profile is the base profile, which only allows function calls and branching, but no arithmetic, classical memory, or classical registers. The generation of QIR according to the spec with no constraints would typically be performed by the frontend. A couple of examples are Q# or OpenQASM 3.0. However, for the generated QIR to be practical it is necessary to reduce it using a profile which is compatible with the target platform: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Frontend \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 QIR \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 QIR Adaptor Tool \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Restricted QIR \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 We propose that such a reduction could be done using the LLVM passes infrastructure to compose a profile which would map the QIR to a subset of the available instructions with any required constraints.","title":"Motivation"},{"location":"base-profile-transformations/#feasibility-study","text":"In order to demonstrate feasibility of this proposal, we have built a proof-of-concept prototype based on LLVM passes which allows transformation from a generic QIR into one which does not have support for dynamic qubit allocation. This transformation is considered to be the smallest, non-trivial case of QIR transformation we can perform which demonstrates the feasibility of this proposal. To demonstrate the feasibility of this proposal, we use Q# as a frontend and will attempt to map the following code namespace Feasibility { open Microsoft.Quantum.Intrinsic; @EntryPoint() operation Run() : Unit { use qs = Qubit[3]; for q in 8..10 { X(qs[q - 8]); } } } to the base profile. We will do so using a combination of existing LLVM passes and custom written passes which are specific to the QIR. The above code is interesting as it is not base profile compliant with regards to two aspects: 1) Qubit allocation is not allowed and 2) arithmetic operations are not supported. Using the Q# QIR generator, the Run functions body becomes: define internal void @Feasibility__Run__body() { entry: %qs = call %Array* @__quantum__rt__qubit_allocate_array(i64 3) call void @__quantum__rt__array_update_alias_count(%Array* %qs, i32 1) br label %header__1 header__1: ; preds = %exiting__1, %entry %q = phi i64 [ 8, %entry ], [ %4, %exiting__1 ] %0 = icmp sle i64 %q, 10 br i1 %0, label %body__1, label %exit__1 body__1: ; preds = %header__1 %1 = sub i64 %q, 8 %2 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %qs, i64 %1) %3 = bitcast i8* %2 to %Qubit** %qubit = load %Qubit*, %Qubit** %3, align 8 call void @__quantum__qis__x__body(%Qubit* %qubit) br label %exiting__1 exiting__1: ; preds = %body__1 %4 = add i64 %q, 1 br label %header__1 exit__1: ; preds = %header__1 call void @__quantum__rt__array_update_alias_count(%Array* %qs, i32 -1) call void @__quantum__rt__qubit_release_array(%Array* %qs) ret void } After applying the our demo profile transformation, the QIR is reduced to: define void @Feasibility__Run__Interop() local_unnamed_addr #0 { entry: call void @__quantum__qis__x__body(%Qubit* null) call void @__quantum__qis__x__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*)) call void @__quantum__qis__x__body(%Qubit* nonnull inttoptr (i64 2 to %Qubit*)) ret void } We note that we successfully have eliminated loops, arithmetic operations, dynamic qubit allocation and alias counting - all operations which are not supported by the base profile.","title":"Feasibility Study"},{"location":"base-profile-transformations/#goal","text":"We envision the tool to work as a stand-alone command line tool which can either validate or generate a QIR in accordance with a given profile. To validate, one would run: qat -p profile.yaml --validate unvalidated-qir.ll In a similar fashion, generation is performed by adding --apply to the command line: qat -p profile.yaml --apply qir.ll > qir-profile.ll Default behaviour of the tool is that it always validates the generated profile. This behaviour can be disabled by qat -p profile.yaml --apply --no-validate qir.ll > qir-profile.ll","title":"Goal"},{"location":"base-profile-transformations/#profile-specification","text":"Every profile is specified through a YAML file which defines an object at the top-level. This object must contain the fields name and displayName : name: profile-name displayName: Profile Name # ... Additionally, top level also contains the fields version and mode . The version refers to the QIR version which forms the basis for the specification and mode explains how the profile is defined. The final two top level fields are lists named specification and generation . These contains the specification and generation procedure, respectively.","title":"Profile Specification"},{"location":"base-profile-transformations/#specification","text":"The default mode of specification is by feature which means that specification describes the feature set available. Alternatively, one can specify a profile by limitation . As an example profile for name: profile-name displayName: Profile Name version: 1.0 mode: feature specification: functions: - __quantum__qis__toffoli__body - __quantum__qis__cnot__body - __quantum__qis__cz__body - __quantum__qis__h__body - __quantum__qis__mz__body - __quantum__qis__reset__body - __quantum__qis__rx__body - __quantum__qis__ry__body - __quantum__qis__rz__body - __quantum__qis__s__body - __quantum__qis__s__adj - __quantum__qis__t__body - __quantum__qis__t__adj - __quantum__qis__x__body - __quantum__qis__y__body - __quantum__qis__z__body instructions: - call - br - ret - inttoptr # ... This specification describes that 16 quantum instructions are available and 4 classical operations of the full QIR spec. Contrary, a specification by limitation could be as follows: name: profile-name displayName: Profile Name version: 1.0 mode: limitation specification: functions: - __quantum__rt__array_update_alias_count - __quantum__rt__array_update_reference_count instructions: - br # ... This profile specifies a system that does not allow reference and alias counting and neither have support for branching, but otherwise has the full QIR vesion 1.0 available.","title":"Specification"},{"location":"base-profile-transformations/#generation-specification","text":"To achieve the QIR generation in the feasibility section we made use of a number of different passes in order fold constants, unroll loops and map qubit allocations to static allocations. Based on this, we propose that generators are specified by creating a pipeline of LLVM passes to analyse and transform the QIR: name: profile-name displayName: Profile Name # ... generation: - passName: loopUnroll - passName: functionInline - passName: useStaticQubitAllocation - passName: eliminateClassicalMemoryUsage - passName: ignoreCall config: names: - __quantum__rt__array_update_alias_count - __quantum__rt__array_update_reference_count For those passes which are defined specifically for QIR we we allow configuration to be passed to them. This will allow the end-user to fine-tune the behaviour of profile generator.","title":"Generation specification"},{"location":"base-profile-transformations/#library-outline","text":"This is a placeholder for describing the outline of the QAT library. The aim is to create a dynamic library where we can add new components that allow to extend the QIR profile generation components with more passes and/or spefication options.","title":"Library outline"},{"location":"Api/","text":"API Documentation","title":"API Documentation"},{"location":"Api/#api-documentation","text":"","title":"API Documentation"},{"location":"Api/Classes/","text":"Classes namespace microsoft namespace quantum class AnyPattern Pattern that matches any operand. class BasicAllocationManager struct AllocatedMemoryBlock class BasicBlockPattern class BitCastPattern class BranchPattern class CallPattern class CommentLogger Concrete ILogger implementation that prints all messages as IR comments to llvm::errs(). class ConfigBind class ConfigurableProfileGenerator class ConfigurationManager struct Section class ConstIntPattern class FactoryConfiguration struct GroupAnalysis class GroupingAnalysisPass class GroupingAnalysisPassPrinter class GroupingPass class GroupingPassConfiguration class IAllocationManager class IConfigBind class ILogger class IOperandPrototype class IntToPtrPattern class IrManipulationTestHelper class LlvmPassesConfiguration class LoadPattern class LogCollection struct Location Class that holds the location of where the incident happened. struct Message Struct to hold a message together with its type and location. class ModuleLoader class SingleModuleTransformation class ParameterParser struct ParsedValue Struct that contains parsed and interpreted values of command line arguments. class PhiPattern class Profile class ProfileGenerator class RemoveDisallowedAttributesPass class ReplacementRule class RuleFactory class RuleSet class SelectPattern class StorePattern class SwitchPattern class TransformationRulesPass class TransformationRulesPassConfiguration Configuration class for the RuleTransformation pass. class UnnamedInvokePattern class ValidationPass struct Location class ValidationPassConfiguration class Validator namespace notation class Capture namespace microsoft::quantum::@33 Updated on 22 March 2022 at 08:31:22 UTC","title":"Classes"},{"location":"Api/Classes/#classes","text":"namespace microsoft namespace quantum class AnyPattern Pattern that matches any operand. class BasicAllocationManager struct AllocatedMemoryBlock class BasicBlockPattern class BitCastPattern class BranchPattern class CallPattern class CommentLogger Concrete ILogger implementation that prints all messages as IR comments to llvm::errs(). class ConfigBind class ConfigurableProfileGenerator class ConfigurationManager struct Section class ConstIntPattern class FactoryConfiguration struct GroupAnalysis class GroupingAnalysisPass class GroupingAnalysisPassPrinter class GroupingPass class GroupingPassConfiguration class IAllocationManager class IConfigBind class ILogger class IOperandPrototype class IntToPtrPattern class IrManipulationTestHelper class LlvmPassesConfiguration class LoadPattern class LogCollection struct Location Class that holds the location of where the incident happened. struct Message Struct to hold a message together with its type and location. class ModuleLoader class SingleModuleTransformation class ParameterParser struct ParsedValue Struct that contains parsed and interpreted values of command line arguments. class PhiPattern class Profile class ProfileGenerator class RemoveDisallowedAttributesPass class ReplacementRule class RuleFactory class RuleSet class SelectPattern class StorePattern class SwitchPattern class TransformationRulesPass class TransformationRulesPassConfiguration Configuration class for the RuleTransformation pass. class UnnamedInvokePattern class ValidationPass struct Location class ValidationPassConfiguration class Validator namespace notation class Capture namespace microsoft::quantum::@33 Updated on 22 March 2022 at 08:31:22 UTC","title":"Classes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/","text":"microsoft::quantum::AnyPattern Pattern that matches any operand. #include <Rules/Patterns/AnyPattern.hpp> Inherits from microsoft::quantum::IOperandPrototype Public Functions Name AnyPattern () ~AnyPattern () override virtual bool match (Value * instr, Captures & captures) const override Match of any operand always returns true and ignores children. virtual Child copy () const override Creates a copy of the AnyPattern instance. Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function AnyPattern AnyPattern() function ~AnyPattern ~AnyPattern() override function match virtual bool match( Value * instr, Captures & captures ) const override Match of any operand always returns true and ignores children. Reimplements : microsoft::quantum::IOperandPrototype::match function copy virtual Child copy() const override Creates a copy of the AnyPattern instance. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::AnyPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#microsoftquantumanypattern","text":"Pattern that matches any operand. #include <Rules/Patterns/AnyPattern.hpp> Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::AnyPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#public-functions","text":"Name AnyPattern () ~AnyPattern () override virtual bool match (Value * instr, Captures & captures) const override Match of any operand always returns true and ignores children. virtual Child copy () const override Creates a copy of the AnyPattern instance.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#function-anypattern","text":"AnyPattern()","title":"function AnyPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#function-anypattern_1","text":"~AnyPattern() override","title":"function ~AnyPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#function-match","text":"virtual bool match( Value * instr, Captures & captures ) const override Match of any operand always returns true and ignores children. Reimplements : microsoft::quantum::IOperandPrototype::match","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#function-copy","text":"virtual Child copy() const override Creates a copy of the AnyPattern instance. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 22 March 2022 at 08:31:22 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/","text":"microsoft::quantum::BasicAllocationManager More... #include <AllocationManager/AllocationManager.hpp> Inherits from microsoft::quantum::IAllocationManager Public Classes Name struct AllocatedMemoryBlock Public Types Name using std::vector< AllocatedMemoryBlock > Mappings Vector of memory segments. using std::shared_ptr< BasicAllocationManager > BasicAllocationManagerPtr Allocator pointer type. Public Functions Name BasicAllocationManagerPtr createNew () virtual Address allocate (String const & name =\"\", Index const & count =1) override virtual void release ( Address const & address) override Releases the segment by address. virtual void reset () override Resets the allocation manager and all its statistics. void setReuseRegisters (bool val) Additional inherited members Public Types inherited from microsoft::quantum::IAllocationManager Name using uint64_t Address Value type for address. using uint64_t Index Index type used to access an array element. using std::shared_ptr< IAllocationManager > AllocationManagerPtr Pointer interface. Public Functions inherited from microsoft::quantum::IAllocationManager Name IAllocationManager ( IAllocationManager const & ) IAllocationManager ( IAllocationManager && ) IAllocationManager & operator= ( IAllocationManager const & ) IAllocationManager & operator= ( IAllocationManager && ) virtual ~IAllocationManager () uint64_t allocationsInUse () const uint64_t maxAllocationsUsed () const Protected Functions inherited from microsoft::quantum::IAllocationManager Name IAllocationManager () =default void updateRegistersInUse (uint64_t n) Detailed Description class microsoft::quantum::BasicAllocationManager; AllocationManager is a simple qubit and results allocator that can be used at compile-time. It is based on an assumption that all qubit allocating function calls are inlined and that qubits/results can be allocated with strictly growing IDs. Public Types Documentation using Mappings using microsoft::quantum::BasicAllocationManager::Mappings = std::vector<AllocatedMemoryBlock>; Vector of memory segments. using BasicAllocationManagerPtr using microsoft::quantum::BasicAllocationManager::BasicAllocationManagerPtr = std::shared_ptr<BasicAllocationManager>; Allocator pointer type. Public Functions Documentation function createNew static BasicAllocationManagerPtr createNew() Creates a new allocation manager. The manager is kept as a shared pointer to enable allocation across different passes and/or replacement rules. function allocate virtual Address allocate( String const & name =\"\", Index const & count =1 ) override Reimplements : microsoft::quantum::IAllocationManager::allocate Allocates a possibly named segment of a given count. Calling allocate without and arguments allocates a single anonymous resource and returns the address. In case of a larger segment, the function returns the address pointing to the first element. Allocation is guaranteed to be sequential. function release virtual void release( Address const & address ) override Releases the segment by address. Reimplements : microsoft::quantum::IAllocationManager::release function reset virtual void reset() override Resets the allocation manager and all its statistics. Reimplements : microsoft::quantum::IAllocationManager::reset function setReuseRegisters void setReuseRegisters( bool val ) Configuration function to set mode of qubit allocation. If function argument is true, the allocation manager will reuse qubits. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::BasicAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#microsoftquantumbasicallocationmanager","text":"More... #include <AllocationManager/AllocationManager.hpp> Inherits from microsoft::quantum::IAllocationManager","title":"microsoft::quantum::BasicAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#public-classes","text":"Name struct AllocatedMemoryBlock","title":"Public Classes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#public-types","text":"Name using std::vector< AllocatedMemoryBlock > Mappings Vector of memory segments. using std::shared_ptr< BasicAllocationManager > BasicAllocationManagerPtr Allocator pointer type.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#public-functions","text":"Name BasicAllocationManagerPtr createNew () virtual Address allocate (String const & name =\"\", Index const & count =1) override virtual void release ( Address const & address) override Releases the segment by address. virtual void reset () override Resets the allocation manager and all its statistics. void setReuseRegisters (bool val)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IAllocationManager Name using uint64_t Address Value type for address. using uint64_t Index Index type used to access an array element. using std::shared_ptr< IAllocationManager > AllocationManagerPtr Pointer interface. Public Functions inherited from microsoft::quantum::IAllocationManager Name IAllocationManager ( IAllocationManager const & ) IAllocationManager ( IAllocationManager && ) IAllocationManager & operator= ( IAllocationManager const & ) IAllocationManager & operator= ( IAllocationManager && ) virtual ~IAllocationManager () uint64_t allocationsInUse () const uint64_t maxAllocationsUsed () const Protected Functions inherited from microsoft::quantum::IAllocationManager Name IAllocationManager () =default void updateRegistersInUse (uint64_t n)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#detailed-description","text":"class microsoft::quantum::BasicAllocationManager; AllocationManager is a simple qubit and results allocator that can be used at compile-time. It is based on an assumption that all qubit allocating function calls are inlined and that qubits/results can be allocated with strictly growing IDs.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#using-mappings","text":"using microsoft::quantum::BasicAllocationManager::Mappings = std::vector<AllocatedMemoryBlock>; Vector of memory segments.","title":"using Mappings"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#using-basicallocationmanagerptr","text":"using microsoft::quantum::BasicAllocationManager::BasicAllocationManagerPtr = std::shared_ptr<BasicAllocationManager>; Allocator pointer type.","title":"using BasicAllocationManagerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#function-createnew","text":"static BasicAllocationManagerPtr createNew() Creates a new allocation manager. The manager is kept as a shared pointer to enable allocation across different passes and/or replacement rules.","title":"function createNew"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#function-allocate","text":"virtual Address allocate( String const & name =\"\", Index const & count =1 ) override Reimplements : microsoft::quantum::IAllocationManager::allocate Allocates a possibly named segment of a given count. Calling allocate without and arguments allocates a single anonymous resource and returns the address. In case of a larger segment, the function returns the address pointing to the first element. Allocation is guaranteed to be sequential.","title":"function allocate"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#function-release","text":"virtual void release( Address const & address ) override Releases the segment by address. Reimplements : microsoft::quantum::IAllocationManager::release","title":"function release"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#function-reset","text":"virtual void reset() override Resets the allocation manager and all its statistics. Reimplements : microsoft::quantum::IAllocationManager::reset","title":"function reset"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#function-setreuseregisters","text":"void setReuseRegisters( bool val ) Configuration function to set mode of qubit allocation. If function argument is true, the allocation manager will reuse qubits. Updated on 22 March 2022 at 08:31:22 UTC","title":"function setReuseRegisters"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_block_pattern/","text":"microsoft::quantum::BasicBlockPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::BasicBlockPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_block_pattern/#microsoftquantumbasicblockpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::BasicBlockPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_block_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_block_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_block_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_block_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_block_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 March 2022 at 08:31:22 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_bit_cast_pattern/","text":"microsoft::quantum::BitCastPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::BitCastPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_bit_cast_pattern/#microsoftquantumbitcastpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::BitCastPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_bit_cast_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_bit_cast_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_bit_cast_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_bit_cast_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_bit_cast_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 March 2022 at 08:31:22 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_branch_pattern/","text":"microsoft::quantum::BranchPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::BranchPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_branch_pattern/#microsoftquantumbranchpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::BranchPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_branch_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_branch_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_branch_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_branch_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_branch_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 March 2022 at 08:31:22 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/","text":"microsoft::quantum::CallPattern Inherits from microsoft::quantum::IOperandPrototype Public Types Name using std::string String Public Functions Name CallPattern (String const & name) Construction by name. CallPattern ( CallPattern const & other) Copy construction prohibited. CallPattern ( CallPattern && other) =default Move construction allowed. ~CallPattern () override Destructor implementation. virtual bool match (Value * instr, Captures & captures) const override Matches the callee by name. virtual Child copy () const override Creates a copy of itself. Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Types Documentation using String using microsoft::quantum::CallPattern::String = std::string; Public Functions Documentation function CallPattern explicit CallPattern( String const & name ) Construction by name. function CallPattern CallPattern( CallPattern const & other ) Copy construction prohibited. function CallPattern CallPattern( CallPattern && other ) =default Move construction allowed. function ~CallPattern ~CallPattern() override Destructor implementation. function match virtual bool match( Value * instr, Captures & captures ) const override Matches the callee by name. Reimplements : microsoft::quantum::IOperandPrototype::match function copy virtual Child copy() const override Creates a copy of itself. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::CallPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#microsoftquantumcallpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::CallPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#public-types","text":"Name using std::string String","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#public-functions","text":"Name CallPattern (String const & name) Construction by name. CallPattern ( CallPattern const & other) Copy construction prohibited. CallPattern ( CallPattern && other) =default Move construction allowed. ~CallPattern () override Destructor implementation. virtual bool match (Value * instr, Captures & captures) const override Matches the callee by name. virtual Child copy () const override Creates a copy of itself.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#using-string","text":"using microsoft::quantum::CallPattern::String = std::string;","title":"using String"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#function-callpattern","text":"explicit CallPattern( String const & name ) Construction by name.","title":"function CallPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#function-callpattern_1","text":"CallPattern( CallPattern const & other ) Copy construction prohibited.","title":"function CallPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#function-callpattern_2","text":"CallPattern( CallPattern && other ) =default Move construction allowed.","title":"function CallPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#function-callpattern_3","text":"~CallPattern() override Destructor implementation.","title":"function ~CallPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#function-match","text":"virtual bool match( Value * instr, Captures & captures ) const override Matches the callee by name. Reimplements : microsoft::quantum::IOperandPrototype::match","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#function-copy","text":"virtual Child copy() const override Creates a copy of itself. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 22 March 2022 at 08:31:22 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/","text":"microsoft::quantum::CommentLogger Concrete ILogger implementation that prints all messages as IR comments to llvm::errs(). #include <Logging/CommentLogger.hpp> Inherits from microsoft::quantum::ILogger Public Functions Name virtual void debug (String const & message) override Adds a debug message to the list. virtual void info (String const & message) override Adds an info message to the list. virtual void warning (String const & message) override Adds a warning message to the list. virtual void error (String const & message) override Adds an error message to the list. virtual void internalError (String const & message) override Adds an internal error message to the list. virtual void setLocation (String const & name, uint64_t row, uint64_t col) override Function that allows to set the current location. virtual void setLlvmHint (String const & value) override Sets the value of the LLVM instruction causing the issue. virtual void setFrontendHint (String const & value) override Sets the value of the frontend instruction causing the issue. Additional inherited members Public Functions inherited from microsoft::quantum::ILogger Name ILogger () =default ILogger ( ILogger const & ) =default ILogger ( ILogger && ) =default ILogger & operator= ( ILogger const & ) =default ILogger & operator= ( ILogger && ) =default virtual ~ILogger () Public Functions Documentation function debug virtual void debug( String const & message ) override Adds a debug message to the list. Reimplements : microsoft::quantum::ILogger::debug function info virtual void info( String const & message ) override Adds an info message to the list. Reimplements : microsoft::quantum::ILogger::info function warning virtual void warning( String const & message ) override Adds a warning message to the list. Reimplements : microsoft::quantum::ILogger::warning function error virtual void error( String const & message ) override Adds an error message to the list. Reimplements : microsoft::quantum::ILogger::error function internalError virtual void internalError( String const & message ) override Adds an internal error message to the list. Reimplements : microsoft::quantum::ILogger::internalError function setLocation virtual void setLocation( String const & name, uint64_t row, uint64_t col ) override Function that allows to set the current location. Reimplements : microsoft::quantum::ILogger::setLocation function setLlvmHint virtual void setLlvmHint( String const & value ) override Sets the value of the LLVM instruction causing the issue. Reimplements : microsoft::quantum::ILogger::setLlvmHint function setFrontendHint virtual void setFrontendHint( String const & value ) override Sets the value of the frontend instruction causing the issue. Reimplements : microsoft::quantum::ILogger::setFrontendHint Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::CommentLogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#microsoftquantumcommentlogger","text":"Concrete ILogger implementation that prints all messages as IR comments to llvm::errs(). #include <Logging/CommentLogger.hpp> Inherits from microsoft::quantum::ILogger","title":"microsoft::quantum::CommentLogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#public-functions","text":"Name virtual void debug (String const & message) override Adds a debug message to the list. virtual void info (String const & message) override Adds an info message to the list. virtual void warning (String const & message) override Adds a warning message to the list. virtual void error (String const & message) override Adds an error message to the list. virtual void internalError (String const & message) override Adds an internal error message to the list. virtual void setLocation (String const & name, uint64_t row, uint64_t col) override Function that allows to set the current location. virtual void setLlvmHint (String const & value) override Sets the value of the LLVM instruction causing the issue. virtual void setFrontendHint (String const & value) override Sets the value of the frontend instruction causing the issue.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#additional-inherited-members","text":"Public Functions inherited from microsoft::quantum::ILogger Name ILogger () =default ILogger ( ILogger const & ) =default ILogger ( ILogger && ) =default ILogger & operator= ( ILogger const & ) =default ILogger & operator= ( ILogger && ) =default virtual ~ILogger ()","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-debug","text":"virtual void debug( String const & message ) override Adds a debug message to the list. Reimplements : microsoft::quantum::ILogger::debug","title":"function debug"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-info","text":"virtual void info( String const & message ) override Adds an info message to the list. Reimplements : microsoft::quantum::ILogger::info","title":"function info"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-warning","text":"virtual void warning( String const & message ) override Adds a warning message to the list. Reimplements : microsoft::quantum::ILogger::warning","title":"function warning"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-error","text":"virtual void error( String const & message ) override Adds an error message to the list. Reimplements : microsoft::quantum::ILogger::error","title":"function error"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-internalerror","text":"virtual void internalError( String const & message ) override Adds an internal error message to the list. Reimplements : microsoft::quantum::ILogger::internalError","title":"function internalError"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-setlocation","text":"virtual void setLocation( String const & name, uint64_t row, uint64_t col ) override Function that allows to set the current location. Reimplements : microsoft::quantum::ILogger::setLocation","title":"function setLocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-setllvmhint","text":"virtual void setLlvmHint( String const & value ) override Sets the value of the LLVM instruction causing the issue. Reimplements : microsoft::quantum::ILogger::setLlvmHint","title":"function setLlvmHint"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-setfrontendhint","text":"virtual void setFrontendHint( String const & value ) override Sets the value of the frontend instruction causing the issue. Reimplements : microsoft::quantum::ILogger::setFrontendHint Updated on 22 March 2022 at 08:31:22 UTC","title":"function setFrontendHint"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/","text":"microsoft::quantum::ConfigBind More... #include <Commandline/ConfigBind.hpp> Inherits from microsoft::quantum::IConfigBind Public Types Name using T Type template <typename A ,typename B ,typename R > using typename std::enable_if< std::is_same< A, B >:: value , R >::type EnableIf Helper template to conditionally disable implementation unless a specific type is used. Public Functions Name ConfigBind () ConfigBind ( ConfigBind const & ) ConfigBind ( ConfigBind && ) ConfigBind & operator= ( ConfigBind const & ) ConfigBind & operator= ( ConfigBind && ) ~ConfigBind () override =default ConfigBind (Type & bind, T default_value, String const & name, String const & description) void markAsExperimental (Type const & off_value) virtual bool setupArguments ( ParameterParser & parser) override Adds the argument to the parser. virtual bool configure ( ParameterParser & parser, bool experimental_mode) override virtual String value () override String representation of the bound value. Additional inherited members Public Functions inherited from microsoft::quantum::IConfigBind Name IConfigBind ( IConfigBind const & ) IConfigBind ( IConfigBind && ) virtual ~IConfigBind () String name () const Returns the name of the bound configuration variable. String description () const Returns the description of the configuration variable. bool isFlag () const Indicates whether or not this. String defaultValue () const Returns the default value for the flag. bool isExperimental () const Indicates whether or not this is an experimental config. Protected Functions inherited from microsoft::quantum::IConfigBind Name IConfigBind (String const & name, String const & description) void setName (String const & name) Sets the name of the configuration variable. void markAsFlag () Marks the variable as a flag. void setDefault (String const & v) Sets the default value as a string. void makeSettingExperimental () Marks the config as experimental. Detailed Description template <typename T > class microsoft::quantum::ConfigBind; Generic implementation of the bind interface for different types. This class holds the name of the command line parameter and a reference variable corresponding to it. It implements serializers and deserializers to allow transforming strings to native values and vice versa. Public Types Documentation using Type using microsoft::quantum::ConfigBind< T >::Type = T; using EnableIf template <typename A , typename B , typename R > using microsoft::quantum::ConfigBind< T >::EnableIf = typename std::enable_if<std::is_same<A, B>::value, R>::type; Helper template to conditionally disable implementation unless a specific type is used. Public Functions Documentation function ConfigBind ConfigBind() function ConfigBind ConfigBind( ConfigBind const & ) function ConfigBind ConfigBind( ConfigBind && ) function operator= ConfigBind & operator=( ConfigBind const & ) function operator= ConfigBind & operator=( ConfigBind && ) function ~ConfigBind ~ConfigBind() override =default function ConfigBind ConfigBind( Type & bind, T default_value, String const & name, String const & description ) Constructor to bind value to parameter. This class holds a reference to a variable together with the name it is expected to have when passed through the parameter parser. function markAsExperimental void markAsExperimental( Type const & off_value ) function setupArguments virtual bool setupArguments( ParameterParser & parser ) override Adds the argument to the parser. Reimplements : microsoft::quantum::IConfigBind::setupArguments function configure virtual bool configure( ParameterParser & parser, bool experimental_mode ) override Reimplements : microsoft::quantum::IConfigBind::configure Configures the bound value. This method examines the parsed input and use updates the bound value accordingly. function value virtual String value() override String representation of the bound value. Reimplements : microsoft::quantum::IConfigBind::value Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::ConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#microsoftquantumconfigbind","text":"More... #include <Commandline/ConfigBind.hpp> Inherits from microsoft::quantum::IConfigBind","title":"microsoft::quantum::ConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#public-types","text":"Name using T Type template <typename A ,typename B ,typename R > using typename std::enable_if< std::is_same< A, B >:: value , R >::type EnableIf Helper template to conditionally disable implementation unless a specific type is used.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#public-functions","text":"Name ConfigBind () ConfigBind ( ConfigBind const & ) ConfigBind ( ConfigBind && ) ConfigBind & operator= ( ConfigBind const & ) ConfigBind & operator= ( ConfigBind && ) ~ConfigBind () override =default ConfigBind (Type & bind, T default_value, String const & name, String const & description) void markAsExperimental (Type const & off_value) virtual bool setupArguments ( ParameterParser & parser) override Adds the argument to the parser. virtual bool configure ( ParameterParser & parser, bool experimental_mode) override virtual String value () override String representation of the bound value.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#additional-inherited-members","text":"Public Functions inherited from microsoft::quantum::IConfigBind Name IConfigBind ( IConfigBind const & ) IConfigBind ( IConfigBind && ) virtual ~IConfigBind () String name () const Returns the name of the bound configuration variable. String description () const Returns the description of the configuration variable. bool isFlag () const Indicates whether or not this. String defaultValue () const Returns the default value for the flag. bool isExperimental () const Indicates whether or not this is an experimental config. Protected Functions inherited from microsoft::quantum::IConfigBind Name IConfigBind (String const & name, String const & description) void setName (String const & name) Sets the name of the configuration variable. void markAsFlag () Marks the variable as a flag. void setDefault (String const & v) Sets the default value as a string. void makeSettingExperimental () Marks the config as experimental.","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#detailed-description","text":"template <typename T > class microsoft::quantum::ConfigBind; Generic implementation of the bind interface for different types. This class holds the name of the command line parameter and a reference variable corresponding to it. It implements serializers and deserializers to allow transforming strings to native values and vice versa.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#using-type","text":"using microsoft::quantum::ConfigBind< T >::Type = T;","title":"using Type"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#using-enableif","text":"template <typename A , typename B , typename R > using microsoft::quantum::ConfigBind< T >::EnableIf = typename std::enable_if<std::is_same<A, B>::value, R>::type; Helper template to conditionally disable implementation unless a specific type is used.","title":"using EnableIf"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-configbind","text":"ConfigBind()","title":"function ConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-configbind_1","text":"ConfigBind( ConfigBind const & )","title":"function ConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-configbind_2","text":"ConfigBind( ConfigBind && )","title":"function ConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-operator","text":"ConfigBind & operator=( ConfigBind const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-operator_1","text":"ConfigBind & operator=( ConfigBind && )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-configbind_3","text":"~ConfigBind() override =default","title":"function ~ConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-configbind_4","text":"ConfigBind( Type & bind, T default_value, String const & name, String const & description ) Constructor to bind value to parameter. This class holds a reference to a variable together with the name it is expected to have when passed through the parameter parser.","title":"function ConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-markasexperimental","text":"void markAsExperimental( Type const & off_value )","title":"function markAsExperimental"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-setuparguments","text":"virtual bool setupArguments( ParameterParser & parser ) override Adds the argument to the parser. Reimplements : microsoft::quantum::IConfigBind::setupArguments","title":"function setupArguments"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-configure","text":"virtual bool configure( ParameterParser & parser, bool experimental_mode ) override Reimplements : microsoft::quantum::IConfigBind::configure Configures the bound value. This method examines the parsed input and use updates the bound value accordingly.","title":"function configure"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-value","text":"virtual String value() override String representation of the bound value. Reimplements : microsoft::quantum::IConfigBind::value Updated on 22 March 2022 at 08:31:22 UTC","title":"function value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_profile_generator/","text":"microsoft::quantum::ConfigurableProfileGenerator More... #include <Generators/ConfigurableProfileGenerator.hpp> Inherits from microsoft::quantum::ProfileGenerator Public Types Name using std::function< void( RuleSet &)> ConfigureFunction Function type that configures a rule set. Public Functions Name ConfigurableProfileGenerator () ConfigurableProfileGenerator ( ConfigureFunction const & configure, TransformationRulesPassConfiguration const & profile_pass_config = TransformationRulesPassConfiguration::createDisabled (), LlvmPassesConfiguration const & llvm_config = LlvmPassesConfiguration::createDisabled ()) TransformationRulesPassConfiguration const & ruleTransformationConfig () const Returns a constant reference to the rule transformation configuration. LlvmPassesConfiguration const & llvmPassesConfig () const Returns a constant reference to the LLVM passes configuration. Additional inherited members Public Types inherited from microsoft::quantum::ProfileGenerator Name using llvm::PassBuilder PassBuilder using PassBuilder::OptimizationLevel OptimizationLevel using llvm::FunctionAnalysisManager FunctionAnalysisManager template <typename R > using std::function< void(R const &, ProfileGenerator *, Profile &)> SetupFunction using std::function< void( ProfileGenerator *, Profile &)> SetupFunctionWrapper Wrapper function type for invoking the profile setup function. using std::vector< std::pair< String, SetupFunctionWrapper > > Components List of components to be configured. Public Functions inherited from microsoft::quantum::ProfileGenerator Name ProfileGenerator () =default ~ProfileGenerator () =default ProfileGenerator ( ProfileGenerator const & ) ProfileGenerator ( ProfileGenerator && ) ProfileGenerator & operator= ( ProfileGenerator const & ) ProfileGenerator & operator= ( ProfileGenerator && ) ConfigurationManager & configurationManager () ConfigurationManager const & configurationManager () const Profile newProfile (String const & name, OptimizationLevel const & optimization_level, bool debug) template <typename R > void registerProfileComponent (String const & id, SetupFunction < R > setup) template <typename R > void replaceProfileComponent (String const & id, SetupFunction < R > setup) template <typename R > void registerAnonymousProfileComponent ( SetupFunction < R > setup) void replicateProfileComponent (String const & id) llvm::ModulePassManager & modulePassManager () Returns the module pass manager. llvm::FunctionPassManager & functionPassManager () Returns the module pass manager. llvm::PassBuilder & passBuilder () Returns the pass builder. OptimizationLevel optimizationLevel () const Returns the optimization level. bool isDebugMode () const Flag indicating whether we are operating in debug mode or not. void setupDefaultComponentPipeline () Sets the default pipeline up. Protected Functions inherited from microsoft::quantum::ProfileGenerator Name llvm::ModulePassManager createGenerationModulePassManager ( Profile & profile, OptimizationLevel const & optimization_level, bool debug) llvm::ModulePassManager createValidationModulePass (PassBuilder & pass_builder, OptimizationLevel const & optimization_level, bool debug) Detailed Description class microsoft::quantum::ConfigurableProfileGenerator; ConfigurableProfileGenerator defines a profile that configures the rule set used by the Profile pass. This profile is useful for generating dynamic profiles and is well suited for testing purposes or YAML configured transformation of the IR. Public Types Documentation using ConfigureFunction using microsoft::quantum::ConfigurableProfileGenerator::ConfigureFunction = std::function<void(RuleSet&)>; Function type that configures a rule set. Public Functions Documentation function ConfigurableProfileGenerator ConfigurableProfileGenerator() Default constructor. This constructor adds components for rule transformation and LLVM passes. These are configurable through the corresponding configuration classes which can be access through the configuration manager. function ConfigurableProfileGenerator explicit ConfigurableProfileGenerator( ConfigureFunction const & configure, TransformationRulesPassConfiguration const & profile_pass_config =TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration const & llvm_config =LlvmPassesConfiguration::createDisabled() ) The constructor takes a lambda function which configures the rule set. This function is invoked during the creation of the generation module. This constructor further overrides the default configuration function ruleTransformationConfig TransformationRulesPassConfiguration const & ruleTransformationConfig() const Returns a constant reference to the rule transformation configuration. function llvmPassesConfig LlvmPassesConfiguration const & llvmPassesConfig() const Returns a constant reference to the LLVM passes configuration. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::ConfigurableProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_profile_generator/#microsoftquantumconfigurableprofilegenerator","text":"More... #include <Generators/ConfigurableProfileGenerator.hpp> Inherits from microsoft::quantum::ProfileGenerator","title":"microsoft::quantum::ConfigurableProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_profile_generator/#public-types","text":"Name using std::function< void( RuleSet &)> ConfigureFunction Function type that configures a rule set.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_profile_generator/#public-functions","text":"Name ConfigurableProfileGenerator () ConfigurableProfileGenerator ( ConfigureFunction const & configure, TransformationRulesPassConfiguration const & profile_pass_config = TransformationRulesPassConfiguration::createDisabled (), LlvmPassesConfiguration const & llvm_config = LlvmPassesConfiguration::createDisabled ()) TransformationRulesPassConfiguration const & ruleTransformationConfig () const Returns a constant reference to the rule transformation configuration. LlvmPassesConfiguration const & llvmPassesConfig () const Returns a constant reference to the LLVM passes configuration.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_profile_generator/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::ProfileGenerator Name using llvm::PassBuilder PassBuilder using PassBuilder::OptimizationLevel OptimizationLevel using llvm::FunctionAnalysisManager FunctionAnalysisManager template <typename R > using std::function< void(R const &, ProfileGenerator *, Profile &)> SetupFunction using std::function< void( ProfileGenerator *, Profile &)> SetupFunctionWrapper Wrapper function type for invoking the profile setup function. using std::vector< std::pair< String, SetupFunctionWrapper > > Components List of components to be configured. Public Functions inherited from microsoft::quantum::ProfileGenerator Name ProfileGenerator () =default ~ProfileGenerator () =default ProfileGenerator ( ProfileGenerator const & ) ProfileGenerator ( ProfileGenerator && ) ProfileGenerator & operator= ( ProfileGenerator const & ) ProfileGenerator & operator= ( ProfileGenerator && ) ConfigurationManager & configurationManager () ConfigurationManager const & configurationManager () const Profile newProfile (String const & name, OptimizationLevel const & optimization_level, bool debug) template <typename R > void registerProfileComponent (String const & id, SetupFunction < R > setup) template <typename R > void replaceProfileComponent (String const & id, SetupFunction < R > setup) template <typename R > void registerAnonymousProfileComponent ( SetupFunction < R > setup) void replicateProfileComponent (String const & id) llvm::ModulePassManager & modulePassManager () Returns the module pass manager. llvm::FunctionPassManager & functionPassManager () Returns the module pass manager. llvm::PassBuilder & passBuilder () Returns the pass builder. OptimizationLevel optimizationLevel () const Returns the optimization level. bool isDebugMode () const Flag indicating whether we are operating in debug mode or not. void setupDefaultComponentPipeline () Sets the default pipeline up. Protected Functions inherited from microsoft::quantum::ProfileGenerator Name llvm::ModulePassManager createGenerationModulePassManager ( Profile & profile, OptimizationLevel const & optimization_level, bool debug) llvm::ModulePassManager createValidationModulePass (PassBuilder & pass_builder, OptimizationLevel const & optimization_level, bool debug)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_profile_generator/#detailed-description","text":"class microsoft::quantum::ConfigurableProfileGenerator; ConfigurableProfileGenerator defines a profile that configures the rule set used by the Profile pass. This profile is useful for generating dynamic profiles and is well suited for testing purposes or YAML configured transformation of the IR.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_profile_generator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_profile_generator/#using-configurefunction","text":"using microsoft::quantum::ConfigurableProfileGenerator::ConfigureFunction = std::function<void(RuleSet&)>; Function type that configures a rule set.","title":"using ConfigureFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_profile_generator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_profile_generator/#function-configurableprofilegenerator","text":"ConfigurableProfileGenerator() Default constructor. This constructor adds components for rule transformation and LLVM passes. These are configurable through the corresponding configuration classes which can be access through the configuration manager.","title":"function ConfigurableProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_profile_generator/#function-configurableprofilegenerator_1","text":"explicit ConfigurableProfileGenerator( ConfigureFunction const & configure, TransformationRulesPassConfiguration const & profile_pass_config =TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration const & llvm_config =LlvmPassesConfiguration::createDisabled() ) The constructor takes a lambda function which configures the rule set. This function is invoked during the creation of the generation module. This constructor further overrides the default configuration","title":"function ConfigurableProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_profile_generator/#function-ruletransformationconfig","text":"TransformationRulesPassConfiguration const & ruleTransformationConfig() const Returns a constant reference to the rule transformation configuration.","title":"function ruleTransformationConfig"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configurable_profile_generator/#function-llvmpassesconfig","text":"LlvmPassesConfiguration const & llvmPassesConfig() const Returns a constant reference to the LLVM passes configuration. Updated on 22 March 2022 at 08:31:22 UTC","title":"function llvmPassesConfig"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/","text":"microsoft::quantum::ConfigurationManager More... #include <Commandline/ConfigurationManager.hpp> Public Classes Name struct Section Public Types Name using std::shared_ptr< IConfigBind > IConfigBindPtr Pointer class used to bind a parameter to a value. using std::vector< IConfigBindPtr > ConfigList List of bound variables. using std::shared_ptr< void > VoidPtr Type-erased configuration pointer. using std::type_index TypeId Type index class. using std::shared_ptr< bool > BoolPtr using std::vector< Section > Sections List of available sections. Public Functions Name ConfigurationManager () =default Configuration manager is default constructible, non-copyable and non-movable. ConfigurationManager ( ConfigurationManager const & ) ConfigurationManager ( ConfigurationManager && ) ConfigurationManager & operator= ( ConfigurationManager const & ) ConfigurationManager & operator= ( ConfigurationManager && ) ~ConfigurationManager () void setupArguments ( ParameterParser & parser) Adds all bound variables as parser arguments. void configure ( ParameterParser & parser, bool experimental_mode =false) Configures the value of each bound variable given a parser instance. template <typename T > void setConfig (T const & value) Given an instance of the ConfigurationManager , this method override settings of class T. template <typename T > T const & get () const Gets the configuration instance of type T. void printHelp (bool experimental_mode) const Prints options for configurability to the terminal. void printConfiguration () const template <typename T > void addConfig (String const & id =\"\", T const & default_value =T()) Adds a new configuration of type T. template <typename T > bool configWasRegistered () Whether or not a configuration of type previously registered. template <typename T > bool isActive () Whether or not the component associated with T is active. void setSectionName (String const & name, String const & description) void disableSectionByDefault () template <typename T > void addParameter (T & bind, T default_value, String const & name, String const & description) template <typename T > void addExperimentalParameter (T & bind, T default_value, T off_value, String const & name, String const & description) template <typename T > void addExperimentalParameter (T & bind, T default_value, String const & name, String const & description) template <typename T > void addExperimentalParameter (T & bind, String const & name, String const & description) template <typename T > void addParameter (T & bind, String const & name, String const & description) Detailed Description class microsoft::quantum::ConfigurationManager; ConfigurationManager is a class that holds a collection of configurations (sections). Each of these sections are embodied in their own class with a one-to-one mapping between configuration section and the configuration type. As an example, if one wishes to make a configuration for the class Foo, one would create a class FooConfig which would hold all the variables that are configurable and then add FooConfig to the ConfigurationManager using [addConfig()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addconfig) . For FooConfig to fulfill the concept of a configuration, it must implement a setup functions whose first argument is the ConfigurationManager . Public Types Documentation using IConfigBindPtr using microsoft::quantum::ConfigurationManager::IConfigBindPtr = std::shared_ptr<IConfigBind>; Pointer class used to bind a parameter to a value. using ConfigList using microsoft::quantum::ConfigurationManager::ConfigList = std::vector<IConfigBindPtr>; List of bound variables. using VoidPtr using microsoft::quantum::ConfigurationManager::VoidPtr = std::shared_ptr<void>; Type-erased configuration pointer. using TypeId using microsoft::quantum::ConfigurationManager::TypeId = std::type_index; Type index class. using BoolPtr using microsoft::quantum::ConfigurationManager::BoolPtr = std::shared_ptr<bool>; using Sections using microsoft::quantum::ConfigurationManager::Sections = std::vector<Section>; List of available sections. Public Functions Documentation function ConfigurationManager ConfigurationManager() =default Configuration manager is default constructible, non-copyable and non-movable. function ConfigurationManager ConfigurationManager( ConfigurationManager const & ) function ConfigurationManager ConfigurationManager( ConfigurationManager && ) function operator= ConfigurationManager & operator=( ConfigurationManager const & ) function operator= ConfigurationManager & operator=( ConfigurationManager && ) function ~ConfigurationManager inline ~ConfigurationManager() function setupArguments void setupArguments( ParameterParser & parser ) Adds all bound variables as parser arguments. function configure void configure( ParameterParser & parser, bool experimental_mode =false ) Configures the value of each bound variable given a parser instance. function setConfig template <typename T > inline void setConfig( T const & value ) Given an instance of the ConfigurationManager , this method override settings of class T. function get template <typename T > inline T const & get() const Gets the configuration instance of type T. function printHelp void printHelp( bool experimental_mode ) const Prints options for configurability to the terminal. function printConfiguration void printConfiguration() const Prints the configuration to the terminal. The configuration print is LLVM IR compatible meaning that every line starts with a semicolon ; to ensure that it is interpreted as a comment. function addConfig template <typename T > inline void addConfig( String const & id =\"\", T const & default_value =T() ) Adds a new configuration of type T. function configWasRegistered template <typename T > inline bool configWasRegistered() Whether or not a configuration of type previously registered. function isActive template <typename T > inline bool isActive() Whether or not the component associated with T is active. function setSectionName void setSectionName( String const & name, String const & description ) Sets the section name. This method is used by the configuration class to set a section name. function disableSectionByDefault void disableSectionByDefault() function addParameter template <typename T > inline void addParameter( T & bind, T default_value, String const & name, String const & description ) Adds a new parameter with a default value to the configuration section. This function should be used by the configuration class. function addExperimentalParameter template <typename T > inline void addExperimentalParameter( T & bind, T default_value, T off_value, String const & name, String const & description ) Adds an experimental parameter with a default value and an experimental \"off\" value to the configuration section. This function should be used by the configuration class. The difference to addParameter is that this function marks the parameter as experimental and has a default \"off\" value function addExperimentalParameter template <typename T > inline void addExperimentalParameter( T & bind, T default_value, String const & name, String const & description ) Adds an experimental parameter with a default value to the configuration section. The experimental off value will be set to the default value of parameter. This function should be used by the configuration class. function addExperimentalParameter template <typename T > inline void addExperimentalParameter( T & bind, String const & name, String const & description ) Adds an experimental parameter. The default value and the experimental off value will be the value of the parameter added. This function should be used by the configuration class. function addParameter template <typename T > inline void addParameter( T & bind, String const & name, String const & description ) Adds a new parameter to the configuration section. This method uses the bound variable value as default value. This function should be used by the configuration class. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::ConfigurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#microsoftquantumconfigurationmanager","text":"More... #include <Commandline/ConfigurationManager.hpp>","title":"microsoft::quantum::ConfigurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#public-classes","text":"Name struct Section","title":"Public Classes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#public-types","text":"Name using std::shared_ptr< IConfigBind > IConfigBindPtr Pointer class used to bind a parameter to a value. using std::vector< IConfigBindPtr > ConfigList List of bound variables. using std::shared_ptr< void > VoidPtr Type-erased configuration pointer. using std::type_index TypeId Type index class. using std::shared_ptr< bool > BoolPtr using std::vector< Section > Sections List of available sections.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#public-functions","text":"Name ConfigurationManager () =default Configuration manager is default constructible, non-copyable and non-movable. ConfigurationManager ( ConfigurationManager const & ) ConfigurationManager ( ConfigurationManager && ) ConfigurationManager & operator= ( ConfigurationManager const & ) ConfigurationManager & operator= ( ConfigurationManager && ) ~ConfigurationManager () void setupArguments ( ParameterParser & parser) Adds all bound variables as parser arguments. void configure ( ParameterParser & parser, bool experimental_mode =false) Configures the value of each bound variable given a parser instance. template <typename T > void setConfig (T const & value) Given an instance of the ConfigurationManager , this method override settings of class T. template <typename T > T const & get () const Gets the configuration instance of type T. void printHelp (bool experimental_mode) const Prints options for configurability to the terminal. void printConfiguration () const template <typename T > void addConfig (String const & id =\"\", T const & default_value =T()) Adds a new configuration of type T. template <typename T > bool configWasRegistered () Whether or not a configuration of type previously registered. template <typename T > bool isActive () Whether or not the component associated with T is active. void setSectionName (String const & name, String const & description) void disableSectionByDefault () template <typename T > void addParameter (T & bind, T default_value, String const & name, String const & description) template <typename T > void addExperimentalParameter (T & bind, T default_value, T off_value, String const & name, String const & description) template <typename T > void addExperimentalParameter (T & bind, T default_value, String const & name, String const & description) template <typename T > void addExperimentalParameter (T & bind, String const & name, String const & description) template <typename T > void addParameter (T & bind, String const & name, String const & description)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#detailed-description","text":"class microsoft::quantum::ConfigurationManager; ConfigurationManager is a class that holds a collection of configurations (sections). Each of these sections are embodied in their own class with a one-to-one mapping between configuration section and the configuration type. As an example, if one wishes to make a configuration for the class Foo, one would create a class FooConfig which would hold all the variables that are configurable and then add FooConfig to the ConfigurationManager using [addConfig()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addconfig) . For FooConfig to fulfill the concept of a configuration, it must implement a setup functions whose first argument is the ConfigurationManager .","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-iconfigbindptr","text":"using microsoft::quantum::ConfigurationManager::IConfigBindPtr = std::shared_ptr<IConfigBind>; Pointer class used to bind a parameter to a value.","title":"using IConfigBindPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-configlist","text":"using microsoft::quantum::ConfigurationManager::ConfigList = std::vector<IConfigBindPtr>; List of bound variables.","title":"using ConfigList"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-voidptr","text":"using microsoft::quantum::ConfigurationManager::VoidPtr = std::shared_ptr<void>; Type-erased configuration pointer.","title":"using VoidPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-typeid","text":"using microsoft::quantum::ConfigurationManager::TypeId = std::type_index; Type index class.","title":"using TypeId"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-boolptr","text":"using microsoft::quantum::ConfigurationManager::BoolPtr = std::shared_ptr<bool>;","title":"using BoolPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-sections","text":"using microsoft::quantum::ConfigurationManager::Sections = std::vector<Section>; List of available sections.","title":"using Sections"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-configurationmanager","text":"ConfigurationManager() =default Configuration manager is default constructible, non-copyable and non-movable.","title":"function ConfigurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-configurationmanager_1","text":"ConfigurationManager( ConfigurationManager const & )","title":"function ConfigurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-configurationmanager_2","text":"ConfigurationManager( ConfigurationManager && )","title":"function ConfigurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-operator","text":"ConfigurationManager & operator=( ConfigurationManager const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-operator_1","text":"ConfigurationManager & operator=( ConfigurationManager && )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-configurationmanager_3","text":"inline ~ConfigurationManager()","title":"function ~ConfigurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-setuparguments","text":"void setupArguments( ParameterParser & parser ) Adds all bound variables as parser arguments.","title":"function setupArguments"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-configure","text":"void configure( ParameterParser & parser, bool experimental_mode =false ) Configures the value of each bound variable given a parser instance.","title":"function configure"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-setconfig","text":"template <typename T > inline void setConfig( T const & value ) Given an instance of the ConfigurationManager , this method override settings of class T.","title":"function setConfig"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-get","text":"template <typename T > inline T const & get() const Gets the configuration instance of type T.","title":"function get"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-printhelp","text":"void printHelp( bool experimental_mode ) const Prints options for configurability to the terminal.","title":"function printHelp"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-printconfiguration","text":"void printConfiguration() const Prints the configuration to the terminal. The configuration print is LLVM IR compatible meaning that every line starts with a semicolon ; to ensure that it is interpreted as a comment.","title":"function printConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addconfig","text":"template <typename T > inline void addConfig( String const & id =\"\", T const & default_value =T() ) Adds a new configuration of type T.","title":"function addConfig"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-configwasregistered","text":"template <typename T > inline bool configWasRegistered() Whether or not a configuration of type previously registered.","title":"function configWasRegistered"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-isactive","text":"template <typename T > inline bool isActive() Whether or not the component associated with T is active.","title":"function isActive"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-setsectionname","text":"void setSectionName( String const & name, String const & description ) Sets the section name. This method is used by the configuration class to set a section name.","title":"function setSectionName"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-disablesectionbydefault","text":"void disableSectionByDefault()","title":"function disableSectionByDefault"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addparameter","text":"template <typename T > inline void addParameter( T & bind, T default_value, String const & name, String const & description ) Adds a new parameter with a default value to the configuration section. This function should be used by the configuration class.","title":"function addParameter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addexperimentalparameter","text":"template <typename T > inline void addExperimentalParameter( T & bind, T default_value, T off_value, String const & name, String const & description ) Adds an experimental parameter with a default value and an experimental \"off\" value to the configuration section. This function should be used by the configuration class. The difference to addParameter is that this function marks the parameter as experimental and has a default \"off\" value","title":"function addExperimentalParameter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addexperimentalparameter_1","text":"template <typename T > inline void addExperimentalParameter( T & bind, T default_value, String const & name, String const & description ) Adds an experimental parameter with a default value to the configuration section. The experimental off value will be set to the default value of parameter. This function should be used by the configuration class.","title":"function addExperimentalParameter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addexperimentalparameter_2","text":"template <typename T > inline void addExperimentalParameter( T & bind, String const & name, String const & description ) Adds an experimental parameter. The default value and the experimental off value will be the value of the parameter added. This function should be used by the configuration class.","title":"function addExperimentalParameter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addparameter_1","text":"template <typename T > inline void addParameter( T & bind, String const & name, String const & description ) Adds a new parameter to the configuration section. This method uses the bound variable value as default value. This function should be used by the configuration class. Updated on 22 March 2022 at 08:31:22 UTC","title":"function addParameter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_const_int_pattern/","text":"microsoft::quantum::ConstIntPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::ConstIntPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_const_int_pattern/#microsoftquantumconstintpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::ConstIntPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_const_int_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_const_int_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_const_int_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_const_int_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_const_int_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 March 2022 at 08:31:22 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/","text":"microsoft::quantum::FactoryConfiguration Public Functions Name void setup ( ConfigurationManager & config) bool disableReferenceCounting () const bool disableAliasCounting () const bool disableStringSupport () const bool optimizeResultOne () const bool optimizeResultZero () const bool useStaticQubitArrayAllocation () const bool useStaticQubitAllocation () const bool useStaticResultAllocation () const uint32_t defaultIntegerWidth () const bool isDisabled () const bool isDefault () const FactoryConfiguration createDisabled () Public Functions Documentation function setup inline void setup( ConfigurationManager & config ) function disableReferenceCounting inline bool disableReferenceCounting() const function disableAliasCounting inline bool disableAliasCounting() const function disableStringSupport inline bool disableStringSupport() const function optimizeResultOne inline bool optimizeResultOne() const function optimizeResultZero inline bool optimizeResultZero() const function useStaticQubitArrayAllocation inline bool useStaticQubitArrayAllocation() const function useStaticQubitAllocation inline bool useStaticQubitAllocation() const function useStaticResultAllocation inline bool useStaticResultAllocation() const function defaultIntegerWidth inline uint32_t defaultIntegerWidth() const function isDisabled inline bool isDisabled() const function isDefault inline bool isDefault() const function createDisabled static inline FactoryConfiguration createDisabled() Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::FactoryConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#microsoftquantumfactoryconfiguration","text":"","title":"microsoft::quantum::FactoryConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#public-functions","text":"Name void setup ( ConfigurationManager & config) bool disableReferenceCounting () const bool disableAliasCounting () const bool disableStringSupport () const bool optimizeResultOne () const bool optimizeResultZero () const bool useStaticQubitArrayAllocation () const bool useStaticQubitAllocation () const bool useStaticResultAllocation () const uint32_t defaultIntegerWidth () const bool isDisabled () const bool isDefault () const FactoryConfiguration createDisabled ()","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-setup","text":"inline void setup( ConfigurationManager & config )","title":"function setup"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-disablereferencecounting","text":"inline bool disableReferenceCounting() const","title":"function disableReferenceCounting"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-disablealiascounting","text":"inline bool disableAliasCounting() const","title":"function disableAliasCounting"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-disablestringsupport","text":"inline bool disableStringSupport() const","title":"function disableStringSupport"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-optimizeresultone","text":"inline bool optimizeResultOne() const","title":"function optimizeResultOne"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-optimizeresultzero","text":"inline bool optimizeResultZero() const","title":"function optimizeResultZero"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-usestaticqubitarrayallocation","text":"inline bool useStaticQubitArrayAllocation() const","title":"function useStaticQubitArrayAllocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-usestaticqubitallocation","text":"inline bool useStaticQubitAllocation() const","title":"function useStaticQubitAllocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-usestaticresultallocation","text":"inline bool useStaticResultAllocation() const","title":"function useStaticResultAllocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-defaultintegerwidth","text":"inline uint32_t defaultIntegerWidth() const","title":"function defaultIntegerWidth"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-isdisabled","text":"inline bool isDisabled() const","title":"function isDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-isdefault","text":"inline bool isDefault() const","title":"function isDefault"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-createdisabled","text":"static inline FactoryConfiguration createDisabled() Updated on 22 March 2022 at 08:31:22 UTC","title":"function createDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/","text":"microsoft::quantum::GroupingAnalysisPass Inherits from llvm::AnalysisInfoMixin< GroupingAnalysisPass > Public Types Name using GroupAnalysis Result using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< ILogger > ILoggerPtr using std::unordered_set< llvm::BasicBlock * > BlockSet Public Functions Name GroupingAnalysisPass ( GroupingPassConfiguration const & cfg) GroupingAnalysisPass ( GroupingAnalysisPass const & ) Copy construction is banned. GroupingAnalysisPass ( GroupingAnalysisPass && ) =default We allow move semantics. ~GroupingAnalysisPass () =default Default destruction. Result run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runBlockAnalysis (llvm::Module & module) bool isRequired () Whether or not this pass is required to run. Public Attributes Name const String QIS_START const String READ_INSTR_START Friends Name struct llvm::AnalysisInfoMixin< GroupingAnalysisPass > Public Types Documentation using Result using microsoft::quantum::GroupingAnalysisPass::Result = GroupAnalysis; using Instruction using microsoft::quantum::GroupingAnalysisPass::Instruction = llvm::Instruction; using Value using microsoft::quantum::GroupingAnalysisPass::Value = llvm::Value; using ILoggerPtr using microsoft::quantum::GroupingAnalysisPass::ILoggerPtr = std::shared_ptr<ILogger>; using BlockSet using microsoft::quantum::GroupingAnalysisPass::BlockSet = std::unordered_set<llvm::BasicBlock*>; Public Functions Documentation function GroupingAnalysisPass inline explicit GroupingAnalysisPass( GroupingPassConfiguration const & cfg ) function GroupingAnalysisPass GroupingAnalysisPass( GroupingAnalysisPass const & ) Copy construction is banned. function GroupingAnalysisPass GroupingAnalysisPass( GroupingAnalysisPass && ) =default We allow move semantics. function ~GroupingAnalysisPass ~GroupingAnalysisPass() =default Default destruction. function run Result run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function runBlockAnalysis void runBlockAnalysis( llvm::Module & module ) function isRequired static bool isRequired() Whether or not this pass is required to run. Public Attributes Documentation variable QIS_START static const String QIS_START = \"__quantum\" \"__qis_\"; variable READ_INSTR_START static const String READ_INSTR_START = \"__quantum\" \"__qis__read_\"; Friends friend llvm::AnalysisInfoMixin< GroupingAnalysisPass > friend struct llvm::AnalysisInfoMixin< GroupingAnalysisPass >(); Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::GroupingAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#microsoftquantumgroupinganalysispass","text":"Inherits from llvm::AnalysisInfoMixin< GroupingAnalysisPass >","title":"microsoft::quantum::GroupingAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#public-types","text":"Name using GroupAnalysis Result using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< ILogger > ILoggerPtr using std::unordered_set< llvm::BasicBlock * > BlockSet","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#public-functions","text":"Name GroupingAnalysisPass ( GroupingPassConfiguration const & cfg) GroupingAnalysisPass ( GroupingAnalysisPass const & ) Copy construction is banned. GroupingAnalysisPass ( GroupingAnalysisPass && ) =default We allow move semantics. ~GroupingAnalysisPass () =default Default destruction. Result run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runBlockAnalysis (llvm::Module & module) bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#public-attributes","text":"Name const String QIS_START const String READ_INSTR_START","title":"Public Attributes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#friends","text":"Name struct llvm::AnalysisInfoMixin< GroupingAnalysisPass >","title":"Friends"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#using-result","text":"using microsoft::quantum::GroupingAnalysisPass::Result = GroupAnalysis;","title":"using Result"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#using-instruction","text":"using microsoft::quantum::GroupingAnalysisPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#using-value","text":"using microsoft::quantum::GroupingAnalysisPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#using-iloggerptr","text":"using microsoft::quantum::GroupingAnalysisPass::ILoggerPtr = std::shared_ptr<ILogger>;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#using-blockset","text":"using microsoft::quantum::GroupingAnalysisPass::BlockSet = std::unordered_set<llvm::BasicBlock*>;","title":"using BlockSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#function-groupinganalysispass","text":"inline explicit GroupingAnalysisPass( GroupingPassConfiguration const & cfg )","title":"function GroupingAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#function-groupinganalysispass_1","text":"GroupingAnalysisPass( GroupingAnalysisPass const & ) Copy construction is banned.","title":"function GroupingAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#function-groupinganalysispass_2","text":"GroupingAnalysisPass( GroupingAnalysisPass && ) =default We allow move semantics.","title":"function GroupingAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#function-groupinganalysispass_3","text":"~GroupingAnalysisPass() =default Default destruction.","title":"function ~GroupingAnalysisPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#function-run","text":"Result run( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#function-runblockanalysis","text":"void runBlockAnalysis( llvm::Module & module )","title":"function runBlockAnalysis"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run.","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#variable-qis_start","text":"static const String QIS_START = \"__quantum\" \"__qis_\";","title":"variable QIS_START"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#variable-read_instr_start","text":"static const String READ_INSTR_START = \"__quantum\" \"__qis__read_\";","title":"variable READ_INSTR_START"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#friends_1","text":"","title":"Friends"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass/#friend-llvmanalysisinfomixin-groupinganalysispass","text":"friend struct llvm::AnalysisInfoMixin< GroupingAnalysisPass >(); Updated on 22 March 2022 at 08:31:22 UTC","title":"friend llvm::AnalysisInfoMixin&lt; GroupingAnalysisPass &gt;"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass_printer/","text":"microsoft::quantum::GroupingAnalysisPassPrinter Inherits from llvm::PassInfoMixin< GroupingAnalysisPassPrinter > Public Functions Name llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool isRequired () Public Functions Documentation function run llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function isRequired static inline bool isRequired() Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::GroupingAnalysisPassPrinter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass_printer/#microsoftquantumgroupinganalysispassprinter","text":"Inherits from llvm::PassInfoMixin< GroupingAnalysisPassPrinter >","title":"microsoft::quantum::GroupingAnalysisPassPrinter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass_printer/#public-functions","text":"Name llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool isRequired ()","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass_printer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass_printer/#function-run","text":"llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_analysis_pass_printer/#function-isrequired","text":"static inline bool isRequired() Updated on 22 March 2022 at 08:31:22 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/","text":"microsoft::quantum::GroupingPass More... #include <GroupingPass/GroupingPass.hpp> Inherits from llvm::PassInfoMixin< GroupingPass > Public Types Name enum @0 { PURE_CLASSICAL = 0, SOURCE_QUANTUM = 1, DEST_QUANTUM = 2, PURE_QUANTUM = SOURCE_QUANTUM using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< ILogger > ILoggerPtr using std::unordered_set< llvm::BasicBlock * > BlockSet using std::shared_ptr< llvm::IRBuilder<> > SharedBuilder Public Functions Name GroupingPass ( GroupingPassConfiguration const & cfg) GroupingPass ( GroupingPass const & ) Copy construction is banned. GroupingPass ( GroupingPass && ) =default We allow move semantics. ~GroupingPass () =default Default destruction. void prepareSourceSeparation (llvm::Module & module, llvm::BasicBlock * block) void nextQuantumCycle (llvm::Module & module, llvm::BasicBlock * block) void expandBasedOnSource (llvm::Module & module, llvm::BasicBlock * block) void expandBasedOnDest (llvm::Module & module, llvm::BasicBlock * block, bool move_quatum, String const & name) bool isQuantumRegister (llvm::Type const * type) int64_t classifyInstruction (llvm::Instruction const * instr) llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runBlockAnalysis (llvm::Module & module) bool isRequired () Whether or not this pass is required to run. Detailed Description class microsoft::quantum::GroupingPass; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 No measurements \u2502\u2502\u2502 With measurements \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 Before After \u2502 Before After \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 [entry] \u2502 [entry] \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500 [entry] \u2502 [entry] \u2502 \u2502 \u250c\u2500\u2500\u2500 \u2502 \u2502 \u2502 [bb head cc] \u2502 \u2502 \u2502 \u2502 [bb cc] \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 [bb qc] [mixed qc/cc] \u2500\u2500\u25b6 \u2502 [mixed qc/mc/cc]\u2500\u2500\u25b6 \u2502 \u2502 \u2502 \u2502 \u2502 [bb qc] \u2502 \u2502 \u2502 [bb mc] \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500 \u2502 \u2502 [bb2] \u2502 \u2502 [bb2] \u2502 \u2502 [bb tail cc] \u2502 \u2502 [bb2] \u2502 \u2514\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 [bb2] \u2502 Public Types Documentation enum @0 Enumerator Value Description PURE_CLASSICAL 0 SOURCE_QUANTUM 1 DEST_QUANTUM 2 PURE_QUANTUM SOURCE_QUANTUM DEST_QUANTUM TRANSFER_CLASSICAL_TO_QUANTUM DEST_QUANTUM TRANSFER_QUANTUM_TO_CLASSICAL SOURCE_QUANTUM INVALID_MIXED_LOCATION -1 using Instruction using microsoft::quantum::GroupingPass::Instruction = llvm::Instruction; using Value using microsoft::quantum::GroupingPass::Value = llvm::Value; using ILoggerPtr using microsoft::quantum::GroupingPass::ILoggerPtr = std::shared_ptr<ILogger>; using BlockSet using microsoft::quantum::GroupingPass::BlockSet = std::unordered_set<llvm::BasicBlock*>; using SharedBuilder using microsoft::quantum::GroupingPass::SharedBuilder = std::shared_ptr<llvm::IRBuilder<> >; Public Functions Documentation function GroupingPass inline explicit GroupingPass( GroupingPassConfiguration const & cfg ) function GroupingPass GroupingPass( GroupingPass const & ) Copy construction is banned. function GroupingPass GroupingPass( GroupingPass && ) =default We allow move semantics. function ~GroupingPass ~GroupingPass() =default Default destruction. function prepareSourceSeparation void prepareSourceSeparation( llvm::Module & module, llvm::BasicBlock * block ) function nextQuantumCycle void nextQuantumCycle( llvm::Module & module, llvm::BasicBlock * block ) function expandBasedOnSource void expandBasedOnSource( llvm::Module & module, llvm::BasicBlock * block ) function expandBasedOnDest void expandBasedOnDest( llvm::Module & module, llvm::BasicBlock * block, bool move_quatum, String const & name ) function isQuantumRegister bool isQuantumRegister( llvm::Type const * type ) function classifyInstruction int64_t classifyInstruction( llvm::Instruction const * instr ) function run llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function runBlockAnalysis void runBlockAnalysis( llvm::Module & module ) function isRequired static bool isRequired() Whether or not this pass is required to run. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::GroupingPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#microsoftquantumgroupingpass","text":"More... #include <GroupingPass/GroupingPass.hpp> Inherits from llvm::PassInfoMixin< GroupingPass >","title":"microsoft::quantum::GroupingPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#public-types","text":"Name enum @0 { PURE_CLASSICAL = 0, SOURCE_QUANTUM = 1, DEST_QUANTUM = 2, PURE_QUANTUM = SOURCE_QUANTUM using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< ILogger > ILoggerPtr using std::unordered_set< llvm::BasicBlock * > BlockSet using std::shared_ptr< llvm::IRBuilder<> > SharedBuilder","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#public-functions","text":"Name GroupingPass ( GroupingPassConfiguration const & cfg) GroupingPass ( GroupingPass const & ) Copy construction is banned. GroupingPass ( GroupingPass && ) =default We allow move semantics. ~GroupingPass () =default Default destruction. void prepareSourceSeparation (llvm::Module & module, llvm::BasicBlock * block) void nextQuantumCycle (llvm::Module & module, llvm::BasicBlock * block) void expandBasedOnSource (llvm::Module & module, llvm::BasicBlock * block) void expandBasedOnDest (llvm::Module & module, llvm::BasicBlock * block, bool move_quatum, String const & name) bool isQuantumRegister (llvm::Type const * type) int64_t classifyInstruction (llvm::Instruction const * instr) llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runBlockAnalysis (llvm::Module & module) bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#detailed-description","text":"class microsoft::quantum::GroupingPass; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 No measurements \u2502\u2502\u2502 With measurements \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 Before After \u2502 Before After \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 [entry] \u2502 [entry] \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500 [entry] \u2502 [entry] \u2502 \u2502 \u250c\u2500\u2500\u2500 \u2502 \u2502 \u2502 [bb head cc] \u2502 \u2502 \u2502 \u2502 [bb cc] \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 [bb qc] [mixed qc/cc] \u2500\u2500\u25b6 \u2502 [mixed qc/mc/cc]\u2500\u2500\u25b6 \u2502 \u2502 \u2502 \u2502 \u2502 [bb qc] \u2502 \u2502 \u2502 [bb mc] \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500 \u2502 \u2502 [bb2] \u2502 \u2502 [bb2] \u2502 \u2502 [bb tail cc] \u2502 \u2502 [bb2] \u2502 \u2514\u2500\u2500\u2500 \u2502 \u2502 \u2502 \u2502 [bb2] \u2502","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#enum-0","text":"Enumerator Value Description PURE_CLASSICAL 0 SOURCE_QUANTUM 1 DEST_QUANTUM 2 PURE_QUANTUM SOURCE_QUANTUM DEST_QUANTUM TRANSFER_CLASSICAL_TO_QUANTUM DEST_QUANTUM TRANSFER_QUANTUM_TO_CLASSICAL SOURCE_QUANTUM INVALID_MIXED_LOCATION -1","title":"enum @0"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#using-instruction","text":"using microsoft::quantum::GroupingPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#using-value","text":"using microsoft::quantum::GroupingPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#using-iloggerptr","text":"using microsoft::quantum::GroupingPass::ILoggerPtr = std::shared_ptr<ILogger>;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#using-blockset","text":"using microsoft::quantum::GroupingPass::BlockSet = std::unordered_set<llvm::BasicBlock*>;","title":"using BlockSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#using-sharedbuilder","text":"using microsoft::quantum::GroupingPass::SharedBuilder = std::shared_ptr<llvm::IRBuilder<> >;","title":"using SharedBuilder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-groupingpass","text":"inline explicit GroupingPass( GroupingPassConfiguration const & cfg )","title":"function GroupingPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-groupingpass_1","text":"GroupingPass( GroupingPass const & ) Copy construction is banned.","title":"function GroupingPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-groupingpass_2","text":"GroupingPass( GroupingPass && ) =default We allow move semantics.","title":"function GroupingPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-groupingpass_3","text":"~GroupingPass() =default Default destruction.","title":"function ~GroupingPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-preparesourceseparation","text":"void prepareSourceSeparation( llvm::Module & module, llvm::BasicBlock * block )","title":"function prepareSourceSeparation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-nextquantumcycle","text":"void nextQuantumCycle( llvm::Module & module, llvm::BasicBlock * block )","title":"function nextQuantumCycle"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-expandbasedonsource","text":"void expandBasedOnSource( llvm::Module & module, llvm::BasicBlock * block )","title":"function expandBasedOnSource"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-expandbasedondest","text":"void expandBasedOnDest( llvm::Module & module, llvm::BasicBlock * block, bool move_quatum, String const & name )","title":"function expandBasedOnDest"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-isquantumregister","text":"bool isQuantumRegister( llvm::Type const * type )","title":"function isQuantumRegister"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-classifyinstruction","text":"int64_t classifyInstruction( llvm::Instruction const * instr )","title":"function classifyInstruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-run","text":"llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-runblockanalysis","text":"void runBlockAnalysis( llvm::Module & module )","title":"function runBlockAnalysis"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run. Updated on 22 March 2022 at 08:31:22 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/","text":"microsoft::quantum::GroupingPassConfiguration Public Types Name using std::unordered_set< std::string > Set Public Functions Name void setup ( ConfigurationManager & config) bool circuitSeparation () const GroupingPassConfiguration createDisabled () Public Types Documentation using Set using microsoft::quantum::GroupingPassConfiguration::Set = std::unordered_set<std::string>; Public Functions Documentation function setup inline void setup( ConfigurationManager & config ) Setup function that adds the configuration flags to the ConfigurationManager . See the ConfigurationManager documentation for more details on how the setup process is implemented. function circuitSeparation inline bool circuitSeparation() const function createDisabled static inline GroupingPassConfiguration createDisabled() Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::GroupingPassConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/#microsoftquantumgroupingpassconfiguration","text":"","title":"microsoft::quantum::GroupingPassConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/#public-types","text":"Name using std::unordered_set< std::string > Set","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/#public-functions","text":"Name void setup ( ConfigurationManager & config) bool circuitSeparation () const GroupingPassConfiguration createDisabled ()","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/#using-set","text":"using microsoft::quantum::GroupingPassConfiguration::Set = std::unordered_set<std::string>;","title":"using Set"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/#function-setup","text":"inline void setup( ConfigurationManager & config ) Setup function that adds the configuration flags to the ConfigurationManager . See the ConfigurationManager documentation for more details on how the setup process is implemented.","title":"function setup"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/#function-circuitseparation","text":"inline bool circuitSeparation() const","title":"function circuitSeparation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_grouping_pass_configuration/#function-createdisabled","text":"static inline GroupingPassConfiguration createDisabled() Updated on 22 March 2022 at 08:31:22 UTC","title":"function createDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/","text":"microsoft::quantum::IAllocationManager More... #include <AllocationManager/IAllocationManager.hpp> Inherited by microsoft::quantum::BasicAllocationManager Public Types Name using uint64_t Address Value type for address. using uint64_t Index Index type used to access an array element. using std::shared_ptr< IAllocationManager > AllocationManagerPtr Pointer interface. Public Functions Name IAllocationManager ( IAllocationManager const & ) IAllocationManager ( IAllocationManager && ) IAllocationManager & operator= ( IAllocationManager const & ) IAllocationManager & operator= ( IAllocationManager && ) virtual ~IAllocationManager () virtual Address allocate (String const & name =\"\", Index const & count =1) =0 virtual void release ( Address const & address) =0 virtual void reset () =0 uint64_t allocationsInUse () const uint64_t maxAllocationsUsed () const Protected Functions Name IAllocationManager () =default void updateRegistersInUse (uint64_t n) Detailed Description class microsoft::quantum::IAllocationManager; Interface class for allocation management. This interface provides means to allocate and release statically allocated resources such as qubits and results. In a future version, it may be extended with get and store in order to support Arrays and Tuples. Public Types Documentation using Address using microsoft::quantum::IAllocationManager::Address = uint64_t; Value type for address. using Index using microsoft::quantum::IAllocationManager::Index = uint64_t; Index type used to access an array element. using AllocationManagerPtr using microsoft::quantum::IAllocationManager::AllocationManagerPtr = std::shared_ptr<IAllocationManager>; Pointer interface. Public Functions Documentation function IAllocationManager IAllocationManager( IAllocationManager const & ) function IAllocationManager IAllocationManager( IAllocationManager && ) function operator= IAllocationManager & operator=( IAllocationManager const & ) function operator= IAllocationManager & operator=( IAllocationManager && ) function ~IAllocationManager virtual ~IAllocationManager() function allocate virtual Address allocate( String const & name =\"\", Index const & count =1 ) =0 Reimplemented by : microsoft::quantum::BasicAllocationManager::allocate Abstract member function to allocate an element or sequence of elements. The developer should not assume continuity of the address segment as this is not guaranteed. Note this function may throw if allocation is not possible. function release virtual void release( Address const & address ) =0 Reimplemented by : microsoft::quantum::BasicAllocationManager::release Abstract member function to release a previously allocated function. Note this function may throw if an invalid address is passed. function reset virtual void reset() =0 Reimplemented by : microsoft::quantum::BasicAllocationManager::reset Abstract member function to reset the allocation manager. This function clears all allocations and resets all statistics. function allocationsInUse uint64_t allocationsInUse() const Current number of registers in use. This function is used to inquire about the current number registers/resources in use. function maxAllocationsUsed uint64_t maxAllocationsUsed() const Maximum number of registers in use at any one time. The maximum number of registers used at any one time. As an example of usage, this function is useful to calculate the total number of qubits required to execute the entry function. Protected Functions Documentation function IAllocationManager IAllocationManager() =default function updateRegistersInUse void updateRegistersInUse( uint64_t n ) Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::IAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#microsoftquantumiallocationmanager","text":"More... #include <AllocationManager/IAllocationManager.hpp> Inherited by microsoft::quantum::BasicAllocationManager","title":"microsoft::quantum::IAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#public-types","text":"Name using uint64_t Address Value type for address. using uint64_t Index Index type used to access an array element. using std::shared_ptr< IAllocationManager > AllocationManagerPtr Pointer interface.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#public-functions","text":"Name IAllocationManager ( IAllocationManager const & ) IAllocationManager ( IAllocationManager && ) IAllocationManager & operator= ( IAllocationManager const & ) IAllocationManager & operator= ( IAllocationManager && ) virtual ~IAllocationManager () virtual Address allocate (String const & name =\"\", Index const & count =1) =0 virtual void release ( Address const & address) =0 virtual void reset () =0 uint64_t allocationsInUse () const uint64_t maxAllocationsUsed () const","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#protected-functions","text":"Name IAllocationManager () =default void updateRegistersInUse (uint64_t n)","title":"Protected Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#detailed-description","text":"class microsoft::quantum::IAllocationManager; Interface class for allocation management. This interface provides means to allocate and release statically allocated resources such as qubits and results. In a future version, it may be extended with get and store in order to support Arrays and Tuples.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#using-address","text":"using microsoft::quantum::IAllocationManager::Address = uint64_t; Value type for address.","title":"using Address"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#using-index","text":"using microsoft::quantum::IAllocationManager::Index = uint64_t; Index type used to access an array element.","title":"using Index"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#using-allocationmanagerptr","text":"using microsoft::quantum::IAllocationManager::AllocationManagerPtr = std::shared_ptr<IAllocationManager>; Pointer interface.","title":"using AllocationManagerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-iallocationmanager","text":"IAllocationManager( IAllocationManager const & )","title":"function IAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-iallocationmanager_1","text":"IAllocationManager( IAllocationManager && )","title":"function IAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-operator","text":"IAllocationManager & operator=( IAllocationManager const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-operator_1","text":"IAllocationManager & operator=( IAllocationManager && )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-iallocationmanager_2","text":"virtual ~IAllocationManager()","title":"function ~IAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-allocate","text":"virtual Address allocate( String const & name =\"\", Index const & count =1 ) =0 Reimplemented by : microsoft::quantum::BasicAllocationManager::allocate Abstract member function to allocate an element or sequence of elements. The developer should not assume continuity of the address segment as this is not guaranteed. Note this function may throw if allocation is not possible.","title":"function allocate"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-release","text":"virtual void release( Address const & address ) =0 Reimplemented by : microsoft::quantum::BasicAllocationManager::release Abstract member function to release a previously allocated function. Note this function may throw if an invalid address is passed.","title":"function release"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-reset","text":"virtual void reset() =0 Reimplemented by : microsoft::quantum::BasicAllocationManager::reset Abstract member function to reset the allocation manager. This function clears all allocations and resets all statistics.","title":"function reset"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-allocationsinuse","text":"uint64_t allocationsInUse() const Current number of registers in use. This function is used to inquire about the current number registers/resources in use.","title":"function allocationsInUse"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-maxallocationsused","text":"uint64_t maxAllocationsUsed() const Maximum number of registers in use at any one time. The maximum number of registers used at any one time. As an example of usage, this function is useful to calculate the total number of qubits required to execute the entry function.","title":"function maxAllocationsUsed"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-iallocationmanager_3","text":"IAllocationManager() =default","title":"function IAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-updateregistersinuse","text":"void updateRegistersInUse( uint64_t n ) Updated on 22 March 2022 at 08:31:22 UTC","title":"function updateRegistersInUse"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/","text":"microsoft::quantum::IConfigBind More... #include <Commandline/IConfigBind.hpp> Inherited by microsoft::quantum::ConfigBind< T > Public Functions Name IConfigBind ( IConfigBind const & ) IConfigBind ( IConfigBind && ) IConfigBind & operator= ( IConfigBind const & ) IConfigBind & operator= ( IConfigBind && ) virtual ~IConfigBind () virtual bool setupArguments ( ParameterParser & parser) =0 virtual bool configure ( ParameterParser & parser, bool experimental_mode) =0 virtual String value () =0 String name () const Returns the name of the bound configuration variable. String description () const Returns the description of the configuration variable. bool isFlag () const Indicates whether or not this. String defaultValue () const Returns the default value for the flag. bool isExperimental () const Indicates whether or not this is an experimental config. Protected Functions Name IConfigBind (String const & name, String const & description) void setName (String const & name) Sets the name of the configuration variable. void markAsFlag () Marks the variable as a flag. void setDefault (String const & v) Sets the default value as a string. void makeSettingExperimental () Marks the config as experimental. Detailed Description class microsoft::quantum::IConfigBind; Interface class to bind a variable to a configuration flag. This class provides the necessary interface to bind variables and populate their value based on given command-line arguments. Public Functions Documentation function IConfigBind IConfigBind( IConfigBind const & ) function IConfigBind IConfigBind( IConfigBind && ) function operator= IConfigBind & operator=( IConfigBind const & ) function operator= IConfigBind & operator=( IConfigBind && ) function ~IConfigBind virtual ~IConfigBind() function setupArguments virtual bool setupArguments( ParameterParser & parser ) =0 Reimplemented by : microsoft::quantum::ConfigBind::setupArguments Interface function to register configuration in the parser. This function register the configuration to the parameter parser. This makes the configuration available in the parameter parsers help function. This method should return true if arguments were successfully setup. function configure virtual bool configure( ParameterParser & parser, bool experimental_mode ) =0 Reimplemented by : microsoft::quantum::ConfigBind::configure Interface function to extract configuration from the command line arguments. Given an instance of the command line parameter parser, this function is meant to read the command line arguments, interpret it and set the bound variable value (if present). This method should return true if configure operation was successful. function value virtual String value() =0 Reimplemented by : microsoft::quantum::ConfigBind::value Interface function to return a string representation of the current value of the bound variable. function name String name() const Returns the name of the bound configuration variable. function description String description() const Returns the description of the configuration variable. function isFlag bool isFlag() const Indicates whether or not this. function defaultValue String defaultValue() const Returns the default value for the flag. function isExperimental bool isExperimental() const Indicates whether or not this is an experimental config. Protected Functions Documentation function IConfigBind IConfigBind( String const & name, String const & description ) function setName void setName( String const & name ) Sets the name of the configuration variable. function markAsFlag void markAsFlag() Marks the variable as a flag. function setDefault void setDefault( String const & v ) Sets the default value as a string. function makeSettingExperimental void makeSettingExperimental() Marks the config as experimental. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::IConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#microsoftquantumiconfigbind","text":"More... #include <Commandline/IConfigBind.hpp> Inherited by microsoft::quantum::ConfigBind< T >","title":"microsoft::quantum::IConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#public-functions","text":"Name IConfigBind ( IConfigBind const & ) IConfigBind ( IConfigBind && ) IConfigBind & operator= ( IConfigBind const & ) IConfigBind & operator= ( IConfigBind && ) virtual ~IConfigBind () virtual bool setupArguments ( ParameterParser & parser) =0 virtual bool configure ( ParameterParser & parser, bool experimental_mode) =0 virtual String value () =0 String name () const Returns the name of the bound configuration variable. String description () const Returns the description of the configuration variable. bool isFlag () const Indicates whether or not this. String defaultValue () const Returns the default value for the flag. bool isExperimental () const Indicates whether or not this is an experimental config.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#protected-functions","text":"Name IConfigBind (String const & name, String const & description) void setName (String const & name) Sets the name of the configuration variable. void markAsFlag () Marks the variable as a flag. void setDefault (String const & v) Sets the default value as a string. void makeSettingExperimental () Marks the config as experimental.","title":"Protected Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#detailed-description","text":"class microsoft::quantum::IConfigBind; Interface class to bind a variable to a configuration flag. This class provides the necessary interface to bind variables and populate their value based on given command-line arguments.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-iconfigbind","text":"IConfigBind( IConfigBind const & )","title":"function IConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-iconfigbind_1","text":"IConfigBind( IConfigBind && )","title":"function IConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-operator","text":"IConfigBind & operator=( IConfigBind const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-operator_1","text":"IConfigBind & operator=( IConfigBind && )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-iconfigbind_2","text":"virtual ~IConfigBind()","title":"function ~IConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-setuparguments","text":"virtual bool setupArguments( ParameterParser & parser ) =0 Reimplemented by : microsoft::quantum::ConfigBind::setupArguments Interface function to register configuration in the parser. This function register the configuration to the parameter parser. This makes the configuration available in the parameter parsers help function. This method should return true if arguments were successfully setup.","title":"function setupArguments"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-configure","text":"virtual bool configure( ParameterParser & parser, bool experimental_mode ) =0 Reimplemented by : microsoft::quantum::ConfigBind::configure Interface function to extract configuration from the command line arguments. Given an instance of the command line parameter parser, this function is meant to read the command line arguments, interpret it and set the bound variable value (if present). This method should return true if configure operation was successful.","title":"function configure"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-value","text":"virtual String value() =0 Reimplemented by : microsoft::quantum::ConfigBind::value Interface function to return a string representation of the current value of the bound variable.","title":"function value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-name","text":"String name() const Returns the name of the bound configuration variable.","title":"function name"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-description","text":"String description() const Returns the description of the configuration variable.","title":"function description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-isflag","text":"bool isFlag() const Indicates whether or not this.","title":"function isFlag"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-defaultvalue","text":"String defaultValue() const Returns the default value for the flag.","title":"function defaultValue"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-isexperimental","text":"bool isExperimental() const Indicates whether or not this is an experimental config.","title":"function isExperimental"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-iconfigbind_3","text":"IConfigBind( String const & name, String const & description )","title":"function IConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-setname","text":"void setName( String const & name ) Sets the name of the configuration variable.","title":"function setName"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-markasflag","text":"void markAsFlag() Marks the variable as a flag.","title":"function markAsFlag"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-setdefault","text":"void setDefault( String const & v ) Sets the default value as a string.","title":"function setDefault"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-makesettingexperimental","text":"void makeSettingExperimental() Marks the config as experimental. Updated on 22 March 2022 at 08:31:22 UTC","title":"function makeSettingExperimental"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/","text":"microsoft::quantum::ILogger More... #include <Logging/ILogger.hpp> Inherited by microsoft::quantum::CommentLogger , microsoft::quantum::LogCollection Public Functions Name ILogger () =default ILogger ( ILogger const & ) =default ILogger ( ILogger && ) =default ILogger & operator= ( ILogger const & ) =default ILogger & operator= ( ILogger && ) =default virtual ~ILogger () virtual void debug (String const & message) =0 Reports a debug message. virtual void info (String const & message) =0 Reports an info message. virtual void warning (String const & message) =0 Reports a warning message. virtual void error (String const & message) =0 Reports an error message. virtual void internalError (String const & message) =0 Reports an internal error message. virtual void setLocation (String const & name, uint64_t row, uint64_t col) =0 virtual void setLlvmHint (String const & value) =0 Sets the value of the LLVM instruction causing the issue. virtual void setFrontendHint (String const & value) =0 Sets the value of the frontend instruction causing the issue. Detailed Description class microsoft::quantum::ILogger; Logger interface to allow the collection of different types of messages during QIR transformation and/or validation. Public Functions Documentation function ILogger ILogger() =default function ILogger ILogger( ILogger const & ) =default function ILogger ILogger( ILogger && ) =default function operator= ILogger & operator=( ILogger const & ) =default function operator= ILogger & operator=( ILogger && ) =default function ~ILogger virtual ~ILogger() function debug virtual void debug( String const & message ) =0 Reports a debug message. Reimplemented by : microsoft::quantum::CommentLogger::debug , microsoft::quantum::LogCollection::debug function info virtual void info( String const & message ) =0 Reports an info message. Reimplemented by : microsoft::quantum::CommentLogger::info , microsoft::quantum::LogCollection::info function warning virtual void warning( String const & message ) =0 Reports a warning message. Reimplemented by : microsoft::quantum::CommentLogger::warning , microsoft::quantum::LogCollection::warning function error virtual void error( String const & message ) =0 Reports an error message. Reimplemented by : microsoft::quantum::CommentLogger::error , microsoft::quantum::LogCollection::error function internalError virtual void internalError( String const & message ) =0 Reports an internal error message. Reimplemented by : microsoft::quantum::CommentLogger::internalError , microsoft::quantum::LogCollection::internalError function setLocation virtual void setLocation( String const & name, uint64_t row, uint64_t col ) =0 Reimplemented by : microsoft::quantum::CommentLogger::setLocation , microsoft::quantum::LogCollection::setLocation Sets the current location. Importantly, the location can be set independently of the reported messages. This allows one to update the location upon updating the cursor position without having to worry about keeping a copy of the location to pass when reporting messages. The most obvious case of this is file path (name) with a line and character (row, col). function setLlvmHint virtual void setLlvmHint( String const & value ) =0 Sets the value of the LLVM instruction causing the issue. Reimplemented by : microsoft::quantum::CommentLogger::setLlvmHint , microsoft::quantum::LogCollection::setLlvmHint function setFrontendHint virtual void setFrontendHint( String const & value ) =0 Sets the value of the frontend instruction causing the issue. Reimplemented by : microsoft::quantum::CommentLogger::setFrontendHint , microsoft::quantum::LogCollection::setFrontendHint Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::ILogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#microsoftquantumilogger","text":"More... #include <Logging/ILogger.hpp> Inherited by microsoft::quantum::CommentLogger , microsoft::quantum::LogCollection","title":"microsoft::quantum::ILogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#public-functions","text":"Name ILogger () =default ILogger ( ILogger const & ) =default ILogger ( ILogger && ) =default ILogger & operator= ( ILogger const & ) =default ILogger & operator= ( ILogger && ) =default virtual ~ILogger () virtual void debug (String const & message) =0 Reports a debug message. virtual void info (String const & message) =0 Reports an info message. virtual void warning (String const & message) =0 Reports a warning message. virtual void error (String const & message) =0 Reports an error message. virtual void internalError (String const & message) =0 Reports an internal error message. virtual void setLocation (String const & name, uint64_t row, uint64_t col) =0 virtual void setLlvmHint (String const & value) =0 Sets the value of the LLVM instruction causing the issue. virtual void setFrontendHint (String const & value) =0 Sets the value of the frontend instruction causing the issue.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#detailed-description","text":"class microsoft::quantum::ILogger; Logger interface to allow the collection of different types of messages during QIR transformation and/or validation.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-ilogger","text":"ILogger() =default","title":"function ILogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-ilogger_1","text":"ILogger( ILogger const & ) =default","title":"function ILogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-ilogger_2","text":"ILogger( ILogger && ) =default","title":"function ILogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-operator","text":"ILogger & operator=( ILogger const & ) =default","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-operator_1","text":"ILogger & operator=( ILogger && ) =default","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-ilogger_3","text":"virtual ~ILogger()","title":"function ~ILogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-debug","text":"virtual void debug( String const & message ) =0 Reports a debug message. Reimplemented by : microsoft::quantum::CommentLogger::debug , microsoft::quantum::LogCollection::debug","title":"function debug"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-info","text":"virtual void info( String const & message ) =0 Reports an info message. Reimplemented by : microsoft::quantum::CommentLogger::info , microsoft::quantum::LogCollection::info","title":"function info"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-warning","text":"virtual void warning( String const & message ) =0 Reports a warning message. Reimplemented by : microsoft::quantum::CommentLogger::warning , microsoft::quantum::LogCollection::warning","title":"function warning"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-error","text":"virtual void error( String const & message ) =0 Reports an error message. Reimplemented by : microsoft::quantum::CommentLogger::error , microsoft::quantum::LogCollection::error","title":"function error"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-internalerror","text":"virtual void internalError( String const & message ) =0 Reports an internal error message. Reimplemented by : microsoft::quantum::CommentLogger::internalError , microsoft::quantum::LogCollection::internalError","title":"function internalError"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-setlocation","text":"virtual void setLocation( String const & name, uint64_t row, uint64_t col ) =0 Reimplemented by : microsoft::quantum::CommentLogger::setLocation , microsoft::quantum::LogCollection::setLocation Sets the current location. Importantly, the location can be set independently of the reported messages. This allows one to update the location upon updating the cursor position without having to worry about keeping a copy of the location to pass when reporting messages. The most obvious case of this is file path (name) with a line and character (row, col).","title":"function setLocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-setllvmhint","text":"virtual void setLlvmHint( String const & value ) =0 Sets the value of the LLVM instruction causing the issue. Reimplemented by : microsoft::quantum::CommentLogger::setLlvmHint , microsoft::quantum::LogCollection::setLlvmHint","title":"function setLlvmHint"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-setfrontendhint","text":"virtual void setFrontendHint( String const & value ) =0 Sets the value of the frontend instruction causing the issue. Reimplemented by : microsoft::quantum::CommentLogger::setFrontendHint , microsoft::quantum::LogCollection::setFrontendHint Updated on 22 March 2022 at 08:31:22 UTC","title":"function setFrontendHint"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/","text":"microsoft::quantum::IOperandPrototype More... #include <Rules/IOperandPrototype.hpp> Inherited by microsoft::quantum::AnyPattern , microsoft::quantum::BasicBlockPattern , microsoft::quantum::BitCastPattern , microsoft::quantum::BranchPattern , microsoft::quantum::CallPattern , microsoft::quantum::ConstIntPattern , microsoft::quantum::IntToPtrPattern , microsoft::quantum::LoadPattern , microsoft::quantum::PhiPattern , microsoft::quantum::SelectPattern , microsoft::quantum::StorePattern , microsoft::quantum::SwitchPattern , microsoft::quantum::UnnamedInvokePattern Public Types Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions Name IOperandPrototype () =default virtual ~IOperandPrototype () virtual bool match (Value * value, Captures & captures) const =0 virtual Child copy () const =0 void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Detailed Description class microsoft::quantum::IOperandPrototype; IOperandPrototype describes an IR pattern and allows matching against LLVMs llvm::Value type. Each value may or may not be captured during the matching process which means that they are stored in a map under a given name. Capturing is enabled using captureAs(name) which sets the name the value should be stored under. Public Types Documentation using Instruction using microsoft::quantum::IOperandPrototype::Instruction = llvm::Instruction; using String using microsoft::quantum::IOperandPrototype::String = std::string; using Value using microsoft::quantum::IOperandPrototype::Value = llvm::Value; using Child using microsoft::quantum::IOperandPrototype::Child = std::shared_ptr<IOperandPrototype>; using Children using microsoft::quantum::IOperandPrototype::Children = std::vector<Child>; using Captures using microsoft::quantum::IOperandPrototype::Captures = std::unordered_map<std::string, Value*>; Public Functions Documentation function IOperandPrototype IOperandPrototype() =default function ~IOperandPrototype virtual ~IOperandPrototype() function match virtual bool match( Value * value, Captures & captures ) const =0 Reimplemented by : microsoft::quantum::StorePattern::match , microsoft::quantum::LoadPattern::match , microsoft::quantum::AnyPattern::match , microsoft::quantum::BitCastPattern::match , microsoft::quantum::UnnamedInvokePattern::match , microsoft::quantum::PhiPattern::match , microsoft::quantum::IntToPtrPattern::match , microsoft::quantum::CallPattern::match , microsoft::quantum::ConstIntPattern::match , microsoft::quantum::BranchPattern::match , microsoft::quantum::SelectPattern::match , microsoft::quantum::BasicBlockPattern::match , microsoft::quantum::SwitchPattern::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const =0 Reimplemented by : microsoft::quantum::StorePattern::copy , microsoft::quantum::LoadPattern::copy , microsoft::quantum::AnyPattern::copy , microsoft::quantum::BitCastPattern::copy , microsoft::quantum::IntToPtrPattern::copy , microsoft::quantum::UnnamedInvokePattern::copy , microsoft::quantum::PhiPattern::copy , microsoft::quantum::CallPattern::copy , microsoft::quantum::ConstIntPattern::copy , microsoft::quantum::BranchPattern::copy , microsoft::quantum::SelectPattern::copy , microsoft::quantum::BasicBlockPattern::copy , microsoft::quantum::SwitchPattern::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. function addChild void addChild( Child const & child ) Adds a child to be matched against the matches children. Children are matched in order and by size. function captureAs void captureAs( std::string capture_name ) Flags that this operand should be captured. This function ensures that the captured operand is given a name. The subsequent logic in this class is responsible for capturing (upon match) and uncapturing (upon backtrack) with specified name Protected Functions Documentation function fail bool fail( Value * value, Captures & captures ) const Function which should be called whenever a match fails. function success bool success( Value * value, Captures & captures ) const Function which should be called whenever a match is successful. function matchChildren bool matchChildren( Value * value, Captures & captures ) const Subroutine to match all children. function copyPropertiesFrom inline void copyPropertiesFrom( IOperandPrototype const & other ) Shallow copy of the operand to allow name change of the capture Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::IOperandPrototype"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#microsoftquantumioperandprototype","text":"More... #include <Rules/IOperandPrototype.hpp> Inherited by microsoft::quantum::AnyPattern , microsoft::quantum::BasicBlockPattern , microsoft::quantum::BitCastPattern , microsoft::quantum::BranchPattern , microsoft::quantum::CallPattern , microsoft::quantum::ConstIntPattern , microsoft::quantum::IntToPtrPattern , microsoft::quantum::LoadPattern , microsoft::quantum::PhiPattern , microsoft::quantum::SelectPattern , microsoft::quantum::StorePattern , microsoft::quantum::SwitchPattern , microsoft::quantum::UnnamedInvokePattern","title":"microsoft::quantum::IOperandPrototype"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#public-types","text":"Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#public-functions","text":"Name IOperandPrototype () =default virtual ~IOperandPrototype () virtual bool match (Value * value, Captures & captures) const =0 virtual Child copy () const =0 void addChild (Child const & child) void captureAs (std::string capture_name)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#protected-functions","text":"Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Protected Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#detailed-description","text":"class microsoft::quantum::IOperandPrototype; IOperandPrototype describes an IR pattern and allows matching against LLVMs llvm::Value type. Each value may or may not be captured during the matching process which means that they are stored in a map under a given name. Capturing is enabled using captureAs(name) which sets the name the value should be stored under.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#using-instruction","text":"using microsoft::quantum::IOperandPrototype::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#using-string","text":"using microsoft::quantum::IOperandPrototype::String = std::string;","title":"using String"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#using-value","text":"using microsoft::quantum::IOperandPrototype::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#using-child","text":"using microsoft::quantum::IOperandPrototype::Child = std::shared_ptr<IOperandPrototype>;","title":"using Child"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#using-children","text":"using microsoft::quantum::IOperandPrototype::Children = std::vector<Child>;","title":"using Children"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#using-captures","text":"using microsoft::quantum::IOperandPrototype::Captures = std::unordered_map<std::string, Value*>;","title":"using Captures"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-ioperandprototype","text":"IOperandPrototype() =default","title":"function IOperandPrototype"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-ioperandprototype_1","text":"virtual ~IOperandPrototype()","title":"function ~IOperandPrototype"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const =0 Reimplemented by : microsoft::quantum::StorePattern::match , microsoft::quantum::LoadPattern::match , microsoft::quantum::AnyPattern::match , microsoft::quantum::BitCastPattern::match , microsoft::quantum::UnnamedInvokePattern::match , microsoft::quantum::PhiPattern::match , microsoft::quantum::IntToPtrPattern::match , microsoft::quantum::CallPattern::match , microsoft::quantum::ConstIntPattern::match , microsoft::quantum::BranchPattern::match , microsoft::quantum::SelectPattern::match , microsoft::quantum::BasicBlockPattern::match , microsoft::quantum::SwitchPattern::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-copy","text":"virtual Child copy() const =0 Reimplemented by : microsoft::quantum::StorePattern::copy , microsoft::quantum::LoadPattern::copy , microsoft::quantum::AnyPattern::copy , microsoft::quantum::BitCastPattern::copy , microsoft::quantum::IntToPtrPattern::copy , microsoft::quantum::UnnamedInvokePattern::copy , microsoft::quantum::PhiPattern::copy , microsoft::quantum::CallPattern::copy , microsoft::quantum::ConstIntPattern::copy , microsoft::quantum::BranchPattern::copy , microsoft::quantum::SelectPattern::copy , microsoft::quantum::BasicBlockPattern::copy , microsoft::quantum::SwitchPattern::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy.","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-addchild","text":"void addChild( Child const & child ) Adds a child to be matched against the matches children. Children are matched in order and by size.","title":"function addChild"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-captureas","text":"void captureAs( std::string capture_name ) Flags that this operand should be captured. This function ensures that the captured operand is given a name. The subsequent logic in this class is responsible for capturing (upon match) and uncapturing (upon backtrack) with specified name","title":"function captureAs"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail","text":"bool fail( Value * value, Captures & captures ) const Function which should be called whenever a match fails.","title":"function fail"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success","text":"bool success( Value * value, Captures & captures ) const Function which should be called whenever a match is successful.","title":"function success"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-matchchildren","text":"bool matchChildren( Value * value, Captures & captures ) const Subroutine to match all children.","title":"function matchChildren"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-copypropertiesfrom","text":"inline void copyPropertiesFrom( IOperandPrototype const & other ) Shallow copy of the operand to allow name change of the capture Updated on 22 March 2022 at 08:31:22 UTC","title":"function copyPropertiesFrom"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_int_to_ptr_pattern/","text":"microsoft::quantum::IntToPtrPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::IntToPtrPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_int_to_ptr_pattern/#microsoftquantuminttoptrpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::IntToPtrPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_int_to_ptr_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_int_to_ptr_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_int_to_ptr_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_int_to_ptr_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_int_to_ptr_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 March 2022 at 08:31:22 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/","text":"microsoft::quantum::IrManipulationTestHelper Public Types Name using std::string String using std::vector< String > Strings using llvm::LLVMContext LLVMContext using llvm::SMDiagnostic SMDiagnostic using llvm::Module Module using std::unique_ptr< Module > ModulePtr using llvm::PassBuilder::OptimizationLevel OptimizationLevel using std::shared_ptr< ProfileGenerator > GeneratorPtr Public Functions Name IrManipulationTestHelper () IrManipulationTestHelper ( IrManipulationTestHelper const & ) IrManipulationTestHelper & operator= ( IrManipulationTestHelper const & ) IrManipulationTestHelper ( IrManipulationTestHelper && ) IrManipulationTestHelper & operator= ( IrManipulationTestHelper && ) String toString () const Generates a string for the IR currently held in the module. Strings toBodyInstructions () Generates a list of instructions for the main function in the module. bool hasInstructionSequence (Strings const & instructions) void applyProfile (GeneratorPtr const & generator, OptimizationLevel const & optimization_level =OptimizationLevel::O0, bool debug =false) bool validateProfile (GeneratorPtr const & generator, String const & profile_name =\"generic\", bool debug =false) bool containsValidationErrors (GeneratorPtr const & generator, String const & profile_name, Strings const & errors, bool debug =false) const bool containsExactValidationErrors (GeneratorPtr const & generator, String const & profile_name, Strings const & errors, bool debug =false) const void declareOpaque (String const & name) void declareFunction (String const & declaration) bool fromBodyString (String const & body, String const & args =\"\") String generateScript (String const & body, String const & args =\"\") const Generates a script given the body of the main function. bool fromString (String const & data) String getErrorMessage () const Gets an error message if the compilation failed. bool isModuleBroken () Whether or not the module is broken. ModulePtr & module () Returns a reference to the module. Public Types Documentation using String using microsoft::quantum::IrManipulationTestHelper::String = std::string; using Strings using microsoft::quantum::IrManipulationTestHelper::Strings = std::vector<String>; using LLVMContext using microsoft::quantum::IrManipulationTestHelper::LLVMContext = llvm::LLVMContext; using SMDiagnostic using microsoft::quantum::IrManipulationTestHelper::SMDiagnostic = llvm::SMDiagnostic; using Module using microsoft::quantum::IrManipulationTestHelper::Module = llvm::Module; using ModulePtr using microsoft::quantum::IrManipulationTestHelper::ModulePtr = std::unique_ptr<Module>; using OptimizationLevel using microsoft::quantum::IrManipulationTestHelper::OptimizationLevel = llvm::PassBuilder::OptimizationLevel; using GeneratorPtr using microsoft::quantum::IrManipulationTestHelper::GeneratorPtr = std::shared_ptr<ProfileGenerator>; Public Functions Documentation function IrManipulationTestHelper IrManipulationTestHelper() function IrManipulationTestHelper IrManipulationTestHelper( IrManipulationTestHelper const & ) function operator= IrManipulationTestHelper & operator=( IrManipulationTestHelper const & ) function IrManipulationTestHelper IrManipulationTestHelper( IrManipulationTestHelper && ) function operator= IrManipulationTestHelper & operator=( IrManipulationTestHelper && ) function toString String toString() const Generates a string for the IR currently held in the module. function toBodyInstructions Strings toBodyInstructions() Generates a list of instructions for the main function in the module. function hasInstructionSequence bool hasInstructionSequence( Strings const & instructions ) Tests whether the main body contains a sequence of instructions. This function ignores instructions in-between the instruction set given. function applyProfile void applyProfile( GeneratorPtr const & generator, OptimizationLevel const & optimization_level =OptimizationLevel::O0, bool debug =false ) Applies a profile to the module to allow which transforms the IR. This allow us to write small profiles to test a single piece of transformation. function validateProfile bool validateProfile( GeneratorPtr const & generator, String const & profile_name =\"generic\", bool debug =false ) Validates a profile to the module to allow which transforms the IR. This allow us to write small profiles to test a single piece of transformation. function containsValidationErrors bool containsValidationErrors( GeneratorPtr const & generator, String const & profile_name, Strings const & errors, bool debug =false ) const Tests whether a given set of errors (LLVM hints) are present in the validation errors for a specific profile. This method only checks if errors are present but does not fail if there are more errors than requested through the API. function containsExactValidationErrors bool containsExactValidationErrors( GeneratorPtr const & generator, String const & profile_name, Strings const & errors, bool debug =false ) const Tests whether a given set of errors (LLVM hints) are present in the validation errors for a specific profile. In contrast to containsValidationErrors, this function expect an exact match in the actual and expected errors. function declareOpaque void declareOpaque( String const & name ) Declares a opaque type. Only the name of the type should be supplied to this function. Example usage irmanip.declareOpaque(\"Qubit\"); function declareFunction void declareFunction( String const & declaration ) Declares a function. The full signature should be supplied to as the first argument. Example usage irmanip.declareOpaque(\"%Result* @__quantum__rt__result_get_zero()\"); function fromBodyString bool fromBodyString( String const & body, String const & args =\"\" ) Creates an LLVM module given a function body. This function makes use of the inputs from IrManipulationTestHelper::declareOpaque and IrManipulationTestHelper::declareFunction to construct the full IR. Example usage: irmanip.fromBodyString(R\"script( %leftMessage = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %leftMessage) )script\"); Returns false if the IR is invalid. function generateScript String generateScript( String const & body, String const & args =\"\" ) const Generates a script given the body of the main function. function fromString bool fromString( String const & data ) Creates an LLVM module given from a fully specified IR. This function ignores all inputs from IrManipulationTestHelper::declareOpaque and IrManipulationTestHelper::declareFunction . Returns false if the IR is invalid. function getErrorMessage String getErrorMessage() const Gets an error message if the compilation failed. function isModuleBroken bool isModuleBroken() Whether or not the module is broken. function module ModulePtr & module() Returns a reference to the module. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::IrManipulationTestHelper"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#microsoftquantumirmanipulationtesthelper","text":"","title":"microsoft::quantum::IrManipulationTestHelper"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#public-types","text":"Name using std::string String using std::vector< String > Strings using llvm::LLVMContext LLVMContext using llvm::SMDiagnostic SMDiagnostic using llvm::Module Module using std::unique_ptr< Module > ModulePtr using llvm::PassBuilder::OptimizationLevel OptimizationLevel using std::shared_ptr< ProfileGenerator > GeneratorPtr","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#public-functions","text":"Name IrManipulationTestHelper () IrManipulationTestHelper ( IrManipulationTestHelper const & ) IrManipulationTestHelper & operator= ( IrManipulationTestHelper const & ) IrManipulationTestHelper ( IrManipulationTestHelper && ) IrManipulationTestHelper & operator= ( IrManipulationTestHelper && ) String toString () const Generates a string for the IR currently held in the module. Strings toBodyInstructions () Generates a list of instructions for the main function in the module. bool hasInstructionSequence (Strings const & instructions) void applyProfile (GeneratorPtr const & generator, OptimizationLevel const & optimization_level =OptimizationLevel::O0, bool debug =false) bool validateProfile (GeneratorPtr const & generator, String const & profile_name =\"generic\", bool debug =false) bool containsValidationErrors (GeneratorPtr const & generator, String const & profile_name, Strings const & errors, bool debug =false) const bool containsExactValidationErrors (GeneratorPtr const & generator, String const & profile_name, Strings const & errors, bool debug =false) const void declareOpaque (String const & name) void declareFunction (String const & declaration) bool fromBodyString (String const & body, String const & args =\"\") String generateScript (String const & body, String const & args =\"\") const Generates a script given the body of the main function. bool fromString (String const & data) String getErrorMessage () const Gets an error message if the compilation failed. bool isModuleBroken () Whether or not the module is broken. ModulePtr & module () Returns a reference to the module.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-string","text":"using microsoft::quantum::IrManipulationTestHelper::String = std::string;","title":"using String"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-strings","text":"using microsoft::quantum::IrManipulationTestHelper::Strings = std::vector<String>;","title":"using Strings"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-llvmcontext","text":"using microsoft::quantum::IrManipulationTestHelper::LLVMContext = llvm::LLVMContext;","title":"using LLVMContext"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-smdiagnostic","text":"using microsoft::quantum::IrManipulationTestHelper::SMDiagnostic = llvm::SMDiagnostic;","title":"using SMDiagnostic"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-module","text":"using microsoft::quantum::IrManipulationTestHelper::Module = llvm::Module;","title":"using Module"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-moduleptr","text":"using microsoft::quantum::IrManipulationTestHelper::ModulePtr = std::unique_ptr<Module>;","title":"using ModulePtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-optimizationlevel","text":"using microsoft::quantum::IrManipulationTestHelper::OptimizationLevel = llvm::PassBuilder::OptimizationLevel;","title":"using OptimizationLevel"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-generatorptr","text":"using microsoft::quantum::IrManipulationTestHelper::GeneratorPtr = std::shared_ptr<ProfileGenerator>;","title":"using GeneratorPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-irmanipulationtesthelper","text":"IrManipulationTestHelper()","title":"function IrManipulationTestHelper"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-irmanipulationtesthelper_1","text":"IrManipulationTestHelper( IrManipulationTestHelper const & )","title":"function IrManipulationTestHelper"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-operator","text":"IrManipulationTestHelper & operator=( IrManipulationTestHelper const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-irmanipulationtesthelper_2","text":"IrManipulationTestHelper( IrManipulationTestHelper && )","title":"function IrManipulationTestHelper"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-operator_1","text":"IrManipulationTestHelper & operator=( IrManipulationTestHelper && )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-tostring","text":"String toString() const Generates a string for the IR currently held in the module.","title":"function toString"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-tobodyinstructions","text":"Strings toBodyInstructions() Generates a list of instructions for the main function in the module.","title":"function toBodyInstructions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-hasinstructionsequence","text":"bool hasInstructionSequence( Strings const & instructions ) Tests whether the main body contains a sequence of instructions. This function ignores instructions in-between the instruction set given.","title":"function hasInstructionSequence"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-applyprofile","text":"void applyProfile( GeneratorPtr const & generator, OptimizationLevel const & optimization_level =OptimizationLevel::O0, bool debug =false ) Applies a profile to the module to allow which transforms the IR. This allow us to write small profiles to test a single piece of transformation.","title":"function applyProfile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-validateprofile","text":"bool validateProfile( GeneratorPtr const & generator, String const & profile_name =\"generic\", bool debug =false ) Validates a profile to the module to allow which transforms the IR. This allow us to write small profiles to test a single piece of transformation.","title":"function validateProfile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-containsvalidationerrors","text":"bool containsValidationErrors( GeneratorPtr const & generator, String const & profile_name, Strings const & errors, bool debug =false ) const Tests whether a given set of errors (LLVM hints) are present in the validation errors for a specific profile. This method only checks if errors are present but does not fail if there are more errors than requested through the API.","title":"function containsValidationErrors"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-containsexactvalidationerrors","text":"bool containsExactValidationErrors( GeneratorPtr const & generator, String const & profile_name, Strings const & errors, bool debug =false ) const Tests whether a given set of errors (LLVM hints) are present in the validation errors for a specific profile. In contrast to containsValidationErrors, this function expect an exact match in the actual and expected errors.","title":"function containsExactValidationErrors"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-declareopaque","text":"void declareOpaque( String const & name ) Declares a opaque type. Only the name of the type should be supplied to this function. Example usage irmanip.declareOpaque(\"Qubit\");","title":"function declareOpaque"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-declarefunction","text":"void declareFunction( String const & declaration ) Declares a function. The full signature should be supplied to as the first argument. Example usage irmanip.declareOpaque(\"%Result* @__quantum__rt__result_get_zero()\");","title":"function declareFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-frombodystring","text":"bool fromBodyString( String const & body, String const & args =\"\" ) Creates an LLVM module given a function body. This function makes use of the inputs from IrManipulationTestHelper::declareOpaque and IrManipulationTestHelper::declareFunction to construct the full IR. Example usage: irmanip.fromBodyString(R\"script( %leftMessage = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %leftMessage) )script\"); Returns false if the IR is invalid.","title":"function fromBodyString"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-generatescript","text":"String generateScript( String const & body, String const & args =\"\" ) const Generates a script given the body of the main function.","title":"function generateScript"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-fromstring","text":"bool fromString( String const & data ) Creates an LLVM module given from a fully specified IR. This function ignores all inputs from IrManipulationTestHelper::declareOpaque and IrManipulationTestHelper::declareFunction . Returns false if the IR is invalid.","title":"function fromString"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-geterrormessage","text":"String getErrorMessage() const Gets an error message if the compilation failed.","title":"function getErrorMessage"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-ismodulebroken","text":"bool isModuleBroken() Whether or not the module is broken.","title":"function isModuleBroken"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-module","text":"ModulePtr & module() Returns a reference to the module. Updated on 22 March 2022 at 08:31:22 UTC","title":"function module"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/","text":"microsoft::quantum::LlvmPassesConfiguration Public Functions Name void setup ( ConfigurationManager & config) bool alwaysInline () const Whether or not the LLVM AlwaysInline pass should be added to the profile. bool unrollLoops () const Whether or not the LLVM LoopUnroll pass should be added to the profile. int32_t inlineParameter () const Parameter that defines the maximum number of lines of code allowed for inlining. bool unrollAllowPartial () const Whether or not to allow partial unrolling. When disable only full unrolling will be used. bool unrollAllowPeeling () const Whether or not to allow peeling. bool unrollAllowRuntime () const bool unrollAllowUpperBound () const Enables or disables the usage of trip counting in loop unrolling. bool unrollAllowProfilBasedPeeling () const uint64_t unrolFullUnrollCount () const The max count full unroll count. int32_t unrollOptLevel () const The optimization level for the loop unrolling pass. bool unrollOnlyWhenForced () const bool unrollForgeScev () const bool useLlvmOptPipeline () const Whether or not to use a full opt pipeline. String optPipelineConfig () const Opt pipeline configuration string. bool eliminateConstants () const Whether or not to add a pass to eliminate constants. bool eliminateDeadCode () const Whether or not to add a pass to eliminate dead code. bool eliminateMemory () const Whether or not memory allocations should be attempted to be mapped into registers. bool isDisabled () const Checking if the configuration amounts to being disabled. bool operator== ( LlvmPassesConfiguration const & o) const =default Checking whether two configurations are identical. LlvmPassesConfiguration createDisabled () Creating a configuration that disables all passes and/or their effect on the IR. LlvmPassesConfiguration createUnrollInline () Creates a configuration that unrolls and inlines code. Public Functions Documentation function setup void setup( ConfigurationManager & config ) function alwaysInline bool alwaysInline() const Whether or not the LLVM AlwaysInline pass should be added to the profile. function unrollLoops bool unrollLoops() const Whether or not the LLVM LoopUnroll pass should be added to the profile. function inlineParameter int32_t inlineParameter() const Parameter that defines the maximum number of lines of code allowed for inlining. function unrollAllowPartial bool unrollAllowPartial() const Whether or not to allow partial unrolling. When disable only full unrolling will be used. function unrollAllowPeeling bool unrollAllowPeeling() const Whether or not to allow peeling. function unrollAllowRuntime bool unrollAllowRuntime() const Whether or not to allow unrolling of loops with runtime trip counts. See implementation for details. function unrollAllowUpperBound bool unrollAllowUpperBound() const Enables or disables the usage of trip counting in loop unrolling. function unrollAllowProfilBasedPeeling bool unrollAllowProfilBasedPeeling() const function unrolFullUnrollCount uint64_t unrolFullUnrollCount() const The max count full unroll count. function unrollOptLevel int32_t unrollOptLevel() const The optimization level for the loop unrolling pass. function unrollOnlyWhenForced bool unrollOnlyWhenForced() const Whether or not to limit unrolling to which are requested to be unrolled via meta data is consider. When false, a cost model is used to determine whether or not to unroll a loop. function unrollForgeScev bool unrollForgeScev() const function useLlvmOptPipeline bool useLlvmOptPipeline() const Whether or not to use a full opt pipeline. function optPipelineConfig String optPipelineConfig() const Opt pipeline configuration string. function eliminateConstants bool eliminateConstants() const Whether or not to add a pass to eliminate constants. function eliminateDeadCode bool eliminateDeadCode() const Whether or not to add a pass to eliminate dead code. function eliminateMemory bool eliminateMemory() const Whether or not memory allocations should be attempted to be mapped into registers. function isDisabled bool isDisabled() const Checking if the configuration amounts to being disabled. function operator== bool operator==( LlvmPassesConfiguration const & o ) const =default Checking whether two configurations are identical. function createDisabled static LlvmPassesConfiguration createDisabled() Creating a configuration that disables all passes and/or their effect on the IR. function createUnrollInline static LlvmPassesConfiguration createUnrollInline() Creates a configuration that unrolls and inlines code. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::LlvmPassesConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#microsoftquantumllvmpassesconfiguration","text":"","title":"microsoft::quantum::LlvmPassesConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#public-functions","text":"Name void setup ( ConfigurationManager & config) bool alwaysInline () const Whether or not the LLVM AlwaysInline pass should be added to the profile. bool unrollLoops () const Whether or not the LLVM LoopUnroll pass should be added to the profile. int32_t inlineParameter () const Parameter that defines the maximum number of lines of code allowed for inlining. bool unrollAllowPartial () const Whether or not to allow partial unrolling. When disable only full unrolling will be used. bool unrollAllowPeeling () const Whether or not to allow peeling. bool unrollAllowRuntime () const bool unrollAllowUpperBound () const Enables or disables the usage of trip counting in loop unrolling. bool unrollAllowProfilBasedPeeling () const uint64_t unrolFullUnrollCount () const The max count full unroll count. int32_t unrollOptLevel () const The optimization level for the loop unrolling pass. bool unrollOnlyWhenForced () const bool unrollForgeScev () const bool useLlvmOptPipeline () const Whether or not to use a full opt pipeline. String optPipelineConfig () const Opt pipeline configuration string. bool eliminateConstants () const Whether or not to add a pass to eliminate constants. bool eliminateDeadCode () const Whether or not to add a pass to eliminate dead code. bool eliminateMemory () const Whether or not memory allocations should be attempted to be mapped into registers. bool isDisabled () const Checking if the configuration amounts to being disabled. bool operator== ( LlvmPassesConfiguration const & o) const =default Checking whether two configurations are identical. LlvmPassesConfiguration createDisabled () Creating a configuration that disables all passes and/or their effect on the IR. LlvmPassesConfiguration createUnrollInline () Creates a configuration that unrolls and inlines code.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-setup","text":"void setup( ConfigurationManager & config )","title":"function setup"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-alwaysinline","text":"bool alwaysInline() const Whether or not the LLVM AlwaysInline pass should be added to the profile.","title":"function alwaysInline"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-unrollloops","text":"bool unrollLoops() const Whether or not the LLVM LoopUnroll pass should be added to the profile.","title":"function unrollLoops"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-inlineparameter","text":"int32_t inlineParameter() const Parameter that defines the maximum number of lines of code allowed for inlining.","title":"function inlineParameter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-unrollallowpartial","text":"bool unrollAllowPartial() const Whether or not to allow partial unrolling. When disable only full unrolling will be used.","title":"function unrollAllowPartial"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-unrollallowpeeling","text":"bool unrollAllowPeeling() const Whether or not to allow peeling.","title":"function unrollAllowPeeling"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-unrollallowruntime","text":"bool unrollAllowRuntime() const Whether or not to allow unrolling of loops with runtime trip counts. See implementation for details.","title":"function unrollAllowRuntime"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-unrollallowupperbound","text":"bool unrollAllowUpperBound() const Enables or disables the usage of trip counting in loop unrolling.","title":"function unrollAllowUpperBound"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-unrollallowprofilbasedpeeling","text":"bool unrollAllowProfilBasedPeeling() const","title":"function unrollAllowProfilBasedPeeling"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-unrolfullunrollcount","text":"uint64_t unrolFullUnrollCount() const The max count full unroll count.","title":"function unrolFullUnrollCount"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-unrolloptlevel","text":"int32_t unrollOptLevel() const The optimization level for the loop unrolling pass.","title":"function unrollOptLevel"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-unrollonlywhenforced","text":"bool unrollOnlyWhenForced() const Whether or not to limit unrolling to which are requested to be unrolled via meta data is consider. When false, a cost model is used to determine whether or not to unroll a loop.","title":"function unrollOnlyWhenForced"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-unrollforgescev","text":"bool unrollForgeScev() const","title":"function unrollForgeScev"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-usellvmoptpipeline","text":"bool useLlvmOptPipeline() const Whether or not to use a full opt pipeline.","title":"function useLlvmOptPipeline"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-optpipelineconfig","text":"String optPipelineConfig() const Opt pipeline configuration string.","title":"function optPipelineConfig"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-eliminateconstants","text":"bool eliminateConstants() const Whether or not to add a pass to eliminate constants.","title":"function eliminateConstants"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-eliminatedeadcode","text":"bool eliminateDeadCode() const Whether or not to add a pass to eliminate dead code.","title":"function eliminateDeadCode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-eliminatememory","text":"bool eliminateMemory() const Whether or not memory allocations should be attempted to be mapped into registers.","title":"function eliminateMemory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-isdisabled","text":"bool isDisabled() const Checking if the configuration amounts to being disabled.","title":"function isDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-operator","text":"bool operator==( LlvmPassesConfiguration const & o ) const =default Checking whether two configurations are identical.","title":"function operator=="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-createdisabled","text":"static LlvmPassesConfiguration createDisabled() Creating a configuration that disables all passes and/or their effect on the IR.","title":"function createDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-createunrollinline","text":"static LlvmPassesConfiguration createUnrollInline() Creates a configuration that unrolls and inlines code. Updated on 22 March 2022 at 08:31:22 UTC","title":"function createUnrollInline"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_load_pattern/","text":"microsoft::quantum::LoadPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::LoadPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_load_pattern/#microsoftquantumloadpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::LoadPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_load_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_load_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_load_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_load_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_load_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 March 2022 at 08:31:22 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/","text":"microsoft::quantum::LogCollection More... #include <Logging/LogCollection.hpp> Inherits from microsoft::quantum::ILogger Public Classes Name struct Location Class that holds the location of where the incident happened. struct Message Struct to hold a message together with its type and location. Public Types Name enum class Type { Debug, Info, Warning, Error, InternalError} Enum description what type of information we are conveying. using std::vector< Message > Messages List of messages defined as alias. Public Functions Name virtual void debug (String const & message) override Adds a debug message to the list. virtual void info (String const & message) override Adds an info message to the list. virtual void warning (String const & message) override Adds a warning message to the list. virtual void error (String const & message) override Adds an error message to the list. virtual void internalError (String const & message) override Adds an internal error message to the list. virtual void setLocation (String const & name, uint64_t row, uint64_t col) override Function that allows to set the current location. virtual void setLlvmHint (String const & value) override Sets the value of the LLVM instruction causing the issue. virtual void setFrontendHint (String const & value) override Sets the value of the frontend instruction causing the issue. Messages const & messages () const Accessor to the messages. Additional inherited members Public Functions inherited from microsoft::quantum::ILogger Name ILogger () =default ILogger ( ILogger const & ) =default ILogger ( ILogger && ) =default ILogger & operator= ( ILogger const & ) =default ILogger & operator= ( ILogger && ) =default virtual ~ILogger () Detailed Description class microsoft::quantum::LogCollection; Concrete ILogger implementation that collects all messages and their corresponding location in a list that can be traversed later on. Public Types Documentation enum Type Enumerator Value Description Debug Info Warning Error InternalError Enum description what type of information we are conveying. using Messages using microsoft::quantum::LogCollection::Messages = std::vector<Message>; List of messages defined as alias. Public Functions Documentation function debug virtual void debug( String const & message ) override Adds a debug message to the list. Reimplements : microsoft::quantum::ILogger::debug function info virtual void info( String const & message ) override Adds an info message to the list. Reimplements : microsoft::quantum::ILogger::info function warning virtual void warning( String const & message ) override Adds a warning message to the list. Reimplements : microsoft::quantum::ILogger::warning function error virtual void error( String const & message ) override Adds an error message to the list. Reimplements : microsoft::quantum::ILogger::error function internalError virtual void internalError( String const & message ) override Adds an internal error message to the list. Reimplements : microsoft::quantum::ILogger::internalError function setLocation virtual void setLocation( String const & name, uint64_t row, uint64_t col ) override Function that allows to set the current location. Reimplements : microsoft::quantum::ILogger::setLocation function setLlvmHint virtual void setLlvmHint( String const & value ) override Sets the value of the LLVM instruction causing the issue. Reimplements : microsoft::quantum::ILogger::setLlvmHint function setFrontendHint virtual void setFrontendHint( String const & value ) override Sets the value of the frontend instruction causing the issue. Reimplements : microsoft::quantum::ILogger::setFrontendHint function messages Messages const & messages() const Accessor to the messages. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::LogCollection"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#microsoftquantumlogcollection","text":"More... #include <Logging/LogCollection.hpp> Inherits from microsoft::quantum::ILogger","title":"microsoft::quantum::LogCollection"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#public-classes","text":"Name struct Location Class that holds the location of where the incident happened. struct Message Struct to hold a message together with its type and location.","title":"Public Classes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#public-types","text":"Name enum class Type { Debug, Info, Warning, Error, InternalError} Enum description what type of information we are conveying. using std::vector< Message > Messages List of messages defined as alias.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#public-functions","text":"Name virtual void debug (String const & message) override Adds a debug message to the list. virtual void info (String const & message) override Adds an info message to the list. virtual void warning (String const & message) override Adds a warning message to the list. virtual void error (String const & message) override Adds an error message to the list. virtual void internalError (String const & message) override Adds an internal error message to the list. virtual void setLocation (String const & name, uint64_t row, uint64_t col) override Function that allows to set the current location. virtual void setLlvmHint (String const & value) override Sets the value of the LLVM instruction causing the issue. virtual void setFrontendHint (String const & value) override Sets the value of the frontend instruction causing the issue. Messages const & messages () const Accessor to the messages.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#additional-inherited-members","text":"Public Functions inherited from microsoft::quantum::ILogger Name ILogger () =default ILogger ( ILogger const & ) =default ILogger ( ILogger && ) =default ILogger & operator= ( ILogger const & ) =default ILogger & operator= ( ILogger && ) =default virtual ~ILogger ()","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#detailed-description","text":"class microsoft::quantum::LogCollection; Concrete ILogger implementation that collects all messages and their corresponding location in a list that can be traversed later on.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#enum-type","text":"Enumerator Value Description Debug Info Warning Error InternalError Enum description what type of information we are conveying.","title":"enum Type"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#using-messages","text":"using microsoft::quantum::LogCollection::Messages = std::vector<Message>; List of messages defined as alias.","title":"using Messages"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-debug","text":"virtual void debug( String const & message ) override Adds a debug message to the list. Reimplements : microsoft::quantum::ILogger::debug","title":"function debug"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-info","text":"virtual void info( String const & message ) override Adds an info message to the list. Reimplements : microsoft::quantum::ILogger::info","title":"function info"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-warning","text":"virtual void warning( String const & message ) override Adds a warning message to the list. Reimplements : microsoft::quantum::ILogger::warning","title":"function warning"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-error","text":"virtual void error( String const & message ) override Adds an error message to the list. Reimplements : microsoft::quantum::ILogger::error","title":"function error"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-internalerror","text":"virtual void internalError( String const & message ) override Adds an internal error message to the list. Reimplements : microsoft::quantum::ILogger::internalError","title":"function internalError"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-setlocation","text":"virtual void setLocation( String const & name, uint64_t row, uint64_t col ) override Function that allows to set the current location. Reimplements : microsoft::quantum::ILogger::setLocation","title":"function setLocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-setllvmhint","text":"virtual void setLlvmHint( String const & value ) override Sets the value of the LLVM instruction causing the issue. Reimplements : microsoft::quantum::ILogger::setLlvmHint","title":"function setLlvmHint"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-setfrontendhint","text":"virtual void setFrontendHint( String const & value ) override Sets the value of the frontend instruction causing the issue. Reimplements : microsoft::quantum::ILogger::setFrontendHint","title":"function setFrontendHint"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-messages","text":"Messages const & messages() const Accessor to the messages. Updated on 22 March 2022 at 08:31:22 UTC","title":"function messages"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/","text":"microsoft::quantum::ModuleLoader Public Types Name using llvm::Module Module using llvm::Linker Linker using llvm::SMDiagnostic SMDiagnostic Public Functions Name ModuleLoader (Module * final_module) bool addModule (std::unique_ptr< Module > && module, String const & filename =\"unknown\") bool addIrFile (String const & filename) Public Types Documentation using Module using microsoft::quantum::ModuleLoader::Module = llvm::Module; using Linker using microsoft::quantum::ModuleLoader::Linker = llvm::Linker; using SMDiagnostic using microsoft::quantum::ModuleLoader::SMDiagnostic = llvm::SMDiagnostic; Public Functions Documentation function ModuleLoader inline explicit ModuleLoader( Module * final_module ) function addModule inline bool addModule( std::unique_ptr< Module > && module, String const & filename =\"unknown\" ) function addIrFile inline bool addIrFile( String const & filename ) Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::ModuleLoader"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#microsoftquantummoduleloader","text":"","title":"microsoft::quantum::ModuleLoader"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#public-types","text":"Name using llvm::Module Module using llvm::Linker Linker using llvm::SMDiagnostic SMDiagnostic","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#public-functions","text":"Name ModuleLoader (Module * final_module) bool addModule (std::unique_ptr< Module > && module, String const & filename =\"unknown\") bool addIrFile (String const & filename)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#using-module","text":"using microsoft::quantum::ModuleLoader::Module = llvm::Module;","title":"using Module"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#using-linker","text":"using microsoft::quantum::ModuleLoader::Linker = llvm::Linker;","title":"using Linker"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#using-smdiagnostic","text":"using microsoft::quantum::ModuleLoader::SMDiagnostic = llvm::SMDiagnostic;","title":"using SMDiagnostic"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#function-moduleloader","text":"inline explicit ModuleLoader( Module * final_module )","title":"function ModuleLoader"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#function-addmodule","text":"inline bool addModule( std::unique_ptr< Module > && module, String const & filename =\"unknown\" )","title":"function addModule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#function-addirfile","text":"inline bool addIrFile( String const & filename ) Updated on 22 March 2022 at 08:31:22 UTC","title":"function addIrFile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/","text":"microsoft::quantum::ModuleLoader::SingleModuleTransformation Public Types Name using llvm::PassBuilder PassBuilder using PassBuilder::OptimizationLevel OptimizationLevel using llvm::FunctionAnalysisManager FunctionAnalysisManager Public Functions Name SingleModuleTransformation (OptimizationLevel const & optimization_level =OptimizationLevel::O0, bool debug =false) bool apply (llvm::Module * module) bool isDebugMode () const Public Types Documentation using PassBuilder using microsoft::quantum::ModuleLoader::SingleModuleTransformation::PassBuilder = llvm::PassBuilder; using OptimizationLevel using microsoft::quantum::ModuleLoader::SingleModuleTransformation::OptimizationLevel = PassBuilder::OptimizationLevel; using FunctionAnalysisManager using microsoft::quantum::ModuleLoader::SingleModuleTransformation::FunctionAnalysisManager = llvm::FunctionAnalysisManager; Public Functions Documentation function SingleModuleTransformation inline explicit SingleModuleTransformation( OptimizationLevel const & optimization_level =OptimizationLevel::O0, bool debug =false ) function apply inline bool apply( llvm::Module * module ) function isDebugMode inline bool isDebugMode() const Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::ModuleLoader::SingleModuleTransformation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#microsoftquantummoduleloadersinglemoduletransformation","text":"","title":"microsoft::quantum::ModuleLoader::SingleModuleTransformation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#public-types","text":"Name using llvm::PassBuilder PassBuilder using PassBuilder::OptimizationLevel OptimizationLevel using llvm::FunctionAnalysisManager FunctionAnalysisManager","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#public-functions","text":"Name SingleModuleTransformation (OptimizationLevel const & optimization_level =OptimizationLevel::O0, bool debug =false) bool apply (llvm::Module * module) bool isDebugMode () const","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#using-passbuilder","text":"using microsoft::quantum::ModuleLoader::SingleModuleTransformation::PassBuilder = llvm::PassBuilder;","title":"using PassBuilder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#using-optimizationlevel","text":"using microsoft::quantum::ModuleLoader::SingleModuleTransformation::OptimizationLevel = PassBuilder::OptimizationLevel;","title":"using OptimizationLevel"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#using-functionanalysismanager","text":"using microsoft::quantum::ModuleLoader::SingleModuleTransformation::FunctionAnalysisManager = llvm::FunctionAnalysisManager;","title":"using FunctionAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#function-singlemoduletransformation","text":"inline explicit SingleModuleTransformation( OptimizationLevel const & optimization_level =OptimizationLevel::O0, bool debug =false )","title":"function SingleModuleTransformation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#function-apply","text":"inline bool apply( llvm::Module * module )","title":"function apply"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#function-isdebugmode","text":"inline bool isDebugMode() const Updated on 22 March 2022 at 08:31:22 UTC","title":"function isDebugMode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/","text":"microsoft::quantum::ParameterParser More... #include <Commandline/ParameterParser.hpp> Public Types Name using std::vector< String > Arguments using std::unordered_set< String > Flags using std::unordered_map< String, String > SettingsMap using std::unordered_set< String > UnusedSettings Public Functions Name ParameterParser () =default ParameterParser ( ParameterParser const & other) ParameterParser ( ParameterParser && other) =default ~ParameterParser () =default void addFlag (String const & v) void parseArgs (int argc, char ** argv) Arguments const & arguments () const String const & getArg (Arguments::size_type const & n) const Returns the n'th commandline argument. String const & get (String const & name, String const & default_value) Gets a named setting, falling back to a default if the key is not found. String const & get (String const & name) Gets a named setting. This method throws if the setting is not present. void markAsUsed (String const & name) Marks a flag as used. bool has (String const & name) const Checks whether or not a given parameter is present. void reset () Resets the state of the parser to its construction state. UnusedSettings const & unusedSettings () const Lists unknown settings. Detailed Description class microsoft::quantum::ParameterParser; Parameter parser class which allows the developer to specify a set of default settings and update those using the commandline argc and argv. Public Types Documentation using Arguments using microsoft::quantum::ParameterParser::Arguments = std::vector<String>; using Flags using microsoft::quantum::ParameterParser::Flags = std::unordered_set<String>; using SettingsMap using microsoft::quantum::ParameterParser::SettingsMap = std::unordered_map<String, String>; using UnusedSettings using microsoft::quantum::ParameterParser::UnusedSettings = std::unordered_set<String>; Public Functions Documentation function ParameterParser ParameterParser() =default function ParameterParser ParameterParser( ParameterParser const & other ) function ParameterParser ParameterParser( ParameterParser && other ) =default function ~ParameterParser ~ParameterParser() =default function addFlag void addFlag( String const & v ) Marks a name as a flag (as opposed to an option). This ensures that no parameter is expected after the flag is specified. For instance --debug is a flag as opposed to --log-level 3 which is an option. function parseArgs void parseArgs( int argc, char ** argv ) Parses the command line arguments given the argc and argv from the main function. function arguments Arguments const & arguments() const Returns list of arguments without flags and/or options included. function getArg String const & getArg( Arguments::size_type const & n ) const Returns the n'th commandline argument. function get String const & get( String const & name, String const & default_value ) Gets a named setting, falling back to a default if the key is not found. function get String const & get( String const & name ) Gets a named setting. This method throws if the setting is not present. function markAsUsed void markAsUsed( String const & name ) Marks a flag as used. function has bool has( String const & name ) const Checks whether or not a given parameter is present. function reset void reset() Resets the state of the parser to its construction state. function unusedSettings UnusedSettings const & unusedSettings() const Lists unknown settings. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::ParameterParser"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#microsoftquantumparameterparser","text":"More... #include <Commandline/ParameterParser.hpp>","title":"microsoft::quantum::ParameterParser"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#public-types","text":"Name using std::vector< String > Arguments using std::unordered_set< String > Flags using std::unordered_map< String, String > SettingsMap using std::unordered_set< String > UnusedSettings","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#public-functions","text":"Name ParameterParser () =default ParameterParser ( ParameterParser const & other) ParameterParser ( ParameterParser && other) =default ~ParameterParser () =default void addFlag (String const & v) void parseArgs (int argc, char ** argv) Arguments const & arguments () const String const & getArg (Arguments::size_type const & n) const Returns the n'th commandline argument. String const & get (String const & name, String const & default_value) Gets a named setting, falling back to a default if the key is not found. String const & get (String const & name) Gets a named setting. This method throws if the setting is not present. void markAsUsed (String const & name) Marks a flag as used. bool has (String const & name) const Checks whether or not a given parameter is present. void reset () Resets the state of the parser to its construction state. UnusedSettings const & unusedSettings () const Lists unknown settings.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#detailed-description","text":"class microsoft::quantum::ParameterParser; Parameter parser class which allows the developer to specify a set of default settings and update those using the commandline argc and argv.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#using-arguments","text":"using microsoft::quantum::ParameterParser::Arguments = std::vector<String>;","title":"using Arguments"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#using-flags","text":"using microsoft::quantum::ParameterParser::Flags = std::unordered_set<String>;","title":"using Flags"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#using-settingsmap","text":"using microsoft::quantum::ParameterParser::SettingsMap = std::unordered_map<String, String>;","title":"using SettingsMap"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#using-unusedsettings","text":"using microsoft::quantum::ParameterParser::UnusedSettings = std::unordered_set<String>;","title":"using UnusedSettings"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-parameterparser","text":"ParameterParser() =default","title":"function ParameterParser"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-parameterparser_1","text":"ParameterParser( ParameterParser const & other )","title":"function ParameterParser"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-parameterparser_2","text":"ParameterParser( ParameterParser && other ) =default","title":"function ParameterParser"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-parameterparser_3","text":"~ParameterParser() =default","title":"function ~ParameterParser"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-addflag","text":"void addFlag( String const & v ) Marks a name as a flag (as opposed to an option). This ensures that no parameter is expected after the flag is specified. For instance --debug is a flag as opposed to --log-level 3 which is an option.","title":"function addFlag"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-parseargs","text":"void parseArgs( int argc, char ** argv ) Parses the command line arguments given the argc and argv from the main function.","title":"function parseArgs"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-arguments","text":"Arguments const & arguments() const Returns list of arguments without flags and/or options included.","title":"function arguments"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-getarg","text":"String const & getArg( Arguments::size_type const & n ) const Returns the n'th commandline argument.","title":"function getArg"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-get","text":"String const & get( String const & name, String const & default_value ) Gets a named setting, falling back to a default if the key is not found.","title":"function get"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-get_1","text":"String const & get( String const & name ) Gets a named setting. This method throws if the setting is not present.","title":"function get"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-markasused","text":"void markAsUsed( String const & name ) Marks a flag as used.","title":"function markAsUsed"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-has","text":"bool has( String const & name ) const Checks whether or not a given parameter is present.","title":"function has"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-reset","text":"void reset() Resets the state of the parser to its construction state.","title":"function reset"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-unusedsettings","text":"UnusedSettings const & unusedSettings() const Lists unknown settings. Updated on 22 March 2022 at 08:31:22 UTC","title":"function unusedSettings"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/","text":"microsoft::quantum::PhiPattern Inherits from microsoft::quantum::IOperandPrototype Public Types Name using std::string String Public Functions Name PhiPattern () =default Construction by name. PhiPattern ( PhiPattern const & other) Copy construction prohibited. PhiPattern ( PhiPattern && other) =default Move construction allowed. ~PhiPattern () override Destructor implementation. virtual bool match (Value * instr, Captures & captures) const override Matches the phi node. virtual Child copy () const override Creates a copy of itself. Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Types Documentation using String using microsoft::quantum::PhiPattern::String = std::string; Public Functions Documentation function PhiPattern PhiPattern() =default Construction by name. function PhiPattern PhiPattern( PhiPattern const & other ) Copy construction prohibited. function PhiPattern PhiPattern( PhiPattern && other ) =default Move construction allowed. function ~PhiPattern ~PhiPattern() override Destructor implementation. function match virtual bool match( Value * instr, Captures & captures ) const override Matches the phi node. Reimplements : microsoft::quantum::IOperandPrototype::match function copy virtual Child copy() const override Creates a copy of itself. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::PhiPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#microsoftquantumphipattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::PhiPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#public-types","text":"Name using std::string String","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#public-functions","text":"Name PhiPattern () =default Construction by name. PhiPattern ( PhiPattern const & other) Copy construction prohibited. PhiPattern ( PhiPattern && other) =default Move construction allowed. ~PhiPattern () override Destructor implementation. virtual bool match (Value * instr, Captures & captures) const override Matches the phi node. virtual Child copy () const override Creates a copy of itself.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#using-string","text":"using microsoft::quantum::PhiPattern::String = std::string;","title":"using String"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#function-phipattern","text":"PhiPattern() =default Construction by name.","title":"function PhiPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#function-phipattern_1","text":"PhiPattern( PhiPattern const & other ) Copy construction prohibited.","title":"function PhiPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#function-phipattern_2","text":"PhiPattern( PhiPattern && other ) =default Move construction allowed.","title":"function PhiPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#function-phipattern_3","text":"~PhiPattern() override Destructor implementation.","title":"function ~PhiPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#function-match","text":"virtual bool match( Value * instr, Captures & captures ) const override Matches the phi node. Reimplements : microsoft::quantum::IOperandPrototype::match","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#function-copy","text":"virtual Child copy() const override Creates a copy of itself. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 22 March 2022 at 08:31:22 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/","text":"microsoft::quantum::Profile More... #include <Profile/Profile.hpp> Public Types Name using IAllocationManager::AllocationManagerPtr AllocationManagerPtr using Validator::ValidatorPtr ValidatorPtr Validator class used to check that an IR fulfils a given specification. Public Functions Name Profile (String const & name, bool debug, llvm::TargetMachine * target_machine =nullptr, AllocationManagerPtr qubit_allocation_manager = BasicAllocationManager::createNew (), AllocationManagerPtr result_allocation_manager = BasicAllocationManager::createNew ()) Profile () Profile ( Profile const & ) Profile ( Profile && ) =default Profile & operator= ( Profile const & ) Profile & operator= ( Profile && ) =default ~Profile () =default void apply (llvm::Module & module) Applies the profile to a module. bool verify (llvm::Module & module) Verifies that a module is a valid LLVM IR. bool validate (llvm::Module & module) Validates that a module complies with the specified QIR profile. AllocationManagerPtr getQubitAllocationManager () AllocationManagerPtr getResultAllocationManager () String const & name () const llvm::PassBuilder & passBuilder () Returns a reference to the pass builder. llvm::LoopAnalysisManager & loopAnalysisManager () Returns a reference to the loop analysis manager. llvm::FunctionAnalysisManager & functionAnalysisManager () Returns a reference to the function analysis manager. llvm::CGSCCAnalysisManager & gsccAnalysisManager () Returns a reference to the GSCC analysis manager. llvm::ModuleAnalysisManager & moduleAnalysisManager () Returns a reference to the module analysis manager. Protected Functions Name void setModulePassManager (llvm::ModulePassManager && manager) Sets the module pass manager used for the transformation of the IR. void setValidator ( ValidatorPtr && validator) Sets the validator. Friends Name class ProfileGenerator Detailed Description class microsoft::quantum::Profile; Profile class that defines a set of rules which constitutes the profile definition. Each of the rules can be used to transform a generic QIR and/or validate that the QIR is compliant with said rule. Public Types Documentation using AllocationManagerPtr using microsoft::quantum::Profile::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; Allocation manager pointer type. Used to reference to concrete allocation manager implementations which defines the allocation logic of the profile. using ValidatorPtr using microsoft::quantum::Profile::ValidatorPtr = Validator::ValidatorPtr; Validator class used to check that an IR fulfils a given specification. Public Functions Documentation function Profile explicit Profile( String const & name, bool debug, llvm::TargetMachine * target_machine =nullptr, AllocationManagerPtr qubit_allocation_manager =BasicAllocationManager::createNew(), AllocationManagerPtr result_allocation_manager =BasicAllocationManager::createNew() ) function Profile Profile() function Profile Profile( Profile const & ) function Profile Profile( Profile && ) =default function operator= Profile & operator=( Profile const & ) function operator= Profile & operator=( Profile && ) =default function ~Profile ~Profile() =default function apply void apply( llvm::Module & module ) Applies the profile to a module. function verify bool verify( llvm::Module & module ) Verifies that a module is a valid LLVM IR. function validate bool validate( llvm::Module & module ) Validates that a module complies with the specified QIR profile. function getQubitAllocationManager AllocationManagerPtr getQubitAllocationManager() function getResultAllocationManager AllocationManagerPtr getResultAllocationManager() function name String const & name() const function passBuilder llvm::PassBuilder & passBuilder() Returns a reference to the pass builder. function loopAnalysisManager llvm::LoopAnalysisManager & loopAnalysisManager() Returns a reference to the loop analysis manager. function functionAnalysisManager llvm::FunctionAnalysisManager & functionAnalysisManager() Returns a reference to the function analysis manager. function gsccAnalysisManager llvm::CGSCCAnalysisManager & gsccAnalysisManager() Returns a reference to the GSCC analysis manager. function moduleAnalysisManager llvm::ModuleAnalysisManager & moduleAnalysisManager() Returns a reference to the module analysis manager. Protected Functions Documentation function setModulePassManager void setModulePassManager( llvm::ModulePassManager && manager ) Sets the module pass manager used for the transformation of the IR. function setValidator void setValidator( ValidatorPtr && validator ) Sets the validator. Friends friend ProfileGenerator friend class ProfileGenerator; Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::Profile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#microsoftquantumprofile","text":"More... #include <Profile/Profile.hpp>","title":"microsoft::quantum::Profile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#public-types","text":"Name using IAllocationManager::AllocationManagerPtr AllocationManagerPtr using Validator::ValidatorPtr ValidatorPtr Validator class used to check that an IR fulfils a given specification.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#public-functions","text":"Name Profile (String const & name, bool debug, llvm::TargetMachine * target_machine =nullptr, AllocationManagerPtr qubit_allocation_manager = BasicAllocationManager::createNew (), AllocationManagerPtr result_allocation_manager = BasicAllocationManager::createNew ()) Profile () Profile ( Profile const & ) Profile ( Profile && ) =default Profile & operator= ( Profile const & ) Profile & operator= ( Profile && ) =default ~Profile () =default void apply (llvm::Module & module) Applies the profile to a module. bool verify (llvm::Module & module) Verifies that a module is a valid LLVM IR. bool validate (llvm::Module & module) Validates that a module complies with the specified QIR profile. AllocationManagerPtr getQubitAllocationManager () AllocationManagerPtr getResultAllocationManager () String const & name () const llvm::PassBuilder & passBuilder () Returns a reference to the pass builder. llvm::LoopAnalysisManager & loopAnalysisManager () Returns a reference to the loop analysis manager. llvm::FunctionAnalysisManager & functionAnalysisManager () Returns a reference to the function analysis manager. llvm::CGSCCAnalysisManager & gsccAnalysisManager () Returns a reference to the GSCC analysis manager. llvm::ModuleAnalysisManager & moduleAnalysisManager () Returns a reference to the module analysis manager.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#protected-functions","text":"Name void setModulePassManager (llvm::ModulePassManager && manager) Sets the module pass manager used for the transformation of the IR. void setValidator ( ValidatorPtr && validator) Sets the validator.","title":"Protected Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#friends","text":"Name class ProfileGenerator","title":"Friends"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#detailed-description","text":"class microsoft::quantum::Profile; Profile class that defines a set of rules which constitutes the profile definition. Each of the rules can be used to transform a generic QIR and/or validate that the QIR is compliant with said rule.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#using-allocationmanagerptr","text":"using microsoft::quantum::Profile::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; Allocation manager pointer type. Used to reference to concrete allocation manager implementations which defines the allocation logic of the profile.","title":"using AllocationManagerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#using-validatorptr","text":"using microsoft::quantum::Profile::ValidatorPtr = Validator::ValidatorPtr; Validator class used to check that an IR fulfils a given specification.","title":"using ValidatorPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-profile","text":"explicit Profile( String const & name, bool debug, llvm::TargetMachine * target_machine =nullptr, AllocationManagerPtr qubit_allocation_manager =BasicAllocationManager::createNew(), AllocationManagerPtr result_allocation_manager =BasicAllocationManager::createNew() )","title":"function Profile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-profile_1","text":"Profile()","title":"function Profile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-profile_2","text":"Profile( Profile const & )","title":"function Profile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-profile_3","text":"Profile( Profile && ) =default","title":"function Profile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-operator","text":"Profile & operator=( Profile const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-operator_1","text":"Profile & operator=( Profile && ) =default","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-profile_4","text":"~Profile() =default","title":"function ~Profile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-apply","text":"void apply( llvm::Module & module ) Applies the profile to a module.","title":"function apply"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-verify","text":"bool verify( llvm::Module & module ) Verifies that a module is a valid LLVM IR.","title":"function verify"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-validate","text":"bool validate( llvm::Module & module ) Validates that a module complies with the specified QIR profile.","title":"function validate"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-getqubitallocationmanager","text":"AllocationManagerPtr getQubitAllocationManager()","title":"function getQubitAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-getresultallocationmanager","text":"AllocationManagerPtr getResultAllocationManager()","title":"function getResultAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-name","text":"String const & name() const","title":"function name"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-passbuilder","text":"llvm::PassBuilder & passBuilder() Returns a reference to the pass builder.","title":"function passBuilder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-loopanalysismanager","text":"llvm::LoopAnalysisManager & loopAnalysisManager() Returns a reference to the loop analysis manager.","title":"function loopAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-functionanalysismanager","text":"llvm::FunctionAnalysisManager & functionAnalysisManager() Returns a reference to the function analysis manager.","title":"function functionAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-gsccanalysismanager","text":"llvm::CGSCCAnalysisManager & gsccAnalysisManager() Returns a reference to the GSCC analysis manager.","title":"function gsccAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-moduleanalysismanager","text":"llvm::ModuleAnalysisManager & moduleAnalysisManager() Returns a reference to the module analysis manager.","title":"function moduleAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-setmodulepassmanager","text":"void setModulePassManager( llvm::ModulePassManager && manager ) Sets the module pass manager used for the transformation of the IR.","title":"function setModulePassManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-setvalidator","text":"void setValidator( ValidatorPtr && validator ) Sets the validator.","title":"function setValidator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#friends_1","text":"","title":"Friends"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#friend-profilegenerator","text":"friend class ProfileGenerator; Updated on 22 March 2022 at 08:31:22 UTC","title":"friend ProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/","text":"microsoft::quantum::ProfileGenerator Inherited by microsoft::quantum::ConfigurableProfileGenerator Public Types Name using llvm::PassBuilder PassBuilder using PassBuilder::OptimizationLevel OptimizationLevel using llvm::FunctionAnalysisManager FunctionAnalysisManager template <typename R > using std::function< void(R const &, ProfileGenerator *, Profile &)> SetupFunction using std::function< void( ProfileGenerator *, Profile &)> SetupFunctionWrapper Wrapper function type for invoking the profile setup function. using std::vector< std::pair< String, SetupFunctionWrapper > > Components List of components to be configured. Public Functions Name ProfileGenerator () =default ~ProfileGenerator () =default ProfileGenerator ( ProfileGenerator const & ) ProfileGenerator ( ProfileGenerator && ) ProfileGenerator & operator= ( ProfileGenerator const & ) ProfileGenerator & operator= ( ProfileGenerator && ) ConfigurationManager & configurationManager () ConfigurationManager const & configurationManager () const Profile newProfile (String const & name, OptimizationLevel const & optimization_level, bool debug) template <typename R > void registerProfileComponent (String const & id, SetupFunction < R > setup) template <typename R > void replaceProfileComponent (String const & id, SetupFunction < R > setup) template <typename R > void registerAnonymousProfileComponent ( SetupFunction < R > setup) void replicateProfileComponent (String const & id) llvm::ModulePassManager & modulePassManager () Returns the module pass manager. llvm::FunctionPassManager & functionPassManager () Returns the module pass manager. llvm::PassBuilder & passBuilder () Returns the pass builder. OptimizationLevel optimizationLevel () const Returns the optimization level. bool isDebugMode () const Flag indicating whether we are operating in debug mode or not. void setupDefaultComponentPipeline () Sets the default pipeline up. Protected Functions Name llvm::ModulePassManager createGenerationModulePassManager ( Profile & profile, OptimizationLevel const & optimization_level, bool debug) llvm::ModulePassManager createValidationModulePass (PassBuilder & pass_builder, OptimizationLevel const & optimization_level, bool debug) Public Types Documentation using PassBuilder using microsoft::quantum::ProfileGenerator::PassBuilder = llvm::PassBuilder; using OptimizationLevel using microsoft::quantum::ProfileGenerator::OptimizationLevel = PassBuilder::OptimizationLevel; using FunctionAnalysisManager using microsoft::quantum::ProfileGenerator::FunctionAnalysisManager = llvm::FunctionAnalysisManager; using SetupFunction template <typename R > using microsoft::quantum::ProfileGenerator::SetupFunction = std::function<void(R const&, ProfileGenerator*, Profile&)>; Setup function that uses a configuration type R to configure the profile and/or generator. using SetupFunctionWrapper using microsoft::quantum::ProfileGenerator::SetupFunctionWrapper = std::function<void(ProfileGenerator*, Profile&)>; Wrapper function type for invoking the profile setup function. using Components using microsoft::quantum::ProfileGenerator::Components = std::vector<std::pair<String, SetupFunctionWrapper> >; List of components to be configured. Public Functions Documentation function ProfileGenerator ProfileGenerator() =default function ~ProfileGenerator ~ProfileGenerator() =default function ProfileGenerator ProfileGenerator( ProfileGenerator const & ) function ProfileGenerator ProfileGenerator( ProfileGenerator && ) function operator= ProfileGenerator & operator=( ProfileGenerator const & ) function operator= ProfileGenerator & operator=( ProfileGenerator && ) function configurationManager ConfigurationManager & configurationManager() Reference to configuration manager. This property allows to access and modify configurations of the generator. This property is intended for managing the configuration. function configurationManager ConfigurationManager const & configurationManager() const Constant reference to the configuration manager. This property allows read access to the configuration manager and is intended for profile generation. function newProfile Profile newProfile( String const & name, OptimizationLevel const & optimization_level, bool debug ) Creates a new profile based on the registered components, optimization level and debug requirements. The returned profile can be applied to an IR to transform it in accordance with the configurations given. function registerProfileComponent template <typename R > void registerProfileComponent( String const & id, SetupFunction< R > setup ) Registers a new profile component with a given configuration R. The profile component is given a name and a setup function which is responsible for configuring the profile in accordance with the configuration. function replaceProfileComponent template <typename R > void replaceProfileComponent( String const & id, SetupFunction< R > setup ) Replaces a profile component. This function is useful for testing purposes and alteration to the default set of components. For instance, one can setup a production set of components and then replace a single component to test the effects of this single replacement while keeping all other components actually as they are in production. function registerAnonymousProfileComponent template <typename R > void registerAnonymousProfileComponent( SetupFunction< R > setup ) Registers a new profile component with a given configuration R. Unlike registerProfileComponent this component will not have an ID. function replicateProfileComponent void replicateProfileComponent( String const & id ) Replicates an existing component as an anonymous component. The original component is found by its id and then copied as an anonymous component which is appended to the list of components. function modulePassManager llvm::ModulePassManager & modulePassManager() Returns the module pass manager. function functionPassManager llvm::FunctionPassManager & functionPassManager() Returns the module pass manager. function passBuilder llvm::PassBuilder & passBuilder() Returns the pass builder. function optimizationLevel OptimizationLevel optimizationLevel() const Returns the optimization level. function isDebugMode bool isDebugMode() const Flag indicating whether we are operating in debug mode or not. function setupDefaultComponentPipeline void setupDefaultComponentPipeline() Sets the default pipeline up. More unroll parameters https://llvm.org/doxygen/LoopUnrollPass_8cpp.html Header https://llvm.org/doxygen/LoopUnrollPass_8h.html Protected Functions Documentation function createGenerationModulePassManager llvm::ModulePassManager createGenerationModulePassManager( Profile & profile, OptimizationLevel const & optimization_level, bool debug ) Internal function that creates a module pass for QIR transformation. The module pass is defined through the profile, the optimization level and whether or not we are in debug mode. function createValidationModulePass llvm::ModulePassManager createValidationModulePass( PassBuilder & pass_builder, OptimizationLevel const & optimization_level, bool debug ) Internal function that creates a module pass for QIR validation. At the moment, this function is a placeholder for future functionality. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::ProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#microsoftquantumprofilegenerator","text":"Inherited by microsoft::quantum::ConfigurableProfileGenerator","title":"microsoft::quantum::ProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#public-types","text":"Name using llvm::PassBuilder PassBuilder using PassBuilder::OptimizationLevel OptimizationLevel using llvm::FunctionAnalysisManager FunctionAnalysisManager template <typename R > using std::function< void(R const &, ProfileGenerator *, Profile &)> SetupFunction using std::function< void( ProfileGenerator *, Profile &)> SetupFunctionWrapper Wrapper function type for invoking the profile setup function. using std::vector< std::pair< String, SetupFunctionWrapper > > Components List of components to be configured.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#public-functions","text":"Name ProfileGenerator () =default ~ProfileGenerator () =default ProfileGenerator ( ProfileGenerator const & ) ProfileGenerator ( ProfileGenerator && ) ProfileGenerator & operator= ( ProfileGenerator const & ) ProfileGenerator & operator= ( ProfileGenerator && ) ConfigurationManager & configurationManager () ConfigurationManager const & configurationManager () const Profile newProfile (String const & name, OptimizationLevel const & optimization_level, bool debug) template <typename R > void registerProfileComponent (String const & id, SetupFunction < R > setup) template <typename R > void replaceProfileComponent (String const & id, SetupFunction < R > setup) template <typename R > void registerAnonymousProfileComponent ( SetupFunction < R > setup) void replicateProfileComponent (String const & id) llvm::ModulePassManager & modulePassManager () Returns the module pass manager. llvm::FunctionPassManager & functionPassManager () Returns the module pass manager. llvm::PassBuilder & passBuilder () Returns the pass builder. OptimizationLevel optimizationLevel () const Returns the optimization level. bool isDebugMode () const Flag indicating whether we are operating in debug mode or not. void setupDefaultComponentPipeline () Sets the default pipeline up.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#protected-functions","text":"Name llvm::ModulePassManager createGenerationModulePassManager ( Profile & profile, OptimizationLevel const & optimization_level, bool debug) llvm::ModulePassManager createValidationModulePass (PassBuilder & pass_builder, OptimizationLevel const & optimization_level, bool debug)","title":"Protected Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#using-passbuilder","text":"using microsoft::quantum::ProfileGenerator::PassBuilder = llvm::PassBuilder;","title":"using PassBuilder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#using-optimizationlevel","text":"using microsoft::quantum::ProfileGenerator::OptimizationLevel = PassBuilder::OptimizationLevel;","title":"using OptimizationLevel"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#using-functionanalysismanager","text":"using microsoft::quantum::ProfileGenerator::FunctionAnalysisManager = llvm::FunctionAnalysisManager;","title":"using FunctionAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#using-setupfunction","text":"template <typename R > using microsoft::quantum::ProfileGenerator::SetupFunction = std::function<void(R const&, ProfileGenerator*, Profile&)>; Setup function that uses a configuration type R to configure the profile and/or generator.","title":"using SetupFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#using-setupfunctionwrapper","text":"using microsoft::quantum::ProfileGenerator::SetupFunctionWrapper = std::function<void(ProfileGenerator*, Profile&)>; Wrapper function type for invoking the profile setup function.","title":"using SetupFunctionWrapper"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#using-components","text":"using microsoft::quantum::ProfileGenerator::Components = std::vector<std::pair<String, SetupFunctionWrapper> >; List of components to be configured.","title":"using Components"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-profilegenerator","text":"ProfileGenerator() =default","title":"function ProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-profilegenerator_1","text":"~ProfileGenerator() =default","title":"function ~ProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-profilegenerator_2","text":"ProfileGenerator( ProfileGenerator const & )","title":"function ProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-profilegenerator_3","text":"ProfileGenerator( ProfileGenerator && )","title":"function ProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-operator","text":"ProfileGenerator & operator=( ProfileGenerator const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-operator_1","text":"ProfileGenerator & operator=( ProfileGenerator && )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-configurationmanager","text":"ConfigurationManager & configurationManager() Reference to configuration manager. This property allows to access and modify configurations of the generator. This property is intended for managing the configuration.","title":"function configurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-configurationmanager_1","text":"ConfigurationManager const & configurationManager() const Constant reference to the configuration manager. This property allows read access to the configuration manager and is intended for profile generation.","title":"function configurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-newprofile","text":"Profile newProfile( String const & name, OptimizationLevel const & optimization_level, bool debug ) Creates a new profile based on the registered components, optimization level and debug requirements. The returned profile can be applied to an IR to transform it in accordance with the configurations given.","title":"function newProfile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-registerprofilecomponent","text":"template <typename R > void registerProfileComponent( String const & id, SetupFunction< R > setup ) Registers a new profile component with a given configuration R. The profile component is given a name and a setup function which is responsible for configuring the profile in accordance with the configuration.","title":"function registerProfileComponent"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-replaceprofilecomponent","text":"template <typename R > void replaceProfileComponent( String const & id, SetupFunction< R > setup ) Replaces a profile component. This function is useful for testing purposes and alteration to the default set of components. For instance, one can setup a production set of components and then replace a single component to test the effects of this single replacement while keeping all other components actually as they are in production.","title":"function replaceProfileComponent"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-registeranonymousprofilecomponent","text":"template <typename R > void registerAnonymousProfileComponent( SetupFunction< R > setup ) Registers a new profile component with a given configuration R. Unlike registerProfileComponent this component will not have an ID.","title":"function registerAnonymousProfileComponent"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-replicateprofilecomponent","text":"void replicateProfileComponent( String const & id ) Replicates an existing component as an anonymous component. The original component is found by its id and then copied as an anonymous component which is appended to the list of components.","title":"function replicateProfileComponent"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-modulepassmanager","text":"llvm::ModulePassManager & modulePassManager() Returns the module pass manager.","title":"function modulePassManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-functionpassmanager","text":"llvm::FunctionPassManager & functionPassManager() Returns the module pass manager.","title":"function functionPassManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-passbuilder","text":"llvm::PassBuilder & passBuilder() Returns the pass builder.","title":"function passBuilder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-optimizationlevel","text":"OptimizationLevel optimizationLevel() const Returns the optimization level.","title":"function optimizationLevel"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-isdebugmode","text":"bool isDebugMode() const Flag indicating whether we are operating in debug mode or not.","title":"function isDebugMode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-setupdefaultcomponentpipeline","text":"void setupDefaultComponentPipeline() Sets the default pipeline up. More unroll parameters https://llvm.org/doxygen/LoopUnrollPass_8cpp.html Header https://llvm.org/doxygen/LoopUnrollPass_8h.html","title":"function setupDefaultComponentPipeline"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-creategenerationmodulepassmanager","text":"llvm::ModulePassManager createGenerationModulePassManager( Profile & profile, OptimizationLevel const & optimization_level, bool debug ) Internal function that creates a module pass for QIR transformation. The module pass is defined through the profile, the optimization level and whether or not we are in debug mode.","title":"function createGenerationModulePassManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-createvalidationmodulepass","text":"llvm::ModulePassManager createValidationModulePass( PassBuilder & pass_builder, OptimizationLevel const & optimization_level, bool debug ) Internal function that creates a module pass for QIR validation. At the moment, this function is a placeholder for future functionality. Updated on 22 March 2022 at 08:31:22 UTC","title":"function createValidationModulePass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_disallowed_attributes_pass/","text":"microsoft::quantum::RemoveDisallowedAttributesPass Inherits from llvm::PassInfoMixin< RemoveDisallowedAttributesPass > Public Functions Name RemoveDisallowedAttributesPass () llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & ) Public Functions Documentation function RemoveDisallowedAttributesPass inline RemoveDisallowedAttributesPass() function run inline llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & ) Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::RemoveDisallowedAttributesPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_disallowed_attributes_pass/#microsoftquantumremovedisallowedattributespass","text":"Inherits from llvm::PassInfoMixin< RemoveDisallowedAttributesPass >","title":"microsoft::quantum::RemoveDisallowedAttributesPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_disallowed_attributes_pass/#public-functions","text":"Name RemoveDisallowedAttributesPass () llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & )","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_disallowed_attributes_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_disallowed_attributes_pass/#function-removedisallowedattributespass","text":"inline RemoveDisallowedAttributesPass()","title":"function RemoveDisallowedAttributesPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_disallowed_attributes_pass/#function-run","text":"inline llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & ) Updated on 22 March 2022 at 08:31:22 UTC","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/","text":"microsoft::quantum::ReplacementRule More... #include <Rules/ReplacementRule.hpp> Public Types Name using IOperandPrototype::Captures Captures Table to store LLVM values using a name. using llvm::Value Value Value alias for shorthand usage. using std::shared_ptr< IOperandPrototype > IOperandPrototypePtr Pointer to the pattern type. using llvm::IRBuilder<> Builder Builder alias for shorthand notation. using std::vector< std::pair< Value *, Value * > > Replacements List of replacements. using std::function< bool( Builder &, Value *, Captures &, Replacements &)> ReplaceFunction Function to perform replacements. Public Functions Name ReplacementRule () =default ReplacementRule (String const & name, IOperandPrototypePtr && pattern, ReplaceFunction && replacer) ReplacementRule ( IOperandPrototypePtr && pattern, ReplaceFunction && replacer) void setPattern ( IOperandPrototypePtr && pattern) Sets the pattern describing logic to be replaced. void setReplacer ( ReplaceFunction const & replacer) bool match ( Value * value, Captures & captures) const bool replace ( Builder & builder, Value * value, Captures & captures, Replacements & replacements) const Invokes the replacer given a matched value and its corresponding captures. String name () const Detailed Description class microsoft::quantum::ReplacementRule; Rule that describes a pattern and how to make a replacement of the matched values. The class contains a OperandPrototype which is used to test whether an LLVM IR value follows a specific pattern. The class also holds a function pointer to logic that allows replacement of the specified value. Public Types Documentation using Captures using microsoft::quantum::ReplacementRule::Captures = IOperandPrototype::Captures; Table to store LLVM values using a name. using Value using microsoft::quantum::ReplacementRule::Value = llvm::Value; Value alias for shorthand usage. using IOperandPrototypePtr using microsoft::quantum::ReplacementRule::IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; Pointer to the pattern type. using Builder using microsoft::quantum::ReplacementRule::Builder = llvm::IRBuilder<>; Builder alias for shorthand notation. using Replacements using microsoft::quantum::ReplacementRule::Replacements = std::vector<std::pair<Value*, Value*> >; List of replacements. using ReplaceFunction using microsoft::quantum::ReplacementRule::ReplaceFunction = std::function<bool(Builder&, Value*, Captures&, Replacements&)>; Function to perform replacements. Public Functions Documentation function ReplacementRule ReplacementRule() =default function ReplacementRule ReplacementRule( String const & name, IOperandPrototypePtr && pattern, ReplaceFunction && replacer ) function ReplacementRule ReplacementRule( IOperandPrototypePtr && pattern, ReplaceFunction && replacer ) function setPattern void setPattern( IOperandPrototypePtr && pattern ) Sets the pattern describing logic to be replaced. function setReplacer void setReplacer( ReplaceFunction const & replacer ) Sets the replacer logic which given a successful match will perform a replacement on the IR. function match bool match( Value * value, Captures & captures ) const Tests whether a given value matches the rule pattern and store captures. The function returns true if the match was successful in which case captures are recorded. function replace bool replace( Builder & builder, Value * value, Captures & captures, Replacements & replacements ) const Invokes the replacer given a matched value and its corresponding captures. function name String name() const Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::ReplacementRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#microsoftquantumreplacementrule","text":"More... #include <Rules/ReplacementRule.hpp>","title":"microsoft::quantum::ReplacementRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#public-types","text":"Name using IOperandPrototype::Captures Captures Table to store LLVM values using a name. using llvm::Value Value Value alias for shorthand usage. using std::shared_ptr< IOperandPrototype > IOperandPrototypePtr Pointer to the pattern type. using llvm::IRBuilder<> Builder Builder alias for shorthand notation. using std::vector< std::pair< Value *, Value * > > Replacements List of replacements. using std::function< bool( Builder &, Value *, Captures &, Replacements &)> ReplaceFunction Function to perform replacements.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#public-functions","text":"Name ReplacementRule () =default ReplacementRule (String const & name, IOperandPrototypePtr && pattern, ReplaceFunction && replacer) ReplacementRule ( IOperandPrototypePtr && pattern, ReplaceFunction && replacer) void setPattern ( IOperandPrototypePtr && pattern) Sets the pattern describing logic to be replaced. void setReplacer ( ReplaceFunction const & replacer) bool match ( Value * value, Captures & captures) const bool replace ( Builder & builder, Value * value, Captures & captures, Replacements & replacements) const Invokes the replacer given a matched value and its corresponding captures. String name () const","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#detailed-description","text":"class microsoft::quantum::ReplacementRule; Rule that describes a pattern and how to make a replacement of the matched values. The class contains a OperandPrototype which is used to test whether an LLVM IR value follows a specific pattern. The class also holds a function pointer to logic that allows replacement of the specified value.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#using-captures","text":"using microsoft::quantum::ReplacementRule::Captures = IOperandPrototype::Captures; Table to store LLVM values using a name.","title":"using Captures"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#using-value","text":"using microsoft::quantum::ReplacementRule::Value = llvm::Value; Value alias for shorthand usage.","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#using-ioperandprototypeptr","text":"using microsoft::quantum::ReplacementRule::IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; Pointer to the pattern type.","title":"using IOperandPrototypePtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#using-builder","text":"using microsoft::quantum::ReplacementRule::Builder = llvm::IRBuilder<>; Builder alias for shorthand notation.","title":"using Builder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#using-replacements","text":"using microsoft::quantum::ReplacementRule::Replacements = std::vector<std::pair<Value*, Value*> >; List of replacements.","title":"using Replacements"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#using-replacefunction","text":"using microsoft::quantum::ReplacementRule::ReplaceFunction = std::function<bool(Builder&, Value*, Captures&, Replacements&)>; Function to perform replacements.","title":"using ReplaceFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-replacementrule","text":"ReplacementRule() =default","title":"function ReplacementRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-replacementrule_1","text":"ReplacementRule( String const & name, IOperandPrototypePtr && pattern, ReplaceFunction && replacer )","title":"function ReplacementRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-replacementrule_2","text":"ReplacementRule( IOperandPrototypePtr && pattern, ReplaceFunction && replacer )","title":"function ReplacementRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-setpattern","text":"void setPattern( IOperandPrototypePtr && pattern ) Sets the pattern describing logic to be replaced.","title":"function setPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-setreplacer","text":"void setReplacer( ReplaceFunction const & replacer ) Sets the replacer logic which given a successful match will perform a replacement on the IR.","title":"function setReplacer"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-match","text":"bool match( Value * value, Captures & captures ) const Tests whether a given value matches the rule pattern and store captures. The function returns true if the match was successful in which case captures are recorded.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-replace","text":"bool replace( Builder & builder, Value * value, Captures & captures, Replacements & replacements ) const Invokes the replacer given a matched value and its corresponding captures.","title":"function replace"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-name","text":"String name() const Updated on 22 March 2022 at 08:31:22 UTC","title":"function name"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/","text":"microsoft::quantum::RuleFactory More... #include <Rules/Factory.hpp> Public Types Name using std::shared_ptr< ReplacementRule > ReplacementRulePtr ReplacementRule pointer type used for the construction of replacement rules. using IAllocationManager::AllocationManagerPtr AllocationManagerPtr Allocation manager pointer used to hold allocation managers. Public Functions Name RuleFactory ( RuleSet & rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager) RuleFactory () RuleFactory ( RuleFactory const & ) RuleFactory ( RuleFactory && ) =default ~RuleFactory () =default void usingConfiguration ( FactoryConfiguration const & config) This takes a FactoryConfiguration as argument and enable rules accordingly. void removeFunctionCall (String const & name) void useStaticQubitArrayAllocation () void useStaticQubitAllocation () void useStaticResultAllocation () void resolveConstantArraySizes () void inlineCallables () void optimizeResultOne () void optimizeResultZero () Replaces branching of quantum results compared to zero. This method is not implemented yet. void disableReferenceCounting () void disableAliasCounting () This method disables alias counting for arrays, strings and results. void disableStringSupport () void setDefaultIntegerWidth (uint32_t v) Sets the integer width used when it cannot be deducted from the context of the transformation. Detailed Description class microsoft::quantum::RuleFactory; Rule factory provides a high-level methods to build a rule set that enforces certain aspects of QIR transformation. Public Types Documentation using ReplacementRulePtr using microsoft::quantum::RuleFactory::ReplacementRulePtr = std::shared_ptr<ReplacementRule>; ReplacementRule pointer type used for the construction of replacement rules. using AllocationManagerPtr using microsoft::quantum::RuleFactory::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; Allocation manager pointer used to hold allocation managers. Public Functions Documentation function RuleFactory RuleFactory( RuleSet & rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager ) function RuleFactory RuleFactory() function RuleFactory RuleFactory( RuleFactory const & ) function RuleFactory RuleFactory( RuleFactory && ) =default function ~RuleFactory ~RuleFactory() =default function usingConfiguration void usingConfiguration( FactoryConfiguration const & config ) This takes a FactoryConfiguration as argument and enable rules accordingly. function removeFunctionCall void removeFunctionCall( String const & name ) Removes all calls to functions with a specified name. This function matches on name alone and ignores function arguments. function useStaticQubitArrayAllocation void useStaticQubitArrayAllocation() Static qubit array allocation identifies allocations, array access and releases. Each of these are replaced with static values. Patterns recognized include %array = call %Array* @__quantum__rt__qubit_allocate_array(i64 10) which is replaced by a constant pointer %array = inttoptr i64 0 to %Array* The array allocation is managed through the qubit allocation manager. Access to qubit arrays %0 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %array, i64 7) %1 = bitcast i8* %0 to %Qubit** %qubit = load %Qubit*, %Qubit** %1, align 8 is replaced by off-setting the array value by 7 to get %qubit = inttoptr i64 7 to %Qubit* Finally, release is recognized and the allocation manager is invoked accordingly. Allocation This rule is replacing the allocate qubit array instruction leftPreshared = call Array* @__quantum__rt__qubit_allocate_array(i64 2) by changing it to a constant pointer leftPreshared = inttoptr i64 0 to Array* In this way, we use the Array access replacement Release replacement function useStaticQubitAllocation void useStaticQubitAllocation() Static qubit allocation identifies allocation and release of single qubits. It uses the qubit allocation manager to track allocation and releases of qubits. It translates %qubit1 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit2 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit3 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit4 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit5 = call %Qubit* @__quantum__rt__qubit_allocate() to %qubit1 = inttoptr i64 0 to %Qubit* %qubit2 = inttoptr i64 1 to %Qubit* %qubit3 = inttoptr i64 2 to %Qubit* %qubit4 = inttoptr i64 3 to %Qubit* %qubit5 = inttoptr i64 4 to %Qubit* if the BasicAllocationManager is used. Release replacement function useStaticResultAllocation void useStaticResultAllocation() Static allocation of results. This feature is similar to useStaticQubitAllocation but uses the result allocation manager. function resolveConstantArraySizes void resolveConstantArraySizes() Array access replacement function inlineCallables void inlineCallables() Array access replacement function optimizeResultOne void optimizeResultOne() Replaces branching of quantum results compared to one. This is a relatively advanced pattern, intended for base profile-like constructs where %1 = tail call %Result* @__quantum__rt__result_get_one() %2 = tail call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 is mapped into %1 = call i1 @__quantum__qis__read_result__body(%Result* %0) br i1 %1, label %then0__1, label %continue__1 which removes the need for constant one. function optimizeResultZero void optimizeResultZero() Replaces branching of quantum results compared to zero. This method is not implemented yet. function disableReferenceCounting void disableReferenceCounting() This method disables reference counting for arrays, strings and results. It does so by simply removing the instructions and the resulting code is expected to be executed either on a stack VM or with shared pointer logic. function disableAliasCounting void disableAliasCounting() This method disables alias counting for arrays, strings and results. function disableStringSupport void disableStringSupport() Removes string support by removing string related instructions. At the moment these include __quantum__rt__string_create , __quantum__rt__string_update_reference_count , __quantum__rt__string_update_alias_count and __quantum__rt__message . function setDefaultIntegerWidth void setDefaultIntegerWidth( uint32_t v ) Sets the integer width used when it cannot be deducted from the context of the transformation. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::RuleFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#microsoftquantumrulefactory","text":"More... #include <Rules/Factory.hpp>","title":"microsoft::quantum::RuleFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#public-types","text":"Name using std::shared_ptr< ReplacementRule > ReplacementRulePtr ReplacementRule pointer type used for the construction of replacement rules. using IAllocationManager::AllocationManagerPtr AllocationManagerPtr Allocation manager pointer used to hold allocation managers.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#public-functions","text":"Name RuleFactory ( RuleSet & rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager) RuleFactory () RuleFactory ( RuleFactory const & ) RuleFactory ( RuleFactory && ) =default ~RuleFactory () =default void usingConfiguration ( FactoryConfiguration const & config) This takes a FactoryConfiguration as argument and enable rules accordingly. void removeFunctionCall (String const & name) void useStaticQubitArrayAllocation () void useStaticQubitAllocation () void useStaticResultAllocation () void resolveConstantArraySizes () void inlineCallables () void optimizeResultOne () void optimizeResultZero () Replaces branching of quantum results compared to zero. This method is not implemented yet. void disableReferenceCounting () void disableAliasCounting () This method disables alias counting for arrays, strings and results. void disableStringSupport () void setDefaultIntegerWidth (uint32_t v) Sets the integer width used when it cannot be deducted from the context of the transformation.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#detailed-description","text":"class microsoft::quantum::RuleFactory; Rule factory provides a high-level methods to build a rule set that enforces certain aspects of QIR transformation.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#using-replacementruleptr","text":"using microsoft::quantum::RuleFactory::ReplacementRulePtr = std::shared_ptr<ReplacementRule>; ReplacementRule pointer type used for the construction of replacement rules.","title":"using ReplacementRulePtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#using-allocationmanagerptr","text":"using microsoft::quantum::RuleFactory::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; Allocation manager pointer used to hold allocation managers.","title":"using AllocationManagerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-rulefactory","text":"RuleFactory( RuleSet & rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager )","title":"function RuleFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-rulefactory_1","text":"RuleFactory()","title":"function RuleFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-rulefactory_2","text":"RuleFactory( RuleFactory const & )","title":"function RuleFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-rulefactory_3","text":"RuleFactory( RuleFactory && ) =default","title":"function RuleFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-rulefactory_4","text":"~RuleFactory() =default","title":"function ~RuleFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-usingconfiguration","text":"void usingConfiguration( FactoryConfiguration const & config ) This takes a FactoryConfiguration as argument and enable rules accordingly.","title":"function usingConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-removefunctioncall","text":"void removeFunctionCall( String const & name ) Removes all calls to functions with a specified name. This function matches on name alone and ignores function arguments.","title":"function removeFunctionCall"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-usestaticqubitarrayallocation","text":"void useStaticQubitArrayAllocation() Static qubit array allocation identifies allocations, array access and releases. Each of these are replaced with static values. Patterns recognized include %array = call %Array* @__quantum__rt__qubit_allocate_array(i64 10) which is replaced by a constant pointer %array = inttoptr i64 0 to %Array* The array allocation is managed through the qubit allocation manager. Access to qubit arrays %0 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %array, i64 7) %1 = bitcast i8* %0 to %Qubit** %qubit = load %Qubit*, %Qubit** %1, align 8 is replaced by off-setting the array value by 7 to get %qubit = inttoptr i64 7 to %Qubit* Finally, release is recognized and the allocation manager is invoked accordingly. Allocation This rule is replacing the allocate qubit array instruction leftPreshared = call Array* @__quantum__rt__qubit_allocate_array(i64 2) by changing it to a constant pointer leftPreshared = inttoptr i64 0 to Array* In this way, we use the Array access replacement Release replacement","title":"function useStaticQubitArrayAllocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-usestaticqubitallocation","text":"void useStaticQubitAllocation() Static qubit allocation identifies allocation and release of single qubits. It uses the qubit allocation manager to track allocation and releases of qubits. It translates %qubit1 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit2 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit3 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit4 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit5 = call %Qubit* @__quantum__rt__qubit_allocate() to %qubit1 = inttoptr i64 0 to %Qubit* %qubit2 = inttoptr i64 1 to %Qubit* %qubit3 = inttoptr i64 2 to %Qubit* %qubit4 = inttoptr i64 3 to %Qubit* %qubit5 = inttoptr i64 4 to %Qubit* if the BasicAllocationManager is used. Release replacement","title":"function useStaticQubitAllocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-usestaticresultallocation","text":"void useStaticResultAllocation() Static allocation of results. This feature is similar to useStaticQubitAllocation but uses the result allocation manager.","title":"function useStaticResultAllocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-resolveconstantarraysizes","text":"void resolveConstantArraySizes() Array access replacement","title":"function resolveConstantArraySizes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-inlinecallables","text":"void inlineCallables() Array access replacement","title":"function inlineCallables"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-optimizeresultone","text":"void optimizeResultOne() Replaces branching of quantum results compared to one. This is a relatively advanced pattern, intended for base profile-like constructs where %1 = tail call %Result* @__quantum__rt__result_get_one() %2 = tail call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 is mapped into %1 = call i1 @__quantum__qis__read_result__body(%Result* %0) br i1 %1, label %then0__1, label %continue__1 which removes the need for constant one.","title":"function optimizeResultOne"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-optimizeresultzero","text":"void optimizeResultZero() Replaces branching of quantum results compared to zero. This method is not implemented yet.","title":"function optimizeResultZero"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-disablereferencecounting","text":"void disableReferenceCounting() This method disables reference counting for arrays, strings and results. It does so by simply removing the instructions and the resulting code is expected to be executed either on a stack VM or with shared pointer logic.","title":"function disableReferenceCounting"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-disablealiascounting","text":"void disableAliasCounting() This method disables alias counting for arrays, strings and results.","title":"function disableAliasCounting"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-disablestringsupport","text":"void disableStringSupport() Removes string support by removing string related instructions. At the moment these include __quantum__rt__string_create , __quantum__rt__string_update_reference_count , __quantum__rt__string_update_alias_count and __quantum__rt__message .","title":"function disableStringSupport"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-setdefaultintegerwidth","text":"void setDefaultIntegerWidth( uint32_t v ) Sets the integer width used when it cannot be deducted from the context of the transformation. Updated on 22 March 2022 at 08:31:22 UTC","title":"function setDefaultIntegerWidth"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/","text":"microsoft::quantum::RuleSet More... #include <Rules/RuleSet.hpp> Public Types Name using std::shared_ptr< ReplacementRule > ReplacementRulePtr using std::vector< ReplacementRulePtr > Rules using ReplacementRule::Replacements Replacements using IOperandPrototype::Captures Captures using llvm::Instruction Instruction using llvm::Value Value using ReplacementRule::Builder Builder using IAllocationManager::AllocationManagerPtr AllocationManagerPtr Public Functions Name RuleSet () =default RuleSet ( RuleSet const & ) =default RuleSet ( RuleSet && ) =default ~RuleSet () =default RuleSet & operator= ( RuleSet const & ) =default RuleSet & operator= ( RuleSet && ) =default bool matchAndReplace (Instruction * value, Replacements & replacements) void addRule (ReplacementRulePtr const & rule) Adds a new replacement rule to the set. void addRule ( ReplacementRule && rule) void clear () Clears the rule set for all rules. uint64_t size () const Returns the size of the rule set. Detailed Description class microsoft::quantum::RuleSet; RuleSet contains a set of replacement rules and the corresponding logic to apply the rules. The class allows one to apply the rules by which each rule is tested one-by-one until a successful attempt at performing a replace has happened, or the list was exhausted. Public Types Documentation using ReplacementRulePtr using microsoft::quantum::RuleSet::ReplacementRulePtr = std::shared_ptr<ReplacementRule>; using Rules using microsoft::quantum::RuleSet::Rules = std::vector<ReplacementRulePtr>; using Replacements using microsoft::quantum::RuleSet::Replacements = ReplacementRule::Replacements; using Captures using microsoft::quantum::RuleSet::Captures = IOperandPrototype::Captures; using Instruction using microsoft::quantum::RuleSet::Instruction = llvm::Instruction; using Value using microsoft::quantum::RuleSet::Value = llvm::Value; using Builder using microsoft::quantum::RuleSet::Builder = ReplacementRule::Builder; using AllocationManagerPtr using microsoft::quantum::RuleSet::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; Public Functions Documentation function RuleSet RuleSet() =default function RuleSet RuleSet( RuleSet const & ) =default function RuleSet RuleSet( RuleSet && ) =default function ~RuleSet ~RuleSet() =default function operator= RuleSet & operator=( RuleSet const & ) =default function operator= RuleSet & operator=( RuleSet && ) =default function matchAndReplace bool matchAndReplace( Instruction * value, Replacements & replacements ) Matches patterns and runs the replacement routines if a match is found. The function returns true if a pattern is matched and and the replacement was a success. In all other cases, it returns false. function addRule void addRule( ReplacementRulePtr const & rule ) Adds a new replacement rule to the set. function addRule void addRule( ReplacementRule && rule ) function clear void clear() Clears the rule set for all rules. function size uint64_t size() const Returns the size of the rule set. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::RuleSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#microsoftquantumruleset","text":"More... #include <Rules/RuleSet.hpp>","title":"microsoft::quantum::RuleSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#public-types","text":"Name using std::shared_ptr< ReplacementRule > ReplacementRulePtr using std::vector< ReplacementRulePtr > Rules using ReplacementRule::Replacements Replacements using IOperandPrototype::Captures Captures using llvm::Instruction Instruction using llvm::Value Value using ReplacementRule::Builder Builder using IAllocationManager::AllocationManagerPtr AllocationManagerPtr","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#public-functions","text":"Name RuleSet () =default RuleSet ( RuleSet const & ) =default RuleSet ( RuleSet && ) =default ~RuleSet () =default RuleSet & operator= ( RuleSet const & ) =default RuleSet & operator= ( RuleSet && ) =default bool matchAndReplace (Instruction * value, Replacements & replacements) void addRule (ReplacementRulePtr const & rule) Adds a new replacement rule to the set. void addRule ( ReplacementRule && rule) void clear () Clears the rule set for all rules. uint64_t size () const Returns the size of the rule set.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#detailed-description","text":"class microsoft::quantum::RuleSet; RuleSet contains a set of replacement rules and the corresponding logic to apply the rules. The class allows one to apply the rules by which each rule is tested one-by-one until a successful attempt at performing a replace has happened, or the list was exhausted.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-replacementruleptr","text":"using microsoft::quantum::RuleSet::ReplacementRulePtr = std::shared_ptr<ReplacementRule>;","title":"using ReplacementRulePtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-rules","text":"using microsoft::quantum::RuleSet::Rules = std::vector<ReplacementRulePtr>;","title":"using Rules"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-replacements","text":"using microsoft::quantum::RuleSet::Replacements = ReplacementRule::Replacements;","title":"using Replacements"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-captures","text":"using microsoft::quantum::RuleSet::Captures = IOperandPrototype::Captures;","title":"using Captures"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-instruction","text":"using microsoft::quantum::RuleSet::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-value","text":"using microsoft::quantum::RuleSet::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-builder","text":"using microsoft::quantum::RuleSet::Builder = ReplacementRule::Builder;","title":"using Builder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-allocationmanagerptr","text":"using microsoft::quantum::RuleSet::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr;","title":"using AllocationManagerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-ruleset","text":"RuleSet() =default","title":"function RuleSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-ruleset_1","text":"RuleSet( RuleSet const & ) =default","title":"function RuleSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-ruleset_2","text":"RuleSet( RuleSet && ) =default","title":"function RuleSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-ruleset_3","text":"~RuleSet() =default","title":"function ~RuleSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-operator","text":"RuleSet & operator=( RuleSet const & ) =default","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-operator_1","text":"RuleSet & operator=( RuleSet && ) =default","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-matchandreplace","text":"bool matchAndReplace( Instruction * value, Replacements & replacements ) Matches patterns and runs the replacement routines if a match is found. The function returns true if a pattern is matched and and the replacement was a success. In all other cases, it returns false.","title":"function matchAndReplace"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-addrule","text":"void addRule( ReplacementRulePtr const & rule ) Adds a new replacement rule to the set.","title":"function addRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-addrule_1","text":"void addRule( ReplacementRule && rule )","title":"function addRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-clear","text":"void clear() Clears the rule set for all rules.","title":"function clear"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-size","text":"uint64_t size() const Returns the size of the rule set. Updated on 22 March 2022 at 08:31:22 UTC","title":"function size"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_select_pattern/","text":"microsoft::quantum::SelectPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::SelectPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_select_pattern/#microsoftquantumselectpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::SelectPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_select_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_select_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_select_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_select_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_select_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 March 2022 at 08:31:22 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_store_pattern/","text":"microsoft::quantum::StorePattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::StorePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_store_pattern/#microsoftquantumstorepattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::StorePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_store_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_store_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_store_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_store_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_store_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 March 2022 at 08:31:22 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_switch_pattern/","text":"microsoft::quantum::SwitchPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::SwitchPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_switch_pattern/#microsoftquantumswitchpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::SwitchPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_switch_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_switch_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_switch_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_switch_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_switch_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 March 2022 at 08:31:22 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/","text":"microsoft::quantum::TransformationRulesPass More... #include <TransformationRulesPass/TransformationRulesPass.hpp> Inherits from llvm::PassInfoMixin< TransformationRulesPass > Public Types Name using ReplacementRule::Replacements Replacements using llvm::Instruction Instruction using std::vector< ReplacementRule > Rules using llvm::Value Value using ReplacementRule::Builder Builder using IAllocationManager::AllocationManagerPtr AllocationManagerPtr using RuleSet::Captures Captures using std::unordered_map< std::string, llvm::ConstantInt * > ConstantArguments using std::shared_ptr< ILogger > ILoggerPtr using std::vector< llvm::Instruction * > DeletableInstructions using std::function< llvm::Value (llvm::Value , DeletableInstructions &)> InstructionModifier Public Functions Name TransformationRulesPass ( RuleSet && rule_set, TransformationRulesPassConfiguration const & config, Profile * profile) Custom default constructor. TransformationRulesPass ( TransformationRulesPass const & ) Copy construction is banned. TransformationRulesPass ( TransformationRulesPass && ) =default We allow move semantics. ~TransformationRulesPass () =default Default destruction. TransformationRulesPass & operator= ( TransformationRulesPass const & ) Copy assignment is banned. TransformationRulesPass & operator= ( TransformationRulesPass && ) =default Move assignment is permitted. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool runOnFunction (llvm::Function & function, InstructionModifier const & modifier) void processReplacements () Applies each of the replacements in the replacements_ variable. void setupCopyAndExpand () Configuration function for copy and expand to setup the necessary rules. void runCopyAndExpand (llvm::Module & module, llvm::ModuleAnalysisManager & mam) llvm::Value * copyAndExpand (llvm::Value * input, DeletableInstructions & schedule_instruction_deletion) llvm::Function * expandFunctionCall (llvm::Function & callee, ConstantArguments const & const_args ={}) Copies the function body and replace function arguments whenever arguments are constant. void constantFoldFunction (llvm::Function & callee) Folds all constant expression in function. void addConstExprRule ( ReplacementRule && rule) Helper function to create replacements for constant expressions. void runDetectActiveCode (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runDeleteDeadCode (llvm::Module & module, llvm::ModuleAnalysisManager & mam) llvm::Value * detectActiveCode (llvm::Value * input, DeletableInstructions & ) llvm::Value * deleteDeadCode (llvm::Value * input, DeletableInstructions & ) bool isActive (llvm::Value * value) const void followUsers (llvm::Value * value) void runReplacePhi (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runApplyRules (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool onQubitRelease (llvm::Instruction * instruction, Captures & captures) bool onQubitAllocate (llvm::Instruction * instruction, Captures & captures) void setLogger (ILoggerPtr logger) bool isRequired () Whether or not this pass is required to run. Detailed Description class microsoft::quantum::TransformationRulesPass; This class applies a set of transformation rules to the IR to transform it into a new IR. The rules are added using the RuleSet class which allows the developer to create one or more rules on how to transform the IR. The module executes the following steps: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Apply profile \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Copy and expand functions \u2502\u2500\u2500\u2510 \u2502 clone \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 functions? \u2502 delete dead \u2502 \u2502 \u25bc code? \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Determine active code \u2502 \u2502 \u2502 delete dead \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 code? \u2502 \u2502 leave dead \u2502 \u25bc \u2502 code? \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Simplify phi nodes \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Delete dead code \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 fallback \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Apply rules \u2502\u25c0\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Copying and expanding functions identifies function calls and identifies compile time constants passed to the function. It then copies the full implementation of the function, replacing all compile-time constants (and hence changing the function signature). That is, if a function call f(x, 9) is identified, it is replaced with f.1(x) where f.1 is a copy of f with second argument written into the function. Public Types Documentation using Replacements using microsoft::quantum::TransformationRulesPass::Replacements = ReplacementRule::Replacements; using Instruction using microsoft::quantum::TransformationRulesPass::Instruction = llvm::Instruction; using Rules using microsoft::quantum::TransformationRulesPass::Rules = std::vector<ReplacementRule>; using Value using microsoft::quantum::TransformationRulesPass::Value = llvm::Value; using Builder using microsoft::quantum::TransformationRulesPass::Builder = ReplacementRule::Builder; using AllocationManagerPtr using microsoft::quantum::TransformationRulesPass::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; using Captures using microsoft::quantum::TransformationRulesPass::Captures = RuleSet::Captures; using ConstantArguments using microsoft::quantum::TransformationRulesPass::ConstantArguments = std::unordered_map<std::string, llvm::ConstantInt*>; using ILoggerPtr using microsoft::quantum::TransformationRulesPass::ILoggerPtr = std::shared_ptr<ILogger>; using DeletableInstructions using microsoft::quantum::TransformationRulesPass::DeletableInstructions = std::vector<llvm::Instruction*>; using InstructionModifier using microsoft::quantum::TransformationRulesPass::InstructionModifier = std::function<llvm::Value*(llvm::Value*, DeletableInstructions&)>; Public Functions Documentation function TransformationRulesPass TransformationRulesPass( RuleSet && rule_set, TransformationRulesPassConfiguration const & config, Profile * profile ) Custom default constructor. function TransformationRulesPass TransformationRulesPass( TransformationRulesPass const & ) Copy construction is banned. function TransformationRulesPass TransformationRulesPass( TransformationRulesPass && ) =default We allow move semantics. function ~TransformationRulesPass ~TransformationRulesPass() =default Default destruction. function operator= TransformationRulesPass & operator=( TransformationRulesPass const & ) Copy assignment is banned. function operator= TransformationRulesPass & operator=( TransformationRulesPass && ) =default Move assignment is permitted. function run llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) Implements the transformation analysis which uses the supplied ruleset to make substitutions in each function. function runOnFunction bool runOnFunction( llvm::Function & function, InstructionModifier const & modifier ) Generic function to apply a instructionModifier (lambda function) to every instruction in the function function . This method follows the execution path to the extend possible and deals with branching if the branch statement can be evaluated at compile time. function processReplacements void processReplacements() Applies each of the replacements in the replacements_ variable. function setupCopyAndExpand void setupCopyAndExpand() Configuration function for copy and expand to setup the necessary rules. function runCopyAndExpand void runCopyAndExpand( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) Main function for running the copy and expand functionality. This function first identifies the entry point and then follows every execution path to copy the callee function for every call instruction encountered. This makes that every call in the code has its own unique callee function which ensures that when allocating qubits or results, the assigned registers are not accidentally reused. function copyAndExpand llvm::Value * copyAndExpand( llvm::Value * input, DeletableInstructions & schedule_instruction_deletion ) Test whether the instruction is a call instruction and copy the callee in case it is. This function collects instructions which are scheduled for deletion at a later point. function expandFunctionCall llvm::Function * expandFunctionCall( llvm::Function & callee, ConstantArguments const & const_args ={} ) Copies the function body and replace function arguments whenever arguments are constant. function constantFoldFunction void constantFoldFunction( llvm::Function & callee ) Folds all constant expression in function. function addConstExprRule void addConstExprRule( ReplacementRule && rule ) Helper function to create replacements for constant expressions. function runDetectActiveCode void runDetectActiveCode( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function runDeleteDeadCode void runDeleteDeadCode( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function detectActiveCode llvm::Value * detectActiveCode( llvm::Value * input, DeletableInstructions & ) function deleteDeadCode llvm::Value * deleteDeadCode( llvm::Value * input, DeletableInstructions & ) function isActive bool isActive( llvm::Value * value ) const function followUsers void followUsers( llvm::Value * value ) function runReplacePhi void runReplacePhi( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) Function which replaces phi nodes which refer to inactive blocks. That is, in cases where branch statement evaluates at compile time, only one block will be marked as active. For those case we can eliminate the phi nodes. In the case where branch statements cannot be evaluated all are marked as active. In this case, phi nodes are left unchanged. function runApplyRules void runApplyRules( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function onQubitRelease bool onQubitRelease( llvm::Instruction * instruction, Captures & captures ) function onQubitAllocate bool onQubitAllocate( llvm::Instruction * instruction, Captures & captures ) function setLogger void setLogger( ILoggerPtr logger ) function isRequired static bool isRequired() Whether or not this pass is required to run. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::TransformationRulesPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#microsoftquantumtransformationrulespass","text":"More... #include <TransformationRulesPass/TransformationRulesPass.hpp> Inherits from llvm::PassInfoMixin< TransformationRulesPass >","title":"microsoft::quantum::TransformationRulesPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#public-types","text":"Name using ReplacementRule::Replacements Replacements using llvm::Instruction Instruction using std::vector< ReplacementRule > Rules using llvm::Value Value using ReplacementRule::Builder Builder using IAllocationManager::AllocationManagerPtr AllocationManagerPtr using RuleSet::Captures Captures using std::unordered_map< std::string, llvm::ConstantInt * > ConstantArguments using std::shared_ptr< ILogger > ILoggerPtr using std::vector< llvm::Instruction * > DeletableInstructions using std::function< llvm::Value (llvm::Value , DeletableInstructions &)> InstructionModifier","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#public-functions","text":"Name TransformationRulesPass ( RuleSet && rule_set, TransformationRulesPassConfiguration const & config, Profile * profile) Custom default constructor. TransformationRulesPass ( TransformationRulesPass const & ) Copy construction is banned. TransformationRulesPass ( TransformationRulesPass && ) =default We allow move semantics. ~TransformationRulesPass () =default Default destruction. TransformationRulesPass & operator= ( TransformationRulesPass const & ) Copy assignment is banned. TransformationRulesPass & operator= ( TransformationRulesPass && ) =default Move assignment is permitted. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool runOnFunction (llvm::Function & function, InstructionModifier const & modifier) void processReplacements () Applies each of the replacements in the replacements_ variable. void setupCopyAndExpand () Configuration function for copy and expand to setup the necessary rules. void runCopyAndExpand (llvm::Module & module, llvm::ModuleAnalysisManager & mam) llvm::Value * copyAndExpand (llvm::Value * input, DeletableInstructions & schedule_instruction_deletion) llvm::Function * expandFunctionCall (llvm::Function & callee, ConstantArguments const & const_args ={}) Copies the function body and replace function arguments whenever arguments are constant. void constantFoldFunction (llvm::Function & callee) Folds all constant expression in function. void addConstExprRule ( ReplacementRule && rule) Helper function to create replacements for constant expressions. void runDetectActiveCode (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runDeleteDeadCode (llvm::Module & module, llvm::ModuleAnalysisManager & mam) llvm::Value * detectActiveCode (llvm::Value * input, DeletableInstructions & ) llvm::Value * deleteDeadCode (llvm::Value * input, DeletableInstructions & ) bool isActive (llvm::Value * value) const void followUsers (llvm::Value * value) void runReplacePhi (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runApplyRules (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool onQubitRelease (llvm::Instruction * instruction, Captures & captures) bool onQubitAllocate (llvm::Instruction * instruction, Captures & captures) void setLogger (ILoggerPtr logger) bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#detailed-description","text":"class microsoft::quantum::TransformationRulesPass; This class applies a set of transformation rules to the IR to transform it into a new IR. The rules are added using the RuleSet class which allows the developer to create one or more rules on how to transform the IR. The module executes the following steps: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Apply profile \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Copy and expand functions \u2502\u2500\u2500\u2510 \u2502 clone \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 functions? \u2502 delete dead \u2502 \u2502 \u25bc code? \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Determine active code \u2502 \u2502 \u2502 delete dead \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 code? \u2502 \u2502 leave dead \u2502 \u25bc \u2502 code? \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Simplify phi nodes \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Delete dead code \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 fallback \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Apply rules \u2502\u25c0\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Copying and expanding functions identifies function calls and identifies compile time constants passed to the function. It then copies the full implementation of the function, replacing all compile-time constants (and hence changing the function signature). That is, if a function call f(x, 9) is identified, it is replaced with f.1(x) where f.1 is a copy of f with second argument written into the function.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-replacements","text":"using microsoft::quantum::TransformationRulesPass::Replacements = ReplacementRule::Replacements;","title":"using Replacements"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-instruction","text":"using microsoft::quantum::TransformationRulesPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-rules","text":"using microsoft::quantum::TransformationRulesPass::Rules = std::vector<ReplacementRule>;","title":"using Rules"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-value","text":"using microsoft::quantum::TransformationRulesPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-builder","text":"using microsoft::quantum::TransformationRulesPass::Builder = ReplacementRule::Builder;","title":"using Builder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-allocationmanagerptr","text":"using microsoft::quantum::TransformationRulesPass::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr;","title":"using AllocationManagerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-captures","text":"using microsoft::quantum::TransformationRulesPass::Captures = RuleSet::Captures;","title":"using Captures"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-constantarguments","text":"using microsoft::quantum::TransformationRulesPass::ConstantArguments = std::unordered_map<std::string, llvm::ConstantInt*>;","title":"using ConstantArguments"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-iloggerptr","text":"using microsoft::quantum::TransformationRulesPass::ILoggerPtr = std::shared_ptr<ILogger>;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-deletableinstructions","text":"using microsoft::quantum::TransformationRulesPass::DeletableInstructions = std::vector<llvm::Instruction*>;","title":"using DeletableInstructions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-instructionmodifier","text":"using microsoft::quantum::TransformationRulesPass::InstructionModifier = std::function<llvm::Value*(llvm::Value*, DeletableInstructions&)>;","title":"using InstructionModifier"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-transformationrulespass","text":"TransformationRulesPass( RuleSet && rule_set, TransformationRulesPassConfiguration const & config, Profile * profile ) Custom default constructor.","title":"function TransformationRulesPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-transformationrulespass_1","text":"TransformationRulesPass( TransformationRulesPass const & ) Copy construction is banned.","title":"function TransformationRulesPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-transformationrulespass_2","text":"TransformationRulesPass( TransformationRulesPass && ) =default We allow move semantics.","title":"function TransformationRulesPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-transformationrulespass_3","text":"~TransformationRulesPass() =default Default destruction.","title":"function ~TransformationRulesPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-operator","text":"TransformationRulesPass & operator=( TransformationRulesPass const & ) Copy assignment is banned.","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-operator_1","text":"TransformationRulesPass & operator=( TransformationRulesPass && ) =default Move assignment is permitted.","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-run","text":"llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) Implements the transformation analysis which uses the supplied ruleset to make substitutions in each function.","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-runonfunction","text":"bool runOnFunction( llvm::Function & function, InstructionModifier const & modifier ) Generic function to apply a instructionModifier (lambda function) to every instruction in the function function . This method follows the execution path to the extend possible and deals with branching if the branch statement can be evaluated at compile time.","title":"function runOnFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-processreplacements","text":"void processReplacements() Applies each of the replacements in the replacements_ variable.","title":"function processReplacements"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-setupcopyandexpand","text":"void setupCopyAndExpand() Configuration function for copy and expand to setup the necessary rules.","title":"function setupCopyAndExpand"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-runcopyandexpand","text":"void runCopyAndExpand( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) Main function for running the copy and expand functionality. This function first identifies the entry point and then follows every execution path to copy the callee function for every call instruction encountered. This makes that every call in the code has its own unique callee function which ensures that when allocating qubits or results, the assigned registers are not accidentally reused.","title":"function runCopyAndExpand"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-copyandexpand","text":"llvm::Value * copyAndExpand( llvm::Value * input, DeletableInstructions & schedule_instruction_deletion ) Test whether the instruction is a call instruction and copy the callee in case it is. This function collects instructions which are scheduled for deletion at a later point.","title":"function copyAndExpand"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-expandfunctioncall","text":"llvm::Function * expandFunctionCall( llvm::Function & callee, ConstantArguments const & const_args ={} ) Copies the function body and replace function arguments whenever arguments are constant.","title":"function expandFunctionCall"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-constantfoldfunction","text":"void constantFoldFunction( llvm::Function & callee ) Folds all constant expression in function.","title":"function constantFoldFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-addconstexprrule","text":"void addConstExprRule( ReplacementRule && rule ) Helper function to create replacements for constant expressions.","title":"function addConstExprRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-rundetectactivecode","text":"void runDetectActiveCode( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function runDetectActiveCode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-rundeletedeadcode","text":"void runDeleteDeadCode( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function runDeleteDeadCode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-detectactivecode","text":"llvm::Value * detectActiveCode( llvm::Value * input, DeletableInstructions & )","title":"function detectActiveCode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-deletedeadcode","text":"llvm::Value * deleteDeadCode( llvm::Value * input, DeletableInstructions & )","title":"function deleteDeadCode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-isactive","text":"bool isActive( llvm::Value * value ) const","title":"function isActive"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-followusers","text":"void followUsers( llvm::Value * value )","title":"function followUsers"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-runreplacephi","text":"void runReplacePhi( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) Function which replaces phi nodes which refer to inactive blocks. That is, in cases where branch statement evaluates at compile time, only one block will be marked as active. For those case we can eliminate the phi nodes. In the case where branch statements cannot be evaluated all are marked as active. In this case, phi nodes are left unchanged.","title":"function runReplacePhi"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-runapplyrules","text":"void runApplyRules( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function runApplyRules"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-onqubitrelease","text":"bool onQubitRelease( llvm::Instruction * instruction, Captures & captures )","title":"function onQubitRelease"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-onqubitallocate","text":"bool onQubitAllocate( llvm::Instruction * instruction, Captures & captures )","title":"function onQubitAllocate"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-setlogger","text":"void setLogger( ILoggerPtr logger )","title":"function setLogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run. Updated on 22 March 2022 at 08:31:22 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/","text":"microsoft::quantum::TransformationRulesPassConfiguration Configuration class for the RuleTransformation pass. #include <TransformationRulesPass/TransformationRulesPassConfiguration.hpp> Public Functions Name void setup ( ConfigurationManager & config) Setup function that attached the configuration to the ConfigurationManager . bool isDisabled () const Tests whether all functionality is disabled for this component. bool operator== ( TransformationRulesPassConfiguration const & ref) const Testing equality of two configurations. bool shouldDeleteDeadCode () const Whether or not the component should delete dead code. bool shouldCloneFunctions () const bool assumeNoExceptions () const Whether or not we assume that the code does not throw at runtime. bool shouldTransformExecutionPathOnly () const uint64_t maxRecursion () const The maximum recursion acceptable when unrolling the execution path. bool shouldReuseQubits () const Whether or not to reuse qubits. bool shouldAnnotateQubitUse () const Whether or not to annotate entry point with the number of qubits they use. bool shouldReuseResults () const Whether or not to reuse result registers. bool shouldAnnotateResultUse () const Whether or not to annotate entry point with the number of results they use. bool shouldGroupMeasurements () const Whether or not the component should attempt to group measurements. bool oneShotMeasurement () const std::string entryPointAttr () const Attribute which indicate that a function is the entry point. TransformationRulesPassConfiguration createDisabled () Creates a configuration where all functionality is disabled. TransformationRulesPassConfiguration createReuseQubitsOnly () Creates a configuration where only reuse qubits is enabled. Public Functions Documentation function setup void setup( ConfigurationManager & config ) Setup function that attached the configuration to the ConfigurationManager . function isDisabled bool isDisabled() const Tests whether all functionality is disabled for this component. function operator== bool operator==( TransformationRulesPassConfiguration const & ref ) const Testing equality of two configurations. function shouldDeleteDeadCode bool shouldDeleteDeadCode() const Whether or not the component should delete dead code. function shouldCloneFunctions bool shouldCloneFunctions() const Whether or not the component should clone functions. This is relevant in relation to qubit allocation if execution paths are expanded. function assumeNoExceptions bool assumeNoExceptions() const Whether or not we assume that the code does not throw at runtime. function shouldTransformExecutionPathOnly bool shouldTransformExecutionPathOnly() const Whether or not the component should follow the execution path only or it should be applied to all parts of the code. For statically allocated qubits one generally wants to follow the execution path whereas it makes more sense to apply to all parts of the code for dynamic qubit allocation. function maxRecursion uint64_t maxRecursion() const The maximum recursion acceptable when unrolling the execution path. function shouldReuseQubits bool shouldReuseQubits() const Whether or not to reuse qubits. function shouldAnnotateQubitUse bool shouldAnnotateQubitUse() const Whether or not to annotate entry point with the number of qubits they use. function shouldReuseResults bool shouldReuseResults() const Whether or not to reuse result registers. function shouldAnnotateResultUse bool shouldAnnotateResultUse() const Whether or not to annotate entry point with the number of results they use. function shouldGroupMeasurements bool shouldGroupMeasurements() const Whether or not the component should attempt to group measurements. function oneShotMeasurement bool oneShotMeasurement() const Whether or not the target supports measurement (and result interpretation) during the circuit execution. function entryPointAttr std::string entryPointAttr() const Attribute which indicate that a function is the entry point. function createDisabled static TransformationRulesPassConfiguration createDisabled() Creates a configuration where all functionality is disabled. function createReuseQubitsOnly static TransformationRulesPassConfiguration createReuseQubitsOnly() Creates a configuration where only reuse qubits is enabled. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::TransformationRulesPassConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#microsoftquantumtransformationrulespassconfiguration","text":"Configuration class for the RuleTransformation pass. #include <TransformationRulesPass/TransformationRulesPassConfiguration.hpp>","title":"microsoft::quantum::TransformationRulesPassConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#public-functions","text":"Name void setup ( ConfigurationManager & config) Setup function that attached the configuration to the ConfigurationManager . bool isDisabled () const Tests whether all functionality is disabled for this component. bool operator== ( TransformationRulesPassConfiguration const & ref) const Testing equality of two configurations. bool shouldDeleteDeadCode () const Whether or not the component should delete dead code. bool shouldCloneFunctions () const bool assumeNoExceptions () const Whether or not we assume that the code does not throw at runtime. bool shouldTransformExecutionPathOnly () const uint64_t maxRecursion () const The maximum recursion acceptable when unrolling the execution path. bool shouldReuseQubits () const Whether or not to reuse qubits. bool shouldAnnotateQubitUse () const Whether or not to annotate entry point with the number of qubits they use. bool shouldReuseResults () const Whether or not to reuse result registers. bool shouldAnnotateResultUse () const Whether or not to annotate entry point with the number of results they use. bool shouldGroupMeasurements () const Whether or not the component should attempt to group measurements. bool oneShotMeasurement () const std::string entryPointAttr () const Attribute which indicate that a function is the entry point. TransformationRulesPassConfiguration createDisabled () Creates a configuration where all functionality is disabled. TransformationRulesPassConfiguration createReuseQubitsOnly () Creates a configuration where only reuse qubits is enabled.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-setup","text":"void setup( ConfigurationManager & config ) Setup function that attached the configuration to the ConfigurationManager .","title":"function setup"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-isdisabled","text":"bool isDisabled() const Tests whether all functionality is disabled for this component.","title":"function isDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-operator","text":"bool operator==( TransformationRulesPassConfiguration const & ref ) const Testing equality of two configurations.","title":"function operator=="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-shoulddeletedeadcode","text":"bool shouldDeleteDeadCode() const Whether or not the component should delete dead code.","title":"function shouldDeleteDeadCode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-shouldclonefunctions","text":"bool shouldCloneFunctions() const Whether or not the component should clone functions. This is relevant in relation to qubit allocation if execution paths are expanded.","title":"function shouldCloneFunctions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-assumenoexceptions","text":"bool assumeNoExceptions() const Whether or not we assume that the code does not throw at runtime.","title":"function assumeNoExceptions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-shouldtransformexecutionpathonly","text":"bool shouldTransformExecutionPathOnly() const Whether or not the component should follow the execution path only or it should be applied to all parts of the code. For statically allocated qubits one generally wants to follow the execution path whereas it makes more sense to apply to all parts of the code for dynamic qubit allocation.","title":"function shouldTransformExecutionPathOnly"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-maxrecursion","text":"uint64_t maxRecursion() const The maximum recursion acceptable when unrolling the execution path.","title":"function maxRecursion"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-shouldreusequbits","text":"bool shouldReuseQubits() const Whether or not to reuse qubits.","title":"function shouldReuseQubits"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-shouldannotatequbituse","text":"bool shouldAnnotateQubitUse() const Whether or not to annotate entry point with the number of qubits they use.","title":"function shouldAnnotateQubitUse"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-shouldreuseresults","text":"bool shouldReuseResults() const Whether or not to reuse result registers.","title":"function shouldReuseResults"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-shouldannotateresultuse","text":"bool shouldAnnotateResultUse() const Whether or not to annotate entry point with the number of results they use.","title":"function shouldAnnotateResultUse"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-shouldgroupmeasurements","text":"bool shouldGroupMeasurements() const Whether or not the component should attempt to group measurements.","title":"function shouldGroupMeasurements"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-oneshotmeasurement","text":"bool oneShotMeasurement() const Whether or not the target supports measurement (and result interpretation) during the circuit execution.","title":"function oneShotMeasurement"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-entrypointattr","text":"std::string entryPointAttr() const Attribute which indicate that a function is the entry point.","title":"function entryPointAttr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-createdisabled","text":"static TransformationRulesPassConfiguration createDisabled() Creates a configuration where all functionality is disabled.","title":"function createDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-createreusequbitsonly","text":"static TransformationRulesPassConfiguration createReuseQubitsOnly() Creates a configuration where only reuse qubits is enabled. Updated on 22 March 2022 at 08:31:22 UTC","title":"function createReuseQubitsOnly"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/","text":"microsoft::quantum::UnnamedInvokePattern Inherits from microsoft::quantum::IOperandPrototype Public Types Name using std::string String Public Functions Name UnnamedInvokePattern () =default UnnamedInvokePattern ( UnnamedInvokePattern const & other) Copy construction prohibited. UnnamedInvokePattern ( UnnamedInvokePattern && other) =default Move construction allowed. ~UnnamedInvokePattern () override Destructor implementation. virtual bool match (Value * instr, Captures & captures) const override Matches the callee by name. virtual Child copy () const override Creates a copy of itself. Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Types Documentation using String using microsoft::quantum::UnnamedInvokePattern::String = std::string; Public Functions Documentation function UnnamedInvokePattern UnnamedInvokePattern() =default function UnnamedInvokePattern UnnamedInvokePattern( UnnamedInvokePattern const & other ) Copy construction prohibited. function UnnamedInvokePattern UnnamedInvokePattern( UnnamedInvokePattern && other ) =default Move construction allowed. function ~UnnamedInvokePattern ~UnnamedInvokePattern() override Destructor implementation. function match virtual bool match( Value * instr, Captures & captures ) const override Matches the callee by name. Reimplements : microsoft::quantum::IOperandPrototype::match function copy virtual Child copy() const override Creates a copy of itself. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::UnnamedInvokePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#microsoftquantumunnamedinvokepattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::UnnamedInvokePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#public-types","text":"Name using std::string String","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#public-functions","text":"Name UnnamedInvokePattern () =default UnnamedInvokePattern ( UnnamedInvokePattern const & other) Copy construction prohibited. UnnamedInvokePattern ( UnnamedInvokePattern && other) =default Move construction allowed. ~UnnamedInvokePattern () override Destructor implementation. virtual bool match (Value * instr, Captures & captures) const override Matches the callee by name. virtual Child copy () const override Creates a copy of itself.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#using-string","text":"using microsoft::quantum::UnnamedInvokePattern::String = std::string;","title":"using String"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#function-unnamedinvokepattern","text":"UnnamedInvokePattern() =default","title":"function UnnamedInvokePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#function-unnamedinvokepattern_1","text":"UnnamedInvokePattern( UnnamedInvokePattern const & other ) Copy construction prohibited.","title":"function UnnamedInvokePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#function-unnamedinvokepattern_2","text":"UnnamedInvokePattern( UnnamedInvokePattern && other ) =default Move construction allowed.","title":"function UnnamedInvokePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#function-unnamedinvokepattern_3","text":"~UnnamedInvokePattern() override Destructor implementation.","title":"function ~UnnamedInvokePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#function-match","text":"virtual bool match( Value * instr, Captures & captures ) const override Matches the callee by name. Reimplements : microsoft::quantum::IOperandPrototype::match","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#function-copy","text":"virtual Child copy() const override Creates a copy of itself. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 22 March 2022 at 08:31:22 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/","text":"microsoft::quantum::ValidationPass Inherits from llvm::PassInfoMixin< ValidationPass > Public Types Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< ILogger > ILoggerPtr Public Functions Name ValidationPass ( ValidationPassConfiguration const & cfg, ILoggerPtr const & logger =nullptr) ValidationPass ( ValidationPass const & ) Copy construction is banned. ValidationPass ( ValidationPass && ) =default We allow move semantics. ~ValidationPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool isRequired () Whether or not this pass is required to run. Public Types Documentation using Instruction using microsoft::quantum::ValidationPass::Instruction = llvm::Instruction; using Value using microsoft::quantum::ValidationPass::Value = llvm::Value; using ILoggerPtr using microsoft::quantum::ValidationPass::ILoggerPtr = std::shared_ptr<ILogger>; Public Functions Documentation function ValidationPass inline explicit ValidationPass( ValidationPassConfiguration const & cfg, ILoggerPtr const & logger =nullptr ) function ValidationPass ValidationPass( ValidationPass const & ) Copy construction is banned. function ValidationPass ValidationPass( ValidationPass && ) =default We allow move semantics. function ~ValidationPass ~ValidationPass() =default Default destruction. function run llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function isRequired static bool isRequired() Whether or not this pass is required to run. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::ValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#microsoftquantumvalidationpass","text":"Inherits from llvm::PassInfoMixin< ValidationPass >","title":"microsoft::quantum::ValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#public-types","text":"Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< ILogger > ILoggerPtr","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#public-functions","text":"Name ValidationPass ( ValidationPassConfiguration const & cfg, ILoggerPtr const & logger =nullptr) ValidationPass ( ValidationPass const & ) Copy construction is banned. ValidationPass ( ValidationPass && ) =default We allow move semantics. ~ValidationPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#using-instruction","text":"using microsoft::quantum::ValidationPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#using-value","text":"using microsoft::quantum::ValidationPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#using-iloggerptr","text":"using microsoft::quantum::ValidationPass::ILoggerPtr = std::shared_ptr<ILogger>;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#function-validationpass","text":"inline explicit ValidationPass( ValidationPassConfiguration const & cfg, ILoggerPtr const & logger =nullptr )","title":"function ValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#function-validationpass_1","text":"ValidationPass( ValidationPass const & ) Copy construction is banned.","title":"function ValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#function-validationpass_2","text":"ValidationPass( ValidationPass && ) =default We allow move semantics.","title":"function ValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#function-validationpass_3","text":"~ValidationPass() =default Default destruction.","title":"function ~ValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#function-run","text":"llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run. Updated on 22 March 2022 at 08:31:22 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/","text":"microsoft::quantum::ValidationPassConfiguration Public Types Name using std::unordered_set< std::string > Set Public Functions Name ValidationPassConfiguration () =default void setup ( ConfigurationManager & config) Set const & allowedOpcodes () const Set const & allowedExternalCallNames () const bool allowInternalCalls () const bool allowlistOpcodes () const bool allowlistExternalCalls () const String const & saveReportTo () const bool allowlistPointerTypes () const Set const & allowedPointerTypes () const String profileName () const ValidationPassConfiguration fromProfileName (String const & name) Public Types Documentation using Set using microsoft::quantum::ValidationPassConfiguration::Set = std::unordered_set<std::string>; Public Functions Documentation function ValidationPassConfiguration ValidationPassConfiguration() =default function setup void setup( ConfigurationManager & config ) Setup function that adds the configuration flags to the ConfigurationManager . See the ConfigurationManager documentation for more details on how the setup process is implemented. function allowedOpcodes Set const & allowedOpcodes() const function allowedExternalCallNames Set const & allowedExternalCallNames() const function allowInternalCalls bool allowInternalCalls() const function allowlistOpcodes bool allowlistOpcodes() const function allowlistExternalCalls bool allowlistExternalCalls() const function saveReportTo String const & saveReportTo() const function allowlistPointerTypes bool allowlistPointerTypes() const function allowedPointerTypes Set const & allowedPointerTypes() const function profileName String profileName() const function fromProfileName static ValidationPassConfiguration fromProfileName( String const & name ) Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::ValidationPassConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#microsoftquantumvalidationpassconfiguration","text":"","title":"microsoft::quantum::ValidationPassConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#public-types","text":"Name using std::unordered_set< std::string > Set","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#public-functions","text":"Name ValidationPassConfiguration () =default void setup ( ConfigurationManager & config) Set const & allowedOpcodes () const Set const & allowedExternalCallNames () const bool allowInternalCalls () const bool allowlistOpcodes () const bool allowlistExternalCalls () const String const & saveReportTo () const bool allowlistPointerTypes () const Set const & allowedPointerTypes () const String profileName () const ValidationPassConfiguration fromProfileName (String const & name)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#using-set","text":"using microsoft::quantum::ValidationPassConfiguration::Set = std::unordered_set<std::string>;","title":"using Set"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#function-validationpassconfiguration","text":"ValidationPassConfiguration() =default","title":"function ValidationPassConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#function-setup","text":"void setup( ConfigurationManager & config ) Setup function that adds the configuration flags to the ConfigurationManager . See the ConfigurationManager documentation for more details on how the setup process is implemented.","title":"function setup"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#function-allowedopcodes","text":"Set const & allowedOpcodes() const","title":"function allowedOpcodes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#function-allowedexternalcallnames","text":"Set const & allowedExternalCallNames() const","title":"function allowedExternalCallNames"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#function-allowinternalcalls","text":"bool allowInternalCalls() const","title":"function allowInternalCalls"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#function-allowlistopcodes","text":"bool allowlistOpcodes() const","title":"function allowlistOpcodes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#function-allowlistexternalcalls","text":"bool allowlistExternalCalls() const","title":"function allowlistExternalCalls"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#function-savereportto","text":"String const & saveReportTo() const","title":"function saveReportTo"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#function-allowlistpointertypes","text":"bool allowlistPointerTypes() const","title":"function allowlistPointerTypes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#function-allowedpointertypes","text":"Set const & allowedPointerTypes() const","title":"function allowedPointerTypes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#function-profilename","text":"String profileName() const","title":"function profileName"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#function-fromprofilename","text":"static ValidationPassConfiguration fromProfileName( String const & name ) Updated on 22 March 2022 at 08:31:22 UTC","title":"function fromProfileName"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/","text":"microsoft::quantum::Validator More... #include <Validator/Validator.hpp> Public Types Name using std::unique_ptr< Validator > ValidatorPtr using std::shared_ptr< LogCollection > LogColloectionPtr Protected Types Name using std::unique_ptr< llvm::PassBuilder > PassBuilderPtr Public Functions Name Validator ( ValidationPassConfiguration const & cfg, bool force_log_collection, bool debug, llvm::TargetMachine * target_machine =nullptr) Validator () Validator ( Validator const & ) Validator ( Validator && ) =default Validator & operator= ( Validator const & ) Validator & operator= ( Validator && ) =default ~Validator () =default bool validate (llvm::Module & module) LogColloectionPtr logger () const Returns the logger. This value may be null if no logger was set. Protected Functions Name llvm::PassBuilder & passBuilder () Returns a reference to the pass builder. llvm::LoopAnalysisManager & loopAnalysisManager () Returns a reference to the loop analysis manager. llvm::FunctionAnalysisManager & functionAnalysisManager () Returns a reference to the function analysis manager. llvm::CGSCCAnalysisManager & gsccAnalysisManager () Returns a reference to the GSCC analysis manager. llvm::ModuleAnalysisManager & moduleAnalysisManager () Returns a reference to the module analysis manager. Detailed Description class microsoft::quantum::Validator; Validator class that defines a set of rules which constitutes the profile definition. Each of the rules can be used to transform a generic QIR and/or validate that the QIR is compliant with said rule. Public Types Documentation using ValidatorPtr using microsoft::quantum::Validator::ValidatorPtr = std::unique_ptr<Validator>; using LogColloectionPtr using microsoft::quantum::Validator::LogColloectionPtr = std::shared_ptr<LogCollection>; Protected Types Documentation using PassBuilderPtr using microsoft::quantum::Validator::PassBuilderPtr = std::unique_ptr<llvm::PassBuilder>; Public Functions Documentation function Validator explicit Validator( ValidationPassConfiguration const & cfg, bool force_log_collection, bool debug, llvm::TargetMachine * target_machine =nullptr ) function Validator Validator() function Validator Validator( Validator const & ) function Validator Validator( Validator && ) =default function operator= Validator & operator=( Validator const & ) function operator= Validator & operator=( Validator && ) =default function ~Validator ~Validator() =default function validate bool validate( llvm::Module & module ) Validates that a module complies with the specified QIR profile. Returns true if the module is valid and false otherwize. function logger LogColloectionPtr logger() const Returns the logger. This value may be null if no logger was set. Protected Functions Documentation function passBuilder llvm::PassBuilder & passBuilder() Returns a reference to the pass builder. function loopAnalysisManager llvm::LoopAnalysisManager & loopAnalysisManager() Returns a reference to the loop analysis manager. function functionAnalysisManager llvm::FunctionAnalysisManager & functionAnalysisManager() Returns a reference to the function analysis manager. function gsccAnalysisManager llvm::CGSCCAnalysisManager & gsccAnalysisManager() Returns a reference to the GSCC analysis manager. function moduleAnalysisManager llvm::ModuleAnalysisManager & moduleAnalysisManager() Returns a reference to the module analysis manager. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::Validator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#microsoftquantumvalidator","text":"More... #include <Validator/Validator.hpp>","title":"microsoft::quantum::Validator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#public-types","text":"Name using std::unique_ptr< Validator > ValidatorPtr using std::shared_ptr< LogCollection > LogColloectionPtr","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#protected-types","text":"Name using std::unique_ptr< llvm::PassBuilder > PassBuilderPtr","title":"Protected Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#public-functions","text":"Name Validator ( ValidationPassConfiguration const & cfg, bool force_log_collection, bool debug, llvm::TargetMachine * target_machine =nullptr) Validator () Validator ( Validator const & ) Validator ( Validator && ) =default Validator & operator= ( Validator const & ) Validator & operator= ( Validator && ) =default ~Validator () =default bool validate (llvm::Module & module) LogColloectionPtr logger () const Returns the logger. This value may be null if no logger was set.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#protected-functions","text":"Name llvm::PassBuilder & passBuilder () Returns a reference to the pass builder. llvm::LoopAnalysisManager & loopAnalysisManager () Returns a reference to the loop analysis manager. llvm::FunctionAnalysisManager & functionAnalysisManager () Returns a reference to the function analysis manager. llvm::CGSCCAnalysisManager & gsccAnalysisManager () Returns a reference to the GSCC analysis manager. llvm::ModuleAnalysisManager & moduleAnalysisManager () Returns a reference to the module analysis manager.","title":"Protected Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#detailed-description","text":"class microsoft::quantum::Validator; Validator class that defines a set of rules which constitutes the profile definition. Each of the rules can be used to transform a generic QIR and/or validate that the QIR is compliant with said rule.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#using-validatorptr","text":"using microsoft::quantum::Validator::ValidatorPtr = std::unique_ptr<Validator>;","title":"using ValidatorPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#using-logcolloectionptr","text":"using microsoft::quantum::Validator::LogColloectionPtr = std::shared_ptr<LogCollection>;","title":"using LogColloectionPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#protected-types-documentation","text":"","title":"Protected Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#using-passbuilderptr","text":"using microsoft::quantum::Validator::PassBuilderPtr = std::unique_ptr<llvm::PassBuilder>;","title":"using PassBuilderPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-validator","text":"explicit Validator( ValidationPassConfiguration const & cfg, bool force_log_collection, bool debug, llvm::TargetMachine * target_machine =nullptr )","title":"function Validator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-validator_1","text":"Validator()","title":"function Validator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-validator_2","text":"Validator( Validator const & )","title":"function Validator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-validator_3","text":"Validator( Validator && ) =default","title":"function Validator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-operator","text":"Validator & operator=( Validator const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-operator_1","text":"Validator & operator=( Validator && ) =default","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-validator_4","text":"~Validator() =default","title":"function ~Validator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-validate","text":"bool validate( llvm::Module & module ) Validates that a module complies with the specified QIR profile. Returns true if the module is valid and false otherwize.","title":"function validate"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-logger","text":"LogColloectionPtr logger() const Returns the logger. This value may be null if no logger was set.","title":"function logger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-passbuilder","text":"llvm::PassBuilder & passBuilder() Returns a reference to the pass builder.","title":"function passBuilder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-loopanalysismanager","text":"llvm::LoopAnalysisManager & loopAnalysisManager() Returns a reference to the loop analysis manager.","title":"function loopAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-functionanalysismanager","text":"llvm::FunctionAnalysisManager & functionAnalysisManager() Returns a reference to the function analysis manager.","title":"function functionAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-gsccanalysismanager","text":"llvm::CGSCCAnalysisManager & gsccAnalysisManager() Returns a reference to the GSCC analysis manager.","title":"function gsccAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-moduleanalysismanager","text":"llvm::ModuleAnalysisManager & moduleAnalysisManager() Returns a reference to the module analysis manager. Updated on 22 March 2022 at 08:31:22 UTC","title":"function moduleAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture/","text":"microsoft::quantum::notation::Capture More... #include <Rules/Notation/Notation.hpp> Public Functions Name Capture (std::string const & name) Explicit creation using string name constructor. IOperandPrototypePtr operator= (IOperandPrototypePtr const & other) Detailed Description class microsoft::quantum::notation::Capture; Helper class to enable literals for IR patterns. The main purpose of this class is to enable notation that allows one write \"name\"_cap = operandGenerator() where the operand generator is a function which creates a IOperandPrototypePtr. This notation means that whenever a operand is matched, the matched value is stored under \"name\". Public Functions Documentation function Capture explicit Capture( std::string const & name ) Explicit creation using string name constructor. function operator= IOperandPrototypePtr operator=( IOperandPrototypePtr const & other ) Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::notation::Capture"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture/#microsoftquantumnotationcapture","text":"More... #include <Rules/Notation/Notation.hpp>","title":"microsoft::quantum::notation::Capture"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture/#public-functions","text":"Name Capture (std::string const & name) Explicit creation using string name constructor. IOperandPrototypePtr operator= (IOperandPrototypePtr const & other)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture/#detailed-description","text":"class microsoft::quantum::notation::Capture; Helper class to enable literals for IR patterns. The main purpose of this class is to enable notation that allows one write \"name\"_cap = operandGenerator() where the operand generator is a function which creates a IOperandPrototypePtr. This notation means that whenever a operand is matched, the matched value is stored under \"name\".","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture/#function-capture","text":"explicit Capture( std::string const & name ) Explicit creation using string name constructor.","title":"function Capture"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture/#function-operator","text":"IOperandPrototypePtr operator=( IOperandPrototypePtr const & other ) Updated on 22 March 2022 at 08:31:22 UTC","title":"function operator="},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/","text":"microsoft::quantum::BasicAllocationManager::AllocatedMemoryBlock More... #include <AllocationManager/AllocationManager.hpp> Public Attributes Name String name Name of the segment, if any given. Index count Number of elements contained within memory address segment. Address start Start address of memory address segment. Address end End address (not included in memory address segment) Detailed Description struct microsoft::quantum::BasicAllocationManager::AllocatedMemoryBlock; Defines a named register/memory address segment with start position, end position and count. We think of the address space as a continuous sequence of spaces that can store values and we refer to a bounded continuous sequence memory addresses as a segment (or memory address segment): start end \u2502 \u2502 \u25bc \u25bc \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u250c \u2500 \u2500 \u252c \u2500 \u2500 \u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u253c \u2500 \u2500 \u252c \u2500 \u2500 \u2510 0 1 \u2502 2 \u2502 3 \u2502... \u2502 N+1 \u2502 N+2 N+3 \u2514 \u2500 \u2500 \u2534 \u2500 \u2500 \u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2534 \u2500 \u2500 \u2534 \u2500 \u2500 \u2518 Address \u2502 space \u2502 Memory address segment of N elements \u2502 \u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 Public Attributes Documentation variable name String name {\"\"}; Name of the segment, if any given. variable count Index count {0}; Number of elements contained within memory address segment. variable start Address start {0}; Start address of memory address segment. variable end Address end {0}; End address (not included in memory address segment) Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::BasicAllocationManager::AllocatedMemoryBlock"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#microsoftquantumbasicallocationmanagerallocatedmemoryblock","text":"More... #include <AllocationManager/AllocationManager.hpp>","title":"microsoft::quantum::BasicAllocationManager::AllocatedMemoryBlock"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#public-attributes","text":"Name String name Name of the segment, if any given. Index count Number of elements contained within memory address segment. Address start Start address of memory address segment. Address end End address (not included in memory address segment)","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#detailed-description","text":"struct microsoft::quantum::BasicAllocationManager::AllocatedMemoryBlock; Defines a named register/memory address segment with start position, end position and count. We think of the address space as a continuous sequence of spaces that can store values and we refer to a bounded continuous sequence memory addresses as a segment (or memory address segment): start end \u2502 \u2502 \u25bc \u25bc \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u250c \u2500 \u2500 \u252c \u2500 \u2500 \u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u253c \u2500 \u2500 \u252c \u2500 \u2500 \u2510 0 1 \u2502 2 \u2502 3 \u2502... \u2502 N+1 \u2502 N+2 N+3 \u2514 \u2500 \u2500 \u2534 \u2500 \u2500 \u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2534 \u2500 \u2500 \u2534 \u2500 \u2500 \u2518 Address \u2502 space \u2502 Memory address segment of N elements \u2502 \u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500","title":"Detailed Description"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#variable-name","text":"String name {\"\"}; Name of the segment, if any given.","title":"variable name"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#variable-count","text":"Index count {0}; Number of elements contained within memory address segment.","title":"variable count"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#variable-start","text":"Address start {0}; Start address of memory address segment.","title":"variable start"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#variable-end","text":"Address end {0}; End address (not included in memory address segment) Updated on 22 March 2022 at 08:31:22 UTC","title":"variable end"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/","text":"microsoft::quantum::ConfigurationManager::Section More... #include <Commandline/ConfigurationManager.hpp> Public Attributes Name TypeId type Type of the configuration. String name Name of the section. String description Description of the section. bool enabled_by_default Whether or not this section is enabled by default. VoidPtr configuration Configuration class instance. ConfigList settings List of parameter bindings. BoolPtr active Whether or not this component is active;. String id Id referring to this component. Detailed Description struct microsoft::quantum::ConfigurationManager::Section; Section defines a section in the configuration. It holds the type of the configuration class, the name of the section a description, the instance of the configuration class itself and list of parameter bindings. Public Attributes Documentation variable type TypeId type {[TypeId](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-typeid)(typeid(std::nullptr_t))}; Type of the configuration. variable name String name {}; Name of the section. variable description String description {}; Description of the section. variable enabled_by_default bool enabled_by_default {true}; Whether or not this section is enabled by default. variable configuration VoidPtr configuration {}; Configuration class instance. variable settings ConfigList settings {}; List of parameter bindings. variable active BoolPtr active {nullptr}; Whether or not this component is active;. variable id String id {}; Id referring to this component. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::ConfigurationManager::Section"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#microsoftquantumconfigurationmanagersection","text":"More... #include <Commandline/ConfigurationManager.hpp>","title":"microsoft::quantum::ConfigurationManager::Section"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#public-attributes","text":"Name TypeId type Type of the configuration. String name Name of the section. String description Description of the section. bool enabled_by_default Whether or not this section is enabled by default. VoidPtr configuration Configuration class instance. ConfigList settings List of parameter bindings. BoolPtr active Whether or not this component is active;. String id Id referring to this component.","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#detailed-description","text":"struct microsoft::quantum::ConfigurationManager::Section; Section defines a section in the configuration. It holds the type of the configuration class, the name of the section a description, the instance of the configuration class itself and list of parameter bindings.","title":"Detailed Description"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-type","text":"TypeId type {[TypeId](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-typeid)(typeid(std::nullptr_t))}; Type of the configuration.","title":"variable type"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-name","text":"String name {}; Name of the section.","title":"variable name"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-description","text":"String description {}; Description of the section.","title":"variable description"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-enabled_by_default","text":"bool enabled_by_default {true}; Whether or not this section is enabled by default.","title":"variable enabled_by_default"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-configuration","text":"VoidPtr configuration {}; Configuration class instance.","title":"variable configuration"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-settings","text":"ConfigList settings {}; List of parameter bindings.","title":"variable settings"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-active","text":"BoolPtr active {nullptr}; Whether or not this component is active;.","title":"variable active"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-id","text":"String id {}; Id referring to this component. Updated on 22 March 2022 at 08:31:22 UTC","title":"variable id"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_group_analysis/","text":"microsoft::quantum::GroupAnalysis Public Types Name using std::vector< llvm::BasicBlock * > BlockList Public Attributes Name BlockList qc_cc_blocks BlockList qc_mc_cc_blocks Public Types Documentation using BlockList using microsoft::quantum::GroupAnalysis::BlockList = std::vector<llvm::BasicBlock*>; Public Attributes Documentation variable qc_cc_blocks BlockList qc_cc_blocks {}; variable qc_mc_cc_blocks BlockList qc_mc_cc_blocks {}; Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::GroupAnalysis"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_group_analysis/#microsoftquantumgroupanalysis","text":"","title":"microsoft::quantum::GroupAnalysis"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_group_analysis/#public-types","text":"Name using std::vector< llvm::BasicBlock * > BlockList","title":"Public Types"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_group_analysis/#public-attributes","text":"Name BlockList qc_cc_blocks BlockList qc_mc_cc_blocks","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_group_analysis/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_group_analysis/#using-blocklist","text":"using microsoft::quantum::GroupAnalysis::BlockList = std::vector<llvm::BasicBlock*>;","title":"using BlockList"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_group_analysis/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_group_analysis/#variable-qc_cc_blocks","text":"BlockList qc_cc_blocks {};","title":"variable qc_cc_blocks"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_group_analysis/#variable-qc_mc_cc_blocks","text":"BlockList qc_mc_cc_blocks {}; Updated on 22 March 2022 at 08:31:22 UTC","title":"variable qc_mc_cc_blocks"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_location/","text":"microsoft::quantum::LogCollection::Location Class that holds the location of where the incident happened. #include <Logging/LogCollection.hpp> Public Attributes Name String name uint64_t row uint64_t col String llvm_hint String frontend_hint Public Attributes Documentation variable name String name {}; variable row uint64_t row {0}; variable col uint64_t col {0}; variable llvm_hint String llvm_hint; variable frontend_hint String frontend_hint; Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::LogCollection::Location"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_location/#microsoftquantumlogcollectionlocation","text":"Class that holds the location of where the incident happened. #include <Logging/LogCollection.hpp>","title":"microsoft::quantum::LogCollection::Location"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_location/#public-attributes","text":"Name String name uint64_t row uint64_t col String llvm_hint String frontend_hint","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_location/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_location/#variable-name","text":"String name {};","title":"variable name"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_location/#variable-row","text":"uint64_t row {0};","title":"variable row"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_location/#variable-col","text":"uint64_t col {0};","title":"variable col"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_location/#variable-llvm_hint","text":"String llvm_hint;","title":"variable llvm_hint"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_location/#variable-frontend_hint","text":"String frontend_hint; Updated on 22 March 2022 at 08:31:22 UTC","title":"variable frontend_hint"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_message/","text":"microsoft::quantum::LogCollection::Message Struct to hold a message together with its type and location. #include <Logging/LogCollection.hpp> Public Attributes Name Type type Location location String message Public Attributes Documentation variable type Type type; variable location Location location; variable message String message; Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::LogCollection::Message"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_message/#microsoftquantumlogcollectionmessage","text":"Struct to hold a message together with its type and location. #include <Logging/LogCollection.hpp>","title":"microsoft::quantum::LogCollection::Message"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_message/#public-attributes","text":"Name Type type Location location String message","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_message/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_message/#variable-type","text":"Type type;","title":"variable type"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_message/#variable-location","text":"Location location;","title":"variable location"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_message/#variable-message","text":"String message; Updated on 22 March 2022 at 08:31:22 UTC","title":"variable message"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_parameter_parser_1_1_parsed_value/","text":"microsoft::quantum::ParameterParser::ParsedValue Struct that contains parsed and interpreted values of command line arguments. Public Attributes Name bool is_key Whether or not a parsed value should be considered a key. String value Value after parsing. Public Attributes Documentation variable is_key bool is_key {false}; Whether or not a parsed value should be considered a key. variable value String value; Value after parsing. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::ParameterParser::ParsedValue"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_parameter_parser_1_1_parsed_value/#microsoftquantumparameterparserparsedvalue","text":"Struct that contains parsed and interpreted values of command line arguments.","title":"microsoft::quantum::ParameterParser::ParsedValue"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_parameter_parser_1_1_parsed_value/#public-attributes","text":"Name bool is_key Whether or not a parsed value should be considered a key. String value Value after parsing.","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_parameter_parser_1_1_parsed_value/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_parameter_parser_1_1_parsed_value/#variable-is_key","text":"bool is_key {false}; Whether or not a parsed value should be considered a key.","title":"variable is_key"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_parameter_parser_1_1_parsed_value/#variable-value","text":"String value; Value after parsing. Updated on 22 March 2022 at 08:31:22 UTC","title":"variable value"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_validation_pass_1_1_location/","text":"microsoft::quantum::ValidationPass::Location Public Attributes Name String filename uint64_t row uint64_t col String llvm_hint Public Attributes Documentation variable filename String filename {\"\"}; variable row uint64_t row {0}; variable col uint64_t col {0}; variable llvm_hint String llvm_hint {\"\"}; Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::ValidationPass::Location"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_validation_pass_1_1_location/#microsoftquantumvalidationpasslocation","text":"","title":"microsoft::quantum::ValidationPass::Location"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_validation_pass_1_1_location/#public-attributes","text":"Name String filename uint64_t row uint64_t col String llvm_hint","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_validation_pass_1_1_location/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_validation_pass_1_1_location/#variable-filename","text":"String filename {\"\"};","title":"variable filename"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_validation_pass_1_1_location/#variable-row","text":"uint64_t row {0};","title":"variable row"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_validation_pass_1_1_location/#variable-col","text":"uint64_t col {0};","title":"variable col"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_validation_pass_1_1_location/#variable-llvm_hint","text":"String llvm_hint {\"\"}; Updated on 22 March 2022 at 08:31:22 UTC","title":"variable llvm_hint"},{"location":"Api/Examples/","text":"Examples Updated on 22 March 2022 at 08:31:22 UTC","title":"Examples"},{"location":"Api/Examples/#examples","text":"Updated on 22 March 2022 at 08:31:22 UTC","title":"Examples"},{"location":"Api/Files/","text":"Files dir AllocationManager file AllocationManager/AllocationManager.cpp file AllocationManager/AllocationManager.hpp file AllocationManager/IAllocationManager.cpp file AllocationManager/IAllocationManager.hpp dir Commandline file Commandline/ConfigBind.hpp file Commandline/ConfigurationManager.cpp file Commandline/ConfigurationManager.hpp file Commandline/IConfigBind.cpp file Commandline/IConfigBind.hpp file Commandline/ParameterParser.cpp file Commandline/ParameterParser.hpp dir Generators file Generators/ConfigurableProfileGenerator.cpp file Generators/ConfigurableProfileGenerator.hpp file Generators/LlvmPassesConfiguration.cpp file Generators/LlvmPassesConfiguration.hpp file Generators/ProfileGenerator.cpp file Generators/ProfileGenerator.hpp dir GroupingPass file GroupingPass/GroupingAnalysisPass.cpp file GroupingPass/GroupingAnalysisPass.hpp file GroupingPass/GroupingPass.cpp file GroupingPass/GroupingPass.hpp file GroupingPass/GroupingPassConfiguration.hpp dir Logging file Logging/CommentLogger.cpp file Logging/CommentLogger.hpp file Logging/ILogger.cpp file Logging/ILogger.hpp file Logging/LogCollection.cpp file Logging/LogCollection.hpp dir ModuleLoader file ModuleLoader/ModuleLoader.hpp dir Profile file Profile/Profile.cpp file Profile/Profile.hpp dir QatTypes file QatTypes/QatTypes.hpp dir RemoveDisallowedAttributesPass file RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp dir Rules file Rules/Factory.cpp file Rules/Factory.hpp file Rules/FactoryConfig.hpp file Rules/IOperandPrototype.cpp file Rules/IOperandPrototype.hpp file Rules/ReplacementRule.cpp file Rules/ReplacementRule.hpp file Rules/RuleSet.cpp file Rules/RuleSet.hpp dir Rules/Notation file Rules/Notation/BasicBlock.cpp file Rules/Notation/BitCast.cpp file Rules/Notation/Branch.cpp file Rules/Notation/Call.hpp file Rules/Notation/Call.ipp file Rules/Notation/CallByNameOnly.cpp file Rules/Notation/Capture.cpp file Rules/Notation/ConstInt.cpp file Rules/Notation/IntToPtr.cpp file Rules/Notation/Load.cpp file Rules/Notation/Notation.cpp file Rules/Notation/Notation.hpp file Rules/Notation/Phi.ipp file Rules/Notation/Select.cpp file Rules/Notation/Store.cpp file Rules/Notation/Switch.cpp file Rules/Notation/UnnamedInvoke.cpp dir Rules/Patterns file Rules/Patterns/AnyPattern.cpp file Rules/Patterns/AnyPattern.hpp file Rules/Patterns/CallPattern.cpp file Rules/Patterns/CallPattern.hpp file Rules/Patterns/Instruction.cpp file Rules/Patterns/Instruction.hpp file Rules/Patterns/PhiPattern.cpp file Rules/Patterns/PhiPattern.hpp file Rules/Patterns/UnnamedInvokePattern.cpp file Rules/Patterns/UnnamedInvokePattern.hpp dir TestTools file TestTools/IrManipulationTestHelper.cpp file TestTools/IrManipulationTestHelper.hpp dir TransformationRulesPass file TransformationRulesPass/TransformationRulesPass.cpp file TransformationRulesPass/TransformationRulesPass.hpp file TransformationRulesPass/TransformationRulesPassConfiguration.cpp file TransformationRulesPass/TransformationRulesPassConfiguration.hpp dir Utils file Utils/Trim.hpp dir ValidationPass file ValidationPass/ValidationPass.cpp file ValidationPass/ValidationPass.hpp file ValidationPass/ValidationPassConfiguration.cpp file ValidationPass/ValidationPassConfiguration.hpp dir Validator file Validator/Validator.cpp file Validator/Validator.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Files"},{"location":"Api/Files/#files","text":"dir AllocationManager file AllocationManager/AllocationManager.cpp file AllocationManager/AllocationManager.hpp file AllocationManager/IAllocationManager.cpp file AllocationManager/IAllocationManager.hpp dir Commandline file Commandline/ConfigBind.hpp file Commandline/ConfigurationManager.cpp file Commandline/ConfigurationManager.hpp file Commandline/IConfigBind.cpp file Commandline/IConfigBind.hpp file Commandline/ParameterParser.cpp file Commandline/ParameterParser.hpp dir Generators file Generators/ConfigurableProfileGenerator.cpp file Generators/ConfigurableProfileGenerator.hpp file Generators/LlvmPassesConfiguration.cpp file Generators/LlvmPassesConfiguration.hpp file Generators/ProfileGenerator.cpp file Generators/ProfileGenerator.hpp dir GroupingPass file GroupingPass/GroupingAnalysisPass.cpp file GroupingPass/GroupingAnalysisPass.hpp file GroupingPass/GroupingPass.cpp file GroupingPass/GroupingPass.hpp file GroupingPass/GroupingPassConfiguration.hpp dir Logging file Logging/CommentLogger.cpp file Logging/CommentLogger.hpp file Logging/ILogger.cpp file Logging/ILogger.hpp file Logging/LogCollection.cpp file Logging/LogCollection.hpp dir ModuleLoader file ModuleLoader/ModuleLoader.hpp dir Profile file Profile/Profile.cpp file Profile/Profile.hpp dir QatTypes file QatTypes/QatTypes.hpp dir RemoveDisallowedAttributesPass file RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp dir Rules file Rules/Factory.cpp file Rules/Factory.hpp file Rules/FactoryConfig.hpp file Rules/IOperandPrototype.cpp file Rules/IOperandPrototype.hpp file Rules/ReplacementRule.cpp file Rules/ReplacementRule.hpp file Rules/RuleSet.cpp file Rules/RuleSet.hpp dir Rules/Notation file Rules/Notation/BasicBlock.cpp file Rules/Notation/BitCast.cpp file Rules/Notation/Branch.cpp file Rules/Notation/Call.hpp file Rules/Notation/Call.ipp file Rules/Notation/CallByNameOnly.cpp file Rules/Notation/Capture.cpp file Rules/Notation/ConstInt.cpp file Rules/Notation/IntToPtr.cpp file Rules/Notation/Load.cpp file Rules/Notation/Notation.cpp file Rules/Notation/Notation.hpp file Rules/Notation/Phi.ipp file Rules/Notation/Select.cpp file Rules/Notation/Store.cpp file Rules/Notation/Switch.cpp file Rules/Notation/UnnamedInvoke.cpp dir Rules/Patterns file Rules/Patterns/AnyPattern.cpp file Rules/Patterns/AnyPattern.hpp file Rules/Patterns/CallPattern.cpp file Rules/Patterns/CallPattern.hpp file Rules/Patterns/Instruction.cpp file Rules/Patterns/Instruction.hpp file Rules/Patterns/PhiPattern.cpp file Rules/Patterns/PhiPattern.hpp file Rules/Patterns/UnnamedInvokePattern.cpp file Rules/Patterns/UnnamedInvokePattern.hpp dir TestTools file TestTools/IrManipulationTestHelper.cpp file TestTools/IrManipulationTestHelper.hpp dir TransformationRulesPass file TransformationRulesPass/TransformationRulesPass.cpp file TransformationRulesPass/TransformationRulesPass.hpp file TransformationRulesPass/TransformationRulesPassConfiguration.cpp file TransformationRulesPass/TransformationRulesPassConfiguration.hpp dir Utils file Utils/Trim.hpp dir ValidationPass file ValidationPass/ValidationPass.cpp file ValidationPass/ValidationPass.hpp file ValidationPass/ValidationPassConfiguration.cpp file ValidationPass/ValidationPassConfiguration.hpp dir Validator file Validator/Validator.cpp file Validator/Validator.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Files"},{"location":"Api/Files/_allocation_manager_8cpp/","text":"AllocationManager/AllocationManager.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/AllocationManager.hpp\" #include <memory> #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { BasicAllocationManager::BasicAllocationManagerPtr BasicAllocationManager::createNew() { BasicAllocationManagerPtr ret; ret.reset(new BasicAllocationManager()); return ret; } BasicAllocationManager::Index BasicAllocationManager::allocate(String const& name, Index const& count) { auto ret = next_qubit_index_; // Creating a memory segment mapping in case we are dealing with qubits AllocatedMemoryBlock map; map.name = name; map.count = count; map.start = next_qubit_index_; // Advancing start next_qubit_index_ += count; map.end = map.start + count; mappings_.emplace_back(std::move(map)); // Advancing the allocation index ++allocation_index_; updateRegistersInUse(allocationsInUse() + count); return ret; } void BasicAllocationManager::release(Address const& address) { --allocation_index_; auto it = mappings_.begin(); // Finding the element. Note that we could implement binary // search but assume that we are dealing with few allocations while (it != mappings_.end() && it->start != address) { ++it; } if (it == mappings_.end()) { throw std::runtime_error(\"Qubit segment not found.\"); } if (!reuse_qubits_) { mappings_.erase(it); } else { if (it->count > allocationsInUse()) { throw std::runtime_error(\"Attempting to release more qubits than what is currently allocated.\"); } // In case we are reusing registers, we update how many we are currently using updateRegistersInUse(allocationsInUse() - it->count); mappings_.erase(it); // Updating the next qubit index with naive algorithm that guarantees // 1. Continuous allocation // 2. No overlap in address if (mappings_.empty()) { next_qubit_index_ = 0; } else { auto& b = mappings_.back(); next_qubit_index_ = b.end; } } } void BasicAllocationManager::setReuseRegisters(bool val) { reuse_qubits_ = val; } void BasicAllocationManager::reset() { updateRegistersInUse(0); mappings_.clear(); allocation_index_ = 0; next_qubit_index_ = 0; } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"AllocationManager/AllocationManager.cpp"},{"location":"Api/Files/_allocation_manager_8cpp/#allocationmanagerallocationmanagercpp","text":"","title":"AllocationManager/AllocationManager.cpp"},{"location":"Api/Files/_allocation_manager_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_allocation_manager_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/AllocationManager.hpp\" #include <memory> #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { BasicAllocationManager::BasicAllocationManagerPtr BasicAllocationManager::createNew() { BasicAllocationManagerPtr ret; ret.reset(new BasicAllocationManager()); return ret; } BasicAllocationManager::Index BasicAllocationManager::allocate(String const& name, Index const& count) { auto ret = next_qubit_index_; // Creating a memory segment mapping in case we are dealing with qubits AllocatedMemoryBlock map; map.name = name; map.count = count; map.start = next_qubit_index_; // Advancing start next_qubit_index_ += count; map.end = map.start + count; mappings_.emplace_back(std::move(map)); // Advancing the allocation index ++allocation_index_; updateRegistersInUse(allocationsInUse() + count); return ret; } void BasicAllocationManager::release(Address const& address) { --allocation_index_; auto it = mappings_.begin(); // Finding the element. Note that we could implement binary // search but assume that we are dealing with few allocations while (it != mappings_.end() && it->start != address) { ++it; } if (it == mappings_.end()) { throw std::runtime_error(\"Qubit segment not found.\"); } if (!reuse_qubits_) { mappings_.erase(it); } else { if (it->count > allocationsInUse()) { throw std::runtime_error(\"Attempting to release more qubits than what is currently allocated.\"); } // In case we are reusing registers, we update how many we are currently using updateRegistersInUse(allocationsInUse() - it->count); mappings_.erase(it); // Updating the next qubit index with naive algorithm that guarantees // 1. Continuous allocation // 2. No overlap in address if (mappings_.empty()) { next_qubit_index_ = 0; } else { auto& b = mappings_.back(); next_qubit_index_ = b.end; } } } void BasicAllocationManager::setReuseRegisters(bool val) { reuse_qubits_ = val; } void BasicAllocationManager::reset() { updateRegistersInUse(0); mappings_.clear(); allocation_index_ = 0; next_qubit_index_ = 0; } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_allocation_manager_8hpp/","text":"AllocationManager/AllocationManager.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::BasicAllocationManager struct microsoft::quantum::BasicAllocationManager::AllocatedMemoryBlock Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/IAllocationManager.hpp\" #include \"Llvm/Llvm.hpp\" #include <memory> #include <string> #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class BasicAllocationManager : public IAllocationManager { public: struct AllocatedMemoryBlock { String name{\"\"}; Index count{0}; Address start{0}; Address end{0}; }; using Mappings = std::vector<AllocatedMemoryBlock>; using BasicAllocationManagerPtr = std::shared_ptr<BasicAllocationManager>; // Construction only allowed using smart pointer allocation through static functions. // Constructors are private to prevent // static BasicAllocationManagerPtr createNew(); // Allocation and release functions // Address allocate(String const& name = \"\", Index const& count = 1) override; void release(Address const& address) override; void reset() override; void setReuseRegisters(bool val); private: // Private constructors // BasicAllocationManager() = default; Index next_qubit_index_{0}; // Memory mapping // Mappings mappings_{}; Index allocation_index_{0}; // Configuration // bool reuse_qubits_{true}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"AllocationManager/AllocationManager.hpp"},{"location":"Api/Files/_allocation_manager_8hpp/#allocationmanagerallocationmanagerhpp","text":"","title":"AllocationManager/AllocationManager.hpp"},{"location":"Api/Files/_allocation_manager_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_allocation_manager_8hpp/#classes","text":"Name class microsoft::quantum::BasicAllocationManager struct microsoft::quantum::BasicAllocationManager::AllocatedMemoryBlock","title":"Classes"},{"location":"Api/Files/_allocation_manager_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/IAllocationManager.hpp\" #include \"Llvm/Llvm.hpp\" #include <memory> #include <string> #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class BasicAllocationManager : public IAllocationManager { public: struct AllocatedMemoryBlock { String name{\"\"}; Index count{0}; Address start{0}; Address end{0}; }; using Mappings = std::vector<AllocatedMemoryBlock>; using BasicAllocationManagerPtr = std::shared_ptr<BasicAllocationManager>; // Construction only allowed using smart pointer allocation through static functions. // Constructors are private to prevent // static BasicAllocationManagerPtr createNew(); // Allocation and release functions // Address allocate(String const& name = \"\", Index const& count = 1) override; void release(Address const& address) override; void reset() override; void setReuseRegisters(bool val); private: // Private constructors // BasicAllocationManager() = default; Index next_qubit_index_{0}; // Memory mapping // Mappings mappings_{}; Index allocation_index_{0}; // Configuration // bool reuse_qubits_{true}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_any_pattern_8cpp/","text":"Rules/Patterns/AnyPattern.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" namespace microsoft { namespace quantum { AnyPattern::AnyPattern() = default; AnyPattern::~AnyPattern() = default; bool AnyPattern::match(Value* instr, Captures& captures) const { return success(instr, captures); } AnyPattern::Child AnyPattern::copy() const { return std::make_shared<AnyPattern>(); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Patterns/AnyPattern.cpp"},{"location":"Api/Files/_any_pattern_8cpp/#rulespatternsanypatterncpp","text":"","title":"Rules/Patterns/AnyPattern.cpp"},{"location":"Api/Files/_any_pattern_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_any_pattern_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" namespace microsoft { namespace quantum { AnyPattern::AnyPattern() = default; AnyPattern::~AnyPattern() = default; bool AnyPattern::match(Value* instr, Captures& captures) const { return success(instr, captures); } AnyPattern::Child AnyPattern::copy() const { return std::make_shared<AnyPattern>(); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_any_pattern_8hpp/","text":"Rules/Patterns/AnyPattern.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::AnyPattern Pattern that matches any operand. Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class AnyPattern : public IOperandPrototype { public: // Constructors. // AnyPattern(); ~AnyPattern() override; // \"Any\" implementation of the member functions in IOperandPrototype. bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Patterns/AnyPattern.hpp"},{"location":"Api/Files/_any_pattern_8hpp/#rulespatternsanypatternhpp","text":"","title":"Rules/Patterns/AnyPattern.hpp"},{"location":"Api/Files/_any_pattern_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_any_pattern_8hpp/#classes","text":"Name class microsoft::quantum::AnyPattern Pattern that matches any operand.","title":"Classes"},{"location":"Api/Files/_any_pattern_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class AnyPattern : public IOperandPrototype { public: // Constructors. // AnyPattern(); ~AnyPattern() override; // \"Any\" implementation of the member functions in IOperandPrototype. bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_basic_block_8cpp/","text":"Rules/Notation/BasicBlock.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr basicBlock() { auto ret = std::make_shared<BasicBlockPattern>(); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Notation/BasicBlock.cpp"},{"location":"Api/Files/_basic_block_8cpp/#rulesnotationbasicblockcpp","text":"","title":"Rules/Notation/BasicBlock.cpp"},{"location":"Api/Files/_basic_block_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_basic_block_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr basicBlock() { auto ret = std::make_shared<BasicBlockPattern>(); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_bit_cast_8cpp/","text":"Rules/Notation/BitCast.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr bitCast(IOperandPrototypePtr const& arg) { auto cast_pattern = std::make_shared<BitCastPattern>(); cast_pattern->addChild(arg); return static_cast<IOperandPrototypePtr>(cast_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Notation/BitCast.cpp"},{"location":"Api/Files/_bit_cast_8cpp/#rulesnotationbitcastcpp","text":"","title":"Rules/Notation/BitCast.cpp"},{"location":"Api/Files/_bit_cast_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_bit_cast_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr bitCast(IOperandPrototypePtr const& arg) { auto cast_pattern = std::make_shared<BitCastPattern>(); cast_pattern->addChild(arg); return static_cast<IOperandPrototypePtr>(cast_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_branch_8cpp/","text":"Rules/Notation/Branch.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr branch( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2) { auto branch_pattern = std::make_shared<BranchPattern>(); branch_pattern->addChild(cond); branch_pattern->addChild(arg1); branch_pattern->addChild(arg2); return static_cast<IOperandPrototypePtr>(branch_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Notation/Branch.cpp"},{"location":"Api/Files/_branch_8cpp/#rulesnotationbranchcpp","text":"","title":"Rules/Notation/Branch.cpp"},{"location":"Api/Files/_branch_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_branch_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr branch( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2) { auto branch_pattern = std::make_shared<BranchPattern>(); branch_pattern->addChild(cond); branch_pattern->addChild(arg1); branch_pattern->addChild(arg2); return static_cast<IOperandPrototypePtr>(branch_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_call_8hpp/","text":"Rules/Notation/Call.hpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; template <typename... Args> IOperandPrototypePtr call(std::string const& name, Args... args); } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Notation/Call.hpp"},{"location":"Api/Files/_call_8hpp/#rulesnotationcallhpp","text":"","title":"Rules/Notation/Call.hpp"},{"location":"Api/Files/_call_8hpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_call_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; template <typename... Args> IOperandPrototypePtr call(std::string const& name, Args... args); } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_call_8ipp/","text":"Rules/Notation/Call.ipp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Llvm/Llvm.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; template <typename... Args> IOperandPrototypePtr call(std::string const &name, Args... args) { IOperandPrototypePtr ret = std::make_shared<CallPattern>(name); std::vector<IOperandPrototypePtr> arguments{args...}; // Adding arguments to matching for (auto &a : arguments) { ret->addChild(a); } // Function name is kept in the last operand ret->addChild(std::make_shared<AnyPattern>()); return ret; } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Notation/Call.ipp"},{"location":"Api/Files/_call_8ipp/#rulesnotationcallipp","text":"","title":"Rules/Notation/Call.ipp"},{"location":"Api/Files/_call_8ipp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_call_8ipp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Llvm/Llvm.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; template <typename... Args> IOperandPrototypePtr call(std::string const &name, Args... args) { IOperandPrototypePtr ret = std::make_shared<CallPattern>(name); std::vector<IOperandPrototypePtr> arguments{args...}; // Adding arguments to matching for (auto &a : arguments) { ret->addChild(a); } // Function name is kept in the last operand ret->addChild(std::make_shared<AnyPattern>()); return ret; } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_call_by_name_only_8cpp/","text":"Rules/Notation/CallByNameOnly.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr callByNameOnly(std::string const& name) { IOperandPrototypePtr ret = std::make_shared<CallPattern>(name); return ret; } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Notation/CallByNameOnly.cpp"},{"location":"Api/Files/_call_by_name_only_8cpp/#rulesnotationcallbynameonlycpp","text":"","title":"Rules/Notation/CallByNameOnly.cpp"},{"location":"Api/Files/_call_by_name_only_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_call_by_name_only_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr callByNameOnly(std::string const& name) { IOperandPrototypePtr ret = std::make_shared<CallPattern>(name); return ret; } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_call_pattern_8cpp/","text":"Rules/Patterns/CallPattern.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" namespace microsoft { namespace quantum { CallPattern::CallPattern(String const& name) : name_{name} { } CallPattern::~CallPattern() = default; bool CallPattern::match(Value* instr, Captures& captures) const { auto* call_instr = llvm::dyn_cast<llvm::CallBase>(instr); if (call_instr == nullptr) { return fail(instr, captures); } auto target_function = call_instr->getCalledFunction(); if (target_function == nullptr) { return fail(instr, captures); } auto name = target_function->getName(); if (name != name_) { return fail(instr, captures); } auto ret = success(instr, captures); return ret; } CallPattern::Child CallPattern::copy() const { auto ret = std::make_shared<CallPattern>(name_); ret->copyPropertiesFrom(*this); return std::move(ret); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Patterns/CallPattern.cpp"},{"location":"Api/Files/_call_pattern_8cpp/#rulespatternscallpatterncpp","text":"","title":"Rules/Patterns/CallPattern.cpp"},{"location":"Api/Files/_call_pattern_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_call_pattern_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" namespace microsoft { namespace quantum { CallPattern::CallPattern(String const& name) : name_{name} { } CallPattern::~CallPattern() = default; bool CallPattern::match(Value* instr, Captures& captures) const { auto* call_instr = llvm::dyn_cast<llvm::CallBase>(instr); if (call_instr == nullptr) { return fail(instr, captures); } auto target_function = call_instr->getCalledFunction(); if (target_function == nullptr) { return fail(instr, captures); } auto name = target_function->getName(); if (name != name_) { return fail(instr, captures); } auto ret = success(instr, captures); return ret; } CallPattern::Child CallPattern::copy() const { auto ret = std::make_shared<CallPattern>(name_); ret->copyPropertiesFrom(*this); return std::move(ret); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_call_pattern_8hpp/","text":"Rules/Patterns/CallPattern.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::CallPattern Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class CallPattern : public IOperandPrototype { public: using String = std::string; // Construction of the call pattern by name or move only. // explicit CallPattern(String const& name); CallPattern(CallPattern const& other) = delete; CallPattern(CallPattern&& other) = default; ~CallPattern() override; // Call implmenetation of the member functions in IOperandPrototype. // bool match(Value* instr, Captures& captures) const override; Child copy() const override; private: String name_{}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Patterns/CallPattern.hpp"},{"location":"Api/Files/_call_pattern_8hpp/#rulespatternscallpatternhpp","text":"","title":"Rules/Patterns/CallPattern.hpp"},{"location":"Api/Files/_call_pattern_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_call_pattern_8hpp/#classes","text":"Name class microsoft::quantum::CallPattern","title":"Classes"},{"location":"Api/Files/_call_pattern_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class CallPattern : public IOperandPrototype { public: using String = std::string; // Construction of the call pattern by name or move only. // explicit CallPattern(String const& name); CallPattern(CallPattern const& other) = delete; CallPattern(CallPattern&& other) = default; ~CallPattern() override; // Call implmenetation of the member functions in IOperandPrototype. // bool match(Value* instr, Captures& captures) const override; Child copy() const override; private: String name_{}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_capture_8cpp/","text":"Rules/Notation/Capture.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; Capture::Capture(std::string const& name) : name_{name} { } IOperandPrototypePtr Capture::operator=(IOperandPrototypePtr const& other) // NOLINT { auto ret = other->copy(); ret->captureAs(name_); return ret; } Capture operator\"\"_cap(char const* name, std::size_t) { return Capture(name); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Notation/Capture.cpp"},{"location":"Api/Files/_capture_8cpp/#rulesnotationcapturecpp","text":"","title":"Rules/Notation/Capture.cpp"},{"location":"Api/Files/_capture_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_capture_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; Capture::Capture(std::string const& name) : name_{name} { } IOperandPrototypePtr Capture::operator=(IOperandPrototypePtr const& other) // NOLINT { auto ret = other->copy(); ret->captureAs(name_); return ret; } Capture operator\"\"_cap(char const* name, std::size_t) { return Capture(name); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_comment_logger_8cpp/","text":"Logging/CommentLogger.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/CommentLogger.hpp\" #include \"Llvm/Llvm.hpp\" #include <vector> namespace microsoft { namespace quantum { void CommentLogger::debug(String const& message) { llvm::errs() << \"debug - \" << location_name_ << \":\" << location_row_ << \",\" << location_col_ << \" - \" << message << \"\\n\"; } void CommentLogger::info(String const& message) { llvm::errs() << \"info - \" << location_name_ << \":\" << location_row_ << \",\" << location_col_ << \" - \" << message << \"\\n\"; } void CommentLogger::warning(String const& message) { llvm::errs() << \"warning - \" << location_name_ << \":\" << location_row_ << \",\" << location_col_ << \" - \" << message << \"\\n\"; } void CommentLogger::error(String const& message) { llvm::errs() << \"error - \" << location_name_ << \":\" << location_row_ << \",\" << location_col_ << \" - \" << message << \"\\n\"; } void CommentLogger::internalError(String const& message) { llvm::errs() << \"internal error - \" << location_name_ << \":\" << location_row_ << \",\" << location_col_ << \" - \" << message << \"\\n\"; } void CommentLogger::setLocation(String const& name, uint64_t row, uint64_t col) { location_name_ = name; location_row_ = row; location_col_ = col; } void CommentLogger::setLlvmHint(String const&) {} void CommentLogger::setFrontendHint(String const&) {} } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Logging/CommentLogger.cpp"},{"location":"Api/Files/_comment_logger_8cpp/#loggingcommentloggercpp","text":"","title":"Logging/CommentLogger.cpp"},{"location":"Api/Files/_comment_logger_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_comment_logger_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/CommentLogger.hpp\" #include \"Llvm/Llvm.hpp\" #include <vector> namespace microsoft { namespace quantum { void CommentLogger::debug(String const& message) { llvm::errs() << \"debug - \" << location_name_ << \":\" << location_row_ << \",\" << location_col_ << \" - \" << message << \"\\n\"; } void CommentLogger::info(String const& message) { llvm::errs() << \"info - \" << location_name_ << \":\" << location_row_ << \",\" << location_col_ << \" - \" << message << \"\\n\"; } void CommentLogger::warning(String const& message) { llvm::errs() << \"warning - \" << location_name_ << \":\" << location_row_ << \",\" << location_col_ << \" - \" << message << \"\\n\"; } void CommentLogger::error(String const& message) { llvm::errs() << \"error - \" << location_name_ << \":\" << location_row_ << \",\" << location_col_ << \" - \" << message << \"\\n\"; } void CommentLogger::internalError(String const& message) { llvm::errs() << \"internal error - \" << location_name_ << \":\" << location_row_ << \",\" << location_col_ << \" - \" << message << \"\\n\"; } void CommentLogger::setLocation(String const& name, uint64_t row, uint64_t col) { location_name_ = name; location_row_ = row; location_col_ = col; } void CommentLogger::setLlvmHint(String const&) {} void CommentLogger::setFrontendHint(String const&) {} } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_comment_logger_8hpp/","text":"Logging/CommentLogger.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::CommentLogger Concrete ILogger implementation that prints all messages as IR comments to llvm::errs(). Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/ILogger.hpp\" #include <vector> namespace microsoft { namespace quantum { class CommentLogger : public ILogger { public: // Interface implementation // void debug(String const& message) override; void info(String const& message) override; void warning(String const& message) override; void error(String const& message) override; void internalError(String const& message) override; void setLocation(String const& name, uint64_t row, uint64_t col) override; void setLlvmHint(String const& value) override; void setFrontendHint(String const& value) override; private: String location_name_{\"\"}; uint64_t location_row_{0}; uint64_t location_col_{0}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Logging/CommentLogger.hpp"},{"location":"Api/Files/_comment_logger_8hpp/#loggingcommentloggerhpp","text":"","title":"Logging/CommentLogger.hpp"},{"location":"Api/Files/_comment_logger_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_comment_logger_8hpp/#classes","text":"Name class microsoft::quantum::CommentLogger Concrete ILogger implementation that prints all messages as IR comments to llvm::errs().","title":"Classes"},{"location":"Api/Files/_comment_logger_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/ILogger.hpp\" #include <vector> namespace microsoft { namespace quantum { class CommentLogger : public ILogger { public: // Interface implementation // void debug(String const& message) override; void info(String const& message) override; void warning(String const& message) override; void error(String const& message) override; void internalError(String const& message) override; void setLocation(String const& name, uint64_t row, uint64_t col) override; void setLlvmHint(String const& value) override; void setFrontendHint(String const& value) override; private: String location_name_{\"\"}; uint64_t location_row_{0}; uint64_t location_col_{0}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_config_bind_8hpp/","text":"Commandline/ConfigBind.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ConfigBind Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/IConfigBind.hpp\" #include \"Commandline/ParameterParser.hpp\" #include \"Llvm/Llvm.hpp\" #include <iomanip> #include <iostream> #include <sstream> #include <type_traits> #include <typeindex> namespace microsoft { namespace quantum { template <typename T> class ConfigBind : public IConfigBind { public: using Type = T; template <typename A, typename B, typename R> using EnableIf = typename std::enable_if<std::is_same<A, B>::value, R>::type; // Constructors, operators and destructor // ConfigBind() = delete; ConfigBind(ConfigBind const&) = delete; ConfigBind(ConfigBind&&) = delete; ConfigBind& operator=(ConfigBind const&) = delete; ConfigBind& operator=(ConfigBind&&) = delete; ~ConfigBind() override = default; ConfigBind(Type& bind, T default_value, String const& name, String const& description); // Marks the configuration as being experimental. void markAsExperimental(Type const& off_value); // Interface implementation // bool setupArguments(ParameterParser& parser) override; bool configure(ParameterParser& parser, bool experimental_mode) override; String value() override; private: template <typename R> bool setupArguments(ParameterParser&, R const&); bool setupArguments(ParameterParser& parser, bool const&); template <typename R> void alterNameBasedOnType(R const& default_value); void alterNameBasedOnType(bool const& default_value); template <typename A> String valueAsString(A const&); template <typename A> String valueAsString(EnableIf<A, bool, A> const&); template <typename R> void loadValue(ParameterParser& parser, R const& default_value); template <typename A> void loadValue(ParameterParser& parser, EnableIf<A, bool, A> const& default_value); template <typename A> void loadValue(ParameterParser& parser, EnableIf<A, String, A> const& default_value); Type& bind_; Type default_value_; Type experimental_off_value_; }; template <typename T> ConfigBind<T>::ConfigBind(Type& bind, T default_value, String const& name, String const& description) : IConfigBind(name, description) , bind_{bind} , default_value_{std::move(default_value)} { alterNameBasedOnType(default_value_); } template <typename T> template <typename R> void ConfigBind<T>::alterNameBasedOnType(R const& default_value) { std::stringstream ss{\"\"}; ss << default_value; setDefault(static_cast<String>(ss.str())); } template <typename T> void ConfigBind<T>::alterNameBasedOnType(bool const& default_value) { markAsFlag(); if (default_value) { setDefault(\"true\"); } else { setDefault(\"false\"); } } template <typename T> bool ConfigBind<T>::setupArguments(ParameterParser& parser) { return setupArguments(parser, default_value_); } template <typename T> template <typename R> bool ConfigBind<T>::setupArguments(ParameterParser&, R const&) { return true; } template <typename T> bool ConfigBind<T>::setupArguments(ParameterParser& parser, bool const&) { parser.addFlag(name()); return true; } template <typename T> bool ConfigBind<T>::configure(ParameterParser& parser, bool experimental_mode) { if (!isExperimental()) { // For non-experimental parameters we load the default value loadValue<Type>(parser, default_value_); } else { // If the parameter is experimental and we are in experimental mode if (experimental_mode) { // ... we load the default value loadValue<Type>(parser, default_value_); } else { // ... and else we load the experimental off value bind_ = experimental_off_value_; } } return true; } template <typename T> void ConfigBind<T>::markAsExperimental(Type const& off_value) { experimental_off_value_ = off_value; makeSettingExperimental(); } template <typename T> String ConfigBind<T>::value() { return valueAsString<Type>(default_value_); } template <typename T> template <typename A> String ConfigBind<T>::valueAsString(A const&) { std::stringstream ss{\"\"}; ss << bind_; return static_cast<String>(ss.str()); } template <typename T> template <typename A> String ConfigBind<T>::valueAsString(EnableIf<A, bool, A> const&) { std::stringstream ss{\"\"}; ss << (bind_ ? \"true\" : \"false\"); return static_cast<String>(ss.str()); } template <typename T> template <typename R> void ConfigBind<T>::loadValue(ParameterParser& parser, R const& default_value) { bind_ = default_value; if (parser.has(name())) { std::stringstream ss{parser.get(name())}; ss >> bind_; } } template <typename T> template <typename A> void ConfigBind<T>::loadValue(ParameterParser& parser, EnableIf<A, bool, A> const& default_value) { bind_ = default_value; if (parser.has(name())) { parser.markAsUsed(name()); bind_ = true; } else if (parser.has(\"no-\" + name())) { parser.markAsUsed(\"no-\" + name()); bind_ = false; } } template <typename T> template <typename A> void ConfigBind<T>::loadValue(ParameterParser& parser, EnableIf<A, String, A> const& default_value) { bind_ = default_value; if (parser.has(name())) { bind_ = parser.get(name()); } } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Commandline/ConfigBind.hpp"},{"location":"Api/Files/_config_bind_8hpp/#commandlineconfigbindhpp","text":"","title":"Commandline/ConfigBind.hpp"},{"location":"Api/Files/_config_bind_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_config_bind_8hpp/#classes","text":"Name class microsoft::quantum::ConfigBind","title":"Classes"},{"location":"Api/Files/_config_bind_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/IConfigBind.hpp\" #include \"Commandline/ParameterParser.hpp\" #include \"Llvm/Llvm.hpp\" #include <iomanip> #include <iostream> #include <sstream> #include <type_traits> #include <typeindex> namespace microsoft { namespace quantum { template <typename T> class ConfigBind : public IConfigBind { public: using Type = T; template <typename A, typename B, typename R> using EnableIf = typename std::enable_if<std::is_same<A, B>::value, R>::type; // Constructors, operators and destructor // ConfigBind() = delete; ConfigBind(ConfigBind const&) = delete; ConfigBind(ConfigBind&&) = delete; ConfigBind& operator=(ConfigBind const&) = delete; ConfigBind& operator=(ConfigBind&&) = delete; ~ConfigBind() override = default; ConfigBind(Type& bind, T default_value, String const& name, String const& description); // Marks the configuration as being experimental. void markAsExperimental(Type const& off_value); // Interface implementation // bool setupArguments(ParameterParser& parser) override; bool configure(ParameterParser& parser, bool experimental_mode) override; String value() override; private: template <typename R> bool setupArguments(ParameterParser&, R const&); bool setupArguments(ParameterParser& parser, bool const&); template <typename R> void alterNameBasedOnType(R const& default_value); void alterNameBasedOnType(bool const& default_value); template <typename A> String valueAsString(A const&); template <typename A> String valueAsString(EnableIf<A, bool, A> const&); template <typename R> void loadValue(ParameterParser& parser, R const& default_value); template <typename A> void loadValue(ParameterParser& parser, EnableIf<A, bool, A> const& default_value); template <typename A> void loadValue(ParameterParser& parser, EnableIf<A, String, A> const& default_value); Type& bind_; Type default_value_; Type experimental_off_value_; }; template <typename T> ConfigBind<T>::ConfigBind(Type& bind, T default_value, String const& name, String const& description) : IConfigBind(name, description) , bind_{bind} , default_value_{std::move(default_value)} { alterNameBasedOnType(default_value_); } template <typename T> template <typename R> void ConfigBind<T>::alterNameBasedOnType(R const& default_value) { std::stringstream ss{\"\"}; ss << default_value; setDefault(static_cast<String>(ss.str())); } template <typename T> void ConfigBind<T>::alterNameBasedOnType(bool const& default_value) { markAsFlag(); if (default_value) { setDefault(\"true\"); } else { setDefault(\"false\"); } } template <typename T> bool ConfigBind<T>::setupArguments(ParameterParser& parser) { return setupArguments(parser, default_value_); } template <typename T> template <typename R> bool ConfigBind<T>::setupArguments(ParameterParser&, R const&) { return true; } template <typename T> bool ConfigBind<T>::setupArguments(ParameterParser& parser, bool const&) { parser.addFlag(name()); return true; } template <typename T> bool ConfigBind<T>::configure(ParameterParser& parser, bool experimental_mode) { if (!isExperimental()) { // For non-experimental parameters we load the default value loadValue<Type>(parser, default_value_); } else { // If the parameter is experimental and we are in experimental mode if (experimental_mode) { // ... we load the default value loadValue<Type>(parser, default_value_); } else { // ... and else we load the experimental off value bind_ = experimental_off_value_; } } return true; } template <typename T> void ConfigBind<T>::markAsExperimental(Type const& off_value) { experimental_off_value_ = off_value; makeSettingExperimental(); } template <typename T> String ConfigBind<T>::value() { return valueAsString<Type>(default_value_); } template <typename T> template <typename A> String ConfigBind<T>::valueAsString(A const&) { std::stringstream ss{\"\"}; ss << bind_; return static_cast<String>(ss.str()); } template <typename T> template <typename A> String ConfigBind<T>::valueAsString(EnableIf<A, bool, A> const&) { std::stringstream ss{\"\"}; ss << (bind_ ? \"true\" : \"false\"); return static_cast<String>(ss.str()); } template <typename T> template <typename R> void ConfigBind<T>::loadValue(ParameterParser& parser, R const& default_value) { bind_ = default_value; if (parser.has(name())) { std::stringstream ss{parser.get(name())}; ss >> bind_; } } template <typename T> template <typename A> void ConfigBind<T>::loadValue(ParameterParser& parser, EnableIf<A, bool, A> const& default_value) { bind_ = default_value; if (parser.has(name())) { parser.markAsUsed(name()); bind_ = true; } else if (parser.has(\"no-\" + name())) { parser.markAsUsed(\"no-\" + name()); bind_ = false; } } template <typename T> template <typename A> void ConfigBind<T>::loadValue(ParameterParser& parser, EnableIf<A, String, A> const& default_value) { bind_ = default_value; if (parser.has(name())) { bind_ = parser.get(name()); } } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_configurable_profile_generator_8cpp/","text":"Generators/ConfigurableProfileGenerator.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/ConfigurableProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"Rules/FactoryConfig.hpp\" #include \"Rules/RuleSet.hpp\" #include \"TransformationRulesPass/TransformationRulesPass.hpp\" #include \"Llvm/Llvm.hpp\" #include <iostream> namespace microsoft { namespace quantum { ConfigurableProfileGenerator::ConfigurableProfileGenerator() { configurationManager().addConfig<ValidationPassConfiguration>(); setupDefaultComponentPipeline(); } ConfigurableProfileGenerator::ConfigurableProfileGenerator( ConfigureFunction const& configure, TransformationRulesPassConfiguration const& profile_pass_config, LlvmPassesConfiguration const& llvm_config) { configurationManager().addConfig<ValidationPassConfiguration>(); setupDefaultComponentPipeline(); replaceProfileComponent<TransformationRulesPassConfiguration>( \"transformation-rules\", [configure](TransformationRulesPassConfiguration const& config, ProfileGenerator* ptr, Profile& profile) { auto& ret = ptr->modulePassManager(); // Defining the mapping RuleSet rule_set; auto factory = RuleFactory(rule_set, profile.getQubitAllocationManager(), profile.getResultAllocationManager()); configure(rule_set); // Creating profile pass ret.addPass(TransformationRulesPass(std::move(rule_set), config, &profile)); }); configurationManager().setConfig(profile_pass_config); configurationManager().setConfig(llvm_config); } TransformationRulesPassConfiguration const& ConfigurableProfileGenerator::ruleTransformationConfig() const { return configurationManager().get<TransformationRulesPassConfiguration>(); } LlvmPassesConfiguration const& ConfigurableProfileGenerator::llvmPassesConfig() const { return configurationManager().get<LlvmPassesConfiguration>(); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Generators/ConfigurableProfileGenerator.cpp"},{"location":"Api/Files/_configurable_profile_generator_8cpp/#generatorsconfigurableprofilegeneratorcpp","text":"","title":"Generators/ConfigurableProfileGenerator.cpp"},{"location":"Api/Files/_configurable_profile_generator_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_configurable_profile_generator_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/ConfigurableProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"Rules/FactoryConfig.hpp\" #include \"Rules/RuleSet.hpp\" #include \"TransformationRulesPass/TransformationRulesPass.hpp\" #include \"Llvm/Llvm.hpp\" #include <iostream> namespace microsoft { namespace quantum { ConfigurableProfileGenerator::ConfigurableProfileGenerator() { configurationManager().addConfig<ValidationPassConfiguration>(); setupDefaultComponentPipeline(); } ConfigurableProfileGenerator::ConfigurableProfileGenerator( ConfigureFunction const& configure, TransformationRulesPassConfiguration const& profile_pass_config, LlvmPassesConfiguration const& llvm_config) { configurationManager().addConfig<ValidationPassConfiguration>(); setupDefaultComponentPipeline(); replaceProfileComponent<TransformationRulesPassConfiguration>( \"transformation-rules\", [configure](TransformationRulesPassConfiguration const& config, ProfileGenerator* ptr, Profile& profile) { auto& ret = ptr->modulePassManager(); // Defining the mapping RuleSet rule_set; auto factory = RuleFactory(rule_set, profile.getQubitAllocationManager(), profile.getResultAllocationManager()); configure(rule_set); // Creating profile pass ret.addPass(TransformationRulesPass(std::move(rule_set), config, &profile)); }); configurationManager().setConfig(profile_pass_config); configurationManager().setConfig(llvm_config); } TransformationRulesPassConfiguration const& ConfigurableProfileGenerator::ruleTransformationConfig() const { return configurationManager().get<TransformationRulesPassConfiguration>(); } LlvmPassesConfiguration const& ConfigurableProfileGenerator::llvmPassesConfig() const { return configurationManager().get<LlvmPassesConfiguration>(); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_configurable_profile_generator_8hpp/","text":"Generators/ConfigurableProfileGenerator.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ConfigurableProfileGenerator Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"Generators/LlvmPassesConfiguration.hpp\" #include \"Generators/ProfileGenerator.hpp\" #include \"Rules/FactoryConfig.hpp\" #include \"Rules/RuleSet.hpp\" #include \"TransformationRulesPass/TransformationRulesPassConfiguration.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { class ConfigurableProfileGenerator : public ProfileGenerator { public: using ConfigureFunction = std::function<void(RuleSet&)>; ConfigurableProfileGenerator(); explicit ConfigurableProfileGenerator( ConfigureFunction const& configure, TransformationRulesPassConfiguration const& profile_pass_config = TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration const& llvm_config = LlvmPassesConfiguration::createDisabled()); // Shorthand notation to access configurations // TransformationRulesPassConfiguration const& ruleTransformationConfig() const; LlvmPassesConfiguration const& llvmPassesConfig() const; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Generators/ConfigurableProfileGenerator.hpp"},{"location":"Api/Files/_configurable_profile_generator_8hpp/#generatorsconfigurableprofilegeneratorhpp","text":"","title":"Generators/ConfigurableProfileGenerator.hpp"},{"location":"Api/Files/_configurable_profile_generator_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_configurable_profile_generator_8hpp/#classes","text":"Name class microsoft::quantum::ConfigurableProfileGenerator","title":"Classes"},{"location":"Api/Files/_configurable_profile_generator_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"Generators/LlvmPassesConfiguration.hpp\" #include \"Generators/ProfileGenerator.hpp\" #include \"Rules/FactoryConfig.hpp\" #include \"Rules/RuleSet.hpp\" #include \"TransformationRulesPass/TransformationRulesPassConfiguration.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { class ConfigurableProfileGenerator : public ProfileGenerator { public: using ConfigureFunction = std::function<void(RuleSet&)>; ConfigurableProfileGenerator(); explicit ConfigurableProfileGenerator( ConfigureFunction const& configure, TransformationRulesPassConfiguration const& profile_pass_config = TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration const& llvm_config = LlvmPassesConfiguration::createDisabled()); // Shorthand notation to access configurations // TransformationRulesPassConfiguration const& ruleTransformationConfig() const; LlvmPassesConfiguration const& llvmPassesConfig() const; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_configuration_manager_8cpp/","text":"Commandline/ConfigurationManager.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" using namespace microsoft::quantum; namespace microsoft { namespace quantum { void ConfigurationManager::setupArguments(ParameterParser& parser) { for (auto& section : config_sections_) { if (section.enabled_by_default) { parser.addFlag(\"disable-\" + section.id); } else { parser.addFlag(\"enable-\" + section.id); } } for (auto& section : config_sections_) { for (auto& c : section.settings) { if (!c->setupArguments(parser)) { throw std::runtime_error(\"Failed to set parser arguments up.\"); } } } } void ConfigurationManager::configure(ParameterParser& parser, bool experimental_mode) { for (auto& section : config_sections_) { if (section.enabled_by_default) { *section.active = (parser.get(\"disable-\" + section.id, \"false\") != \"true\"); } else { *section.active = (parser.get(\"enable-\" + section.id, \"false\") == \"true\"); } } for (auto& section : config_sections_) { for (auto& c : section.settings) { if (!c->configure(parser, experimental_mode)) { throw std::runtime_error(\"Failed configure the section.\"); } } } } void ConfigurationManager::printHelp(bool experimental_mode) const { std::cout << std::setfill(' '); // Enable or disable components std::cout << std::endl; std::cout << \"Component configuration\" << \" - \"; std::cout << \"Used to disable or enable components\" << std::endl; std::cout << std::endl; for (auto& section : config_sections_) { if (!section.id.empty()) { if (section.enabled_by_default) { std::cout << std::setw(50) << std::left << (\"--disable-\" + section.id) << \"Disables \" << section.name << \". \"; std::cout << \"Default: false\" << std::endl; } else { std::cout << std::setw(50) << std::left << (\"--enable-\" + section.id) << \"Enables \" << section.name << \". \"; std::cout << \"Default: false\" << std::endl; } } } // Component configuration for (auto& section : config_sections_) { std::cout << std::endl; std::cout << section.name << \" - \"; std::cout << section.description << std::endl; std::cout << std::endl; for (auto& c : section.settings) { if (c->isExperimental() && !experimental_mode) { continue; } if (c->isFlag()) { if (c->defaultValue() == \"false\") { std::cout << std::setw(50) << std::left << (\"--\" + c->name()); } else { std::cout << std::setw(50) << std::left << (\"--[no-]\" + c->name()); } } else { std::cout << std::setw(50) << std::left << (\"--\" + c->name()); } if (c->isExperimental()) { std::cout << \"EXPERIMENTAL. \"; } std::cout << c->description() << \" \"; std::cout << \"Default: \" << c->defaultValue() << std::endl; } } } void ConfigurationManager::printConfiguration() const { std::cout << std::setfill('.'); std::cout << \"; # \" << \"Components\" << \"\\n\"; for (auto& section : config_sections_) { if (!section.id.empty()) { std::cout << \"; \" << std::setw(50) << std::left << (\"disable-\" + section.id) << \": \" << (*section.active ? \"false\" : \"true\") << \"\\n\"; } } std::cout << \"; \\n\"; for (auto& section : config_sections_) { std::cout << \"; # \" << section.name << \"\\n\"; for (auto& c : section.settings) { std::cout << \"; \" << std::setw(50) << std::left << c->name() << \": \" << c->value() << \"\\n\"; } std::cout << \"; \\n\"; } } void ConfigurationManager::setSectionName(String const& name, String const& description) { if (config_sections_.empty()) { throw std::runtime_error(\"No section created yet.\"); } config_sections_.back().name = name; config_sections_.back().description = description; } void ConfigurationManager::disableSectionByDefault() { if (config_sections_.empty()) { throw std::runtime_error(\"No section created yet.\"); } config_sections_.back().enabled_by_default = false; } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Commandline/ConfigurationManager.cpp"},{"location":"Api/Files/_configuration_manager_8cpp/#commandlineconfigurationmanagercpp","text":"","title":"Commandline/ConfigurationManager.cpp"},{"location":"Api/Files/_configuration_manager_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_configuration_manager_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" using namespace microsoft::quantum; namespace microsoft { namespace quantum { void ConfigurationManager::setupArguments(ParameterParser& parser) { for (auto& section : config_sections_) { if (section.enabled_by_default) { parser.addFlag(\"disable-\" + section.id); } else { parser.addFlag(\"enable-\" + section.id); } } for (auto& section : config_sections_) { for (auto& c : section.settings) { if (!c->setupArguments(parser)) { throw std::runtime_error(\"Failed to set parser arguments up.\"); } } } } void ConfigurationManager::configure(ParameterParser& parser, bool experimental_mode) { for (auto& section : config_sections_) { if (section.enabled_by_default) { *section.active = (parser.get(\"disable-\" + section.id, \"false\") != \"true\"); } else { *section.active = (parser.get(\"enable-\" + section.id, \"false\") == \"true\"); } } for (auto& section : config_sections_) { for (auto& c : section.settings) { if (!c->configure(parser, experimental_mode)) { throw std::runtime_error(\"Failed configure the section.\"); } } } } void ConfigurationManager::printHelp(bool experimental_mode) const { std::cout << std::setfill(' '); // Enable or disable components std::cout << std::endl; std::cout << \"Component configuration\" << \" - \"; std::cout << \"Used to disable or enable components\" << std::endl; std::cout << std::endl; for (auto& section : config_sections_) { if (!section.id.empty()) { if (section.enabled_by_default) { std::cout << std::setw(50) << std::left << (\"--disable-\" + section.id) << \"Disables \" << section.name << \". \"; std::cout << \"Default: false\" << std::endl; } else { std::cout << std::setw(50) << std::left << (\"--enable-\" + section.id) << \"Enables \" << section.name << \". \"; std::cout << \"Default: false\" << std::endl; } } } // Component configuration for (auto& section : config_sections_) { std::cout << std::endl; std::cout << section.name << \" - \"; std::cout << section.description << std::endl; std::cout << std::endl; for (auto& c : section.settings) { if (c->isExperimental() && !experimental_mode) { continue; } if (c->isFlag()) { if (c->defaultValue() == \"false\") { std::cout << std::setw(50) << std::left << (\"--\" + c->name()); } else { std::cout << std::setw(50) << std::left << (\"--[no-]\" + c->name()); } } else { std::cout << std::setw(50) << std::left << (\"--\" + c->name()); } if (c->isExperimental()) { std::cout << \"EXPERIMENTAL. \"; } std::cout << c->description() << \" \"; std::cout << \"Default: \" << c->defaultValue() << std::endl; } } } void ConfigurationManager::printConfiguration() const { std::cout << std::setfill('.'); std::cout << \"; # \" << \"Components\" << \"\\n\"; for (auto& section : config_sections_) { if (!section.id.empty()) { std::cout << \"; \" << std::setw(50) << std::left << (\"disable-\" + section.id) << \": \" << (*section.active ? \"false\" : \"true\") << \"\\n\"; } } std::cout << \"; \\n\"; for (auto& section : config_sections_) { std::cout << \"; # \" << section.name << \"\\n\"; for (auto& c : section.settings) { std::cout << \"; \" << std::setw(50) << std::left << c->name() << \": \" << c->value() << \"\\n\"; } std::cout << \"; \\n\"; } } void ConfigurationManager::setSectionName(String const& name, String const& description) { if (config_sections_.empty()) { throw std::runtime_error(\"No section created yet.\"); } config_sections_.back().name = name; config_sections_.back().description = description; } void ConfigurationManager::disableSectionByDefault() { if (config_sections_.empty()) { throw std::runtime_error(\"No section created yet.\"); } config_sections_.back().enabled_by_default = false; } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_configuration_manager_8hpp/","text":"Commandline/ConfigurationManager.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ConfigurationManager struct microsoft::quantum::ConfigurationManager::Section Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigBind.hpp\" #include \"Commandline/IConfigBind.hpp\" #include \"Commandline/ParameterParser.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Llvm/Llvm.hpp\" #include <iomanip> #include <iostream> #include <sstream> #include <type_traits> #include <typeindex> #include <typeinfo> namespace microsoft { namespace quantum { class ConfigurationManager { public: using IConfigBindPtr = std::shared_ptr<IConfigBind>; using ConfigList = std::vector<IConfigBindPtr>; using VoidPtr = std::shared_ptr<void>; using TypeId = std::type_index; using BoolPtr = std::shared_ptr<bool>; struct Section { TypeId type{TypeId(typeid(std::nullptr_t))}; String name{}; String description{}; bool enabled_by_default{true}; VoidPtr configuration{}; ConfigList settings{}; BoolPtr active{nullptr}; String id{}; }; using Sections = std::vector<Section>; // Constructors, copy and move operators, destructor // ConfigurationManager() = default; ConfigurationManager(ConfigurationManager const&) = delete; ConfigurationManager(ConfigurationManager&&) = delete; ConfigurationManager& operator=(ConfigurationManager const&) = delete; ConfigurationManager& operator=(ConfigurationManager&&) = delete; ~ConfigurationManager() { for (auto& s : config_sections_) { s.configuration.reset(); } } // Configuration setup // void setupArguments(ParameterParser& parser); void configure(ParameterParser& parser, bool experimental_mode = false); // Managing configuration // template <typename T> inline void setConfig(T const& value); template <typename T> inline T const& get() const; // Support functions // void printHelp(bool experimental_mode) const; void printConfiguration() const; // Configuration functions // template <typename T> inline void addConfig(String const& id = \"\", T const& default_value = T()); template <typename T> inline bool configWasRegistered(); template <typename T> inline bool isActive(); void setSectionName(String const& name, String const& description); void disableSectionByDefault(); template <typename T> inline void addParameter(T& bind, T default_value, String const& name, String const& description); template <typename T> inline void addExperimentalParameter( T& bind, T default_value, T off_value, String const& name, String const& description); template <typename T> inline void addExperimentalParameter(T& bind, T default_value, String const& name, String const& description); template <typename T> inline void addExperimentalParameter(T& bind, String const& name, String const& description); template <typename T> inline void addParameter(T& bind, String const& name, String const& description); private: template <typename T> inline T& getInternal() const; Sections config_sections_{}; }; template <typename T> inline void ConfigurationManager::addConfig(String const& id, T const& default_value) { Section new_section{std::type_index(typeid(T))}; // Checking whether the section exists auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { throw std::runtime_error( \"Configuration section for type '\" + static_cast<std::string>(typeid(T).name()) + \"' already exists\"); } } // If not we create it. auto ptr = std::make_shared<T>(default_value); new_section.configuration = ptr; new_section.active = std::make_shared<bool>(true); new_section.id = id; config_sections_.emplace_back(std::move(new_section)); ptr->setup(*this); } template <typename T> inline bool ConfigurationManager::configWasRegistered() { auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { return true; } } return false; } template <typename T> inline T& ConfigurationManager::getInternal() const { VoidPtr ptr{nullptr}; auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { ptr = section.configuration; break; } } if (ptr == nullptr) { throw std::runtime_error( \"Could not find configuration class '\" + static_cast<std::string>(typeid(T).name()) + \"'.\"); } return *static_cast<T*>(ptr.get()); } template <typename T> inline void ConfigurationManager::setConfig(T const& value) { auto& config = getInternal<T>(); config = value; } template <typename T> inline T const& ConfigurationManager::get() const { return getInternal<T>(); } template <typename T> inline bool ConfigurationManager::isActive() { BoolPtr ptr{nullptr}; auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { ptr = section.active; break; } } if (ptr == nullptr) { throw std::runtime_error( \"Could not find configuration class '\" + static_cast<std::string>(typeid(T).name()) + \"'.\"); } return *ptr; } template <typename T> inline void ConfigurationManager::addParameter( T& bind, T default_value, String const& name, String const& description) { auto ptr = std::make_shared<ConfigBind<T>>(bind, default_value, name, description); config_sections_.back().settings.push_back(ptr); } template <typename T> inline void ConfigurationManager::addExperimentalParameter( T& bind, T default_value, T off_value, String const& name, String const& description) { auto ptr = std::make_shared<ConfigBind<T>>(bind, default_value, name, description); ptr->markAsExperimental(off_value); config_sections_.back().settings.push_back(ptr); } template <typename T> inline void ConfigurationManager::addParameter(T& bind, String const& name, String const& description) { auto ptr = std::make_shared<ConfigBind<T>>(bind, T(bind), name, description); config_sections_.back().settings.push_back(ptr); } template <typename T> inline void ConfigurationManager::addExperimentalParameter( T& bind, T default_value, String const& name, String const& description) { auto ptr = std::make_shared<ConfigBind<T>>(bind, T(default_value), name, description); ptr->markAsExperimental(T(bind)); config_sections_.back().settings.push_back(ptr); } template <typename T> inline void ConfigurationManager::addExperimentalParameter(T& bind, String const& name, String const& description) { auto ptr = std::make_shared<ConfigBind<T>>(bind, T(bind), name, description); ptr->markAsExperimental(T(bind)); config_sections_.back().settings.push_back(ptr); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Commandline/ConfigurationManager.hpp"},{"location":"Api/Files/_configuration_manager_8hpp/#commandlineconfigurationmanagerhpp","text":"","title":"Commandline/ConfigurationManager.hpp"},{"location":"Api/Files/_configuration_manager_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_configuration_manager_8hpp/#classes","text":"Name class microsoft::quantum::ConfigurationManager struct microsoft::quantum::ConfigurationManager::Section","title":"Classes"},{"location":"Api/Files/_configuration_manager_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigBind.hpp\" #include \"Commandline/IConfigBind.hpp\" #include \"Commandline/ParameterParser.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Llvm/Llvm.hpp\" #include <iomanip> #include <iostream> #include <sstream> #include <type_traits> #include <typeindex> #include <typeinfo> namespace microsoft { namespace quantum { class ConfigurationManager { public: using IConfigBindPtr = std::shared_ptr<IConfigBind>; using ConfigList = std::vector<IConfigBindPtr>; using VoidPtr = std::shared_ptr<void>; using TypeId = std::type_index; using BoolPtr = std::shared_ptr<bool>; struct Section { TypeId type{TypeId(typeid(std::nullptr_t))}; String name{}; String description{}; bool enabled_by_default{true}; VoidPtr configuration{}; ConfigList settings{}; BoolPtr active{nullptr}; String id{}; }; using Sections = std::vector<Section>; // Constructors, copy and move operators, destructor // ConfigurationManager() = default; ConfigurationManager(ConfigurationManager const&) = delete; ConfigurationManager(ConfigurationManager&&) = delete; ConfigurationManager& operator=(ConfigurationManager const&) = delete; ConfigurationManager& operator=(ConfigurationManager&&) = delete; ~ConfigurationManager() { for (auto& s : config_sections_) { s.configuration.reset(); } } // Configuration setup // void setupArguments(ParameterParser& parser); void configure(ParameterParser& parser, bool experimental_mode = false); // Managing configuration // template <typename T> inline void setConfig(T const& value); template <typename T> inline T const& get() const; // Support functions // void printHelp(bool experimental_mode) const; void printConfiguration() const; // Configuration functions // template <typename T> inline void addConfig(String const& id = \"\", T const& default_value = T()); template <typename T> inline bool configWasRegistered(); template <typename T> inline bool isActive(); void setSectionName(String const& name, String const& description); void disableSectionByDefault(); template <typename T> inline void addParameter(T& bind, T default_value, String const& name, String const& description); template <typename T> inline void addExperimentalParameter( T& bind, T default_value, T off_value, String const& name, String const& description); template <typename T> inline void addExperimentalParameter(T& bind, T default_value, String const& name, String const& description); template <typename T> inline void addExperimentalParameter(T& bind, String const& name, String const& description); template <typename T> inline void addParameter(T& bind, String const& name, String const& description); private: template <typename T> inline T& getInternal() const; Sections config_sections_{}; }; template <typename T> inline void ConfigurationManager::addConfig(String const& id, T const& default_value) { Section new_section{std::type_index(typeid(T))}; // Checking whether the section exists auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { throw std::runtime_error( \"Configuration section for type '\" + static_cast<std::string>(typeid(T).name()) + \"' already exists\"); } } // If not we create it. auto ptr = std::make_shared<T>(default_value); new_section.configuration = ptr; new_section.active = std::make_shared<bool>(true); new_section.id = id; config_sections_.emplace_back(std::move(new_section)); ptr->setup(*this); } template <typename T> inline bool ConfigurationManager::configWasRegistered() { auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { return true; } } return false; } template <typename T> inline T& ConfigurationManager::getInternal() const { VoidPtr ptr{nullptr}; auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { ptr = section.configuration; break; } } if (ptr == nullptr) { throw std::runtime_error( \"Could not find configuration class '\" + static_cast<std::string>(typeid(T).name()) + \"'.\"); } return *static_cast<T*>(ptr.get()); } template <typename T> inline void ConfigurationManager::setConfig(T const& value) { auto& config = getInternal<T>(); config = value; } template <typename T> inline T const& ConfigurationManager::get() const { return getInternal<T>(); } template <typename T> inline bool ConfigurationManager::isActive() { BoolPtr ptr{nullptr}; auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { ptr = section.active; break; } } if (ptr == nullptr) { throw std::runtime_error( \"Could not find configuration class '\" + static_cast<std::string>(typeid(T).name()) + \"'.\"); } return *ptr; } template <typename T> inline void ConfigurationManager::addParameter( T& bind, T default_value, String const& name, String const& description) { auto ptr = std::make_shared<ConfigBind<T>>(bind, default_value, name, description); config_sections_.back().settings.push_back(ptr); } template <typename T> inline void ConfigurationManager::addExperimentalParameter( T& bind, T default_value, T off_value, String const& name, String const& description) { auto ptr = std::make_shared<ConfigBind<T>>(bind, default_value, name, description); ptr->markAsExperimental(off_value); config_sections_.back().settings.push_back(ptr); } template <typename T> inline void ConfigurationManager::addParameter(T& bind, String const& name, String const& description) { auto ptr = std::make_shared<ConfigBind<T>>(bind, T(bind), name, description); config_sections_.back().settings.push_back(ptr); } template <typename T> inline void ConfigurationManager::addExperimentalParameter( T& bind, T default_value, String const& name, String const& description) { auto ptr = std::make_shared<ConfigBind<T>>(bind, T(default_value), name, description); ptr->markAsExperimental(T(bind)); config_sections_.back().settings.push_back(ptr); } template <typename T> inline void ConfigurationManager::addExperimentalParameter(T& bind, String const& name, String const& description) { auto ptr = std::make_shared<ConfigBind<T>>(bind, T(bind), name, description); ptr->markAsExperimental(T(bind)); config_sections_.back().settings.push_back(ptr); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_const_int_8cpp/","text":"Rules/Notation/ConstInt.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr constInt() { auto cast_pattern = std::make_shared<ConstIntPattern>(); return static_cast<IOperandPrototypePtr>(cast_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Notation/ConstInt.cpp"},{"location":"Api/Files/_const_int_8cpp/#rulesnotationconstintcpp","text":"","title":"Rules/Notation/ConstInt.cpp"},{"location":"Api/Files/_const_int_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_const_int_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr constInt() { auto cast_pattern = std::make_shared<ConstIntPattern>(); return static_cast<IOperandPrototypePtr>(cast_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_factory_8cpp/","text":"Rules/Factory.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Factory.hpp\" #include \"Rules/Notation/Notation.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { namespace { using Instruction = llvm::Instruction; using Value = llvm::Value; using Builder = ReplacementRule::Builder; using Captures = ReplacementRule::Captures; using Replacements = ReplacementRule::Replacements; } // namespace using ReplacementRulePtr = RuleFactory::ReplacementRulePtr; using namespace microsoft::quantum::notation; RuleFactory::RuleFactory( RuleSet& rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager) : rule_set_{rule_set} , qubit_alloc_manager_{std::move(qubit_alloc_manager)} , result_alloc_manager_{std::move(result_alloc_manager)} { } void RuleFactory::usingConfiguration(FactoryConfiguration const& config) { default_integer_width_ = config.defaultIntegerWidth(); if (config.disableReferenceCounting()) { disableReferenceCounting(); } if (config.disableAliasCounting()) { disableAliasCounting(); } if (config.disableStringSupport()) { disableStringSupport(); } if (config.optimizeResultOne()) { optimizeResultOne(); } if (config.optimizeResultZero()) { optimizeResultZero(); } if (config.useStaticQubitArrayAllocation()) { useStaticQubitArrayAllocation(); } if (config.useStaticQubitAllocation()) { useStaticQubitAllocation(); } if (config.useStaticResultAllocation()) { useStaticResultAllocation(); } } void RuleFactory::removeFunctionCall(String const& name) { addRule({callByNameOnly(name), deleteInstruction()}); } void RuleFactory::resolveConstantArraySizes() { auto size_replacer = [](Builder&, Value* val, Captures& cap, Replacements& replacements) { // Get the index and testing that it is a constant int auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"size\"]); if (cst == nullptr) { // ... if not, we cannot perform the mapping. return false; } val->replaceAllUsesWith(cst); replacements.push_back({llvm::dyn_cast<Instruction>(val), nullptr}); return true; }; auto create_array = call(\"__quantum__rt__array_create_1d\", \"elementSize\"_cap = _, \"size\"_cap = _); auto get_size = call(\"__quantum__rt__array_get_size_1d\", create_array); addRule({std::move(get_size), size_replacer}); } void RuleFactory::inlineCallables() { auto callable_replacer = [](Builder&, Value* val, Captures& captures, Replacements&) { llvm::errs() << \"FOUND CALLABLE\\n\"; llvm::errs() << *val << \"\\n\"; llvm::errs() << \"Calling \" << *captures[\"function\"] << \"\\n\"; return false; }; auto create_callable = call(\"__quantum__rt__callable_create\", \"function\"_cap = _, \"size\"_cap = _, _); auto invoke = call(\"__quantum__rt__callable_invoke\", create_callable, \"args\"_cap = _, \"ret\"_cap = _); addRule({std::move(invoke), callable_replacer}); } void RuleFactory::useStaticQubitArrayAllocation() { // TODO(issue-14): Use weak pointers to capture allocation managers auto qubit_alloc_manager = qubit_alloc_manager_; auto default_iw = default_integer_width_; auto allocation_replacer = [default_iw, qubit_alloc_manager](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"size\"]); if (cst == nullptr) { return false; } auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } if (cst == nullptr) { return false; } auto llvm_size = cst->getValue(); auto name = val->getName().str(); auto size = llvm_size.getZExtValue(); auto offset = qubit_alloc_manager->allocate(name, size); // Creating a new index APInt that is shifted by the offset of the allocation auto idx = llvm::APInt(default_iw, offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); // Replacing the instruction with new instruction auto old_instr = llvm::dyn_cast<Instruction>(val); // Safety precaution to ensure that we are dealing with a Instruction if (old_instr == nullptr) { return false; } auto instr = new llvm::IntToPtrInst(new_index, ptr_type); instr->takeName(old_instr); // Ensuring that we have replaced the instruction before // identifying release old_instr->replaceAllUsesWith(instr); replacements.push_back({old_instr, instr}); return true; }; addRule({call(\"__quantum__rt__qubit_allocate_array\", \"size\"_cap = _), allocation_replacer}); auto access_replacer = [qubit_alloc_manager](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { // Getting the type pointer auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } // Get the index and testing that it is a constant int auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"index\"]); if (cst == nullptr) { // ... if not, we cannot perform the mapping. return false; } // Computing the index by getting the current index value and offsetting by // the offset at which the qubit array is allocated. auto offset_cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"arrayName\"]); if (offset_cst == nullptr) { return false; } auto llvm_offset = offset_cst->getValue(); auto offset = llvm_offset.getZExtValue(); // Creating a new index APInt that is shifted by the offset of the allocation auto llvm_size = cst->getValue(); auto idx = llvm::APInt(llvm_size.getBitWidth(), llvm_size.getZExtValue() + offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto old_instr = llvm::dyn_cast<Instruction>(val); if (old_instr == nullptr) { return false; } // Converting pointer builder.SetInsertPoint(old_instr->getNextNode()); auto instr = builder.CreateIntToPtr(new_index, ptr_type); instr->takeName(old_instr); old_instr->replaceAllUsesWith(instr); // Replacing the instruction with new instruction replacements.push_back({old_instr, nullptr}); // Deleting the getelement and cast operations replacements.push_back({llvm::dyn_cast<Instruction>(cap[\"getElement\"]), nullptr}); replacements.push_back({llvm::dyn_cast<Instruction>(cap[\"cast\"]), nullptr}); return true; }; auto get_element = call( \"__quantum__rt__array_get_element_ptr_1d\", intToPtr(\"arrayName\"_cap = constInt()), \"index\"_cap = constInt()); auto cast_pattern = bitCast(\"getElement\"_cap = get_element); auto load_pattern = load(\"cast\"_cap = cast_pattern); addRule({\"Array Load Pattern\", std::move(load_pattern), access_replacer}); auto deleter = deleteInstruction(); addRule( {call(\"__quantum__rt__qubit_release_array\", intToPtr(\"const\"_cap = constInt())), [qubit_alloc_manager, deleter](Builder& builder, Value* val, Captures& cap, Replacements& rep) { // Recovering the qubit id auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"const\"]); if (cst == nullptr) { return false; } auto address = cst->getValue().getZExtValue(); // Releasing qubit_alloc_manager->release(address); // Deleting instruction return deleter(builder, val, cap, rep); }}); } void RuleFactory::useStaticQubitAllocation() { auto qubit_alloc_manager = qubit_alloc_manager_; auto default_iw = default_integer_width_; auto allocation_replacer = [default_iw, qubit_alloc_manager](Builder& builder, Value* val, Captures&, Replacements& replacements) { // Getting the type pointer auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } auto qubit_name = val->getName().str(); // Computing the index by getting the current index value and offseting by // the offset at which the qubit array is allocated. auto offset = qubit_alloc_manager->allocate(qubit_name); // Creating a new index APInt that is shifted by the offset of the allocation auto idx = llvm::APInt(default_iw, offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto instr = new llvm::IntToPtrInst(new_index, ptr_type); // Replacing the instruction with new instruction auto old_instr = llvm::dyn_cast<Instruction>(val); // Safety precaution to ensure that we are dealing with a Instruction if (old_instr == nullptr) { return false; } instr->takeName(old_instr); // Ensuring that we have replaced the instruction before // identifying release old_instr->replaceAllUsesWith(instr); replacements.push_back({old_instr, instr}); return true; }; // Dealing with qubit allocation addRule({call(\"__quantum__rt__qubit_allocate\"), allocation_replacer}); auto deleter = deleteInstruction(); // Handling the case where a constant integer is cast to a pointer and the pointer // is used in a call to qubit_release: // // %0 = inttoptr i64 0 to %Qubit* // call void @__quantum__rt__qubit_release(%Qubit* %0 // // The case of named addresses are also covered, by this pattern: // %leftMessage = inttoptr i64 0 to %Qubit* // call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) addRule( {call(\"__quantum__rt__qubit_release\", intToPtr(\"const\"_cap = constInt())), [qubit_alloc_manager, deleter](Builder& builder, Value* val, Captures& cap, Replacements& rep) { // Recovering the qubit id auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"const\"]); if (cst == nullptr) { return false; } auto address = cst->getValue().getZExtValue(); // Releasing qubit_alloc_manager->release(address); // Deleting instruction return deleter(builder, val, cap, rep); }}); // Handling where allocation is done by non-standard functions. In // this rule reports an error as we cannot reliably do a mapping. // // %leftMessage = call %Qubit* @__non_standard_allocator() // call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) addRule( {call(\"__quantum__rt__qubit_release\", \"name\"_cap = _), [qubit_alloc_manager, deleter](Builder& builder, Value* val, Captures& cap, Replacements& rep) { // Getting the name auto name = cap[\"name\"]->getName().str(); auto* phi_node = llvm::dyn_cast<llvm::PHINode>(cap[\"name\"]); if (phi_node != nullptr) { llvm::errs() << \"Warning: Cannot release qubit arising from phi node:\\n\"; llvm::errs() << *val << \"\\n\\n\"; return false; } // Returning in case the name comes out empty if (name.empty()) { // TODO(issue-15): report error llvm::errs() << \"FAILED due to unnamed non standard allocation:\\n\"; llvm::errs() << *val << \"\\n\\n\"; // Deleting the instruction in order to proceed // and trying to discover as many other errors as possible return deleter(builder, val, cap, rep); } // TODO(issue-15): report error llvm::errs() << \"FAILED due to non standard allocation:\\n\"; llvm::errs() << *cap[\"name\"] << \"\\n\"; llvm::errs() << *val << \"\\n\\n\"; return deleter(builder, val, cap, rep); } }); } void RuleFactory::useStaticResultAllocation() { auto result_alloc_manager = result_alloc_manager_; auto default_iw = default_integer_width_; auto replace_measurement = [default_iw, result_alloc_manager]( Builder& builder, Value* val, Captures& cap, Replacements& replacements) { // Getting the type pointer auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } // Computing the index by getting the current index value and offseting by // the offset at which the qubit array is allocated. auto offset = result_alloc_manager->allocate(); // Creating a new index APInt that is shifted by the offset of the allocation auto idx = llvm::APInt(default_iw, offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto instr = new llvm::IntToPtrInst(new_index, ptr_type); if (instr == nullptr) { return false; } instr->takeName(val); auto orig_instr = llvm::dyn_cast<llvm::Instruction>(val); if (orig_instr == nullptr) { return false; } auto module = orig_instr->getModule(); auto fnc = module->getFunction(\"__quantum__qis__mz__body\"); std::vector<llvm::Value*> arguments; arguments.push_back(cap[\"qubit\"]); arguments.push_back(instr); if (!fnc) { std::vector<llvm::Type*> types; types.resize(arguments.size()); for (uint64_t i = 0; i < types.size(); ++i) { types[i] = arguments[i]->getType(); } auto return_type = llvm::Type::getVoidTy(val->getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create( fnc_type, llvm::Function::ExternalLinkage, \"__quantum__qis__mz__body\", module); } // Ensuring we are inserting after the instruction being deleted builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(val)->getNextNode()); builder.CreateCall(fnc, arguments); // Replacing the instruction with new instruction replacements.push_back({llvm::dyn_cast<Instruction>(val), instr}); return true; }; // This rules identifies result allocations through the function \"__quantum__qis__m__body\". // As an example, the following // // %result1 = call %Result* @__quantum__qis__m__body(%Qubit* %0) // // translates into // // %result1 = inttoptr i64 0 to %Result* // call void @__quantum__qis__mz__body(%Qubit* %0, %Result* %result1) addRule({call(\"__quantum__qis__m__body\", \"qubit\"_cap = _), std::move(replace_measurement)}); } void RuleFactory::optimizeResultZero() { auto replace_branch_negative = [](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto cond = llvm::dyn_cast<llvm::Instruction>(val); if (cond == nullptr) { return false; } auto result = cap[\"result\"]; // Replacing result auto orig_instr = llvm::dyn_cast<llvm::Instruction>(val); if (orig_instr == nullptr) { return false; } auto module = orig_instr->getModule(); auto fnc = module->getFunction(\"__quantum__qis__read_result__body\"); std::vector<llvm::Value*> arguments; arguments.push_back(result); if (!fnc) { std::vector<llvm::Type*> types; types.resize(arguments.size()); for (uint64_t i = 0; i < types.size(); ++i) { types[i] = arguments[i]->getType(); } auto return_type = llvm::Type::getInt1Ty(val->getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create( fnc_type, llvm::Function::ExternalLinkage, \"__quantum__qis__read_result__body\", module); } builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(val)); auto new_call = builder.CreateCall(fnc, arguments); auto new_cond = builder.CreateNot(new_call); new_cond->takeName(cond); for (auto& use : cond->uses()) { llvm::User* user = use.getUser(); user->setOperand(use.getOperandNo(), new_cond); } cond->replaceAllUsesWith(new_cond); // Deleting the previous condition and function to fetch one replacements.push_back({cond, nullptr}); replacements.push_back({cap[\"zero\"], nullptr}); return true; }; /* Here is an example IR for which we want to make a match: %1 = call %Result* @__quantum__rt__result_get_zero() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 */ // Variations of get_one auto get_zero = call(\"__quantum__rt__result_get_zero\"); addRule( {call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"zero\"_cap = get_zero), replace_branch_negative}); addRule( {call(\"__quantum__rt__result_equal\", \"zero\"_cap = get_zero, \"result\"_cap = _), replace_branch_negative}); } void RuleFactory::optimizeResultOne() { auto replace_branch_positive = [](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto cond = llvm::dyn_cast<llvm::Instruction>(val); if (cond == nullptr) { return false; } auto result = cap[\"result\"]; // Replacing result auto orig_instr = llvm::dyn_cast<llvm::Instruction>(val); if (orig_instr == nullptr) { return false; } auto module = orig_instr->getModule(); auto fnc = module->getFunction(\"__quantum__qis__read_result__body\"); std::vector<llvm::Value*> arguments; arguments.push_back(result); if (!fnc) { std::vector<llvm::Type*> types; types.resize(arguments.size()); for (uint64_t i = 0; i < types.size(); ++i) { types[i] = arguments[i]->getType(); } auto return_type = llvm::Type::getInt1Ty(val->getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create( fnc_type, llvm::Function::ExternalLinkage, \"__quantum__qis__read_result__body\", module); } builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(val)); auto new_call = builder.CreateCall(fnc, arguments); new_call->takeName(cond); for (auto& use : cond->uses()) { llvm::User* user = use.getUser(); user->setOperand(use.getOperandNo(), new_call); } cond->replaceAllUsesWith(new_call); // Deleting the previous condition and function to fetch one replacements.push_back({cond, nullptr}); replacements.push_back({cap[\"one\"], nullptr}); return true; }; /* Here is an example IR for which we want to make a match: %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 */ // Variations of get_one auto get_one = call(\"__quantum__rt__result_get_one\"); addRule({call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), replace_branch_positive}); addRule({call(\"__quantum__rt__result_equal\", \"one\"_cap = get_one, \"result\"_cap = _), replace_branch_positive}); } void RuleFactory::disableReferenceCounting() { removeFunctionCall(\"__quantum__rt__array_update_reference_count\"); removeFunctionCall(\"__quantum__rt__string_update_reference_count\"); removeFunctionCall(\"__quantum__rt__result_update_reference_count\"); } void RuleFactory::disableAliasCounting() { removeFunctionCall(\"__quantum__rt__array_update_alias_count\"); removeFunctionCall(\"__quantum__rt__string_update_alias_count\"); removeFunctionCall(\"__quantum__rt__result_update_alias_count\"); } void RuleFactory::disableStringSupport() { removeFunctionCall(\"__quantum__rt__fail\"); removeFunctionCall(\"__quantum__rt__message\"); removeFunctionCall(\"__quantum__rt__string_update_alias_count\"); removeFunctionCall(\"__quantum__rt__string_create\"); removeFunctionCall(\"__quantum__rt__string_get_data\"); removeFunctionCall(\"__quantum__rt__string_get_length\"); removeFunctionCall(\"__quantum__rt__string_update_reference_count\"); removeFunctionCall(\"__quantum__rt__string_concatenate\"); removeFunctionCall(\"__quantum__rt__string_equal\"); removeFunctionCall(\"__quantum__rt__int_to_string\"); removeFunctionCall(\"__quantum__rt__double_to_string\"); removeFunctionCall(\"__quantum__rt__bool_to_string\"); removeFunctionCall(\"__quantum__rt__result_to_string\"); removeFunctionCall(\"__quantum__rt__pauli_to_string\"); removeFunctionCall(\"__quantum__rt__qubit_to_string\"); removeFunctionCall(\"__quantum__rt__range_to_string\"); removeFunctionCall(\"__quantum__rt__bigint_to_string\"); } ReplacementRulePtr RuleFactory::addRule(ReplacementRule&& rule) { auto ret = std::make_shared<ReplacementRule>(std::move(rule)); rule_set_.addRule(ret); return ret; } void RuleFactory::setDefaultIntegerWidth(uint32_t v) { default_integer_width_ = v; } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Factory.cpp"},{"location":"Api/Files/_factory_8cpp/#rulesfactorycpp","text":"","title":"Rules/Factory.cpp"},{"location":"Api/Files/_factory_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_factory_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Factory.hpp\" #include \"Rules/Notation/Notation.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { namespace { using Instruction = llvm::Instruction; using Value = llvm::Value; using Builder = ReplacementRule::Builder; using Captures = ReplacementRule::Captures; using Replacements = ReplacementRule::Replacements; } // namespace using ReplacementRulePtr = RuleFactory::ReplacementRulePtr; using namespace microsoft::quantum::notation; RuleFactory::RuleFactory( RuleSet& rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager) : rule_set_{rule_set} , qubit_alloc_manager_{std::move(qubit_alloc_manager)} , result_alloc_manager_{std::move(result_alloc_manager)} { } void RuleFactory::usingConfiguration(FactoryConfiguration const& config) { default_integer_width_ = config.defaultIntegerWidth(); if (config.disableReferenceCounting()) { disableReferenceCounting(); } if (config.disableAliasCounting()) { disableAliasCounting(); } if (config.disableStringSupport()) { disableStringSupport(); } if (config.optimizeResultOne()) { optimizeResultOne(); } if (config.optimizeResultZero()) { optimizeResultZero(); } if (config.useStaticQubitArrayAllocation()) { useStaticQubitArrayAllocation(); } if (config.useStaticQubitAllocation()) { useStaticQubitAllocation(); } if (config.useStaticResultAllocation()) { useStaticResultAllocation(); } } void RuleFactory::removeFunctionCall(String const& name) { addRule({callByNameOnly(name), deleteInstruction()}); } void RuleFactory::resolveConstantArraySizes() { auto size_replacer = [](Builder&, Value* val, Captures& cap, Replacements& replacements) { // Get the index and testing that it is a constant int auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"size\"]); if (cst == nullptr) { // ... if not, we cannot perform the mapping. return false; } val->replaceAllUsesWith(cst); replacements.push_back({llvm::dyn_cast<Instruction>(val), nullptr}); return true; }; auto create_array = call(\"__quantum__rt__array_create_1d\", \"elementSize\"_cap = _, \"size\"_cap = _); auto get_size = call(\"__quantum__rt__array_get_size_1d\", create_array); addRule({std::move(get_size), size_replacer}); } void RuleFactory::inlineCallables() { auto callable_replacer = [](Builder&, Value* val, Captures& captures, Replacements&) { llvm::errs() << \"FOUND CALLABLE\\n\"; llvm::errs() << *val << \"\\n\"; llvm::errs() << \"Calling \" << *captures[\"function\"] << \"\\n\"; return false; }; auto create_callable = call(\"__quantum__rt__callable_create\", \"function\"_cap = _, \"size\"_cap = _, _); auto invoke = call(\"__quantum__rt__callable_invoke\", create_callable, \"args\"_cap = _, \"ret\"_cap = _); addRule({std::move(invoke), callable_replacer}); } void RuleFactory::useStaticQubitArrayAllocation() { // TODO(issue-14): Use weak pointers to capture allocation managers auto qubit_alloc_manager = qubit_alloc_manager_; auto default_iw = default_integer_width_; auto allocation_replacer = [default_iw, qubit_alloc_manager](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"size\"]); if (cst == nullptr) { return false; } auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } if (cst == nullptr) { return false; } auto llvm_size = cst->getValue(); auto name = val->getName().str(); auto size = llvm_size.getZExtValue(); auto offset = qubit_alloc_manager->allocate(name, size); // Creating a new index APInt that is shifted by the offset of the allocation auto idx = llvm::APInt(default_iw, offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); // Replacing the instruction with new instruction auto old_instr = llvm::dyn_cast<Instruction>(val); // Safety precaution to ensure that we are dealing with a Instruction if (old_instr == nullptr) { return false; } auto instr = new llvm::IntToPtrInst(new_index, ptr_type); instr->takeName(old_instr); // Ensuring that we have replaced the instruction before // identifying release old_instr->replaceAllUsesWith(instr); replacements.push_back({old_instr, instr}); return true; }; addRule({call(\"__quantum__rt__qubit_allocate_array\", \"size\"_cap = _), allocation_replacer}); auto access_replacer = [qubit_alloc_manager](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { // Getting the type pointer auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } // Get the index and testing that it is a constant int auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"index\"]); if (cst == nullptr) { // ... if not, we cannot perform the mapping. return false; } // Computing the index by getting the current index value and offsetting by // the offset at which the qubit array is allocated. auto offset_cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"arrayName\"]); if (offset_cst == nullptr) { return false; } auto llvm_offset = offset_cst->getValue(); auto offset = llvm_offset.getZExtValue(); // Creating a new index APInt that is shifted by the offset of the allocation auto llvm_size = cst->getValue(); auto idx = llvm::APInt(llvm_size.getBitWidth(), llvm_size.getZExtValue() + offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto old_instr = llvm::dyn_cast<Instruction>(val); if (old_instr == nullptr) { return false; } // Converting pointer builder.SetInsertPoint(old_instr->getNextNode()); auto instr = builder.CreateIntToPtr(new_index, ptr_type); instr->takeName(old_instr); old_instr->replaceAllUsesWith(instr); // Replacing the instruction with new instruction replacements.push_back({old_instr, nullptr}); // Deleting the getelement and cast operations replacements.push_back({llvm::dyn_cast<Instruction>(cap[\"getElement\"]), nullptr}); replacements.push_back({llvm::dyn_cast<Instruction>(cap[\"cast\"]), nullptr}); return true; }; auto get_element = call( \"__quantum__rt__array_get_element_ptr_1d\", intToPtr(\"arrayName\"_cap = constInt()), \"index\"_cap = constInt()); auto cast_pattern = bitCast(\"getElement\"_cap = get_element); auto load_pattern = load(\"cast\"_cap = cast_pattern); addRule({\"Array Load Pattern\", std::move(load_pattern), access_replacer}); auto deleter = deleteInstruction(); addRule( {call(\"__quantum__rt__qubit_release_array\", intToPtr(\"const\"_cap = constInt())), [qubit_alloc_manager, deleter](Builder& builder, Value* val, Captures& cap, Replacements& rep) { // Recovering the qubit id auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"const\"]); if (cst == nullptr) { return false; } auto address = cst->getValue().getZExtValue(); // Releasing qubit_alloc_manager->release(address); // Deleting instruction return deleter(builder, val, cap, rep); }}); } void RuleFactory::useStaticQubitAllocation() { auto qubit_alloc_manager = qubit_alloc_manager_; auto default_iw = default_integer_width_; auto allocation_replacer = [default_iw, qubit_alloc_manager](Builder& builder, Value* val, Captures&, Replacements& replacements) { // Getting the type pointer auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } auto qubit_name = val->getName().str(); // Computing the index by getting the current index value and offseting by // the offset at which the qubit array is allocated. auto offset = qubit_alloc_manager->allocate(qubit_name); // Creating a new index APInt that is shifted by the offset of the allocation auto idx = llvm::APInt(default_iw, offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto instr = new llvm::IntToPtrInst(new_index, ptr_type); // Replacing the instruction with new instruction auto old_instr = llvm::dyn_cast<Instruction>(val); // Safety precaution to ensure that we are dealing with a Instruction if (old_instr == nullptr) { return false; } instr->takeName(old_instr); // Ensuring that we have replaced the instruction before // identifying release old_instr->replaceAllUsesWith(instr); replacements.push_back({old_instr, instr}); return true; }; // Dealing with qubit allocation addRule({call(\"__quantum__rt__qubit_allocate\"), allocation_replacer}); auto deleter = deleteInstruction(); // Handling the case where a constant integer is cast to a pointer and the pointer // is used in a call to qubit_release: // // %0 = inttoptr i64 0 to %Qubit* // call void @__quantum__rt__qubit_release(%Qubit* %0 // // The case of named addresses are also covered, by this pattern: // %leftMessage = inttoptr i64 0 to %Qubit* // call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) addRule( {call(\"__quantum__rt__qubit_release\", intToPtr(\"const\"_cap = constInt())), [qubit_alloc_manager, deleter](Builder& builder, Value* val, Captures& cap, Replacements& rep) { // Recovering the qubit id auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"const\"]); if (cst == nullptr) { return false; } auto address = cst->getValue().getZExtValue(); // Releasing qubit_alloc_manager->release(address); // Deleting instruction return deleter(builder, val, cap, rep); }}); // Handling where allocation is done by non-standard functions. In // this rule reports an error as we cannot reliably do a mapping. // // %leftMessage = call %Qubit* @__non_standard_allocator() // call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) addRule( {call(\"__quantum__rt__qubit_release\", \"name\"_cap = _), [qubit_alloc_manager, deleter](Builder& builder, Value* val, Captures& cap, Replacements& rep) { // Getting the name auto name = cap[\"name\"]->getName().str(); auto* phi_node = llvm::dyn_cast<llvm::PHINode>(cap[\"name\"]); if (phi_node != nullptr) { llvm::errs() << \"Warning: Cannot release qubit arising from phi node:\\n\"; llvm::errs() << *val << \"\\n\\n\"; return false; } // Returning in case the name comes out empty if (name.empty()) { // TODO(issue-15): report error llvm::errs() << \"FAILED due to unnamed non standard allocation:\\n\"; llvm::errs() << *val << \"\\n\\n\"; // Deleting the instruction in order to proceed // and trying to discover as many other errors as possible return deleter(builder, val, cap, rep); } // TODO(issue-15): report error llvm::errs() << \"FAILED due to non standard allocation:\\n\"; llvm::errs() << *cap[\"name\"] << \"\\n\"; llvm::errs() << *val << \"\\n\\n\"; return deleter(builder, val, cap, rep); } }); } void RuleFactory::useStaticResultAllocation() { auto result_alloc_manager = result_alloc_manager_; auto default_iw = default_integer_width_; auto replace_measurement = [default_iw, result_alloc_manager]( Builder& builder, Value* val, Captures& cap, Replacements& replacements) { // Getting the type pointer auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } // Computing the index by getting the current index value and offseting by // the offset at which the qubit array is allocated. auto offset = result_alloc_manager->allocate(); // Creating a new index APInt that is shifted by the offset of the allocation auto idx = llvm::APInt(default_iw, offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto instr = new llvm::IntToPtrInst(new_index, ptr_type); if (instr == nullptr) { return false; } instr->takeName(val); auto orig_instr = llvm::dyn_cast<llvm::Instruction>(val); if (orig_instr == nullptr) { return false; } auto module = orig_instr->getModule(); auto fnc = module->getFunction(\"__quantum__qis__mz__body\"); std::vector<llvm::Value*> arguments; arguments.push_back(cap[\"qubit\"]); arguments.push_back(instr); if (!fnc) { std::vector<llvm::Type*> types; types.resize(arguments.size()); for (uint64_t i = 0; i < types.size(); ++i) { types[i] = arguments[i]->getType(); } auto return_type = llvm::Type::getVoidTy(val->getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create( fnc_type, llvm::Function::ExternalLinkage, \"__quantum__qis__mz__body\", module); } // Ensuring we are inserting after the instruction being deleted builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(val)->getNextNode()); builder.CreateCall(fnc, arguments); // Replacing the instruction with new instruction replacements.push_back({llvm::dyn_cast<Instruction>(val), instr}); return true; }; // This rules identifies result allocations through the function \"__quantum__qis__m__body\". // As an example, the following // // %result1 = call %Result* @__quantum__qis__m__body(%Qubit* %0) // // translates into // // %result1 = inttoptr i64 0 to %Result* // call void @__quantum__qis__mz__body(%Qubit* %0, %Result* %result1) addRule({call(\"__quantum__qis__m__body\", \"qubit\"_cap = _), std::move(replace_measurement)}); } void RuleFactory::optimizeResultZero() { auto replace_branch_negative = [](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto cond = llvm::dyn_cast<llvm::Instruction>(val); if (cond == nullptr) { return false; } auto result = cap[\"result\"]; // Replacing result auto orig_instr = llvm::dyn_cast<llvm::Instruction>(val); if (orig_instr == nullptr) { return false; } auto module = orig_instr->getModule(); auto fnc = module->getFunction(\"__quantum__qis__read_result__body\"); std::vector<llvm::Value*> arguments; arguments.push_back(result); if (!fnc) { std::vector<llvm::Type*> types; types.resize(arguments.size()); for (uint64_t i = 0; i < types.size(); ++i) { types[i] = arguments[i]->getType(); } auto return_type = llvm::Type::getInt1Ty(val->getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create( fnc_type, llvm::Function::ExternalLinkage, \"__quantum__qis__read_result__body\", module); } builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(val)); auto new_call = builder.CreateCall(fnc, arguments); auto new_cond = builder.CreateNot(new_call); new_cond->takeName(cond); for (auto& use : cond->uses()) { llvm::User* user = use.getUser(); user->setOperand(use.getOperandNo(), new_cond); } cond->replaceAllUsesWith(new_cond); // Deleting the previous condition and function to fetch one replacements.push_back({cond, nullptr}); replacements.push_back({cap[\"zero\"], nullptr}); return true; }; /* Here is an example IR for which we want to make a match: %1 = call %Result* @__quantum__rt__result_get_zero() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 */ // Variations of get_one auto get_zero = call(\"__quantum__rt__result_get_zero\"); addRule( {call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"zero\"_cap = get_zero), replace_branch_negative}); addRule( {call(\"__quantum__rt__result_equal\", \"zero\"_cap = get_zero, \"result\"_cap = _), replace_branch_negative}); } void RuleFactory::optimizeResultOne() { auto replace_branch_positive = [](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto cond = llvm::dyn_cast<llvm::Instruction>(val); if (cond == nullptr) { return false; } auto result = cap[\"result\"]; // Replacing result auto orig_instr = llvm::dyn_cast<llvm::Instruction>(val); if (orig_instr == nullptr) { return false; } auto module = orig_instr->getModule(); auto fnc = module->getFunction(\"__quantum__qis__read_result__body\"); std::vector<llvm::Value*> arguments; arguments.push_back(result); if (!fnc) { std::vector<llvm::Type*> types; types.resize(arguments.size()); for (uint64_t i = 0; i < types.size(); ++i) { types[i] = arguments[i]->getType(); } auto return_type = llvm::Type::getInt1Ty(val->getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create( fnc_type, llvm::Function::ExternalLinkage, \"__quantum__qis__read_result__body\", module); } builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(val)); auto new_call = builder.CreateCall(fnc, arguments); new_call->takeName(cond); for (auto& use : cond->uses()) { llvm::User* user = use.getUser(); user->setOperand(use.getOperandNo(), new_call); } cond->replaceAllUsesWith(new_call); // Deleting the previous condition and function to fetch one replacements.push_back({cond, nullptr}); replacements.push_back({cap[\"one\"], nullptr}); return true; }; /* Here is an example IR for which we want to make a match: %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 */ // Variations of get_one auto get_one = call(\"__quantum__rt__result_get_one\"); addRule({call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), replace_branch_positive}); addRule({call(\"__quantum__rt__result_equal\", \"one\"_cap = get_one, \"result\"_cap = _), replace_branch_positive}); } void RuleFactory::disableReferenceCounting() { removeFunctionCall(\"__quantum__rt__array_update_reference_count\"); removeFunctionCall(\"__quantum__rt__string_update_reference_count\"); removeFunctionCall(\"__quantum__rt__result_update_reference_count\"); } void RuleFactory::disableAliasCounting() { removeFunctionCall(\"__quantum__rt__array_update_alias_count\"); removeFunctionCall(\"__quantum__rt__string_update_alias_count\"); removeFunctionCall(\"__quantum__rt__result_update_alias_count\"); } void RuleFactory::disableStringSupport() { removeFunctionCall(\"__quantum__rt__fail\"); removeFunctionCall(\"__quantum__rt__message\"); removeFunctionCall(\"__quantum__rt__string_update_alias_count\"); removeFunctionCall(\"__quantum__rt__string_create\"); removeFunctionCall(\"__quantum__rt__string_get_data\"); removeFunctionCall(\"__quantum__rt__string_get_length\"); removeFunctionCall(\"__quantum__rt__string_update_reference_count\"); removeFunctionCall(\"__quantum__rt__string_concatenate\"); removeFunctionCall(\"__quantum__rt__string_equal\"); removeFunctionCall(\"__quantum__rt__int_to_string\"); removeFunctionCall(\"__quantum__rt__double_to_string\"); removeFunctionCall(\"__quantum__rt__bool_to_string\"); removeFunctionCall(\"__quantum__rt__result_to_string\"); removeFunctionCall(\"__quantum__rt__pauli_to_string\"); removeFunctionCall(\"__quantum__rt__qubit_to_string\"); removeFunctionCall(\"__quantum__rt__range_to_string\"); removeFunctionCall(\"__quantum__rt__bigint_to_string\"); } ReplacementRulePtr RuleFactory::addRule(ReplacementRule&& rule) { auto ret = std::make_shared<ReplacementRule>(std::move(rule)); rule_set_.addRule(ret); return ret; } void RuleFactory::setDefaultIntegerWidth(uint32_t v) { default_integer_width_ = v; } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_factory_8hpp/","text":"Rules/Factory.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::RuleFactory Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/AllocationManager.hpp\" #include \"Commandline/ConfigurationManager.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Rules/FactoryConfig.hpp\" #include \"Rules/ReplacementRule.hpp\" #include \"Rules/RuleSet.hpp\" #include \"Llvm/Llvm.hpp\" #include <memory> namespace microsoft { namespace quantum { class RuleFactory { public: using ReplacementRulePtr = std::shared_ptr<ReplacementRule>; using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; // Constructor configuration. Explicit construction with // rule set to be configured, which can be moved using move // semantics. No copy allowed. // RuleFactory( RuleSet& rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager); RuleFactory() = delete; RuleFactory(RuleFactory const&) = delete; RuleFactory(RuleFactory&&) = default; ~RuleFactory() = default; // // void usingConfiguration(FactoryConfiguration const& config); // Generic rules // void removeFunctionCall(String const& name); // Conventions // void useStaticQubitArrayAllocation(); void useStaticQubitAllocation(); void useStaticResultAllocation(); void resolveConstantArraySizes(); void inlineCallables(); // Optimizations // void optimizeResultOne(); void optimizeResultZero(); // Disabling by feature // void disableReferenceCounting(); void disableAliasCounting(); void disableStringSupport(); // Configuration // void setDefaultIntegerWidth(uint32_t v); private: ReplacementRulePtr addRule(ReplacementRule&& rule); // Affected artefacts // RuleSet& rule_set_; // Allocation managers. // AllocationManagerPtr qubit_alloc_manager_{nullptr}; AllocationManagerPtr result_alloc_manager_{nullptr}; // uint32_t default_integer_width_{64}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Factory.hpp"},{"location":"Api/Files/_factory_8hpp/#rulesfactoryhpp","text":"","title":"Rules/Factory.hpp"},{"location":"Api/Files/_factory_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_factory_8hpp/#classes","text":"Name class microsoft::quantum::RuleFactory","title":"Classes"},{"location":"Api/Files/_factory_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/AllocationManager.hpp\" #include \"Commandline/ConfigurationManager.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Rules/FactoryConfig.hpp\" #include \"Rules/ReplacementRule.hpp\" #include \"Rules/RuleSet.hpp\" #include \"Llvm/Llvm.hpp\" #include <memory> namespace microsoft { namespace quantum { class RuleFactory { public: using ReplacementRulePtr = std::shared_ptr<ReplacementRule>; using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; // Constructor configuration. Explicit construction with // rule set to be configured, which can be moved using move // semantics. No copy allowed. // RuleFactory( RuleSet& rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager); RuleFactory() = delete; RuleFactory(RuleFactory const&) = delete; RuleFactory(RuleFactory&&) = default; ~RuleFactory() = default; // // void usingConfiguration(FactoryConfiguration const& config); // Generic rules // void removeFunctionCall(String const& name); // Conventions // void useStaticQubitArrayAllocation(); void useStaticQubitAllocation(); void useStaticResultAllocation(); void resolveConstantArraySizes(); void inlineCallables(); // Optimizations // void optimizeResultOne(); void optimizeResultZero(); // Disabling by feature // void disableReferenceCounting(); void disableAliasCounting(); void disableStringSupport(); // Configuration // void setDefaultIntegerWidth(uint32_t v); private: ReplacementRulePtr addRule(ReplacementRule&& rule); // Affected artefacts // RuleSet& rule_set_; // Allocation managers. // AllocationManagerPtr qubit_alloc_manager_{nullptr}; AllocationManagerPtr result_alloc_manager_{nullptr}; // uint32_t default_integer_width_{64}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_factory_config_8hpp/","text":"Rules/FactoryConfig.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::FactoryConfiguration Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" namespace microsoft { namespace quantum { class FactoryConfiguration { public: void setup(ConfigurationManager& config) { config.setSectionName(\"Transformation rules\", \"Rules used to transform instruction sequences in the QIR.\"); config.addParameter( optimize_result_one_, true, \"optimize-result-one\", \"Maps branching based on quantum measurements compared to one to base profile \" \"type measurement.\"); config.addParameter( optimize_result_zero_, true, \"optimize-result-zero\", \"Maps branching based on quantum measurements compared to zero to base profile \" \"type measurement.\"); config.addParameter( use_static_qubit_array_allocation_, \"use-static-qubit-array-allocation\", \"Maps allocation of qubit arrays to static array allocation.\"); config.addParameter( use_static_qubit_allocation_, \"use-static-qubit-allocation\", \"Maps qubit allocation to static allocation.\"); config.addParameter( use_static_result_allocation_, \"use-static-result-allocation\", \"Maps result allocation to static allocation.\"); config.addParameter( disable_reference_counting_, true, \"disable-reference-counting\", \"Disables reference counting by instruction removal.\"); config.addParameter( disable_alias_counting_, true, \"disable-alias-counting\", \"Disables alias counting by instruction removal.\"); config.addParameter( disable_string_support_, true, \"disable-string-support\", \"Disables string support by instruction removal.\"); } static FactoryConfiguration createDisabled() { FactoryConfiguration ret; ret.disable_reference_counting_ = false; ret.disable_alias_counting_ = false; ret.disable_string_support_ = false; ret.optimize_result_one_ = false; ret.optimize_result_zero_ = false; ret.use_static_qubit_array_allocation_ = false; ret.use_static_qubit_allocation_ = false; ret.use_static_result_allocation_ = false; return ret; } bool disableReferenceCounting() const { return disable_reference_counting_; } bool disableAliasCounting() const { return disable_alias_counting_; } bool disableStringSupport() const { return disable_string_support_; } bool optimizeResultOne() const { return optimize_result_one_; } bool optimizeResultZero() const { return optimize_result_zero_; } bool useStaticQubitArrayAllocation() const { return use_static_qubit_array_allocation_; } bool useStaticQubitAllocation() const { return use_static_qubit_allocation_; } bool useStaticResultAllocation() const { return use_static_result_allocation_; } uint32_t defaultIntegerWidth() const { return default_integer_width_; } bool isDisabled() const { return ( disable_reference_counting_ == false && disable_alias_counting_ == false && disable_string_support_ == false && optimize_result_one_ == false && optimize_result_zero_ == false && use_static_qubit_array_allocation_ == false && use_static_qubit_allocation_ == false && use_static_result_allocation_ == false); } bool isDefault() const { FactoryConfiguration ref{}; return ( disable_reference_counting_ == ref.disable_reference_counting_ && disable_alias_counting_ == ref.disable_alias_counting_ && disable_string_support_ == ref.disable_string_support_ && optimize_result_one_ == ref.optimize_result_one_ && optimize_result_zero_ == ref.optimize_result_zero_ && use_static_qubit_array_allocation_ == ref.use_static_qubit_array_allocation_ && use_static_qubit_allocation_ == ref.use_static_qubit_allocation_ && use_static_result_allocation_ == ref.use_static_result_allocation_); } private: bool disable_reference_counting_{true}; bool disable_alias_counting_{true}; bool disable_string_support_{true}; bool optimize_result_one_{true}; bool optimize_result_zero_{true}; bool use_static_qubit_array_allocation_{true}; bool use_static_qubit_allocation_{true}; bool use_static_result_allocation_{true}; uint32_t default_integer_width_{64}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/FactoryConfig.hpp"},{"location":"Api/Files/_factory_config_8hpp/#rulesfactoryconfighpp","text":"","title":"Rules/FactoryConfig.hpp"},{"location":"Api/Files/_factory_config_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_factory_config_8hpp/#classes","text":"Name class microsoft::quantum::FactoryConfiguration","title":"Classes"},{"location":"Api/Files/_factory_config_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" namespace microsoft { namespace quantum { class FactoryConfiguration { public: void setup(ConfigurationManager& config) { config.setSectionName(\"Transformation rules\", \"Rules used to transform instruction sequences in the QIR.\"); config.addParameter( optimize_result_one_, true, \"optimize-result-one\", \"Maps branching based on quantum measurements compared to one to base profile \" \"type measurement.\"); config.addParameter( optimize_result_zero_, true, \"optimize-result-zero\", \"Maps branching based on quantum measurements compared to zero to base profile \" \"type measurement.\"); config.addParameter( use_static_qubit_array_allocation_, \"use-static-qubit-array-allocation\", \"Maps allocation of qubit arrays to static array allocation.\"); config.addParameter( use_static_qubit_allocation_, \"use-static-qubit-allocation\", \"Maps qubit allocation to static allocation.\"); config.addParameter( use_static_result_allocation_, \"use-static-result-allocation\", \"Maps result allocation to static allocation.\"); config.addParameter( disable_reference_counting_, true, \"disable-reference-counting\", \"Disables reference counting by instruction removal.\"); config.addParameter( disable_alias_counting_, true, \"disable-alias-counting\", \"Disables alias counting by instruction removal.\"); config.addParameter( disable_string_support_, true, \"disable-string-support\", \"Disables string support by instruction removal.\"); } static FactoryConfiguration createDisabled() { FactoryConfiguration ret; ret.disable_reference_counting_ = false; ret.disable_alias_counting_ = false; ret.disable_string_support_ = false; ret.optimize_result_one_ = false; ret.optimize_result_zero_ = false; ret.use_static_qubit_array_allocation_ = false; ret.use_static_qubit_allocation_ = false; ret.use_static_result_allocation_ = false; return ret; } bool disableReferenceCounting() const { return disable_reference_counting_; } bool disableAliasCounting() const { return disable_alias_counting_; } bool disableStringSupport() const { return disable_string_support_; } bool optimizeResultOne() const { return optimize_result_one_; } bool optimizeResultZero() const { return optimize_result_zero_; } bool useStaticQubitArrayAllocation() const { return use_static_qubit_array_allocation_; } bool useStaticQubitAllocation() const { return use_static_qubit_allocation_; } bool useStaticResultAllocation() const { return use_static_result_allocation_; } uint32_t defaultIntegerWidth() const { return default_integer_width_; } bool isDisabled() const { return ( disable_reference_counting_ == false && disable_alias_counting_ == false && disable_string_support_ == false && optimize_result_one_ == false && optimize_result_zero_ == false && use_static_qubit_array_allocation_ == false && use_static_qubit_allocation_ == false && use_static_result_allocation_ == false); } bool isDefault() const { FactoryConfiguration ref{}; return ( disable_reference_counting_ == ref.disable_reference_counting_ && disable_alias_counting_ == ref.disable_alias_counting_ && disable_string_support_ == ref.disable_string_support_ && optimize_result_one_ == ref.optimize_result_one_ && optimize_result_zero_ == ref.optimize_result_zero_ && use_static_qubit_array_allocation_ == ref.use_static_qubit_array_allocation_ && use_static_qubit_allocation_ == ref.use_static_qubit_allocation_ && use_static_result_allocation_ == ref.use_static_result_allocation_); } private: bool disable_reference_counting_{true}; bool disable_alias_counting_{true}; bool disable_string_support_{true}; bool optimize_result_one_{true}; bool optimize_result_zero_{true}; bool use_static_qubit_array_allocation_{true}; bool use_static_qubit_allocation_{true}; bool use_static_result_allocation_{true}; uint32_t default_integer_width_{64}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_grouping_analysis_pass_8cpp/","text":"GroupingPass/GroupingAnalysisPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"GroupingPass/GroupingAnalysisPass.hpp\" #include \"Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft { namespace quantum { String const GroupingAnalysisPass::QIS_START = \"__quantum\" \"__qis_\"; String const GroupingAnalysisPass::READ_INSTR_START = \"__quantum\" \"__qis__read_\"; llvm::AnalysisKey GroupingAnalysisPass::Key; void GroupingAnalysisPass::runBlockAnalysis(llvm::Module& module) { for (auto& function : module) { for (auto& block : function) { bool pure_quantum = true; bool pure_measurement = true; // Classifying the blocks for (auto& instr : block) { auto call_instr = llvm::dyn_cast<llvm::CallBase>(&instr); if (call_instr != nullptr) { auto f = call_instr->getCalledFunction(); if (f == nullptr) { continue; } auto name = static_cast<std::string>(f->getName()); bool is_quantum = (name.size() >= QIS_START.size() && name.substr(0, QIS_START.size()) == QIS_START); bool is_measurement = (name.size() >= READ_INSTR_START.size() && name.substr(0, READ_INSTR_START.size()) == READ_INSTR_START); if (is_measurement) { contains_quantum_measurement_.insert(&block); } if (is_quantum) { contains_quantum_circuit_.insert(&block); } pure_measurement = pure_measurement && is_measurement; pure_quantum = pure_quantum && is_quantum && !is_measurement; } else { // Any other instruction is makes the block non-pure pure_quantum = false; pure_measurement = false; } } if (pure_quantum) { pure_quantum_instructions_.insert(&block); } if (pure_measurement) { pure_quantum_measurement_.insert(&block); } } } } GroupingAnalysisPass::Result GroupingAnalysisPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { // Preparing analysis contains_quantum_circuit_.clear(); contains_quantum_measurement_.clear(); pure_quantum_instructions_.clear(); pure_quantum_measurement_.clear(); // Classifying each of the blocks runBlockAnalysis(module); GroupAnalysis ret; for (auto& function : module) { for (auto& block : function) { bool is_pure_quantum = pure_quantum_instructions_.find(&block) != pure_quantum_instructions_.end(); bool is_pure_measurement = pure_quantum_measurement_.find(&block) != pure_quantum_measurement_.end(); // Pure blocks are ignored if (is_pure_quantum || is_pure_measurement) { continue; } bool has_quantum = contains_quantum_circuit_.find(&block) != contains_quantum_circuit_.end(); // Pure classical blocks are also ignored if (!has_quantum) { continue; } bool has_measurement = contains_quantum_measurement_.find(&block) != contains_quantum_measurement_.end(); // Differentiating between blocks that has measurements and those that has not if (!has_measurement) { ret.qc_cc_blocks.push_back(&block); } else { ret.qc_mc_cc_blocks.push_back(&block); } } } return ret; } bool GroupingAnalysisPass::isRequired() { return true; } llvm::PreservedAnalyses GroupingAnalysisPassPrinter::run(llvm::Module& module, llvm::ModuleAnalysisManager& mam) { auto& result = mam.getResult<GroupingAnalysisPass>(module); llvm::errs() << result.qc_cc_blocks.size() << \" qc cc blocks.\\n\"; llvm::errs() << result.qc_mc_cc_blocks.size() << \" qc mc cc blocks.\\n\"; return llvm::PreservedAnalyses::all(); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"GroupingPass/GroupingAnalysisPass.cpp"},{"location":"Api/Files/_grouping_analysis_pass_8cpp/#groupingpassgroupinganalysispasscpp","text":"","title":"GroupingPass/GroupingAnalysisPass.cpp"},{"location":"Api/Files/_grouping_analysis_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_grouping_analysis_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"GroupingPass/GroupingAnalysisPass.hpp\" #include \"Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft { namespace quantum { String const GroupingAnalysisPass::QIS_START = \"__quantum\" \"__qis_\"; String const GroupingAnalysisPass::READ_INSTR_START = \"__quantum\" \"__qis__read_\"; llvm::AnalysisKey GroupingAnalysisPass::Key; void GroupingAnalysisPass::runBlockAnalysis(llvm::Module& module) { for (auto& function : module) { for (auto& block : function) { bool pure_quantum = true; bool pure_measurement = true; // Classifying the blocks for (auto& instr : block) { auto call_instr = llvm::dyn_cast<llvm::CallBase>(&instr); if (call_instr != nullptr) { auto f = call_instr->getCalledFunction(); if (f == nullptr) { continue; } auto name = static_cast<std::string>(f->getName()); bool is_quantum = (name.size() >= QIS_START.size() && name.substr(0, QIS_START.size()) == QIS_START); bool is_measurement = (name.size() >= READ_INSTR_START.size() && name.substr(0, READ_INSTR_START.size()) == READ_INSTR_START); if (is_measurement) { contains_quantum_measurement_.insert(&block); } if (is_quantum) { contains_quantum_circuit_.insert(&block); } pure_measurement = pure_measurement && is_measurement; pure_quantum = pure_quantum && is_quantum && !is_measurement; } else { // Any other instruction is makes the block non-pure pure_quantum = false; pure_measurement = false; } } if (pure_quantum) { pure_quantum_instructions_.insert(&block); } if (pure_measurement) { pure_quantum_measurement_.insert(&block); } } } } GroupingAnalysisPass::Result GroupingAnalysisPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { // Preparing analysis contains_quantum_circuit_.clear(); contains_quantum_measurement_.clear(); pure_quantum_instructions_.clear(); pure_quantum_measurement_.clear(); // Classifying each of the blocks runBlockAnalysis(module); GroupAnalysis ret; for (auto& function : module) { for (auto& block : function) { bool is_pure_quantum = pure_quantum_instructions_.find(&block) != pure_quantum_instructions_.end(); bool is_pure_measurement = pure_quantum_measurement_.find(&block) != pure_quantum_measurement_.end(); // Pure blocks are ignored if (is_pure_quantum || is_pure_measurement) { continue; } bool has_quantum = contains_quantum_circuit_.find(&block) != contains_quantum_circuit_.end(); // Pure classical blocks are also ignored if (!has_quantum) { continue; } bool has_measurement = contains_quantum_measurement_.find(&block) != contains_quantum_measurement_.end(); // Differentiating between blocks that has measurements and those that has not if (!has_measurement) { ret.qc_cc_blocks.push_back(&block); } else { ret.qc_mc_cc_blocks.push_back(&block); } } } return ret; } bool GroupingAnalysisPass::isRequired() { return true; } llvm::PreservedAnalyses GroupingAnalysisPassPrinter::run(llvm::Module& module, llvm::ModuleAnalysisManager& mam) { auto& result = mam.getResult<GroupingAnalysisPass>(module); llvm::errs() << result.qc_cc_blocks.size() << \" qc cc blocks.\\n\"; llvm::errs() << result.qc_mc_cc_blocks.size() << \" qc mc cc blocks.\\n\"; return llvm::PreservedAnalyses::all(); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_grouping_analysis_pass_8hpp/","text":"GroupingPass/GroupingAnalysisPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name struct microsoft::quantum::GroupAnalysis class microsoft::quantum::GroupingAnalysisPass class microsoft::quantum::GroupingAnalysisPassPrinter Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"GroupingPass/GroupingPassConfiguration.hpp\" #include \"Logging/ILogger.hpp\" #include \"Profile/Profile.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Llvm/Llvm.hpp\" #include <functional> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft { namespace quantum { struct GroupAnalysis { using BlockList = std::vector<llvm::BasicBlock*>; BlockList qc_cc_blocks{}; BlockList qc_mc_cc_blocks{}; }; class GroupingAnalysisPass : public llvm::AnalysisInfoMixin<GroupingAnalysisPass> { public: using Result = GroupAnalysis; using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = std::shared_ptr<ILogger>; using BlockSet = std::unordered_set<llvm::BasicBlock*>; static String const QIS_START; static String const READ_INSTR_START; // Construction and destruction configuration. // explicit GroupingAnalysisPass(GroupingPassConfiguration const& cfg) : config_{cfg} { } GroupingAnalysisPass(GroupingAnalysisPass const&) = delete; GroupingAnalysisPass(GroupingAnalysisPass&&) = default; ~GroupingAnalysisPass() = default; Result run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); void runBlockAnalysis(llvm::Module& module); static bool isRequired(); private: GroupingPassConfiguration config_{}; // Block classification // BlockSet contains_quantum_circuit_{}; BlockSet contains_quantum_measurement_{}; BlockSet pure_quantum_instructions_{}; BlockSet pure_quantum_measurement_{}; ILoggerPtr logger_{nullptr}; static llvm::AnalysisKey Key; friend struct llvm::AnalysisInfoMixin<GroupingAnalysisPass>; }; class GroupingAnalysisPassPrinter : public llvm::PassInfoMixin<GroupingAnalysisPassPrinter> { public: llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired() { return true; } }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"GroupingPass/GroupingAnalysisPass.hpp"},{"location":"Api/Files/_grouping_analysis_pass_8hpp/#groupingpassgroupinganalysispasshpp","text":"","title":"GroupingPass/GroupingAnalysisPass.hpp"},{"location":"Api/Files/_grouping_analysis_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_grouping_analysis_pass_8hpp/#classes","text":"Name struct microsoft::quantum::GroupAnalysis class microsoft::quantum::GroupingAnalysisPass class microsoft::quantum::GroupingAnalysisPassPrinter","title":"Classes"},{"location":"Api/Files/_grouping_analysis_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"GroupingPass/GroupingPassConfiguration.hpp\" #include \"Logging/ILogger.hpp\" #include \"Profile/Profile.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Llvm/Llvm.hpp\" #include <functional> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft { namespace quantum { struct GroupAnalysis { using BlockList = std::vector<llvm::BasicBlock*>; BlockList qc_cc_blocks{}; BlockList qc_mc_cc_blocks{}; }; class GroupingAnalysisPass : public llvm::AnalysisInfoMixin<GroupingAnalysisPass> { public: using Result = GroupAnalysis; using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = std::shared_ptr<ILogger>; using BlockSet = std::unordered_set<llvm::BasicBlock*>; static String const QIS_START; static String const READ_INSTR_START; // Construction and destruction configuration. // explicit GroupingAnalysisPass(GroupingPassConfiguration const& cfg) : config_{cfg} { } GroupingAnalysisPass(GroupingAnalysisPass const&) = delete; GroupingAnalysisPass(GroupingAnalysisPass&&) = default; ~GroupingAnalysisPass() = default; Result run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); void runBlockAnalysis(llvm::Module& module); static bool isRequired(); private: GroupingPassConfiguration config_{}; // Block classification // BlockSet contains_quantum_circuit_{}; BlockSet contains_quantum_measurement_{}; BlockSet pure_quantum_instructions_{}; BlockSet pure_quantum_measurement_{}; ILoggerPtr logger_{nullptr}; static llvm::AnalysisKey Key; friend struct llvm::AnalysisInfoMixin<GroupingAnalysisPass>; }; class GroupingAnalysisPassPrinter : public llvm::PassInfoMixin<GroupingAnalysisPassPrinter> { public: llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired() { return true; } }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_grouping_pass_8cpp/","text":"GroupingPass/GroupingPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"GroupingPass/GroupingAnalysisPass.hpp\" #include \"GroupingPass/GroupingPass.hpp\" #include \"Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft { namespace quantum { bool GroupingPass::isRequired() { return true; } bool GroupingPass::isQuantumRegister(llvm::Type const* type) { if (type->isPointerTy()) { auto element_type = type->getPointerElementType(); if (element_type->isStructTy()) { auto type_name = static_cast<String const>(element_type->getStructName()); return quantum_register_types_.find(type_name) != quantum_register_types_.end(); } } return false; } int64_t GroupingPass::classifyInstruction(llvm::Instruction const* instr) { int64_t ret = PURE_CLASSICAL; // Checking all operations bool any_quantum = false; bool any_classical = false; bool is_void = instr->getType()->isVoidTy(); bool returns_quantum = isQuantumRegister(instr->getType()); auto call = llvm::dyn_cast<llvm::CallBase>(instr); if (call != nullptr) { for (auto& arg : call->args()) { auto q = isQuantumRegister(arg->getType()); any_quantum |= q; any_classical |= !q; } if (returns_quantum || is_void && !any_classical && any_quantum) { ret |= DEST_QUANTUM; } } else { for (auto& op : instr->operands()) { auto q = isQuantumRegister(op->getType()); any_quantum |= q; any_classical |= !q; } // Setting the destination platform if (returns_quantum) { ret |= DEST_QUANTUM; // If no classical or quantum arguments present, then destination dictates // source if (!any_quantum && !any_classical) { ret |= SOURCE_QUANTUM; } } } if (any_quantum && any_classical) { if (ret != DEST_QUANTUM) { ret = INVALID_MIXED_LOCATION; } } else if (any_quantum) { ret |= SOURCE_QUANTUM; } return ret; } void GroupingPass::prepareSourceSeparation(llvm::Module& module, llvm::BasicBlock* tail_classical) { // Creating replacement blocks auto& context = module.getContext(); post_classical_block_ = llvm::BasicBlock::Create(context, \"post-classical\", tail_classical->getParent(), tail_classical); quantum_block_ = llvm::BasicBlock::Create(context, \"quantum\", tail_classical->getParent(), post_classical_block_); pre_classical_block_ = llvm::BasicBlock::Create(context, \"pre-classical\", tail_classical->getParent(), quantum_block_); // Storing the blocks for later processing quantum_blocks_.push_back(quantum_block_); classical_blocks_.push_back(pre_classical_block_); classical_blocks_.push_back(post_classical_block_); // Renaming the block pre_classical_block_->takeName(tail_classical); // Preparing builders post_classical_builder_->SetInsertPoint(post_classical_block_); quantum_builder_->SetInsertPoint(quantum_block_); pre_classical_builder_->SetInsertPoint(pre_classical_block_); // Replacing entry tail_classical->setName(\"exit_quantum_grouping\"); tail_classical->replaceUsesWithIf(pre_classical_block_, [](llvm::Use& use) { auto* phi_node = llvm::dyn_cast<llvm::PHINode>(use.getUser()); return (phi_node == nullptr); }); } void GroupingPass::nextQuantumCycle(llvm::Module& module, llvm::BasicBlock* tail_classical) { auto& context = module.getContext(); pre_classical_builder_->CreateBr(quantum_block_); quantum_builder_->CreateBr(post_classical_block_); // pre_classical_block_ = post_classical_block_; // Creating replacement blocks post_classical_block_ = llvm::BasicBlock::Create(context, \"post-classical\", tail_classical->getParent(), tail_classical); quantum_block_ = llvm::BasicBlock::Create(context, \"quantum\", tail_classical->getParent(), post_classical_block_); // Storing the blocks for later processing quantum_blocks_.push_back(quantum_block_); classical_blocks_.push_back(post_classical_block_); // Preparing builders post_classical_builder_->SetInsertPoint(post_classical_block_); quantum_builder_->SetInsertPoint(quantum_block_); pre_classical_builder_->SetInsertPoint(pre_classical_block_); } void GroupingPass::expandBasedOnSource(llvm::Module& module, llvm::BasicBlock* tail_classical) { prepareSourceSeparation(module, tail_classical); // Variables used for the modifications std::vector<llvm::Instruction*> to_delete; std::unordered_set<llvm::Value*> depends_on_qc; std::unordered_set<llvm::Value*> post_classical_instructions; for (auto& instr : *tail_classical) { // Ignoring terminators // Only the terminator survives in the tail block if (instr.isTerminator()) { continue; } auto instr_class = classifyInstruction(&instr); if ((instr_class & SOURCE_QUANTUM) != 0) { // Checking if we are starting a new quantum program for (auto& op : instr.operands()) { if (post_classical_instructions.find(op) != post_classical_instructions.end()) { nextQuantumCycle(module, tail_classical); depends_on_qc.clear(); post_classical_instructions.clear(); break; } } // Marking all instructions that depend on a a read out for (auto user : instr.users()) { depends_on_qc.insert(user); } // Moving the instruction to auto new_instr = instr.clone(); new_instr->takeName(&instr); quantum_builder_->Insert(new_instr); instr.replaceAllUsesWith(new_instr); to_delete.push_back(&instr); } else if (instr_class != INVALID_MIXED_LOCATION) { // Check if depends on readout if (depends_on_qc.find(&instr) != depends_on_qc.end()) { for (auto user : instr.users()) { depends_on_qc.insert(user); } // Inserting to post section auto new_instr = instr.clone(); new_instr->takeName(&instr); post_classical_builder_->Insert(new_instr); instr.replaceAllUsesWith(new_instr); to_delete.push_back(&instr); post_classical_instructions.insert(new_instr); continue; } // Post quantum section // Moving remaining to pre-section auto new_instr = instr.clone(); new_instr->takeName(&instr); pre_classical_builder_->Insert(new_instr); instr.replaceAllUsesWith(new_instr); to_delete.push_back(&instr); } else { throw std::runtime_error(\"Unsupported occurring while grouping instructions\"); } } pre_classical_builder_->CreateBr(quantum_block_); quantum_builder_->CreateBr(post_classical_block_); post_classical_builder_->CreateBr(tail_classical); for (auto it = to_delete.rbegin(); it != to_delete.rend(); ++it) { auto ptr = *it; if (!ptr->use_empty()) { llvm::errs() << \";; Error: Could not delete \" << *ptr << \"\\n\"; } else { ptr->eraseFromParent(); } } } void GroupingPass::expandBasedOnDest( llvm::Module& module, llvm::BasicBlock* block, bool move_quatum, String const& name) { auto& context = module.getContext(); std::vector<llvm::Instruction*> to_delete; auto extra_block = llvm::BasicBlock::Create(context, \"unnamed\", block->getParent(), block); extra_block->takeName(block); block->replaceUsesWithIf(extra_block, [](llvm::Use& use) { auto* phi_node = llvm::dyn_cast<llvm::PHINode>(use.getUser()); return (phi_node == nullptr); }); block->setName(name); llvm::IRBuilder<> first_builder{context}; first_builder.SetInsertPoint(extra_block); for (auto& instr : *block) { if (instr.isTerminator()) { continue; } auto instr_class = classifyInstruction(&instr); bool dest_is_quantum = (instr_class & DEST_QUANTUM) != 0; if (dest_is_quantum == move_quatum) { auto new_instr = instr.clone(); new_instr->takeName(&instr); first_builder.Insert(new_instr); instr.replaceAllUsesWith(new_instr); to_delete.push_back(&instr); } } first_builder.CreateBr(block); for (auto it = to_delete.rbegin(); it != to_delete.rend(); ++it) { auto ptr = *it; if (!ptr->use_empty()) { llvm::errs() << \";; Error: Could not delete \" << *ptr << \"\\n\"; } else { ptr->eraseFromParent(); } } } llvm::PreservedAnalyses GroupingPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& mam) { if (!config_.circuitSeparation()) { return llvm::PreservedAnalyses::all(); } auto& result = mam.getResult<GroupingAnalysisPass>(module); // Preparing builders auto& context = module.getContext(); pre_classical_builder_ = std::make_shared<llvm::IRBuilder<>>(context); quantum_builder_ = std::make_shared<llvm::IRBuilder<>>(context); post_classical_builder_ = std::make_shared<llvm::IRBuilder<>>(context); for (auto* block : result.qc_cc_blocks) { quantum_blocks_.clear(); classical_blocks_.clear(); expandBasedOnSource(module, block); for (auto* block : quantum_blocks_) { expandBasedOnDest(module, block, true, \"readout\"); } // Last classical block does not contain any loads classical_blocks_.pop_back(); for (auto* block : classical_blocks_) { expandBasedOnDest(module, block, false, \"load\"); } } for (auto* block : result.qc_mc_cc_blocks) { quantum_blocks_.clear(); classical_blocks_.clear(); expandBasedOnSource(module, block); for (auto* block : quantum_blocks_) { expandBasedOnDest(module, block, true, \"readout\"); } // Last classical block does not contain any loads classical_blocks_.pop_back(); for (auto* block : classical_blocks_) { expandBasedOnDest(module, block, false, \"load\"); } } return llvm::PreservedAnalyses::none(); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"GroupingPass/GroupingPass.cpp"},{"location":"Api/Files/_grouping_pass_8cpp/#groupingpassgroupingpasscpp","text":"","title":"GroupingPass/GroupingPass.cpp"},{"location":"Api/Files/_grouping_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_grouping_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"GroupingPass/GroupingAnalysisPass.hpp\" #include \"GroupingPass/GroupingPass.hpp\" #include \"Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft { namespace quantum { bool GroupingPass::isRequired() { return true; } bool GroupingPass::isQuantumRegister(llvm::Type const* type) { if (type->isPointerTy()) { auto element_type = type->getPointerElementType(); if (element_type->isStructTy()) { auto type_name = static_cast<String const>(element_type->getStructName()); return quantum_register_types_.find(type_name) != quantum_register_types_.end(); } } return false; } int64_t GroupingPass::classifyInstruction(llvm::Instruction const* instr) { int64_t ret = PURE_CLASSICAL; // Checking all operations bool any_quantum = false; bool any_classical = false; bool is_void = instr->getType()->isVoidTy(); bool returns_quantum = isQuantumRegister(instr->getType()); auto call = llvm::dyn_cast<llvm::CallBase>(instr); if (call != nullptr) { for (auto& arg : call->args()) { auto q = isQuantumRegister(arg->getType()); any_quantum |= q; any_classical |= !q; } if (returns_quantum || is_void && !any_classical && any_quantum) { ret |= DEST_QUANTUM; } } else { for (auto& op : instr->operands()) { auto q = isQuantumRegister(op->getType()); any_quantum |= q; any_classical |= !q; } // Setting the destination platform if (returns_quantum) { ret |= DEST_QUANTUM; // If no classical or quantum arguments present, then destination dictates // source if (!any_quantum && !any_classical) { ret |= SOURCE_QUANTUM; } } } if (any_quantum && any_classical) { if (ret != DEST_QUANTUM) { ret = INVALID_MIXED_LOCATION; } } else if (any_quantum) { ret |= SOURCE_QUANTUM; } return ret; } void GroupingPass::prepareSourceSeparation(llvm::Module& module, llvm::BasicBlock* tail_classical) { // Creating replacement blocks auto& context = module.getContext(); post_classical_block_ = llvm::BasicBlock::Create(context, \"post-classical\", tail_classical->getParent(), tail_classical); quantum_block_ = llvm::BasicBlock::Create(context, \"quantum\", tail_classical->getParent(), post_classical_block_); pre_classical_block_ = llvm::BasicBlock::Create(context, \"pre-classical\", tail_classical->getParent(), quantum_block_); // Storing the blocks for later processing quantum_blocks_.push_back(quantum_block_); classical_blocks_.push_back(pre_classical_block_); classical_blocks_.push_back(post_classical_block_); // Renaming the block pre_classical_block_->takeName(tail_classical); // Preparing builders post_classical_builder_->SetInsertPoint(post_classical_block_); quantum_builder_->SetInsertPoint(quantum_block_); pre_classical_builder_->SetInsertPoint(pre_classical_block_); // Replacing entry tail_classical->setName(\"exit_quantum_grouping\"); tail_classical->replaceUsesWithIf(pre_classical_block_, [](llvm::Use& use) { auto* phi_node = llvm::dyn_cast<llvm::PHINode>(use.getUser()); return (phi_node == nullptr); }); } void GroupingPass::nextQuantumCycle(llvm::Module& module, llvm::BasicBlock* tail_classical) { auto& context = module.getContext(); pre_classical_builder_->CreateBr(quantum_block_); quantum_builder_->CreateBr(post_classical_block_); // pre_classical_block_ = post_classical_block_; // Creating replacement blocks post_classical_block_ = llvm::BasicBlock::Create(context, \"post-classical\", tail_classical->getParent(), tail_classical); quantum_block_ = llvm::BasicBlock::Create(context, \"quantum\", tail_classical->getParent(), post_classical_block_); // Storing the blocks for later processing quantum_blocks_.push_back(quantum_block_); classical_blocks_.push_back(post_classical_block_); // Preparing builders post_classical_builder_->SetInsertPoint(post_classical_block_); quantum_builder_->SetInsertPoint(quantum_block_); pre_classical_builder_->SetInsertPoint(pre_classical_block_); } void GroupingPass::expandBasedOnSource(llvm::Module& module, llvm::BasicBlock* tail_classical) { prepareSourceSeparation(module, tail_classical); // Variables used for the modifications std::vector<llvm::Instruction*> to_delete; std::unordered_set<llvm::Value*> depends_on_qc; std::unordered_set<llvm::Value*> post_classical_instructions; for (auto& instr : *tail_classical) { // Ignoring terminators // Only the terminator survives in the tail block if (instr.isTerminator()) { continue; } auto instr_class = classifyInstruction(&instr); if ((instr_class & SOURCE_QUANTUM) != 0) { // Checking if we are starting a new quantum program for (auto& op : instr.operands()) { if (post_classical_instructions.find(op) != post_classical_instructions.end()) { nextQuantumCycle(module, tail_classical); depends_on_qc.clear(); post_classical_instructions.clear(); break; } } // Marking all instructions that depend on a a read out for (auto user : instr.users()) { depends_on_qc.insert(user); } // Moving the instruction to auto new_instr = instr.clone(); new_instr->takeName(&instr); quantum_builder_->Insert(new_instr); instr.replaceAllUsesWith(new_instr); to_delete.push_back(&instr); } else if (instr_class != INVALID_MIXED_LOCATION) { // Check if depends on readout if (depends_on_qc.find(&instr) != depends_on_qc.end()) { for (auto user : instr.users()) { depends_on_qc.insert(user); } // Inserting to post section auto new_instr = instr.clone(); new_instr->takeName(&instr); post_classical_builder_->Insert(new_instr); instr.replaceAllUsesWith(new_instr); to_delete.push_back(&instr); post_classical_instructions.insert(new_instr); continue; } // Post quantum section // Moving remaining to pre-section auto new_instr = instr.clone(); new_instr->takeName(&instr); pre_classical_builder_->Insert(new_instr); instr.replaceAllUsesWith(new_instr); to_delete.push_back(&instr); } else { throw std::runtime_error(\"Unsupported occurring while grouping instructions\"); } } pre_classical_builder_->CreateBr(quantum_block_); quantum_builder_->CreateBr(post_classical_block_); post_classical_builder_->CreateBr(tail_classical); for (auto it = to_delete.rbegin(); it != to_delete.rend(); ++it) { auto ptr = *it; if (!ptr->use_empty()) { llvm::errs() << \";; Error: Could not delete \" << *ptr << \"\\n\"; } else { ptr->eraseFromParent(); } } } void GroupingPass::expandBasedOnDest( llvm::Module& module, llvm::BasicBlock* block, bool move_quatum, String const& name) { auto& context = module.getContext(); std::vector<llvm::Instruction*> to_delete; auto extra_block = llvm::BasicBlock::Create(context, \"unnamed\", block->getParent(), block); extra_block->takeName(block); block->replaceUsesWithIf(extra_block, [](llvm::Use& use) { auto* phi_node = llvm::dyn_cast<llvm::PHINode>(use.getUser()); return (phi_node == nullptr); }); block->setName(name); llvm::IRBuilder<> first_builder{context}; first_builder.SetInsertPoint(extra_block); for (auto& instr : *block) { if (instr.isTerminator()) { continue; } auto instr_class = classifyInstruction(&instr); bool dest_is_quantum = (instr_class & DEST_QUANTUM) != 0; if (dest_is_quantum == move_quatum) { auto new_instr = instr.clone(); new_instr->takeName(&instr); first_builder.Insert(new_instr); instr.replaceAllUsesWith(new_instr); to_delete.push_back(&instr); } } first_builder.CreateBr(block); for (auto it = to_delete.rbegin(); it != to_delete.rend(); ++it) { auto ptr = *it; if (!ptr->use_empty()) { llvm::errs() << \";; Error: Could not delete \" << *ptr << \"\\n\"; } else { ptr->eraseFromParent(); } } } llvm::PreservedAnalyses GroupingPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& mam) { if (!config_.circuitSeparation()) { return llvm::PreservedAnalyses::all(); } auto& result = mam.getResult<GroupingAnalysisPass>(module); // Preparing builders auto& context = module.getContext(); pre_classical_builder_ = std::make_shared<llvm::IRBuilder<>>(context); quantum_builder_ = std::make_shared<llvm::IRBuilder<>>(context); post_classical_builder_ = std::make_shared<llvm::IRBuilder<>>(context); for (auto* block : result.qc_cc_blocks) { quantum_blocks_.clear(); classical_blocks_.clear(); expandBasedOnSource(module, block); for (auto* block : quantum_blocks_) { expandBasedOnDest(module, block, true, \"readout\"); } // Last classical block does not contain any loads classical_blocks_.pop_back(); for (auto* block : classical_blocks_) { expandBasedOnDest(module, block, false, \"load\"); } } for (auto* block : result.qc_mc_cc_blocks) { quantum_blocks_.clear(); classical_blocks_.clear(); expandBasedOnSource(module, block); for (auto* block : quantum_blocks_) { expandBasedOnDest(module, block, true, \"readout\"); } // Last classical block does not contain any loads classical_blocks_.pop_back(); for (auto* block : classical_blocks_) { expandBasedOnDest(module, block, false, \"load\"); } } return llvm::PreservedAnalyses::none(); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_grouping_pass_8hpp/","text":"GroupingPass/GroupingPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::GroupingPass Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"GroupingPass/GroupingPassConfiguration.hpp\" #include \"Logging/ILogger.hpp\" #include \"Profile/Profile.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Llvm/Llvm.hpp\" #include <functional> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft { namespace quantum { class GroupingPass : public llvm::PassInfoMixin<GroupingPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = std::shared_ptr<ILogger>; using BlockSet = std::unordered_set<llvm::BasicBlock*>; using SharedBuilder = std::shared_ptr<llvm::IRBuilder<>>; // Construction and destruction configuration. // enum { PURE_CLASSICAL = 0, SOURCE_QUANTUM = 1, DEST_QUANTUM = 2, PURE_QUANTUM = SOURCE_QUANTUM | DEST_QUANTUM, TRANSFER_CLASSICAL_TO_QUANTUM = DEST_QUANTUM, TRANSFER_QUANTUM_TO_CLASSICAL = SOURCE_QUANTUM, INVALID_MIXED_LOCATION = -1 }; explicit GroupingPass(GroupingPassConfiguration const& cfg) : config_{cfg} { } GroupingPass(GroupingPass const&) = delete; GroupingPass(GroupingPass&&) = default; ~GroupingPass() = default; // void prepareSourceSeparation(llvm::Module& module, llvm::BasicBlock* block); void nextQuantumCycle(llvm::Module& module, llvm::BasicBlock* block); void expandBasedOnSource(llvm::Module& module, llvm::BasicBlock* block); void expandBasedOnDest(llvm::Module& module, llvm::BasicBlock* block, bool move_quatum, String const& name); // bool isQuantumRegister(llvm::Type const* type); int64_t classifyInstruction(llvm::Instruction const* instr); llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); void runBlockAnalysis(llvm::Module& module); static bool isRequired(); private: GroupingPassConfiguration config_{}; // Basic blocks used to build llvm::BasicBlock* post_classical_block_{nullptr}; llvm::BasicBlock* quantum_block_{nullptr}; llvm::BasicBlock* pre_classical_block_{nullptr}; // Builders // SharedBuilder pre_classical_builder_{}; SharedBuilder quantum_builder_{}; SharedBuilder post_classical_builder_{}; std::vector<llvm::BasicBlock*> quantum_blocks_{}; std::vector<llvm::BasicBlock*> classical_blocks_{}; BlockSet visited_blocks_; ILoggerPtr logger_{nullptr}; std::unordered_set<String> quantum_register_types_ = {\"Qubit\", \"Result\"}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"GroupingPass/GroupingPass.hpp"},{"location":"Api/Files/_grouping_pass_8hpp/#groupingpassgroupingpasshpp","text":"","title":"GroupingPass/GroupingPass.hpp"},{"location":"Api/Files/_grouping_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_grouping_pass_8hpp/#classes","text":"Name class microsoft::quantum::GroupingPass","title":"Classes"},{"location":"Api/Files/_grouping_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"GroupingPass/GroupingPassConfiguration.hpp\" #include \"Logging/ILogger.hpp\" #include \"Profile/Profile.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Llvm/Llvm.hpp\" #include <functional> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft { namespace quantum { class GroupingPass : public llvm::PassInfoMixin<GroupingPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = std::shared_ptr<ILogger>; using BlockSet = std::unordered_set<llvm::BasicBlock*>; using SharedBuilder = std::shared_ptr<llvm::IRBuilder<>>; // Construction and destruction configuration. // enum { PURE_CLASSICAL = 0, SOURCE_QUANTUM = 1, DEST_QUANTUM = 2, PURE_QUANTUM = SOURCE_QUANTUM | DEST_QUANTUM, TRANSFER_CLASSICAL_TO_QUANTUM = DEST_QUANTUM, TRANSFER_QUANTUM_TO_CLASSICAL = SOURCE_QUANTUM, INVALID_MIXED_LOCATION = -1 }; explicit GroupingPass(GroupingPassConfiguration const& cfg) : config_{cfg} { } GroupingPass(GroupingPass const&) = delete; GroupingPass(GroupingPass&&) = default; ~GroupingPass() = default; // void prepareSourceSeparation(llvm::Module& module, llvm::BasicBlock* block); void nextQuantumCycle(llvm::Module& module, llvm::BasicBlock* block); void expandBasedOnSource(llvm::Module& module, llvm::BasicBlock* block); void expandBasedOnDest(llvm::Module& module, llvm::BasicBlock* block, bool move_quatum, String const& name); // bool isQuantumRegister(llvm::Type const* type); int64_t classifyInstruction(llvm::Instruction const* instr); llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); void runBlockAnalysis(llvm::Module& module); static bool isRequired(); private: GroupingPassConfiguration config_{}; // Basic blocks used to build llvm::BasicBlock* post_classical_block_{nullptr}; llvm::BasicBlock* quantum_block_{nullptr}; llvm::BasicBlock* pre_classical_block_{nullptr}; // Builders // SharedBuilder pre_classical_builder_{}; SharedBuilder quantum_builder_{}; SharedBuilder post_classical_builder_{}; std::vector<llvm::BasicBlock*> quantum_blocks_{}; std::vector<llvm::BasicBlock*> classical_blocks_{}; BlockSet visited_blocks_; ILoggerPtr logger_{nullptr}; std::unordered_set<String> quantum_register_types_ = {\"Qubit\", \"Result\"}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_grouping_pass_configuration_8hpp/","text":"GroupingPass/GroupingPassConfiguration.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::GroupingPassConfiguration Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"QatTypes/QatTypes.hpp\" namespace microsoft { namespace quantum { class GroupingPassConfiguration { public: using Set = std::unordered_set<std::string>; // Setup and construction // void setup(ConfigurationManager& config) { config.setSectionName(\"Grouping quantum instructions\", \"\"); config.addExperimentalParameter( circuit_separation_, \"separate-circuits\", \"Whether or not to separate quantum and classical circuits\"); } static GroupingPassConfiguration createDisabled() { GroupingPassConfiguration ret; ret.circuit_separation_ = false; return ret; } bool circuitSeparation() const { return circuit_separation_; } private: bool circuit_separation_{true}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"GroupingPass/GroupingPassConfiguration.hpp"},{"location":"Api/Files/_grouping_pass_configuration_8hpp/#groupingpassgroupingpassconfigurationhpp","text":"","title":"GroupingPass/GroupingPassConfiguration.hpp"},{"location":"Api/Files/_grouping_pass_configuration_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_grouping_pass_configuration_8hpp/#classes","text":"Name class microsoft::quantum::GroupingPassConfiguration","title":"Classes"},{"location":"Api/Files/_grouping_pass_configuration_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"QatTypes/QatTypes.hpp\" namespace microsoft { namespace quantum { class GroupingPassConfiguration { public: using Set = std::unordered_set<std::string>; // Setup and construction // void setup(ConfigurationManager& config) { config.setSectionName(\"Grouping quantum instructions\", \"\"); config.addExperimentalParameter( circuit_separation_, \"separate-circuits\", \"Whether or not to separate quantum and classical circuits\"); } static GroupingPassConfiguration createDisabled() { GroupingPassConfiguration ret; ret.circuit_separation_ = false; return ret; } bool circuitSeparation() const { return circuit_separation_; } private: bool circuit_separation_{true}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_i_allocation_manager_8cpp/","text":"AllocationManager/IAllocationManager.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/IAllocationManager.hpp\" namespace microsoft { namespace quantum { IAllocationManager::~IAllocationManager() = default; uint64_t IAllocationManager::allocationsInUse() const { return registers_in_use_; } uint64_t IAllocationManager::maxAllocationsUsed() const { return max_registers_used_; } void IAllocationManager::updateRegistersInUse(uint64_t n) { registers_in_use_ = n; if (n > max_registers_used_) { max_registers_used_ = n; } } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"AllocationManager/IAllocationManager.cpp"},{"location":"Api/Files/_i_allocation_manager_8cpp/#allocationmanageriallocationmanagercpp","text":"","title":"AllocationManager/IAllocationManager.cpp"},{"location":"Api/Files/_i_allocation_manager_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_allocation_manager_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/IAllocationManager.hpp\" namespace microsoft { namespace quantum { IAllocationManager::~IAllocationManager() = default; uint64_t IAllocationManager::allocationsInUse() const { return registers_in_use_; } uint64_t IAllocationManager::maxAllocationsUsed() const { return max_registers_used_; } void IAllocationManager::updateRegistersInUse(uint64_t n) { registers_in_use_ = n; if (n > max_registers_used_) { max_registers_used_ = n; } } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_i_allocation_manager_8hpp/","text":"AllocationManager/IAllocationManager.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::IAllocationManager Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include <memory> #include <string> namespace microsoft { namespace quantum { class IAllocationManager { public: using Address = uint64_t; using Index = uint64_t; using AllocationManagerPtr = std::shared_ptr<IAllocationManager>; // Construction, moves and copies // IAllocationManager(IAllocationManager const&) = delete; IAllocationManager(IAllocationManager&&) = delete; IAllocationManager& operator=(IAllocationManager const&) = delete; IAllocationManager& operator=(IAllocationManager&&) = delete; virtual ~IAllocationManager(); // Interface // virtual Address allocate(String const& name = \"\", Index const& count = 1) = 0; virtual void release(Address const& address) = 0; virtual void reset() = 0; // Statistics // uint64_t allocationsInUse() const; uint64_t maxAllocationsUsed() const; protected: IAllocationManager() = default; void updateRegistersInUse(uint64_t n); private: uint64_t registers_in_use_{0}; uint64_t max_registers_used_{0}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"AllocationManager/IAllocationManager.hpp"},{"location":"Api/Files/_i_allocation_manager_8hpp/#allocationmanageriallocationmanagerhpp","text":"","title":"AllocationManager/IAllocationManager.hpp"},{"location":"Api/Files/_i_allocation_manager_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_allocation_manager_8hpp/#classes","text":"Name class microsoft::quantum::IAllocationManager","title":"Classes"},{"location":"Api/Files/_i_allocation_manager_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include <memory> #include <string> namespace microsoft { namespace quantum { class IAllocationManager { public: using Address = uint64_t; using Index = uint64_t; using AllocationManagerPtr = std::shared_ptr<IAllocationManager>; // Construction, moves and copies // IAllocationManager(IAllocationManager const&) = delete; IAllocationManager(IAllocationManager&&) = delete; IAllocationManager& operator=(IAllocationManager const&) = delete; IAllocationManager& operator=(IAllocationManager&&) = delete; virtual ~IAllocationManager(); // Interface // virtual Address allocate(String const& name = \"\", Index const& count = 1) = 0; virtual void release(Address const& address) = 0; virtual void reset() = 0; // Statistics // uint64_t allocationsInUse() const; uint64_t maxAllocationsUsed() const; protected: IAllocationManager() = default; void updateRegistersInUse(uint64_t n); private: uint64_t registers_in_use_{0}; uint64_t max_registers_used_{0}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_i_config_bind_8cpp/","text":"Commandline/IConfigBind.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"Commandline/IConfigBind.hpp\" using namespace microsoft::quantum; namespace microsoft { namespace quantum { IConfigBind::IConfigBind(String const& name, String const& description) : name_{name} , description_{description} { } IConfigBind::~IConfigBind() = default; String IConfigBind::name() const { return name_; } String IConfigBind::description() const { return description_; } void IConfigBind::setName(String const& name) { name_ = name; } bool IConfigBind::isFlag() const { return is_flag_; } String IConfigBind::defaultValue() const { return str_default_value_; } void IConfigBind::markAsFlag() { is_flag_ = true; } void IConfigBind::setDefault(String const& v) { str_default_value_ = v; } void IConfigBind::makeSettingExperimental() { is_experimental_ = true; } bool IConfigBind::isExperimental() const { return is_experimental_; } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Commandline/IConfigBind.cpp"},{"location":"Api/Files/_i_config_bind_8cpp/#commandlineiconfigbindcpp","text":"","title":"Commandline/IConfigBind.cpp"},{"location":"Api/Files/_i_config_bind_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_config_bind_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"Commandline/IConfigBind.hpp\" using namespace microsoft::quantum; namespace microsoft { namespace quantum { IConfigBind::IConfigBind(String const& name, String const& description) : name_{name} , description_{description} { } IConfigBind::~IConfigBind() = default; String IConfigBind::name() const { return name_; } String IConfigBind::description() const { return description_; } void IConfigBind::setName(String const& name) { name_ = name; } bool IConfigBind::isFlag() const { return is_flag_; } String IConfigBind::defaultValue() const { return str_default_value_; } void IConfigBind::markAsFlag() { is_flag_ = true; } void IConfigBind::setDefault(String const& v) { str_default_value_ = v; } void IConfigBind::makeSettingExperimental() { is_experimental_ = true; } bool IConfigBind::isExperimental() const { return is_experimental_; } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_i_config_bind_8hpp/","text":"Commandline/IConfigBind.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::IConfigBind Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ParameterParser.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Llvm/Llvm.hpp\" #include <iomanip> #include <iostream> #include <sstream> #include <type_traits> #include <typeindex> namespace microsoft { namespace quantum { class IConfigBind { public: // Deleted constructors and deleted operators // // Strictly speaking the code would remain correct if we allowed copy and/or move, but // we have chosen to ban them by choice as potential bugs arising from allowing copy and/or // move can be difficult to find. We consider this behaviour a part of the interface definition. IConfigBind(IConfigBind const&) = delete; IConfigBind(IConfigBind&&) = delete; IConfigBind& operator=(IConfigBind const&) = delete; IConfigBind& operator=(IConfigBind&&) = delete; // Virtual destructor // virtual ~IConfigBind(); // Interface // virtual bool setupArguments(ParameterParser& parser) = 0; virtual bool configure(ParameterParser& parser, bool experimental_mode) = 0; virtual String value() = 0; // Properties // String name() const; String description() const; bool isFlag() const; String defaultValue() const; bool isExperimental() const; protected: // Constructor // IConfigBind(String const& name, String const& description); // Configuration // void setName(String const& name); void markAsFlag(); void setDefault(String const& v); void makeSettingExperimental(); private: String name_; String description_; bool is_flag_{false}; String str_default_value_{\"\"}; bool is_experimental_{false}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Commandline/IConfigBind.hpp"},{"location":"Api/Files/_i_config_bind_8hpp/#commandlineiconfigbindhpp","text":"","title":"Commandline/IConfigBind.hpp"},{"location":"Api/Files/_i_config_bind_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_config_bind_8hpp/#classes","text":"Name class microsoft::quantum::IConfigBind","title":"Classes"},{"location":"Api/Files/_i_config_bind_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ParameterParser.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Llvm/Llvm.hpp\" #include <iomanip> #include <iostream> #include <sstream> #include <type_traits> #include <typeindex> namespace microsoft { namespace quantum { class IConfigBind { public: // Deleted constructors and deleted operators // // Strictly speaking the code would remain correct if we allowed copy and/or move, but // we have chosen to ban them by choice as potential bugs arising from allowing copy and/or // move can be difficult to find. We consider this behaviour a part of the interface definition. IConfigBind(IConfigBind const&) = delete; IConfigBind(IConfigBind&&) = delete; IConfigBind& operator=(IConfigBind const&) = delete; IConfigBind& operator=(IConfigBind&&) = delete; // Virtual destructor // virtual ~IConfigBind(); // Interface // virtual bool setupArguments(ParameterParser& parser) = 0; virtual bool configure(ParameterParser& parser, bool experimental_mode) = 0; virtual String value() = 0; // Properties // String name() const; String description() const; bool isFlag() const; String defaultValue() const; bool isExperimental() const; protected: // Constructor // IConfigBind(String const& name, String const& description); // Configuration // void setName(String const& name); void markAsFlag(); void setDefault(String const& v); void makeSettingExperimental(); private: String name_; String description_; bool is_flag_{false}; String str_default_value_{\"\"}; bool is_experimental_{false}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_i_logger_8cpp/","text":"Logging/ILogger.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/ILogger.hpp\" #include <cstdint> #include <string> namespace microsoft { namespace quantum { ILogger::~ILogger() = default; } } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Logging/ILogger.cpp"},{"location":"Api/Files/_i_logger_8cpp/#loggingiloggercpp","text":"","title":"Logging/ILogger.cpp"},{"location":"Api/Files/_i_logger_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_logger_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/ILogger.hpp\" #include <cstdint> #include <string> namespace microsoft { namespace quantum { ILogger::~ILogger() = default; } } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_i_logger_8hpp/","text":"Logging/ILogger.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ILogger Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include <cstdint> #include <string> namespace microsoft { namespace quantum { class ILogger { public: // Constructors, copy and move operators and destructors // ILogger() = default; ILogger(ILogger const&) = default; ILogger(ILogger&&) = default; ILogger& operator=(ILogger const&) = default; ILogger& operator=(ILogger&&) = default; virtual ~ILogger(); // Abstract interface methods // virtual void debug(String const& message) = 0; virtual void info(String const& message) = 0; virtual void warning(String const& message) = 0; virtual void error(String const& message) = 0; virtual void internalError(String const& message) = 0; virtual void setLocation(String const& name, uint64_t row, uint64_t col) = 0; virtual void setLlvmHint(String const& value) = 0; virtual void setFrontendHint(String const& value) = 0; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Logging/ILogger.hpp"},{"location":"Api/Files/_i_logger_8hpp/#loggingiloggerhpp","text":"","title":"Logging/ILogger.hpp"},{"location":"Api/Files/_i_logger_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_logger_8hpp/#classes","text":"Name class microsoft::quantum::ILogger","title":"Classes"},{"location":"Api/Files/_i_logger_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include <cstdint> #include <string> namespace microsoft { namespace quantum { class ILogger { public: // Constructors, copy and move operators and destructors // ILogger() = default; ILogger(ILogger const&) = default; ILogger(ILogger&&) = default; ILogger& operator=(ILogger const&) = default; ILogger& operator=(ILogger&&) = default; virtual ~ILogger(); // Abstract interface methods // virtual void debug(String const& message) = 0; virtual void info(String const& message) = 0; virtual void warning(String const& message) = 0; virtual void error(String const& message) = 0; virtual void internalError(String const& message) = 0; virtual void setLocation(String const& name, uint64_t row, uint64_t col) = 0; virtual void setLlvmHint(String const& value) = 0; virtual void setFrontendHint(String const& value) = 0; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_i_operand_prototype_8cpp/","text":"Rules/IOperandPrototype.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" namespace microsoft { namespace quantum { IOperandPrototype::~IOperandPrototype() = default; bool IOperandPrototype::matchChildren(Value* value, Captures& captures) const { if (!children_.empty()) { auto user = llvm::dyn_cast<llvm::User>(value); if (user == nullptr) { return false; } if (user->getNumOperands() != children_.size()) { return false; } uint64_t i = 0; while (i < children_.size()) { auto v = user->getOperand(static_cast<uint32_t>(i)); if (!children_[i]->match(v, captures)) { return false; } ++i; } return true; } // TODO(issue-16): value may be other type than llvm::User. Check other relevant types // and deal with it. return true; } void IOperandPrototype::addChild(Child const& child) { children_.push_back(child); } void IOperandPrototype::captureAs(std::string capture_name) { capture_name_ = std::move(capture_name); } bool IOperandPrototype::fail(Value* /*value*/, Captures& /*captures*/) const { return false; } bool IOperandPrototype::success(Value* value, Captures& captures) const { capture(value, captures); auto ret = matchChildren(value, captures); if (!ret) { uncapture(value, captures); } return ret; } void IOperandPrototype::capture(Value* value, Captures& captures) const { if (!capture_name_.empty()) { captures[capture_name_] = value; } } void IOperandPrototype::uncapture(Value* /*value*/, Captures& captures) const { if (!capture_name_.empty()) { auto it = captures.find(capture_name_); if (it == captures.end()) { throw std::runtime_error(\"Previously captured name \" + capture_name_ + \" not found in capture list.\"); } captures.erase(it); } } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/IOperandPrototype.cpp"},{"location":"Api/Files/_i_operand_prototype_8cpp/#rulesioperandprototypecpp","text":"","title":"Rules/IOperandPrototype.cpp"},{"location":"Api/Files/_i_operand_prototype_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_operand_prototype_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" namespace microsoft { namespace quantum { IOperandPrototype::~IOperandPrototype() = default; bool IOperandPrototype::matchChildren(Value* value, Captures& captures) const { if (!children_.empty()) { auto user = llvm::dyn_cast<llvm::User>(value); if (user == nullptr) { return false; } if (user->getNumOperands() != children_.size()) { return false; } uint64_t i = 0; while (i < children_.size()) { auto v = user->getOperand(static_cast<uint32_t>(i)); if (!children_[i]->match(v, captures)) { return false; } ++i; } return true; } // TODO(issue-16): value may be other type than llvm::User. Check other relevant types // and deal with it. return true; } void IOperandPrototype::addChild(Child const& child) { children_.push_back(child); } void IOperandPrototype::captureAs(std::string capture_name) { capture_name_ = std::move(capture_name); } bool IOperandPrototype::fail(Value* /*value*/, Captures& /*captures*/) const { return false; } bool IOperandPrototype::success(Value* value, Captures& captures) const { capture(value, captures); auto ret = matchChildren(value, captures); if (!ret) { uncapture(value, captures); } return ret; } void IOperandPrototype::capture(Value* value, Captures& captures) const { if (!capture_name_.empty()) { captures[capture_name_] = value; } } void IOperandPrototype::uncapture(Value* /*value*/, Captures& captures) const { if (!capture_name_.empty()) { auto it = captures.find(capture_name_); if (it == captures.end()) { throw std::runtime_error(\"Previously captured name \" + capture_name_ + \" not found in capture list.\"); } captures.erase(it); } } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_i_operand_prototype_8hpp/","text":"Rules/IOperandPrototype.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::IOperandPrototype Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class IOperandPrototype { public: using Instruction = llvm::Instruction; using String = std::string; using Value = llvm::Value; using Child = std::shared_ptr<IOperandPrototype>; using Children = std::vector<Child>; using Captures = std::unordered_map<std::string, Value*>; // Constructors and destructors // IOperandPrototype() = default; virtual ~IOperandPrototype(); // Interface functions // virtual bool match(Value* value, Captures& captures) const = 0; virtual Child copy() const = 0; // Shared functionality // void addChild(Child const& child); void captureAs(std::string capture_name); protected: // Function to indicate match success or failure. Either of these // must be called prior to return from an implementation of // IOperandPrototype::match. // bool fail(Value* value, Captures& captures) const; bool success(Value* value, Captures& captures) const; // Helper functions for the capture logic. // bool matchChildren(Value* value, Captures& captures) const; // Helper functions for operation // void copyPropertiesFrom(IOperandPrototype const& other) { capture_name_ = other.capture_name_; children_ = other.children_; } private: void capture(Value* value, Captures& captures) const; void uncapture(Value* value, Captures& captures) const; // Data variables for common matching functionality // std::string capture_name_{\"\"}; Children children_{}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/IOperandPrototype.hpp"},{"location":"Api/Files/_i_operand_prototype_8hpp/#rulesioperandprototypehpp","text":"","title":"Rules/IOperandPrototype.hpp"},{"location":"Api/Files/_i_operand_prototype_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_operand_prototype_8hpp/#classes","text":"Name class microsoft::quantum::IOperandPrototype","title":"Classes"},{"location":"Api/Files/_i_operand_prototype_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class IOperandPrototype { public: using Instruction = llvm::Instruction; using String = std::string; using Value = llvm::Value; using Child = std::shared_ptr<IOperandPrototype>; using Children = std::vector<Child>; using Captures = std::unordered_map<std::string, Value*>; // Constructors and destructors // IOperandPrototype() = default; virtual ~IOperandPrototype(); // Interface functions // virtual bool match(Value* value, Captures& captures) const = 0; virtual Child copy() const = 0; // Shared functionality // void addChild(Child const& child); void captureAs(std::string capture_name); protected: // Function to indicate match success or failure. Either of these // must be called prior to return from an implementation of // IOperandPrototype::match. // bool fail(Value* value, Captures& captures) const; bool success(Value* value, Captures& captures) const; // Helper functions for the capture logic. // bool matchChildren(Value* value, Captures& captures) const; // Helper functions for operation // void copyPropertiesFrom(IOperandPrototype const& other) { capture_name_ = other.capture_name_; children_ = other.children_; } private: void capture(Value* value, Captures& captures) const; void uncapture(Value* value, Captures& captures) const; // Data variables for common matching functionality // std::string capture_name_{\"\"}; Children children_{}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_instruction_8cpp/","text":"Rules/Patterns/Instruction.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/Patterns/Instruction.hpp\" namespace microsoft { namespace quantum { bool StorePattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::StoreInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } StorePattern::Child StorePattern::copy() const { auto ret = std::make_shared<StorePattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool LoadPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::LoadInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } LoadPattern::Child LoadPattern::copy() const { auto ret = std::make_shared<LoadPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool BitCastPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::BitCastInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } BitCastPattern::Child BitCastPattern::copy() const { auto ret = std::make_shared<BitCastPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool IntToPtrPattern::match(Value* instr, Captures& captures) const { auto* a = llvm::dyn_cast<llvm::IntToPtrInst>(instr); auto* b = llvm::dyn_cast<llvm::ConcreteOperator<llvm::Operator, llvm::Instruction::IntToPtr>>(instr); if (a == nullptr && b == nullptr) { return fail(instr, captures); } auto ret = success(instr, captures); return ret; } IntToPtrPattern::Child IntToPtrPattern::copy() const { auto ret = std::make_shared<IntToPtrPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool ConstIntPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::ConstantInt>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } ConstIntPattern::Child ConstIntPattern::copy() const { auto ret = std::make_shared<ConstIntPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool BranchPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::BranchInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } BranchPattern::Child BranchPattern::copy() const { auto ret = std::make_shared<BranchPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool SelectPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::SelectInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } SelectPattern::Child SelectPattern::copy() const { auto ret = std::make_shared<SelectPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool BasicBlockPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::BasicBlock>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } BasicBlockPattern::Child BasicBlockPattern::copy() const { auto ret = std::make_shared<BasicBlockPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool SwitchPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::SwitchInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } SwitchPattern::Child SwitchPattern::copy() const { auto ret = std::make_shared<SwitchPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Patterns/Instruction.cpp"},{"location":"Api/Files/_instruction_8cpp/#rulespatternsinstructioncpp","text":"","title":"Rules/Patterns/Instruction.cpp"},{"location":"Api/Files/_instruction_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_instruction_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/Patterns/Instruction.hpp\" namespace microsoft { namespace quantum { bool StorePattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::StoreInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } StorePattern::Child StorePattern::copy() const { auto ret = std::make_shared<StorePattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool LoadPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::LoadInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } LoadPattern::Child LoadPattern::copy() const { auto ret = std::make_shared<LoadPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool BitCastPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::BitCastInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } BitCastPattern::Child BitCastPattern::copy() const { auto ret = std::make_shared<BitCastPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool IntToPtrPattern::match(Value* instr, Captures& captures) const { auto* a = llvm::dyn_cast<llvm::IntToPtrInst>(instr); auto* b = llvm::dyn_cast<llvm::ConcreteOperator<llvm::Operator, llvm::Instruction::IntToPtr>>(instr); if (a == nullptr && b == nullptr) { return fail(instr, captures); } auto ret = success(instr, captures); return ret; } IntToPtrPattern::Child IntToPtrPattern::copy() const { auto ret = std::make_shared<IntToPtrPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool ConstIntPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::ConstantInt>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } ConstIntPattern::Child ConstIntPattern::copy() const { auto ret = std::make_shared<ConstIntPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool BranchPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::BranchInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } BranchPattern::Child BranchPattern::copy() const { auto ret = std::make_shared<BranchPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool SelectPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::SelectInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } SelectPattern::Child SelectPattern::copy() const { auto ret = std::make_shared<SelectPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool BasicBlockPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::BasicBlock>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } BasicBlockPattern::Child BasicBlockPattern::copy() const { auto ret = std::make_shared<BasicBlockPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool SwitchPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::SwitchInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } SwitchPattern::Child SwitchPattern::copy() const { auto ret = std::make_shared<SwitchPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_instruction_8hpp/","text":"Rules/Patterns/Instruction.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::StorePattern class microsoft::quantum::LoadPattern class microsoft::quantum::BitCastPattern class microsoft::quantum::IntToPtrPattern class microsoft::quantum::ConstIntPattern class microsoft::quantum::BranchPattern class microsoft::quantum::SelectPattern class microsoft::quantum::BasicBlockPattern class microsoft::quantum::SwitchPattern Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class StorePattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class LoadPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class BitCastPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class IntToPtrPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class ConstIntPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class BranchPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class SelectPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class BasicBlockPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class SwitchPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Patterns/Instruction.hpp"},{"location":"Api/Files/_instruction_8hpp/#rulespatternsinstructionhpp","text":"","title":"Rules/Patterns/Instruction.hpp"},{"location":"Api/Files/_instruction_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_instruction_8hpp/#classes","text":"Name class microsoft::quantum::StorePattern class microsoft::quantum::LoadPattern class microsoft::quantum::BitCastPattern class microsoft::quantum::IntToPtrPattern class microsoft::quantum::ConstIntPattern class microsoft::quantum::BranchPattern class microsoft::quantum::SelectPattern class microsoft::quantum::BasicBlockPattern class microsoft::quantum::SwitchPattern","title":"Classes"},{"location":"Api/Files/_instruction_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class StorePattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class LoadPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class BitCastPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class IntToPtrPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class ConstIntPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class BranchPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class SelectPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class BasicBlockPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class SwitchPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_int_to_ptr_8cpp/","text":"Rules/Notation/IntToPtr.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr intToPtr(IOperandPrototypePtr const& arg) { auto cast_pattern = std::make_shared<IntToPtrPattern>(); cast_pattern->addChild(arg); return static_cast<IOperandPrototypePtr>(cast_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Notation/IntToPtr.cpp"},{"location":"Api/Files/_int_to_ptr_8cpp/#rulesnotationinttoptrcpp","text":"","title":"Rules/Notation/IntToPtr.cpp"},{"location":"Api/Files/_int_to_ptr_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_int_to_ptr_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr intToPtr(IOperandPrototypePtr const& arg) { auto cast_pattern = std::make_shared<IntToPtrPattern>(); cast_pattern->addChild(arg); return static_cast<IOperandPrototypePtr>(cast_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_ir_manipulation_test_helper_8cpp/","text":"TestTools/IrManipulationTestHelper.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"Utils/Trim.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { IrManipulationTestHelper::IrManipulationTestHelper() { pass_builder_.registerModuleAnalyses(module_analysis_manager_); pass_builder_.registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_.registerFunctionAnalyses(function_analysis_manager_); pass_builder_.registerLoopAnalyses(loop_analysis_manager_); pass_builder_.crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); } bool IrManipulationTestHelper::fromString(String const& data) { module_ = llvm::parseIR(llvm::MemoryBufferRef(data, \"IrManipulationTestHelper\"), error_, context_); compilation_failed_ = (module_ == nullptr); return !compilation_failed_; } String IrManipulationTestHelper::toString() const { String str; llvm::raw_string_ostream ostream(str); ostream << *module_; ostream.flush(); return str; } IrManipulationTestHelper::Strings IrManipulationTestHelper::toBodyInstructions() { if (isModuleBroken()) { return {}; } String data = toString(); Strings ret; auto pos = data.find(\"define i8 @Main() local_unnamed_addr\"); if (pos == String::npos) { return {}; } // Skipping entry pos = data.find(\"entry:\", pos); if (pos == String::npos) { return {}; } auto last_pos = data.find('\\n', pos); assert(last_pos != String::npos); auto next_pos = data.find('\\n', last_pos + 1); auto terminator = data.find('}', pos); while ((next_pos != String::npos) && (next_pos < terminator)) { auto val = data.substr(last_pos, next_pos - last_pos); trim(val); if (val != \"\") { ret.emplace_back(std::move(val)); } last_pos = next_pos; next_pos = data.find('\\n', last_pos + 1); } return ret; } bool IrManipulationTestHelper::hasInstructionSequence(Strings const& instructions) { auto body_instructions = toBodyInstructions(); uint64_t i = 0; uint64_t j = 0; while (i < instructions.size() && j < body_instructions.size()) { auto& a = instructions[i]; auto& b = body_instructions[j]; if (a == b) { ++i; } ++j; } if (i < instructions.size()) { return false; } return true; } void IrManipulationTestHelper::applyProfile( GeneratorPtr const& generator, OptimizationLevel const& optimization_level, bool debug) { auto profile = generator->newProfile(\"generic\", optimization_level, debug); profile.apply(*module_); // Verifying that the module is valid if (isModuleBroken()) { throw std::runtime_error(\"Module was broken after applying result\"); } } bool IrManipulationTestHelper::validateProfile( GeneratorPtr const& generator, String const& profile_name, bool debug) { auto profile = generator->newProfile(profile_name, OptimizationLevel::O0, debug); return profile.validate(*module_); } bool IrManipulationTestHelper::containsValidationErrors( GeneratorPtr const& generator, String const& profile_name, Strings const& errors, bool debug) const { auto profile = generator->newProfile(profile_name, OptimizationLevel::O0, debug); auto& configuration_manager = generator->configurationManager(); auto validator = std::make_unique<Validator>(configuration_manager.get<ValidationPassConfiguration>(), true, debug); validator->validate(*module_); auto logger = validator->logger(); if (!logger) { throw std::runtime_error(\"Logger not present. Cannot test the presence of errors without a logger.\"); } std::unordered_set<String> hints; for (auto& message : logger->messages()) { hints.insert(message.location.llvm_hint); } auto ret = true; for (auto const& error : errors) { if (hints.find(error) == hints.end()) { ret = false; if (debug) { llvm::errs() << \"Missing '\" << error << \"' in LLVM output.\\n\"; } } } if (!ret && debug) { llvm::errs() << \"\\nExpected errors: \\n\"; for (auto const& error : errors) { llvm::errs() << error << \"\\n\"; } llvm::errs() << \"\\nActual errors: \\n\"; for (auto const& message : logger->messages()) { llvm::errs() << message.location.llvm_hint << \"\\n\"; llvm::errs() << \" - \" << message.message << \"\\n\"; } llvm::errs() << \"\\n\"; } return ret; } bool IrManipulationTestHelper::containsExactValidationErrors( GeneratorPtr const& generator, String const& profile_name, Strings const& errors, bool debug) const { auto profile = generator->newProfile(profile_name, OptimizationLevel::O0, debug); auto& configuration_manager = generator->configurationManager(); auto validator = std::make_unique<Validator>(configuration_manager.get<ValidationPassConfiguration>(), true, debug); validator->validate(*module_); auto logger = validator->logger(); if (!logger) { throw std::runtime_error(\"Logger not present. Cannot test the presence of errors without a logger.\"); } auto ret = true; std::unordered_set<String> hints; std::unordered_set<String> error_set{errors.begin(), errors.end()}; for (auto const& message : logger->messages()) { hints.insert(message.location.llvm_hint); if (error_set.find(message.location.llvm_hint) == error_set.end()) { ret = false; if (debug) { llvm::errs() << \"Missing '\" << message.location.llvm_hint << \"' in expected errors.\\n\"; } } } for (auto const& error : errors) { if (hints.find(error) == hints.end()) { ret = false; if (debug) { llvm::errs() << \"Missing '\" << error << \"' in LLVM output.\\n\"; } } } if (!ret && debug) { llvm::errs() << \"\\nExpected errors: \\n\"; for (auto const& error : errors) { llvm::errs() << error << \"\\n\"; } llvm::errs() << \"\\nActual errors: \\n\"; for (auto const& message : logger->messages()) { llvm::errs() << message.location.llvm_hint << \"\\n\"; llvm::errs() << \" - \" << message.message << \"\\n\"; } llvm::errs() << \"\\n\"; } return ret; } void IrManipulationTestHelper::declareOpaque(String const& name) { opaque_declarations_.insert(name); } void IrManipulationTestHelper::declareFunction(String const& declaration) { function_declarations_.insert(declaration); } String IrManipulationTestHelper::generateScript(String const& body, String const& args) const { String script = R\"script( ; ModuleID = 'IrManipulationTestHelper' source_filename = \"IrManipulationTestHelper.ll\" )script\"; // Adding opaque types for (auto const& op : opaque_declarations_) { script += \"%\" + op + \" = type opaque\\n\"; } script += \"define i8 @Main(\" + args + \") local_unnamed_addr #0 {\\nentry:\\n\"; script += body; script += \"\\n ret i8 0\\n\"; script += \"\\n}\\n\\n\"; for (auto const& op : function_declarations_) { script += \"declare \" + op + \"\\n\"; } script += \"\\nattributes #0 = { \\\"InteropFriendly\\\" }\\n\"; return script; } String IrManipulationTestHelper::getErrorMessage() const { String str; llvm::raw_string_ostream ostream(str); switch (error_.getKind()) { case llvm::SourceMgr::DiagKind::DK_Error: ostream << \"Error at \"; break; case llvm::SourceMgr::DiagKind::DK_Warning: ostream << \"Warning at \"; break; case llvm::SourceMgr::DiagKind::DK_Remark: ostream << \"Remark at \"; break; case llvm::SourceMgr::DiagKind::DK_Note: ostream << \"Note at \"; break; } ostream << error_.getLineNo() << \":\" << error_.getColumnNo() << \": \"; ostream << error_.getMessage() << \"\\n\\n\"; ostream << error_.getLineContents(); ostream.flush(); return str; } bool IrManipulationTestHelper::fromBodyString(String const& body, String const& args) { auto script = generateScript(body, args); return fromString(script); } IrManipulationTestHelper::ModulePtr& IrManipulationTestHelper::module() { return module_; } bool IrManipulationTestHelper::isModuleBroken() { if (compilation_failed_) { return compilation_failed_; } llvm::VerifierAnalysis verifier; auto result = verifier.run(*module_, module_analysis_manager_); return result.IRBroken; } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"TestTools/IrManipulationTestHelper.cpp"},{"location":"Api/Files/_ir_manipulation_test_helper_8cpp/#testtoolsirmanipulationtesthelpercpp","text":"","title":"TestTools/IrManipulationTestHelper.cpp"},{"location":"Api/Files/_ir_manipulation_test_helper_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_ir_manipulation_test_helper_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"Utils/Trim.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { IrManipulationTestHelper::IrManipulationTestHelper() { pass_builder_.registerModuleAnalyses(module_analysis_manager_); pass_builder_.registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_.registerFunctionAnalyses(function_analysis_manager_); pass_builder_.registerLoopAnalyses(loop_analysis_manager_); pass_builder_.crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); } bool IrManipulationTestHelper::fromString(String const& data) { module_ = llvm::parseIR(llvm::MemoryBufferRef(data, \"IrManipulationTestHelper\"), error_, context_); compilation_failed_ = (module_ == nullptr); return !compilation_failed_; } String IrManipulationTestHelper::toString() const { String str; llvm::raw_string_ostream ostream(str); ostream << *module_; ostream.flush(); return str; } IrManipulationTestHelper::Strings IrManipulationTestHelper::toBodyInstructions() { if (isModuleBroken()) { return {}; } String data = toString(); Strings ret; auto pos = data.find(\"define i8 @Main() local_unnamed_addr\"); if (pos == String::npos) { return {}; } // Skipping entry pos = data.find(\"entry:\", pos); if (pos == String::npos) { return {}; } auto last_pos = data.find('\\n', pos); assert(last_pos != String::npos); auto next_pos = data.find('\\n', last_pos + 1); auto terminator = data.find('}', pos); while ((next_pos != String::npos) && (next_pos < terminator)) { auto val = data.substr(last_pos, next_pos - last_pos); trim(val); if (val != \"\") { ret.emplace_back(std::move(val)); } last_pos = next_pos; next_pos = data.find('\\n', last_pos + 1); } return ret; } bool IrManipulationTestHelper::hasInstructionSequence(Strings const& instructions) { auto body_instructions = toBodyInstructions(); uint64_t i = 0; uint64_t j = 0; while (i < instructions.size() && j < body_instructions.size()) { auto& a = instructions[i]; auto& b = body_instructions[j]; if (a == b) { ++i; } ++j; } if (i < instructions.size()) { return false; } return true; } void IrManipulationTestHelper::applyProfile( GeneratorPtr const& generator, OptimizationLevel const& optimization_level, bool debug) { auto profile = generator->newProfile(\"generic\", optimization_level, debug); profile.apply(*module_); // Verifying that the module is valid if (isModuleBroken()) { throw std::runtime_error(\"Module was broken after applying result\"); } } bool IrManipulationTestHelper::validateProfile( GeneratorPtr const& generator, String const& profile_name, bool debug) { auto profile = generator->newProfile(profile_name, OptimizationLevel::O0, debug); return profile.validate(*module_); } bool IrManipulationTestHelper::containsValidationErrors( GeneratorPtr const& generator, String const& profile_name, Strings const& errors, bool debug) const { auto profile = generator->newProfile(profile_name, OptimizationLevel::O0, debug); auto& configuration_manager = generator->configurationManager(); auto validator = std::make_unique<Validator>(configuration_manager.get<ValidationPassConfiguration>(), true, debug); validator->validate(*module_); auto logger = validator->logger(); if (!logger) { throw std::runtime_error(\"Logger not present. Cannot test the presence of errors without a logger.\"); } std::unordered_set<String> hints; for (auto& message : logger->messages()) { hints.insert(message.location.llvm_hint); } auto ret = true; for (auto const& error : errors) { if (hints.find(error) == hints.end()) { ret = false; if (debug) { llvm::errs() << \"Missing '\" << error << \"' in LLVM output.\\n\"; } } } if (!ret && debug) { llvm::errs() << \"\\nExpected errors: \\n\"; for (auto const& error : errors) { llvm::errs() << error << \"\\n\"; } llvm::errs() << \"\\nActual errors: \\n\"; for (auto const& message : logger->messages()) { llvm::errs() << message.location.llvm_hint << \"\\n\"; llvm::errs() << \" - \" << message.message << \"\\n\"; } llvm::errs() << \"\\n\"; } return ret; } bool IrManipulationTestHelper::containsExactValidationErrors( GeneratorPtr const& generator, String const& profile_name, Strings const& errors, bool debug) const { auto profile = generator->newProfile(profile_name, OptimizationLevel::O0, debug); auto& configuration_manager = generator->configurationManager(); auto validator = std::make_unique<Validator>(configuration_manager.get<ValidationPassConfiguration>(), true, debug); validator->validate(*module_); auto logger = validator->logger(); if (!logger) { throw std::runtime_error(\"Logger not present. Cannot test the presence of errors without a logger.\"); } auto ret = true; std::unordered_set<String> hints; std::unordered_set<String> error_set{errors.begin(), errors.end()}; for (auto const& message : logger->messages()) { hints.insert(message.location.llvm_hint); if (error_set.find(message.location.llvm_hint) == error_set.end()) { ret = false; if (debug) { llvm::errs() << \"Missing '\" << message.location.llvm_hint << \"' in expected errors.\\n\"; } } } for (auto const& error : errors) { if (hints.find(error) == hints.end()) { ret = false; if (debug) { llvm::errs() << \"Missing '\" << error << \"' in LLVM output.\\n\"; } } } if (!ret && debug) { llvm::errs() << \"\\nExpected errors: \\n\"; for (auto const& error : errors) { llvm::errs() << error << \"\\n\"; } llvm::errs() << \"\\nActual errors: \\n\"; for (auto const& message : logger->messages()) { llvm::errs() << message.location.llvm_hint << \"\\n\"; llvm::errs() << \" - \" << message.message << \"\\n\"; } llvm::errs() << \"\\n\"; } return ret; } void IrManipulationTestHelper::declareOpaque(String const& name) { opaque_declarations_.insert(name); } void IrManipulationTestHelper::declareFunction(String const& declaration) { function_declarations_.insert(declaration); } String IrManipulationTestHelper::generateScript(String const& body, String const& args) const { String script = R\"script( ; ModuleID = 'IrManipulationTestHelper' source_filename = \"IrManipulationTestHelper.ll\" )script\"; // Adding opaque types for (auto const& op : opaque_declarations_) { script += \"%\" + op + \" = type opaque\\n\"; } script += \"define i8 @Main(\" + args + \") local_unnamed_addr #0 {\\nentry:\\n\"; script += body; script += \"\\n ret i8 0\\n\"; script += \"\\n}\\n\\n\"; for (auto const& op : function_declarations_) { script += \"declare \" + op + \"\\n\"; } script += \"\\nattributes #0 = { \\\"InteropFriendly\\\" }\\n\"; return script; } String IrManipulationTestHelper::getErrorMessage() const { String str; llvm::raw_string_ostream ostream(str); switch (error_.getKind()) { case llvm::SourceMgr::DiagKind::DK_Error: ostream << \"Error at \"; break; case llvm::SourceMgr::DiagKind::DK_Warning: ostream << \"Warning at \"; break; case llvm::SourceMgr::DiagKind::DK_Remark: ostream << \"Remark at \"; break; case llvm::SourceMgr::DiagKind::DK_Note: ostream << \"Note at \"; break; } ostream << error_.getLineNo() << \":\" << error_.getColumnNo() << \": \"; ostream << error_.getMessage() << \"\\n\\n\"; ostream << error_.getLineContents(); ostream.flush(); return str; } bool IrManipulationTestHelper::fromBodyString(String const& body, String const& args) { auto script = generateScript(body, args); return fromString(script); } IrManipulationTestHelper::ModulePtr& IrManipulationTestHelper::module() { return module_; } bool IrManipulationTestHelper::isModuleBroken() { if (compilation_failed_) { return compilation_failed_; } llvm::VerifierAnalysis verifier; auto result = verifier.run(*module_, module_analysis_manager_); return result.IRBroken; } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_ir_manipulation_test_helper_8hpp/","text":"TestTools/IrManipulationTestHelper.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::IrManipulationTestHelper Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/ProfileGenerator.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_set> #include <vector> namespace microsoft { namespace quantum { class IrManipulationTestHelper { public: using String = std::string; using Strings = std::vector<String>; using LLVMContext = llvm::LLVMContext; using SMDiagnostic = llvm::SMDiagnostic; using Module = llvm::Module; using ModulePtr = std::unique_ptr<Module>; using OptimizationLevel = llvm::PassBuilder::OptimizationLevel; using GeneratorPtr = std::shared_ptr<ProfileGenerator>; // IrManipulationTestHelper is default constructible with no ability to move // or copy. // IrManipulationTestHelper(); IrManipulationTestHelper(IrManipulationTestHelper const&) = delete; IrManipulationTestHelper& operator=(IrManipulationTestHelper const&) = delete; IrManipulationTestHelper(IrManipulationTestHelper&&) = delete; IrManipulationTestHelper& operator=(IrManipulationTestHelper&&) = delete; // Output functions // String toString() const; Strings toBodyInstructions(); // Test functions // bool hasInstructionSequence(Strings const& instructions); void applyProfile( GeneratorPtr const& generator, OptimizationLevel const& optimization_level = OptimizationLevel::O0, bool debug = false); bool validateProfile(GeneratorPtr const& generator, String const& profile_name = \"generic\", bool debug = false); bool containsValidationErrors( GeneratorPtr const& generator, String const& profile_name, Strings const& errors, bool debug = false) const; bool containsExactValidationErrors( GeneratorPtr const& generator, String const& profile_name, Strings const& errors, bool debug = false) const; // Declaration of partial or full IR // void declareOpaque(String const& name); void declareFunction(String const& declaration); bool fromBodyString(String const& body, String const& args = \"\"); String generateScript(String const& body, String const& args = \"\") const; bool fromString(String const& data); String getErrorMessage() const; bool isModuleBroken(); // Acccess member functions // ModulePtr& module(); private: // Declarations // std::unordered_set<std::string> opaque_declarations_{}; std::unordered_set<std::string> function_declarations_{}; // Compilation state // bool compilation_failed_{false}; SMDiagnostic error_; LLVMContext context_; ModulePtr module_; // Objects used to run a set of passes // llvm::PassBuilder pass_builder_; llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"TestTools/IrManipulationTestHelper.hpp"},{"location":"Api/Files/_ir_manipulation_test_helper_8hpp/#testtoolsirmanipulationtesthelperhpp","text":"","title":"TestTools/IrManipulationTestHelper.hpp"},{"location":"Api/Files/_ir_manipulation_test_helper_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_ir_manipulation_test_helper_8hpp/#classes","text":"Name class microsoft::quantum::IrManipulationTestHelper","title":"Classes"},{"location":"Api/Files/_ir_manipulation_test_helper_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/ProfileGenerator.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_set> #include <vector> namespace microsoft { namespace quantum { class IrManipulationTestHelper { public: using String = std::string; using Strings = std::vector<String>; using LLVMContext = llvm::LLVMContext; using SMDiagnostic = llvm::SMDiagnostic; using Module = llvm::Module; using ModulePtr = std::unique_ptr<Module>; using OptimizationLevel = llvm::PassBuilder::OptimizationLevel; using GeneratorPtr = std::shared_ptr<ProfileGenerator>; // IrManipulationTestHelper is default constructible with no ability to move // or copy. // IrManipulationTestHelper(); IrManipulationTestHelper(IrManipulationTestHelper const&) = delete; IrManipulationTestHelper& operator=(IrManipulationTestHelper const&) = delete; IrManipulationTestHelper(IrManipulationTestHelper&&) = delete; IrManipulationTestHelper& operator=(IrManipulationTestHelper&&) = delete; // Output functions // String toString() const; Strings toBodyInstructions(); // Test functions // bool hasInstructionSequence(Strings const& instructions); void applyProfile( GeneratorPtr const& generator, OptimizationLevel const& optimization_level = OptimizationLevel::O0, bool debug = false); bool validateProfile(GeneratorPtr const& generator, String const& profile_name = \"generic\", bool debug = false); bool containsValidationErrors( GeneratorPtr const& generator, String const& profile_name, Strings const& errors, bool debug = false) const; bool containsExactValidationErrors( GeneratorPtr const& generator, String const& profile_name, Strings const& errors, bool debug = false) const; // Declaration of partial or full IR // void declareOpaque(String const& name); void declareFunction(String const& declaration); bool fromBodyString(String const& body, String const& args = \"\"); String generateScript(String const& body, String const& args = \"\") const; bool fromString(String const& data); String getErrorMessage() const; bool isModuleBroken(); // Acccess member functions // ModulePtr& module(); private: // Declarations // std::unordered_set<std::string> opaque_declarations_{}; std::unordered_set<std::string> function_declarations_{}; // Compilation state // bool compilation_failed_{false}; SMDiagnostic error_; LLVMContext context_; ModulePtr module_; // Objects used to run a set of passes // llvm::PassBuilder pass_builder_; llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_llvm_passes_configuration_8cpp/","text":"Generators/LlvmPassesConfiguration.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"Generators/LlvmPassesConfiguration.hpp\" namespace microsoft { namespace quantum { void LlvmPassesConfiguration::setup(ConfigurationManager& config) { config.setSectionName( \"LLVM optimizations\", \"Enables specific LLVM optimizations before and after transformation.\"); // LLVM transformations config.addParameter(unroll_loops_, \"unroll-loops\", \"Aggressively unroll loops.\"); config.addParameter( unroll_allow_partial_, \"allow-partial\", \"Enables or disables partial unrolling. When disabled only full unrolling is allowed.\"); config.addParameter(unroll_allow_peeling_, \"allow-peeling\", \"Enables or disables loop peeling.\"); config.addParameter( unroll_allow_runtime_, \"allow-runtime\", \"Enables or disables unrolling of loops with runtime trip count.\"); config.addParameter( unroll_allow_upper_bound_, \"allow-upper-bound\", \"Enables or disables the use of trip count upper bound in loop unrolling.\"); config.addParameter( unroll_allow_profile_based_peeling_, \"allow-profile-based-peeling\", \"Enables or disables loop peeling basing on profile.\"); config.addParameter(unroll_full_unroll_count_, \"full-unroll-count\", \"Sets the max full unroll count.\"); config.addParameter(unroll_opt_level_, \"unroll-opt-level\", \"Sets the optimization level for loop unrolling.\"); config.addParameter( unroll_only_when_forced_, \"only-when-forced\", \"If true, only loops that explicitly request unrolling via metadata are considered.\"); config.addParameter( unroll_forget_scev_, \"forget-scev\", \"If true, forget all loops when unrolling. If false, forget top-most loop of \" \"the currently processed loops.\"); config.addParameter(always_inline_, \"always-inline\", \"Aggressively inline function calls.\"); config.addParameter(inline_parameter_, \"inlining-parameter\", \"Number of code lines acceptable when inlining.\"); config.addParameter(eliminate_constants_, \"eliminate-constants\", \"Uses LLVM pass to eliminate constants.\"); config.addParameter( eliminate_dead_code_, \"eliminate-dead-code\", \"Uses LLVMs aggressive dead code elimination.\"); config.addParameter(eliminate_memory_, \"eliminate-memory\", \"Maps memory into registers where feasible.\"); config.addExperimentalParameter( use_llvm_opt_pipeline_, false, false, \"use-llvm-opt-pipeline\", \"Disables the the default pipeline.\"); config.addExperimentalParameter( opt_pipeline_config_, static_cast<String>(\"\"), static_cast<String>(\"\"), \"opt-pipeline-config\", \"LLVM passes pipeline to use upon applying this component.\"); } bool LlvmPassesConfiguration::alwaysInline() const { return always_inline_; } bool LlvmPassesConfiguration::unrollLoops() const { return unroll_loops_; } int32_t LlvmPassesConfiguration::inlineParameter() const { return inline_parameter_; } bool LlvmPassesConfiguration::unrollAllowPartial() const { return unroll_allow_partial_; } bool LlvmPassesConfiguration::unrollAllowPeeling() const { return unroll_allow_peeling_; } bool LlvmPassesConfiguration::unrollAllowRuntime() const { return unroll_allow_runtime_; } bool LlvmPassesConfiguration::unrollAllowUpperBound() const { return unroll_allow_upper_bound_; } bool LlvmPassesConfiguration::unrollAllowProfilBasedPeeling() const { return unroll_allow_profile_based_peeling_; } uint64_t LlvmPassesConfiguration::unrolFullUnrollCount() const { return unroll_full_unroll_count_; } int32_t LlvmPassesConfiguration::unrollOptLevel() const { return unroll_opt_level_; } bool LlvmPassesConfiguration::unrollOnlyWhenForced() const { return unroll_only_when_forced_; } bool LlvmPassesConfiguration::unrollForgeScev() const { return unroll_forget_scev_; } bool LlvmPassesConfiguration::useLlvmOptPipeline() const { return use_llvm_opt_pipeline_; } String LlvmPassesConfiguration::optPipelineConfig() const { return opt_pipeline_config_; } bool LlvmPassesConfiguration::eliminateConstants() const { return eliminate_constants_; } bool LlvmPassesConfiguration::eliminateDeadCode() const { return eliminate_dead_code_; } bool LlvmPassesConfiguration::eliminateMemory() const { return eliminate_memory_; } LlvmPassesConfiguration LlvmPassesConfiguration::createDisabled() { LlvmPassesConfiguration ret; ret.always_inline_ = false; ret.inline_parameter_ = 0; ret.unroll_loops_ = false; ret.unroll_allow_partial_ = false; ret.unroll_allow_peeling_ = false; ret.unroll_allow_runtime_ = false; ret.unroll_allow_upper_bound_ = false; ret.unroll_allow_profile_based_peeling_ = false; ret.unroll_full_unroll_count_ = 0; ret.unroll_opt_level_ = 0; ret.unroll_only_when_forced_ = false; ret.unroll_forget_scev_ = false; ret.eliminate_constants_ = false; ret.eliminate_dead_code_ = false; ret.eliminate_memory_ = false; ret.use_llvm_opt_pipeline_ = false; ret.opt_pipeline_config_ = \"\"; return ret; } LlvmPassesConfiguration LlvmPassesConfiguration::createUnrollInline() { LlvmPassesConfiguration ret; ret.always_inline_ = true; ret.inline_parameter_ = std::numeric_limits<int32_t>::max(); ret.unroll_loops_ = true; ret.unroll_allow_partial_ = true; ret.unroll_allow_peeling_ = true; ret.unroll_allow_runtime_ = true; ret.unroll_allow_upper_bound_ = true; ret.unroll_allow_profile_based_peeling_ = true; ret.unroll_full_unroll_count_ = 1024; ret.unroll_opt_level_ = 3; ret.unroll_only_when_forced_ = false; ret.unroll_forget_scev_ = false; ret.eliminate_constants_ = true; ret.eliminate_dead_code_ = true; ret.eliminate_memory_ = true; ret.use_llvm_opt_pipeline_ = false; ret.opt_pipeline_config_ = \"\"; return ret; } bool LlvmPassesConfiguration::isDisabled() const { return always_inline_ == false && inline_parameter_ == 0 && unroll_loops_ == false && unroll_allow_partial_ == false && unroll_allow_peeling_ == false && unroll_allow_runtime_ == false && unroll_allow_upper_bound_ == false && unroll_allow_profile_based_peeling_ == false && unroll_full_unroll_count_ == 0 && unroll_opt_level_ == 0 && unroll_only_when_forced_ == false && unroll_forget_scev_ == false && eliminate_constants_ == false && eliminate_dead_code_ == false && eliminate_memory_ == false && use_llvm_opt_pipeline_ == false && opt_pipeline_config_ == \"\"; } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Generators/LlvmPassesConfiguration.cpp"},{"location":"Api/Files/_llvm_passes_configuration_8cpp/#generatorsllvmpassesconfigurationcpp","text":"","title":"Generators/LlvmPassesConfiguration.cpp"},{"location":"Api/Files/_llvm_passes_configuration_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_llvm_passes_configuration_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"Generators/LlvmPassesConfiguration.hpp\" namespace microsoft { namespace quantum { void LlvmPassesConfiguration::setup(ConfigurationManager& config) { config.setSectionName( \"LLVM optimizations\", \"Enables specific LLVM optimizations before and after transformation.\"); // LLVM transformations config.addParameter(unroll_loops_, \"unroll-loops\", \"Aggressively unroll loops.\"); config.addParameter( unroll_allow_partial_, \"allow-partial\", \"Enables or disables partial unrolling. When disabled only full unrolling is allowed.\"); config.addParameter(unroll_allow_peeling_, \"allow-peeling\", \"Enables or disables loop peeling.\"); config.addParameter( unroll_allow_runtime_, \"allow-runtime\", \"Enables or disables unrolling of loops with runtime trip count.\"); config.addParameter( unroll_allow_upper_bound_, \"allow-upper-bound\", \"Enables or disables the use of trip count upper bound in loop unrolling.\"); config.addParameter( unroll_allow_profile_based_peeling_, \"allow-profile-based-peeling\", \"Enables or disables loop peeling basing on profile.\"); config.addParameter(unroll_full_unroll_count_, \"full-unroll-count\", \"Sets the max full unroll count.\"); config.addParameter(unroll_opt_level_, \"unroll-opt-level\", \"Sets the optimization level for loop unrolling.\"); config.addParameter( unroll_only_when_forced_, \"only-when-forced\", \"If true, only loops that explicitly request unrolling via metadata are considered.\"); config.addParameter( unroll_forget_scev_, \"forget-scev\", \"If true, forget all loops when unrolling. If false, forget top-most loop of \" \"the currently processed loops.\"); config.addParameter(always_inline_, \"always-inline\", \"Aggressively inline function calls.\"); config.addParameter(inline_parameter_, \"inlining-parameter\", \"Number of code lines acceptable when inlining.\"); config.addParameter(eliminate_constants_, \"eliminate-constants\", \"Uses LLVM pass to eliminate constants.\"); config.addParameter( eliminate_dead_code_, \"eliminate-dead-code\", \"Uses LLVMs aggressive dead code elimination.\"); config.addParameter(eliminate_memory_, \"eliminate-memory\", \"Maps memory into registers where feasible.\"); config.addExperimentalParameter( use_llvm_opt_pipeline_, false, false, \"use-llvm-opt-pipeline\", \"Disables the the default pipeline.\"); config.addExperimentalParameter( opt_pipeline_config_, static_cast<String>(\"\"), static_cast<String>(\"\"), \"opt-pipeline-config\", \"LLVM passes pipeline to use upon applying this component.\"); } bool LlvmPassesConfiguration::alwaysInline() const { return always_inline_; } bool LlvmPassesConfiguration::unrollLoops() const { return unroll_loops_; } int32_t LlvmPassesConfiguration::inlineParameter() const { return inline_parameter_; } bool LlvmPassesConfiguration::unrollAllowPartial() const { return unroll_allow_partial_; } bool LlvmPassesConfiguration::unrollAllowPeeling() const { return unroll_allow_peeling_; } bool LlvmPassesConfiguration::unrollAllowRuntime() const { return unroll_allow_runtime_; } bool LlvmPassesConfiguration::unrollAllowUpperBound() const { return unroll_allow_upper_bound_; } bool LlvmPassesConfiguration::unrollAllowProfilBasedPeeling() const { return unroll_allow_profile_based_peeling_; } uint64_t LlvmPassesConfiguration::unrolFullUnrollCount() const { return unroll_full_unroll_count_; } int32_t LlvmPassesConfiguration::unrollOptLevel() const { return unroll_opt_level_; } bool LlvmPassesConfiguration::unrollOnlyWhenForced() const { return unroll_only_when_forced_; } bool LlvmPassesConfiguration::unrollForgeScev() const { return unroll_forget_scev_; } bool LlvmPassesConfiguration::useLlvmOptPipeline() const { return use_llvm_opt_pipeline_; } String LlvmPassesConfiguration::optPipelineConfig() const { return opt_pipeline_config_; } bool LlvmPassesConfiguration::eliminateConstants() const { return eliminate_constants_; } bool LlvmPassesConfiguration::eliminateDeadCode() const { return eliminate_dead_code_; } bool LlvmPassesConfiguration::eliminateMemory() const { return eliminate_memory_; } LlvmPassesConfiguration LlvmPassesConfiguration::createDisabled() { LlvmPassesConfiguration ret; ret.always_inline_ = false; ret.inline_parameter_ = 0; ret.unroll_loops_ = false; ret.unroll_allow_partial_ = false; ret.unroll_allow_peeling_ = false; ret.unroll_allow_runtime_ = false; ret.unroll_allow_upper_bound_ = false; ret.unroll_allow_profile_based_peeling_ = false; ret.unroll_full_unroll_count_ = 0; ret.unroll_opt_level_ = 0; ret.unroll_only_when_forced_ = false; ret.unroll_forget_scev_ = false; ret.eliminate_constants_ = false; ret.eliminate_dead_code_ = false; ret.eliminate_memory_ = false; ret.use_llvm_opt_pipeline_ = false; ret.opt_pipeline_config_ = \"\"; return ret; } LlvmPassesConfiguration LlvmPassesConfiguration::createUnrollInline() { LlvmPassesConfiguration ret; ret.always_inline_ = true; ret.inline_parameter_ = std::numeric_limits<int32_t>::max(); ret.unroll_loops_ = true; ret.unroll_allow_partial_ = true; ret.unroll_allow_peeling_ = true; ret.unroll_allow_runtime_ = true; ret.unroll_allow_upper_bound_ = true; ret.unroll_allow_profile_based_peeling_ = true; ret.unroll_full_unroll_count_ = 1024; ret.unroll_opt_level_ = 3; ret.unroll_only_when_forced_ = false; ret.unroll_forget_scev_ = false; ret.eliminate_constants_ = true; ret.eliminate_dead_code_ = true; ret.eliminate_memory_ = true; ret.use_llvm_opt_pipeline_ = false; ret.opt_pipeline_config_ = \"\"; return ret; } bool LlvmPassesConfiguration::isDisabled() const { return always_inline_ == false && inline_parameter_ == 0 && unroll_loops_ == false && unroll_allow_partial_ == false && unroll_allow_peeling_ == false && unroll_allow_runtime_ == false && unroll_allow_upper_bound_ == false && unroll_allow_profile_based_peeling_ == false && unroll_full_unroll_count_ == 0 && unroll_opt_level_ == 0 && unroll_only_when_forced_ == false && unroll_forget_scev_ == false && eliminate_constants_ == false && eliminate_dead_code_ == false && eliminate_memory_ == false && use_llvm_opt_pipeline_ == false && opt_pipeline_config_ == \"\"; } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_llvm_passes_configuration_8hpp/","text":"Generators/LlvmPassesConfiguration.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::LlvmPassesConfiguration Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include <limits> namespace microsoft { namespace quantum { class LlvmPassesConfiguration { public: void setup(ConfigurationManager& config); bool alwaysInline() const; bool unrollLoops() const; int32_t inlineParameter() const; bool unrollAllowPartial() const; bool unrollAllowPeeling() const; bool unrollAllowRuntime() const; bool unrollAllowUpperBound() const; bool unrollAllowProfilBasedPeeling() const; uint64_t unrolFullUnrollCount() const; int32_t unrollOptLevel() const; bool unrollOnlyWhenForced() const; bool unrollForgeScev() const; bool useLlvmOptPipeline() const; String optPipelineConfig() const; bool eliminateConstants() const; bool eliminateDeadCode() const; bool eliminateMemory() const; // Configuration classification bool isDisabled() const; bool operator==(LlvmPassesConfiguration const& o) const = default; static LlvmPassesConfiguration createDisabled(); static LlvmPassesConfiguration createUnrollInline(); private: bool always_inline_{false}; int32_t inline_parameter_{std::numeric_limits<int32_t>::max()}; bool unroll_loops_{false}; bool unroll_allow_partial_{true}; bool unroll_allow_peeling_{true}; bool unroll_allow_runtime_{true}; bool unroll_allow_upper_bound_{true}; bool unroll_allow_profile_based_peeling_{true}; uint64_t unroll_full_unroll_count_{1024}; int32_t unroll_opt_level_{3}; bool unroll_only_when_forced_{false}; bool unroll_forget_scev_{false}; bool eliminate_constants_{true}; bool eliminate_dead_code_{true}; bool eliminate_memory_{true}; bool use_llvm_opt_pipeline_{false}; String opt_pipeline_config_{\"\"}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Generators/LlvmPassesConfiguration.hpp"},{"location":"Api/Files/_llvm_passes_configuration_8hpp/#generatorsllvmpassesconfigurationhpp","text":"","title":"Generators/LlvmPassesConfiguration.hpp"},{"location":"Api/Files/_llvm_passes_configuration_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_llvm_passes_configuration_8hpp/#classes","text":"Name class microsoft::quantum::LlvmPassesConfiguration","title":"Classes"},{"location":"Api/Files/_llvm_passes_configuration_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include <limits> namespace microsoft { namespace quantum { class LlvmPassesConfiguration { public: void setup(ConfigurationManager& config); bool alwaysInline() const; bool unrollLoops() const; int32_t inlineParameter() const; bool unrollAllowPartial() const; bool unrollAllowPeeling() const; bool unrollAllowRuntime() const; bool unrollAllowUpperBound() const; bool unrollAllowProfilBasedPeeling() const; uint64_t unrolFullUnrollCount() const; int32_t unrollOptLevel() const; bool unrollOnlyWhenForced() const; bool unrollForgeScev() const; bool useLlvmOptPipeline() const; String optPipelineConfig() const; bool eliminateConstants() const; bool eliminateDeadCode() const; bool eliminateMemory() const; // Configuration classification bool isDisabled() const; bool operator==(LlvmPassesConfiguration const& o) const = default; static LlvmPassesConfiguration createDisabled(); static LlvmPassesConfiguration createUnrollInline(); private: bool always_inline_{false}; int32_t inline_parameter_{std::numeric_limits<int32_t>::max()}; bool unroll_loops_{false}; bool unroll_allow_partial_{true}; bool unroll_allow_peeling_{true}; bool unroll_allow_runtime_{true}; bool unroll_allow_upper_bound_{true}; bool unroll_allow_profile_based_peeling_{true}; uint64_t unroll_full_unroll_count_{1024}; int32_t unroll_opt_level_{3}; bool unroll_only_when_forced_{false}; bool unroll_forget_scev_{false}; bool eliminate_constants_{true}; bool eliminate_dead_code_{true}; bool eliminate_memory_{true}; bool use_llvm_opt_pipeline_{false}; String opt_pipeline_config_{\"\"}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_load_8cpp/","text":"Rules/Notation/Load.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr load(IOperandPrototypePtr const& arg) { auto ret = std::make_shared<LoadPattern>(); ret->addChild(arg); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Notation/Load.cpp"},{"location":"Api/Files/_load_8cpp/#rulesnotationloadcpp","text":"","title":"Rules/Notation/Load.cpp"},{"location":"Api/Files/_load_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_load_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr load(IOperandPrototypePtr const& arg) { auto ret = std::make_shared<LoadPattern>(); ret->addChild(arg); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_log_collection_8cpp/","text":"Logging/LogCollection.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/LogCollection.hpp\" #include \"Utils/Trim.hpp\" #include <vector> namespace microsoft { namespace quantum { void LogCollection::debug(String const& message) { messages_.push_back({Type::Debug, current_location_, message}); } void LogCollection::info(String const& message) { messages_.push_back({Type::Info, current_location_, message}); } void LogCollection::warning(String const& message) { messages_.push_back({Type::Warning, current_location_, message}); } void LogCollection::error(String const& message) { messages_.push_back({Type::Error, current_location_, message}); } void LogCollection::internalError(String const& message) { messages_.push_back({Type::InternalError, current_location_, message}); } void LogCollection::setLocation(String const& name, uint64_t row, uint64_t col) { current_location_.name = name; current_location_.row = row; current_location_.col = col; } LogCollection::Messages const& LogCollection::messages() const { return messages_; } void LogCollection::setLlvmHint(String const& value) { current_location_.llvm_hint = value; trim(current_location_.llvm_hint); } void LogCollection::setFrontendHint(String const& value) { current_location_.frontend_hint = value; trim(current_location_.frontend_hint); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Logging/LogCollection.cpp"},{"location":"Api/Files/_log_collection_8cpp/#logginglogcollectioncpp","text":"","title":"Logging/LogCollection.cpp"},{"location":"Api/Files/_log_collection_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_log_collection_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/LogCollection.hpp\" #include \"Utils/Trim.hpp\" #include <vector> namespace microsoft { namespace quantum { void LogCollection::debug(String const& message) { messages_.push_back({Type::Debug, current_location_, message}); } void LogCollection::info(String const& message) { messages_.push_back({Type::Info, current_location_, message}); } void LogCollection::warning(String const& message) { messages_.push_back({Type::Warning, current_location_, message}); } void LogCollection::error(String const& message) { messages_.push_back({Type::Error, current_location_, message}); } void LogCollection::internalError(String const& message) { messages_.push_back({Type::InternalError, current_location_, message}); } void LogCollection::setLocation(String const& name, uint64_t row, uint64_t col) { current_location_.name = name; current_location_.row = row; current_location_.col = col; } LogCollection::Messages const& LogCollection::messages() const { return messages_; } void LogCollection::setLlvmHint(String const& value) { current_location_.llvm_hint = value; trim(current_location_.llvm_hint); } void LogCollection::setFrontendHint(String const& value) { current_location_.frontend_hint = value; trim(current_location_.frontend_hint); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_log_collection_8hpp/","text":"Logging/LogCollection.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::LogCollection struct microsoft::quantum::LogCollection::Location Class that holds the location of where the incident happened. struct microsoft::quantum::LogCollection::Message Struct to hold a message together with its type and location. Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/ILogger.hpp\" #include <vector> namespace microsoft { namespace quantum { class LogCollection : public ILogger { public: struct Location { String name{}; uint64_t row{0}; uint64_t col{0}; String llvm_hint; String frontend_hint; }; enum class Type { Debug, Info, Warning, Error, InternalError, }; struct Message { Type type; Location location; String message; }; using Messages = std::vector<Message>; // Interface implementation // void debug(String const& message) override; void info(String const& message) override; void warning(String const& message) override; void error(String const& message) override; void internalError(String const& message) override; void setLocation(String const& name, uint64_t row, uint64_t col) override; void setLlvmHint(String const& value) override; void setFrontendHint(String const& value) override; Messages const& messages() const; private: Location current_location_{}; Messages messages_; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Logging/LogCollection.hpp"},{"location":"Api/Files/_log_collection_8hpp/#logginglogcollectionhpp","text":"","title":"Logging/LogCollection.hpp"},{"location":"Api/Files/_log_collection_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_log_collection_8hpp/#classes","text":"Name class microsoft::quantum::LogCollection struct microsoft::quantum::LogCollection::Location Class that holds the location of where the incident happened. struct microsoft::quantum::LogCollection::Message Struct to hold a message together with its type and location.","title":"Classes"},{"location":"Api/Files/_log_collection_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/ILogger.hpp\" #include <vector> namespace microsoft { namespace quantum { class LogCollection : public ILogger { public: struct Location { String name{}; uint64_t row{0}; uint64_t col{0}; String llvm_hint; String frontend_hint; }; enum class Type { Debug, Info, Warning, Error, InternalError, }; struct Message { Type type; Location location; String message; }; using Messages = std::vector<Message>; // Interface implementation // void debug(String const& message) override; void info(String const& message) override; void warning(String const& message) override; void error(String const& message) override; void internalError(String const& message) override; void setLocation(String const& name, uint64_t row, uint64_t col) override; void setLlvmHint(String const& value) override; void setFrontendHint(String const& value) override; Messages const& messages() const; private: Location current_location_{}; Messages messages_; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_module_loader_8hpp/","text":"ModuleLoader/ModuleLoader.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ModuleLoader Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include \"RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { class ModuleLoader { public: using Module = llvm::Module; using Linker = llvm::Linker; using SMDiagnostic = llvm::SMDiagnostic; explicit ModuleLoader(Module* final_module) : final_module_{final_module} , linker_{*final_module} { } bool addModule(std::unique_ptr<Module>&& module, String const& filename = \"unknown\") { if (llvm::verifyModule(*module, &llvm::errs())) { llvm::errs() << filename << \": \" << \"input module is broken!\\n\"; return false; } return !linker_.linkInModule(std::move(module), Linker::Flags::None); } bool addIrFile(String const& filename) { // Loading module SMDiagnostic err; std::unique_ptr<Module> module = llvm::parseIRFile(filename, err, final_module_->getContext()); if (!module) { llvm::errs() << \"Failed to load \" << filename << \"\\n\"; return false; } // Transforming module SingleModuleTransformation transformation; if (!transformation.apply(module.get())) { llvm::errs() << \"Failed to transform \" << filename << \"\\n\"; return false; } // Linking return addModule(std::move(module), filename); } private: Module* final_module_; Linker linker_; // Single Module Transformation // class SingleModuleTransformation { public: using PassBuilder = llvm::PassBuilder; using OptimizationLevel = PassBuilder::OptimizationLevel; using FunctionAnalysisManager = llvm::FunctionAnalysisManager; explicit SingleModuleTransformation( OptimizationLevel const& optimization_level = OptimizationLevel::O0, bool debug = false) : loop_analysis_manager_{debug} , function_analysis_manager_{debug} , gscc_analysis_manager_{debug} , module_analysis_manager_{debug} , optimization_level_{optimization_level} , debug_{debug} { pass_builder_.registerModuleAnalyses(module_analysis_manager_); pass_builder_.registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_.registerFunctionAnalyses(function_analysis_manager_); pass_builder_.registerLoopAnalyses(loop_analysis_manager_); pass_builder_.crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); module_pass_manager_.addPass(RemoveDisallowedAttributesPass()); } bool apply(llvm::Module* module) { module_pass_manager_.run(*module, module_analysis_manager_); if (llvm::verifyModule(*module, &llvm::errs())) { return false; } return true; } bool isDebugMode() const { return debug_; } private: llvm::PassBuilder pass_builder_; llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; llvm::ModulePassManager module_pass_manager_{}; OptimizationLevel optimization_level_{}; bool debug_{false}; }; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"ModuleLoader/ModuleLoader.hpp"},{"location":"Api/Files/_module_loader_8hpp/#moduleloadermoduleloaderhpp","text":"","title":"ModuleLoader/ModuleLoader.hpp"},{"location":"Api/Files/_module_loader_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_module_loader_8hpp/#classes","text":"Name class microsoft::quantum::ModuleLoader","title":"Classes"},{"location":"Api/Files/_module_loader_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include \"RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { class ModuleLoader { public: using Module = llvm::Module; using Linker = llvm::Linker; using SMDiagnostic = llvm::SMDiagnostic; explicit ModuleLoader(Module* final_module) : final_module_{final_module} , linker_{*final_module} { } bool addModule(std::unique_ptr<Module>&& module, String const& filename = \"unknown\") { if (llvm::verifyModule(*module, &llvm::errs())) { llvm::errs() << filename << \": \" << \"input module is broken!\\n\"; return false; } return !linker_.linkInModule(std::move(module), Linker::Flags::None); } bool addIrFile(String const& filename) { // Loading module SMDiagnostic err; std::unique_ptr<Module> module = llvm::parseIRFile(filename, err, final_module_->getContext()); if (!module) { llvm::errs() << \"Failed to load \" << filename << \"\\n\"; return false; } // Transforming module SingleModuleTransformation transformation; if (!transformation.apply(module.get())) { llvm::errs() << \"Failed to transform \" << filename << \"\\n\"; return false; } // Linking return addModule(std::move(module), filename); } private: Module* final_module_; Linker linker_; // Single Module Transformation // class SingleModuleTransformation { public: using PassBuilder = llvm::PassBuilder; using OptimizationLevel = PassBuilder::OptimizationLevel; using FunctionAnalysisManager = llvm::FunctionAnalysisManager; explicit SingleModuleTransformation( OptimizationLevel const& optimization_level = OptimizationLevel::O0, bool debug = false) : loop_analysis_manager_{debug} , function_analysis_manager_{debug} , gscc_analysis_manager_{debug} , module_analysis_manager_{debug} , optimization_level_{optimization_level} , debug_{debug} { pass_builder_.registerModuleAnalyses(module_analysis_manager_); pass_builder_.registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_.registerFunctionAnalyses(function_analysis_manager_); pass_builder_.registerLoopAnalyses(loop_analysis_manager_); pass_builder_.crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); module_pass_manager_.addPass(RemoveDisallowedAttributesPass()); } bool apply(llvm::Module* module) { module_pass_manager_.run(*module, module_analysis_manager_); if (llvm::verifyModule(*module, &llvm::errs())) { return false; } return true; } bool isDebugMode() const { return debug_; } private: llvm::PassBuilder pass_builder_; llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; llvm::ModulePassManager module_pass_manager_{}; OptimizationLevel optimization_level_{}; bool debug_{false}; }; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_notation_8cpp/","text":"Rules/Notation/Notation.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { ReplacerFunction deleteInstruction() { return [](ReplacementRule::Builder&, ReplacementRule::Value* val, ReplacementRule::Captures&, ReplacementRule::Replacements& replacements) { auto type = val->getType(); val->replaceAllUsesWith(llvm::UndefValue::get(type)); replacements.push_back({llvm::dyn_cast<llvm::Instruction>(val), nullptr}); return true; }; } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Notation/Notation.cpp"},{"location":"Api/Files/_notation_8cpp/#rulesnotationnotationcpp","text":"","title":"Rules/Notation/Notation.cpp"},{"location":"Api/Files/_notation_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_notation_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { ReplacerFunction deleteInstruction() { return [](ReplacementRule::Builder&, ReplacementRule::Value* val, ReplacementRule::Captures&, ReplacementRule::Replacements& replacements) { auto type = val->getType(); val->replaceAllUsesWith(llvm::UndefValue::get(type)); replacements.push_back({llvm::dyn_cast<llvm::Instruction>(val), nullptr}); return true; }; } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_notation_8hpp/","text":"Rules/Notation/Notation.hpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Classes Name class microsoft::quantum::notation::Capture Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Call.hpp\" #include \"Rules/Notation/Call.ipp\" #include \"Rules/Notation/Phi.ipp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Rules/Patterns/PhiPattern.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; using ReplacerFunction = std::function<bool( ReplacementRule::Builder&, ReplacementRule::Value*, ReplacementRule::Captures&, ReplacementRule::Replacements&)>; class Capture { public: explicit Capture(std::string const& name); // Note that this operator is delibrately unconventional IOperandPrototypePtr operator=(IOperandPrototypePtr const& other); // NOLINT private: std::string name_{}; }; template <typename... Args> IOperandPrototypePtr call(std::string const& name, Args... args); IOperandPrototypePtr unnamedInvoke(); template <typename... Args> IOperandPrototypePtr phi(Args... args); IOperandPrototypePtr callByNameOnly(std::string const& name); IOperandPrototypePtr bitCast(IOperandPrototypePtr const& arg); IOperandPrototypePtr intToPtr(IOperandPrototypePtr const& arg); IOperandPrototypePtr constInt(); IOperandPrototypePtr branch( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2); IOperandPrototypePtr switchOp( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2); IOperandPrototypePtr select( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2); IOperandPrototypePtr load(IOperandPrototypePtr const& arg); IOperandPrototypePtr store(IOperandPrototypePtr const& target, IOperandPrototypePtr const& value); IOperandPrototypePtr basicBlock(); static std::shared_ptr<AnyPattern> const _ = std::make_shared<AnyPattern>(); // NOLINT ReplacerFunction deleteInstruction(); Capture operator\"\"_cap(char const* name, std::size_t); } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Notation/Notation.hpp"},{"location":"Api/Files/_notation_8hpp/#rulesnotationnotationhpp","text":"","title":"Rules/Notation/Notation.hpp"},{"location":"Api/Files/_notation_8hpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_notation_8hpp/#classes","text":"Name class microsoft::quantum::notation::Capture","title":"Classes"},{"location":"Api/Files/_notation_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Call.hpp\" #include \"Rules/Notation/Call.ipp\" #include \"Rules/Notation/Phi.ipp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Rules/Patterns/PhiPattern.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; using ReplacerFunction = std::function<bool( ReplacementRule::Builder&, ReplacementRule::Value*, ReplacementRule::Captures&, ReplacementRule::Replacements&)>; class Capture { public: explicit Capture(std::string const& name); // Note that this operator is delibrately unconventional IOperandPrototypePtr operator=(IOperandPrototypePtr const& other); // NOLINT private: std::string name_{}; }; template <typename... Args> IOperandPrototypePtr call(std::string const& name, Args... args); IOperandPrototypePtr unnamedInvoke(); template <typename... Args> IOperandPrototypePtr phi(Args... args); IOperandPrototypePtr callByNameOnly(std::string const& name); IOperandPrototypePtr bitCast(IOperandPrototypePtr const& arg); IOperandPrototypePtr intToPtr(IOperandPrototypePtr const& arg); IOperandPrototypePtr constInt(); IOperandPrototypePtr branch( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2); IOperandPrototypePtr switchOp( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2); IOperandPrototypePtr select( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2); IOperandPrototypePtr load(IOperandPrototypePtr const& arg); IOperandPrototypePtr store(IOperandPrototypePtr const& target, IOperandPrototypePtr const& value); IOperandPrototypePtr basicBlock(); static std::shared_ptr<AnyPattern> const _ = std::make_shared<AnyPattern>(); // NOLINT ReplacerFunction deleteInstruction(); Capture operator\"\"_cap(char const* name, std::size_t); } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_parameter_parser_8cpp/","text":"Commandline/ParameterParser.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ParameterParser.hpp\" #include <iostream> #include <stdexcept> #include <string> #include <unordered_map> namespace microsoft { namespace quantum { void ParameterParser::parseArgs(int argc, char** argv) { uint64_t i = 1; std::vector<ParsedValue> values; while (i < static_cast<uint64_t>(argc)) { values.push_back(parseSingleArg(argv[i])); ++i; } i = 0; while (i < values.size()) { auto& v = values[i]; ++i; if (!v.is_key) { arguments_.push_back(v.value); continue; } unused_properties_.insert(v.value); if (i >= values.size()) { settings_[v.value] = \"true\"; continue; } auto& v2 = values[i]; if (!v2.is_key && isOption(v.value)) { settings_[v.value] = v2.value; ++i; continue; } settings_[v.value] = \"true\"; } } void ParameterParser::addFlag(String const& v) { flags_.insert(v); } String const& ParameterParser::get(String const& name, String const& default_value) noexcept { auto it = settings_.find(name); if (it == settings_.end()) { return default_value; } markAsUsed(name); return it->second; } String const& ParameterParser::get(String const& name) { auto it = settings_.find(name); if (it == settings_.end()) { throw std::runtime_error(\"Could not find setting '\" + name + \"'.\"); } markAsUsed(name); return it->second; } void ParameterParser::markAsUsed(String const& name) { auto it = unused_properties_.find(name); if (it != unused_properties_.end()) { unused_properties_.erase(it); } } ParameterParser::UnusedSettings const& ParameterParser::unusedSettings() const { return unused_properties_; } bool ParameterParser::has(String const& name) const noexcept { auto it = settings_.find(name); return (it != settings_.end()); } ParameterParser::Arguments const& ParameterParser::arguments() const { return arguments_; } String const& ParameterParser::getArg(Arguments::size_type const& n) const { return arguments_[n]; } ParameterParser::ParsedValue ParameterParser::parseSingleArg(String key) { bool is_key = false; if (key.size() > 2 && key.substr(0, 2) == \"--\") { is_key = true; key = key.substr(2); } else if (key.size() > 1 && key.substr(0, 1) == \"-\") { is_key = true; key = key.substr(1); } return {is_key, key}; } bool ParameterParser::isOption(String const& key) { if (flags_.find(key) != flags_.end()) { return false; } return true; } void ParameterParser::reset() { arguments_.clear(); settings_.clear(); flags_.clear(); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Commandline/ParameterParser.cpp"},{"location":"Api/Files/_parameter_parser_8cpp/#commandlineparameterparsercpp","text":"","title":"Commandline/ParameterParser.cpp"},{"location":"Api/Files/_parameter_parser_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_parameter_parser_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ParameterParser.hpp\" #include <iostream> #include <stdexcept> #include <string> #include <unordered_map> namespace microsoft { namespace quantum { void ParameterParser::parseArgs(int argc, char** argv) { uint64_t i = 1; std::vector<ParsedValue> values; while (i < static_cast<uint64_t>(argc)) { values.push_back(parseSingleArg(argv[i])); ++i; } i = 0; while (i < values.size()) { auto& v = values[i]; ++i; if (!v.is_key) { arguments_.push_back(v.value); continue; } unused_properties_.insert(v.value); if (i >= values.size()) { settings_[v.value] = \"true\"; continue; } auto& v2 = values[i]; if (!v2.is_key && isOption(v.value)) { settings_[v.value] = v2.value; ++i; continue; } settings_[v.value] = \"true\"; } } void ParameterParser::addFlag(String const& v) { flags_.insert(v); } String const& ParameterParser::get(String const& name, String const& default_value) noexcept { auto it = settings_.find(name); if (it == settings_.end()) { return default_value; } markAsUsed(name); return it->second; } String const& ParameterParser::get(String const& name) { auto it = settings_.find(name); if (it == settings_.end()) { throw std::runtime_error(\"Could not find setting '\" + name + \"'.\"); } markAsUsed(name); return it->second; } void ParameterParser::markAsUsed(String const& name) { auto it = unused_properties_.find(name); if (it != unused_properties_.end()) { unused_properties_.erase(it); } } ParameterParser::UnusedSettings const& ParameterParser::unusedSettings() const { return unused_properties_; } bool ParameterParser::has(String const& name) const noexcept { auto it = settings_.find(name); return (it != settings_.end()); } ParameterParser::Arguments const& ParameterParser::arguments() const { return arguments_; } String const& ParameterParser::getArg(Arguments::size_type const& n) const { return arguments_[n]; } ParameterParser::ParsedValue ParameterParser::parseSingleArg(String key) { bool is_key = false; if (key.size() > 2 && key.substr(0, 2) == \"--\") { is_key = true; key = key.substr(2); } else if (key.size() > 1 && key.substr(0, 1) == \"-\") { is_key = true; key = key.substr(1); } return {is_key, key}; } bool ParameterParser::isOption(String const& key) { if (flags_.find(key) != flags_.end()) { return false; } return true; } void ParameterParser::reset() { arguments_.clear(); settings_.clear(); flags_.clear(); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_parameter_parser_8hpp/","text":"Commandline/ParameterParser.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ParameterParser Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include <string> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft { namespace quantum { class ParameterParser { public: using Arguments = std::vector<String>; using Flags = std::unordered_set<String>; using SettingsMap = std::unordered_map<String, String>; using UnusedSettings = std::unordered_set<String>; // Construction and deconstrution configuration // ParameterParser() = default; // No copy construction. ParameterParser(ParameterParser const& other) = delete; // Allow move semantics. ParameterParser(ParameterParser&& other) = default; // Default destruction. ~ParameterParser() = default; // Configuration // void addFlag(String const& v); // Operation // void parseArgs(int argc, char** argv); Arguments const& arguments() const; String const& getArg(Arguments::size_type const& n) const; String const& get(String const& name, String const& default_value) noexcept; String const& get(String const& name); void markAsUsed(String const& name); bool has(String const& name) const noexcept; void reset(); UnusedSettings const& unusedSettings() const; private: struct ParsedValue { bool is_key{false}; String value; }; // Helper functions // // Parses a single argument and returns the parsed value. This function // determines if the string was specified to be a key or a value. ParsedValue parseSingleArg(String key); bool isOption(String const& key); // Storage of parsed data // Flags flags_{}; Arguments arguments_{}; SettingsMap settings_; UnusedSettings unused_properties_{}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Commandline/ParameterParser.hpp"},{"location":"Api/Files/_parameter_parser_8hpp/#commandlineparameterparserhpp","text":"","title":"Commandline/ParameterParser.hpp"},{"location":"Api/Files/_parameter_parser_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_parameter_parser_8hpp/#classes","text":"Name class microsoft::quantum::ParameterParser","title":"Classes"},{"location":"Api/Files/_parameter_parser_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include <string> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft { namespace quantum { class ParameterParser { public: using Arguments = std::vector<String>; using Flags = std::unordered_set<String>; using SettingsMap = std::unordered_map<String, String>; using UnusedSettings = std::unordered_set<String>; // Construction and deconstrution configuration // ParameterParser() = default; // No copy construction. ParameterParser(ParameterParser const& other) = delete; // Allow move semantics. ParameterParser(ParameterParser&& other) = default; // Default destruction. ~ParameterParser() = default; // Configuration // void addFlag(String const& v); // Operation // void parseArgs(int argc, char** argv); Arguments const& arguments() const; String const& getArg(Arguments::size_type const& n) const; String const& get(String const& name, String const& default_value) noexcept; String const& get(String const& name); void markAsUsed(String const& name); bool has(String const& name) const noexcept; void reset(); UnusedSettings const& unusedSettings() const; private: struct ParsedValue { bool is_key{false}; String value; }; // Helper functions // // Parses a single argument and returns the parsed value. This function // determines if the string was specified to be a key or a value. ParsedValue parseSingleArg(String key); bool isOption(String const& key); // Storage of parsed data // Flags flags_{}; Arguments arguments_{}; SettingsMap settings_; UnusedSettings unused_properties_{}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_phi_8ipp/","text":"Rules/Notation/Phi.ipp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Llvm/Llvm.hpp\" #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Rules/Patterns/PhiPattern.hpp\" #include \"Rules/ReplacementRule.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; template <typename... Args> IOperandPrototypePtr phi(Args... args) { IOperandPrototypePtr ret = std::make_shared<PhiPattern>(); std::vector<IOperandPrototypePtr> arguments{args...}; // Adding arguments to matching for (auto &a : arguments) { ret->addChild(a); } return ret; } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Notation/Phi.ipp"},{"location":"Api/Files/_phi_8ipp/#rulesnotationphiipp","text":"","title":"Rules/Notation/Phi.ipp"},{"location":"Api/Files/_phi_8ipp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_phi_8ipp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Llvm/Llvm.hpp\" #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Rules/Patterns/PhiPattern.hpp\" #include \"Rules/ReplacementRule.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; template <typename... Args> IOperandPrototypePtr phi(Args... args) { IOperandPrototypePtr ret = std::make_shared<PhiPattern>(); std::vector<IOperandPrototypePtr> arguments{args...}; // Adding arguments to matching for (auto &a : arguments) { ret->addChild(a); } return ret; } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_phi_pattern_8cpp/","text":"Rules/Patterns/PhiPattern.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/Patterns/PhiPattern.hpp\" namespace microsoft { namespace quantum { PhiPattern::~PhiPattern() = default; bool PhiPattern::match(Value* instr, Captures& captures) const { auto* phi_node = llvm::dyn_cast<llvm::PHINode>(instr); if (phi_node == nullptr) { return fail(instr, captures); } return success(instr, captures); } PhiPattern::Child PhiPattern::copy() const { auto ret = std::make_shared<PhiPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Patterns/PhiPattern.cpp"},{"location":"Api/Files/_phi_pattern_8cpp/#rulespatternsphipatterncpp","text":"","title":"Rules/Patterns/PhiPattern.cpp"},{"location":"Api/Files/_phi_pattern_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_phi_pattern_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/Patterns/PhiPattern.hpp\" namespace microsoft { namespace quantum { PhiPattern::~PhiPattern() = default; bool PhiPattern::match(Value* instr, Captures& captures) const { auto* phi_node = llvm::dyn_cast<llvm::PHINode>(instr); if (phi_node == nullptr) { return fail(instr, captures); } return success(instr, captures); } PhiPattern::Child PhiPattern::copy() const { auto ret = std::make_shared<PhiPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_phi_pattern_8hpp/","text":"Rules/Patterns/PhiPattern.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::PhiPattern Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class PhiPattern : public IOperandPrototype { public: using String = std::string; // Construction of the call pattern by name or move only. // PhiPattern() = default; PhiPattern(PhiPattern const& other) = delete; PhiPattern(PhiPattern&& other) = default; ~PhiPattern() override; // Phi implementation of the member functions in IOperandPrototype. // bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Patterns/PhiPattern.hpp"},{"location":"Api/Files/_phi_pattern_8hpp/#rulespatternsphipatternhpp","text":"","title":"Rules/Patterns/PhiPattern.hpp"},{"location":"Api/Files/_phi_pattern_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_phi_pattern_8hpp/#classes","text":"Name class microsoft::quantum::PhiPattern","title":"Classes"},{"location":"Api/Files/_phi_pattern_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class PhiPattern : public IOperandPrototype { public: using String = std::string; // Construction of the call pattern by name or move only. // PhiPattern() = default; PhiPattern(PhiPattern const& other) = delete; PhiPattern(PhiPattern&& other) = default; ~PhiPattern() override; // Phi implementation of the member functions in IOperandPrototype. // bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_profile_8cpp/","text":"Profile/Profile.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Profile/Profile.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { Profile::Profile( String const& name, bool debug, llvm::TargetMachine* target_machine, AllocationManagerPtr qubit_allocation_manager, AllocationManagerPtr result_allocation_manager) : name_{name} , loop_analysis_manager_{debug} , function_analysis_manager_{debug} , gscc_analysis_manager_{debug} , module_analysis_manager_{debug} , pass_instrumentation_callbacks_{std::make_unique<llvm::PassInstrumentationCallbacks>()} , standard_instrumentations_{std::make_unique<llvm::StandardInstrumentations>()} , qubit_allocation_manager_{std::move(qubit_allocation_manager)} , result_allocation_manager_{std::move(result_allocation_manager)} , validator_{std::make_unique<Validator>(ValidationPassConfiguration(), false, debug)} { bool verify_each_pass = false; standard_instrumentations_->registerCallbacks(*pass_instrumentation_callbacks_); // TODO(issue-13): Parameterize // pipeline_tuning_options_.LoopUnrolling = !DisableLoopUnrolling; // pipeline_tuning_options_.Coroutines = Coroutines; pass_builder_ = std::make_unique<llvm::PassBuilder>( target_machine, pipeline_tuning_options_, pgo_options_, pass_instrumentation_callbacks_.get()); registerEPCallbacks(verify_each_pass, debug); // Creating a full pass builder and registering each of the // components to make them accessible to the developer. pass_builder_->registerModuleAnalyses(module_analysis_manager_); pass_builder_->registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_->registerFunctionAnalyses(function_analysis_manager_); pass_builder_->registerLoopAnalyses(loop_analysis_manager_); pass_builder_->crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); } void Profile::registerEPCallbacks(bool verify_each_pass, bool debug) { if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, peephole_ep_pipeline_)) { pass_builder_->registerPeepholeEPCallback( [this, verify_each_pass, debug](llvm::FunctionPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse PeepholeEP pipeline: \"); error_safeguard( pass_builder_->parsePassPipeline(pass_manager, peephole_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::LoopPassManager>(*pass_builder_, late_loop_optimizations_ep_pipeline_)) { pass_builder_->registerLateLoopOptimizationsEPCallback( [this, verify_each_pass, debug](llvm::LoopPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse LateLoopOptimizationsEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, late_loop_optimizations_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::LoopPassManager>(*pass_builder_, loop_optimizer_end_ep_pipeline_)) { pass_builder_->registerLoopOptimizerEndEPCallback( [this, verify_each_pass, debug](llvm::LoopPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse LoopOptimizerEndEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, loop_optimizer_end_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, scalar_optimizer_late_ep_pipeline_)) { pass_builder_->registerScalarOptimizerLateEPCallback( [this, verify_each_pass, debug](llvm::FunctionPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse ScalarOptimizerLateEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, scalar_optimizer_late_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::CGSCCPassManager>(*pass_builder_, cgscc_optimizer_late_ep_pipeline_)) { pass_builder_->registerCGSCCOptimizerLateEPCallback( [this, verify_each_pass, debug](llvm::CGSCCPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse CGSCCOptimizerLateEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, cgscc_optimizer_late_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, vectorizer_start_ep_pipeline_)) { pass_builder_->registerVectorizerStartEPCallback( [this, verify_each_pass, debug](llvm::FunctionPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse VectorizerStartEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, vectorizer_start_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::ModulePassManager>(*pass_builder_, pipeline_start_ep_pipeline_)) { pass_builder_->registerPipelineStartEPCallback( [this, verify_each_pass, debug](llvm::ModulePassManager& pass_manager) { llvm::ExitOnError error_safeguard(\"Unable to parse PipelineStartEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, pipeline_start_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, optimizer_last_ep_pipeline_)) { pass_builder_->registerOptimizerLastEPCallback( [this, verify_each_pass, debug](llvm::ModulePassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse OptimizerLastEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, optimizer_last_ep_pipeline_, verify_each_pass, debug)); }); } } void Profile::apply(llvm::Module& module) { module_pass_manager_.run(module, module_analysis_manager_); } bool Profile::verify(llvm::Module& module) { llvm::VerifierAnalysis verifier; auto result = verifier.run(module, module_analysis_manager_); return !result.IRBroken; } bool Profile::validate(llvm::Module& module) { return validator_->validate(module); } String const& Profile::name() const { return name_; } Profile::AllocationManagerPtr Profile::getQubitAllocationManager() { return qubit_allocation_manager_; } Profile::AllocationManagerPtr Profile::getResultAllocationManager() { return result_allocation_manager_; } void Profile::setModulePassManager(llvm::ModulePassManager&& manager) { module_pass_manager_ = std::move(manager); } void Profile::setValidator(ValidatorPtr&& validator) { validator_ = std::move(validator); } llvm::PassBuilder& Profile::passBuilder() { return *pass_builder_; } llvm::LoopAnalysisManager& Profile::loopAnalysisManager() { return loop_analysis_manager_; } llvm::FunctionAnalysisManager& Profile::functionAnalysisManager() { return function_analysis_manager_; } llvm::CGSCCAnalysisManager& Profile::gsccAnalysisManager() { return gscc_analysis_manager_; } llvm::ModuleAnalysisManager& Profile::moduleAnalysisManager() { return module_analysis_manager_; } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Profile/Profile.cpp"},{"location":"Api/Files/_profile_8cpp/#profileprofilecpp","text":"","title":"Profile/Profile.cpp"},{"location":"Api/Files/_profile_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_profile_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Profile/Profile.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { Profile::Profile( String const& name, bool debug, llvm::TargetMachine* target_machine, AllocationManagerPtr qubit_allocation_manager, AllocationManagerPtr result_allocation_manager) : name_{name} , loop_analysis_manager_{debug} , function_analysis_manager_{debug} , gscc_analysis_manager_{debug} , module_analysis_manager_{debug} , pass_instrumentation_callbacks_{std::make_unique<llvm::PassInstrumentationCallbacks>()} , standard_instrumentations_{std::make_unique<llvm::StandardInstrumentations>()} , qubit_allocation_manager_{std::move(qubit_allocation_manager)} , result_allocation_manager_{std::move(result_allocation_manager)} , validator_{std::make_unique<Validator>(ValidationPassConfiguration(), false, debug)} { bool verify_each_pass = false; standard_instrumentations_->registerCallbacks(*pass_instrumentation_callbacks_); // TODO(issue-13): Parameterize // pipeline_tuning_options_.LoopUnrolling = !DisableLoopUnrolling; // pipeline_tuning_options_.Coroutines = Coroutines; pass_builder_ = std::make_unique<llvm::PassBuilder>( target_machine, pipeline_tuning_options_, pgo_options_, pass_instrumentation_callbacks_.get()); registerEPCallbacks(verify_each_pass, debug); // Creating a full pass builder and registering each of the // components to make them accessible to the developer. pass_builder_->registerModuleAnalyses(module_analysis_manager_); pass_builder_->registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_->registerFunctionAnalyses(function_analysis_manager_); pass_builder_->registerLoopAnalyses(loop_analysis_manager_); pass_builder_->crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); } void Profile::registerEPCallbacks(bool verify_each_pass, bool debug) { if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, peephole_ep_pipeline_)) { pass_builder_->registerPeepholeEPCallback( [this, verify_each_pass, debug](llvm::FunctionPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse PeepholeEP pipeline: \"); error_safeguard( pass_builder_->parsePassPipeline(pass_manager, peephole_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::LoopPassManager>(*pass_builder_, late_loop_optimizations_ep_pipeline_)) { pass_builder_->registerLateLoopOptimizationsEPCallback( [this, verify_each_pass, debug](llvm::LoopPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse LateLoopOptimizationsEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, late_loop_optimizations_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::LoopPassManager>(*pass_builder_, loop_optimizer_end_ep_pipeline_)) { pass_builder_->registerLoopOptimizerEndEPCallback( [this, verify_each_pass, debug](llvm::LoopPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse LoopOptimizerEndEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, loop_optimizer_end_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, scalar_optimizer_late_ep_pipeline_)) { pass_builder_->registerScalarOptimizerLateEPCallback( [this, verify_each_pass, debug](llvm::FunctionPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse ScalarOptimizerLateEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, scalar_optimizer_late_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::CGSCCPassManager>(*pass_builder_, cgscc_optimizer_late_ep_pipeline_)) { pass_builder_->registerCGSCCOptimizerLateEPCallback( [this, verify_each_pass, debug](llvm::CGSCCPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse CGSCCOptimizerLateEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, cgscc_optimizer_late_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, vectorizer_start_ep_pipeline_)) { pass_builder_->registerVectorizerStartEPCallback( [this, verify_each_pass, debug](llvm::FunctionPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse VectorizerStartEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, vectorizer_start_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::ModulePassManager>(*pass_builder_, pipeline_start_ep_pipeline_)) { pass_builder_->registerPipelineStartEPCallback( [this, verify_each_pass, debug](llvm::ModulePassManager& pass_manager) { llvm::ExitOnError error_safeguard(\"Unable to parse PipelineStartEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, pipeline_start_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, optimizer_last_ep_pipeline_)) { pass_builder_->registerOptimizerLastEPCallback( [this, verify_each_pass, debug](llvm::ModulePassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse OptimizerLastEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, optimizer_last_ep_pipeline_, verify_each_pass, debug)); }); } } void Profile::apply(llvm::Module& module) { module_pass_manager_.run(module, module_analysis_manager_); } bool Profile::verify(llvm::Module& module) { llvm::VerifierAnalysis verifier; auto result = verifier.run(module, module_analysis_manager_); return !result.IRBroken; } bool Profile::validate(llvm::Module& module) { return validator_->validate(module); } String const& Profile::name() const { return name_; } Profile::AllocationManagerPtr Profile::getQubitAllocationManager() { return qubit_allocation_manager_; } Profile::AllocationManagerPtr Profile::getResultAllocationManager() { return result_allocation_manager_; } void Profile::setModulePassManager(llvm::ModulePassManager&& manager) { module_pass_manager_ = std::move(manager); } void Profile::setValidator(ValidatorPtr&& validator) { validator_ = std::move(validator); } llvm::PassBuilder& Profile::passBuilder() { return *pass_builder_; } llvm::LoopAnalysisManager& Profile::loopAnalysisManager() { return loop_analysis_manager_; } llvm::FunctionAnalysisManager& Profile::functionAnalysisManager() { return function_analysis_manager_; } llvm::CGSCCAnalysisManager& Profile::gsccAnalysisManager() { return gscc_analysis_manager_; } llvm::ModuleAnalysisManager& Profile::moduleAnalysisManager() { return module_analysis_manager_; } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_profile_8hpp/","text":"Profile/Profile.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::Profile Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/AllocationManager.hpp\" #include \"AllocationManager/IAllocationManager.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Validator/Validator.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { class ProfileGenerator; class Profile { public: using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; using ValidatorPtr = Validator::ValidatorPtr; // Constructors // explicit Profile( String const& name, bool debug, llvm::TargetMachine* target_machine = nullptr, AllocationManagerPtr qubit_allocation_manager = BasicAllocationManager::createNew(), AllocationManagerPtr result_allocation_manager = BasicAllocationManager::createNew()); // Default construction not allowed as this leads to invalid configuration of the allocation // managers. Profile() = delete; Profile(Profile const&) = delete; Profile(Profile&&) = default; Profile& operator=(Profile const&) = delete; Profile& operator=(Profile&&) = default; ~Profile() = default; // Profile methods // void apply(llvm::Module& module); bool verify(llvm::Module& module); bool validate(llvm::Module& module); AllocationManagerPtr getQubitAllocationManager(); AllocationManagerPtr getResultAllocationManager(); String const& name() const; llvm::PassBuilder& passBuilder(); llvm::LoopAnalysisManager& loopAnalysisManager(); llvm::FunctionAnalysisManager& functionAnalysisManager(); llvm::CGSCCAnalysisManager& gsccAnalysisManager(); llvm::ModuleAnalysisManager& moduleAnalysisManager(); protected: // Ensuring that ProfileGenerator has access to following protected functions. friend class ProfileGenerator; void setModulePassManager(llvm::ModulePassManager&& manager); void setValidator(ValidatorPtr&& validator); private: using PassInstrumentationCallbacksPtr = std::unique_ptr<llvm::PassInstrumentationCallbacks>; using StandardInstrumentationsPtr = std::unique_ptr<llvm::StandardInstrumentations>; using PassBuilderPtr = std::unique_ptr<llvm::PassBuilder>; void registerEPCallbacks(bool verify_each_pass, bool debug); template <typename PassManager> bool tryParsePipelineText(llvm::PassBuilder& pass_builder, std::string const& pipeline_options) { if (pipeline_options.empty()) { return false; } PassManager pass_manager; if (auto err = pass_builder.parsePassPipeline(pass_manager, pipeline_options)) { llvm::errs() << \"Could not parse -\" << pipeline_options << \" pipeline: \" << toString(std::move(err)) << \"\\n\"; return false; } return true; } String name_{}; // LLVM logic to run the passes // llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; llvm::Optional<llvm::PGOOptions> pgo_options_; PassInstrumentationCallbacksPtr pass_instrumentation_callbacks_; StandardInstrumentationsPtr standard_instrumentations_; llvm::PipelineTuningOptions pipeline_tuning_options_; PassBuilderPtr pass_builder_; llvm::ModulePassManager module_pass_manager_{}; llvm::FunctionPassManager function_pass_manager_{}; // Allocation management // AllocationManagerPtr qubit_allocation_manager_{}; AllocationManagerPtr result_allocation_manager_{}; ValidatorPtr validator_{}; std::string peephole_ep_pipeline_{\"\"}; std::string late_loop_optimizations_ep_pipeline_{\"\"}; std::string loop_optimizer_end_ep_pipeline_{\"\"}; std::string scalar_optimizer_late_ep_pipeline_{\"\"}; std::string cgscc_optimizer_late_ep_pipeline_{\"\"}; std::string vectorizer_start_ep_pipeline_{\"\"}; std::string pipeline_start_ep_pipeline_{\"\"}; std::string optimizer_last_ep_pipeline_{\"\"}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Profile/Profile.hpp"},{"location":"Api/Files/_profile_8hpp/#profileprofilehpp","text":"","title":"Profile/Profile.hpp"},{"location":"Api/Files/_profile_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_profile_8hpp/#classes","text":"Name class microsoft::quantum::Profile","title":"Classes"},{"location":"Api/Files/_profile_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/AllocationManager.hpp\" #include \"AllocationManager/IAllocationManager.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Validator/Validator.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { class ProfileGenerator; class Profile { public: using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; using ValidatorPtr = Validator::ValidatorPtr; // Constructors // explicit Profile( String const& name, bool debug, llvm::TargetMachine* target_machine = nullptr, AllocationManagerPtr qubit_allocation_manager = BasicAllocationManager::createNew(), AllocationManagerPtr result_allocation_manager = BasicAllocationManager::createNew()); // Default construction not allowed as this leads to invalid configuration of the allocation // managers. Profile() = delete; Profile(Profile const&) = delete; Profile(Profile&&) = default; Profile& operator=(Profile const&) = delete; Profile& operator=(Profile&&) = default; ~Profile() = default; // Profile methods // void apply(llvm::Module& module); bool verify(llvm::Module& module); bool validate(llvm::Module& module); AllocationManagerPtr getQubitAllocationManager(); AllocationManagerPtr getResultAllocationManager(); String const& name() const; llvm::PassBuilder& passBuilder(); llvm::LoopAnalysisManager& loopAnalysisManager(); llvm::FunctionAnalysisManager& functionAnalysisManager(); llvm::CGSCCAnalysisManager& gsccAnalysisManager(); llvm::ModuleAnalysisManager& moduleAnalysisManager(); protected: // Ensuring that ProfileGenerator has access to following protected functions. friend class ProfileGenerator; void setModulePassManager(llvm::ModulePassManager&& manager); void setValidator(ValidatorPtr&& validator); private: using PassInstrumentationCallbacksPtr = std::unique_ptr<llvm::PassInstrumentationCallbacks>; using StandardInstrumentationsPtr = std::unique_ptr<llvm::StandardInstrumentations>; using PassBuilderPtr = std::unique_ptr<llvm::PassBuilder>; void registerEPCallbacks(bool verify_each_pass, bool debug); template <typename PassManager> bool tryParsePipelineText(llvm::PassBuilder& pass_builder, std::string const& pipeline_options) { if (pipeline_options.empty()) { return false; } PassManager pass_manager; if (auto err = pass_builder.parsePassPipeline(pass_manager, pipeline_options)) { llvm::errs() << \"Could not parse -\" << pipeline_options << \" pipeline: \" << toString(std::move(err)) << \"\\n\"; return false; } return true; } String name_{}; // LLVM logic to run the passes // llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; llvm::Optional<llvm::PGOOptions> pgo_options_; PassInstrumentationCallbacksPtr pass_instrumentation_callbacks_; StandardInstrumentationsPtr standard_instrumentations_; llvm::PipelineTuningOptions pipeline_tuning_options_; PassBuilderPtr pass_builder_; llvm::ModulePassManager module_pass_manager_{}; llvm::FunctionPassManager function_pass_manager_{}; // Allocation management // AllocationManagerPtr qubit_allocation_manager_{}; AllocationManagerPtr result_allocation_manager_{}; ValidatorPtr validator_{}; std::string peephole_ep_pipeline_{\"\"}; std::string late_loop_optimizations_ep_pipeline_{\"\"}; std::string loop_optimizer_end_ep_pipeline_{\"\"}; std::string scalar_optimizer_late_ep_pipeline_{\"\"}; std::string cgscc_optimizer_late_ep_pipeline_{\"\"}; std::string vectorizer_start_ep_pipeline_{\"\"}; std::string pipeline_start_ep_pipeline_{\"\"}; std::string optimizer_last_ep_pipeline_{\"\"}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_profile_generator_8cpp/","text":"Generators/ProfileGenerator.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/LlvmPassesConfiguration.hpp\" #include \"Generators/ProfileGenerator.hpp\" #include \"GroupingPass/GroupingAnalysisPass.hpp\" #include \"GroupingPass/GroupingPass.hpp\" #include \"GroupingPass/GroupingPassConfiguration.hpp\" #include \"Rules/Factory.hpp\" #include \"Rules/RuleSet.hpp\" #include \"TransformationRulesPass/TransformationRulesPass.hpp\" #include \"TransformationRulesPass/TransformationRulesPassConfiguration.hpp\" #include \"ValidationPass/ValidationPassConfiguration.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { Profile ProfileGenerator::newProfile(String const& name, OptimizationLevel const& optimization_level, bool debug) { auto qubit_allocation_manager = BasicAllocationManager::createNew(); auto result_allocation_manager = BasicAllocationManager::createNew(); auto cfg = configuration_manager_.get<TransformationRulesPassConfiguration>(); qubit_allocation_manager->setReuseRegisters(cfg.shouldReuseQubits()); result_allocation_manager->setReuseRegisters(cfg.shouldReuseResults()); // Creating profile // TODO(issue-12): Set target machine Profile ret{name, debug, nullptr, qubit_allocation_manager, result_allocation_manager}; auto module_pass_manager = createGenerationModulePassManager(ret, optimization_level, debug); for (auto& c : components_) { llvm::FunctionPassManager function_pass_manager; function_pass_manager_ = &function_pass_manager; if (debug) { llvm::outs() << \"Setting \" << c.first << \" up\\n\"; } c.second(this, ret); module_pass_manager.addPass(createModuleToFunctionPassAdaptor(std::move(function_pass_manager))); } ret.setModulePassManager(std::move(module_pass_manager)); // Creating validator auto validator = std::make_unique<Validator>(configuration_manager_.get<ValidationPassConfiguration>(), false, debug); ret.setValidator(std::move(validator)); return ret; } llvm::ModulePassManager ProfileGenerator::createGenerationModulePassManager( Profile& profile, OptimizationLevel const& optimization_level, bool debug) { auto& pass_builder = profile.passBuilder(); llvm::ModulePassManager ret{}; module_pass_manager_ = &ret; pass_builder_ = &pass_builder; optimization_level_ = optimization_level; debug_ = debug; return ret; } llvm::ModulePassManager ProfileGenerator::createValidationModulePass(PassBuilder&, OptimizationLevel const&, bool) { throw std::runtime_error(\"Validation is not supported yet.\"); } llvm::ModulePassManager& ProfileGenerator::modulePassManager() { assert(module_pass_manager_ != nullptr); return *module_pass_manager_; } llvm::FunctionPassManager& ProfileGenerator::functionPassManager() { assert(function_pass_manager_ != nullptr); return *function_pass_manager_; } llvm::PassBuilder& ProfileGenerator::passBuilder() { return *pass_builder_; } ConfigurationManager& ProfileGenerator::configurationManager() { return configuration_manager_; } ConfigurationManager const& ProfileGenerator::configurationManager() const { return configuration_manager_; } ProfileGenerator::OptimizationLevel ProfileGenerator::optimizationLevel() const { return optimization_level_; } bool ProfileGenerator::isDebugMode() const { return debug_; } void ProfileGenerator::replicateProfileComponent(String const& id) { for (auto& c : components_) { if (c.first == id) { auto setup_wrapper = c.second; components_.push_back({\"__unnamed__\", std::move(setup_wrapper)}); return; } } throw std::runtime_error(\"Component \" + id + \" not found.\"); } void ProfileGenerator::setupDefaultComponentPipeline() { using namespace llvm; registerProfileComponent<LlvmPassesConfiguration>( \"llvm-optimization\", [](LlvmPassesConfiguration const& cfg, ProfileGenerator* ptr, Profile& /*profile*/) { auto& mpm = ptr->modulePassManager(); auto& fpm = ptr->functionPassManager(); // Always inline if (cfg.alwaysInline()) { auto& pass_builder = ptr->passBuilder(); mpm.addPass(llvm::AlwaysInlinerPass()); auto inline_param = getInlineParams(cfg.inlineParameter()); llvm::ModuleInlinerWrapperPass inliner_pass = ModuleInlinerWrapperPass(inline_param); mpm.addPass(std::move(inliner_pass)); } // Unroll loop if (cfg.unrollLoops()) { auto& pass_builder = ptr->passBuilder(); llvm::LoopUnrollOptions loop_config( cfg.unrollOptLevel(), cfg.unrollOnlyWhenForced(), cfg.unrollForgeScev()); loop_config.setPartial(cfg.unrollAllowPartial()) .setPeeling(cfg.unrollAllowPeeling()) .setRuntime(cfg.unrollAllowRuntime()) .setUpperBound(cfg.unrollAllowUpperBound()) .setProfileBasedPeeling(cfg.unrollAllowProfilBasedPeeling()) .setFullUnrollMaxCount(cfg.unrolFullUnrollCount()); fpm.addPass(llvm::LoopUnrollPass(loop_config)); } if (cfg.useLlvmOptPipeline()) { auto pass_pipeline = cfg.optPipelineConfig(); llvm::PassBuilder::OptimizationLevel opt = ptr->optimizationLevel(); if (!pass_pipeline.empty()) { auto& pass_builder = ptr->passBuilder(); if (auto err = pass_builder.parsePassPipeline(mpm, pass_pipeline, false, false)) { throw std::runtime_error( \"Failed to set pass pipeline up. Value: '\" + pass_pipeline + \"', error: \" + toString(std::move(err))); } } else { // If not explicitly disabled, we fall back to the default LLVM pipeline auto& pass_builder = ptr->passBuilder(); llvm::ModulePassManager pipeline1 = pass_builder.buildPerModuleDefaultPipeline(opt); mpm.addPass(std::move(pipeline1)); llvm::ModulePassManager pipeline2 = pass_builder.buildModuleSimplificationPipeline(opt, llvm::PassBuilder::ThinLTOPhase::None); mpm.addPass(std::move(pipeline2)); llvm::ModulePassManager pipeline3 = pass_builder.buildModuleOptimizationPipeline(opt, ptr->isDebugMode()); mpm.addPass(std::move(pipeline3)); } } fpm.addPass(llvm::SimplifyCFGPass()); if (cfg.eliminateMemory()) { fpm.addPass(llvm::PromotePass()); } if (cfg.eliminateConstants()) { fpm.addPass(llvm::SCCPPass()); } if (cfg.eliminateDeadCode()) { fpm.addPass(llvm::ADCEPass()); } }); registerProfileComponent<TransformationRulesPassConfiguration>( \"transformation-rules\", [](TransformationRulesPassConfiguration const& cfg, ProfileGenerator* ptr, Profile& profile) { auto& ret = ptr->modulePassManager(); // Defining the mapping RuleSet rule_set; auto factory = RuleFactory(rule_set, profile.getQubitAllocationManager(), profile.getResultAllocationManager()); factory.usingConfiguration(ptr->configurationManager().get<FactoryConfiguration>()); // Creating profile pass ret.addPass(TransformationRulesPass(std::move(rule_set), cfg, &profile)); // TODO(issue-59): Move to a separate pass. ret.addPass(createModuleToFunctionPassAdaptor(llvm::InstCombinePass(1000))); ret.addPass(createModuleToFunctionPassAdaptor(llvm::AggressiveInstCombinePass())); ret.addPass(createModuleToFunctionPassAdaptor(llvm::SCCPPass())); ret.addPass(createModuleToFunctionPassAdaptor(llvm::SimplifyCFGPass())); }); // TODO(issue-59): Causes memory sanitation issue // replicateProfileComponent(\"llvm-optimization\"); registerProfileComponent<GroupingPassConfiguration>( \"grouping\", [](GroupingPassConfiguration const& cfg, ProfileGenerator* ptr, Profile& profile) { if (cfg.circuitSeparation()) { auto& mam = profile.moduleAnalysisManager(); mam.registerPass([&] { return GroupingAnalysisPass(cfg); }); auto& ret = ptr->modulePassManager(); ret.addPass(GroupingPass(cfg)); } }); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Generators/ProfileGenerator.cpp"},{"location":"Api/Files/_profile_generator_8cpp/#generatorsprofilegeneratorcpp","text":"","title":"Generators/ProfileGenerator.cpp"},{"location":"Api/Files/_profile_generator_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_profile_generator_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/LlvmPassesConfiguration.hpp\" #include \"Generators/ProfileGenerator.hpp\" #include \"GroupingPass/GroupingAnalysisPass.hpp\" #include \"GroupingPass/GroupingPass.hpp\" #include \"GroupingPass/GroupingPassConfiguration.hpp\" #include \"Rules/Factory.hpp\" #include \"Rules/RuleSet.hpp\" #include \"TransformationRulesPass/TransformationRulesPass.hpp\" #include \"TransformationRulesPass/TransformationRulesPassConfiguration.hpp\" #include \"ValidationPass/ValidationPassConfiguration.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { Profile ProfileGenerator::newProfile(String const& name, OptimizationLevel const& optimization_level, bool debug) { auto qubit_allocation_manager = BasicAllocationManager::createNew(); auto result_allocation_manager = BasicAllocationManager::createNew(); auto cfg = configuration_manager_.get<TransformationRulesPassConfiguration>(); qubit_allocation_manager->setReuseRegisters(cfg.shouldReuseQubits()); result_allocation_manager->setReuseRegisters(cfg.shouldReuseResults()); // Creating profile // TODO(issue-12): Set target machine Profile ret{name, debug, nullptr, qubit_allocation_manager, result_allocation_manager}; auto module_pass_manager = createGenerationModulePassManager(ret, optimization_level, debug); for (auto& c : components_) { llvm::FunctionPassManager function_pass_manager; function_pass_manager_ = &function_pass_manager; if (debug) { llvm::outs() << \"Setting \" << c.first << \" up\\n\"; } c.second(this, ret); module_pass_manager.addPass(createModuleToFunctionPassAdaptor(std::move(function_pass_manager))); } ret.setModulePassManager(std::move(module_pass_manager)); // Creating validator auto validator = std::make_unique<Validator>(configuration_manager_.get<ValidationPassConfiguration>(), false, debug); ret.setValidator(std::move(validator)); return ret; } llvm::ModulePassManager ProfileGenerator::createGenerationModulePassManager( Profile& profile, OptimizationLevel const& optimization_level, bool debug) { auto& pass_builder = profile.passBuilder(); llvm::ModulePassManager ret{}; module_pass_manager_ = &ret; pass_builder_ = &pass_builder; optimization_level_ = optimization_level; debug_ = debug; return ret; } llvm::ModulePassManager ProfileGenerator::createValidationModulePass(PassBuilder&, OptimizationLevel const&, bool) { throw std::runtime_error(\"Validation is not supported yet.\"); } llvm::ModulePassManager& ProfileGenerator::modulePassManager() { assert(module_pass_manager_ != nullptr); return *module_pass_manager_; } llvm::FunctionPassManager& ProfileGenerator::functionPassManager() { assert(function_pass_manager_ != nullptr); return *function_pass_manager_; } llvm::PassBuilder& ProfileGenerator::passBuilder() { return *pass_builder_; } ConfigurationManager& ProfileGenerator::configurationManager() { return configuration_manager_; } ConfigurationManager const& ProfileGenerator::configurationManager() const { return configuration_manager_; } ProfileGenerator::OptimizationLevel ProfileGenerator::optimizationLevel() const { return optimization_level_; } bool ProfileGenerator::isDebugMode() const { return debug_; } void ProfileGenerator::replicateProfileComponent(String const& id) { for (auto& c : components_) { if (c.first == id) { auto setup_wrapper = c.second; components_.push_back({\"__unnamed__\", std::move(setup_wrapper)}); return; } } throw std::runtime_error(\"Component \" + id + \" not found.\"); } void ProfileGenerator::setupDefaultComponentPipeline() { using namespace llvm; registerProfileComponent<LlvmPassesConfiguration>( \"llvm-optimization\", [](LlvmPassesConfiguration const& cfg, ProfileGenerator* ptr, Profile& /*profile*/) { auto& mpm = ptr->modulePassManager(); auto& fpm = ptr->functionPassManager(); // Always inline if (cfg.alwaysInline()) { auto& pass_builder = ptr->passBuilder(); mpm.addPass(llvm::AlwaysInlinerPass()); auto inline_param = getInlineParams(cfg.inlineParameter()); llvm::ModuleInlinerWrapperPass inliner_pass = ModuleInlinerWrapperPass(inline_param); mpm.addPass(std::move(inliner_pass)); } // Unroll loop if (cfg.unrollLoops()) { auto& pass_builder = ptr->passBuilder(); llvm::LoopUnrollOptions loop_config( cfg.unrollOptLevel(), cfg.unrollOnlyWhenForced(), cfg.unrollForgeScev()); loop_config.setPartial(cfg.unrollAllowPartial()) .setPeeling(cfg.unrollAllowPeeling()) .setRuntime(cfg.unrollAllowRuntime()) .setUpperBound(cfg.unrollAllowUpperBound()) .setProfileBasedPeeling(cfg.unrollAllowProfilBasedPeeling()) .setFullUnrollMaxCount(cfg.unrolFullUnrollCount()); fpm.addPass(llvm::LoopUnrollPass(loop_config)); } if (cfg.useLlvmOptPipeline()) { auto pass_pipeline = cfg.optPipelineConfig(); llvm::PassBuilder::OptimizationLevel opt = ptr->optimizationLevel(); if (!pass_pipeline.empty()) { auto& pass_builder = ptr->passBuilder(); if (auto err = pass_builder.parsePassPipeline(mpm, pass_pipeline, false, false)) { throw std::runtime_error( \"Failed to set pass pipeline up. Value: '\" + pass_pipeline + \"', error: \" + toString(std::move(err))); } } else { // If not explicitly disabled, we fall back to the default LLVM pipeline auto& pass_builder = ptr->passBuilder(); llvm::ModulePassManager pipeline1 = pass_builder.buildPerModuleDefaultPipeline(opt); mpm.addPass(std::move(pipeline1)); llvm::ModulePassManager pipeline2 = pass_builder.buildModuleSimplificationPipeline(opt, llvm::PassBuilder::ThinLTOPhase::None); mpm.addPass(std::move(pipeline2)); llvm::ModulePassManager pipeline3 = pass_builder.buildModuleOptimizationPipeline(opt, ptr->isDebugMode()); mpm.addPass(std::move(pipeline3)); } } fpm.addPass(llvm::SimplifyCFGPass()); if (cfg.eliminateMemory()) { fpm.addPass(llvm::PromotePass()); } if (cfg.eliminateConstants()) { fpm.addPass(llvm::SCCPPass()); } if (cfg.eliminateDeadCode()) { fpm.addPass(llvm::ADCEPass()); } }); registerProfileComponent<TransformationRulesPassConfiguration>( \"transformation-rules\", [](TransformationRulesPassConfiguration const& cfg, ProfileGenerator* ptr, Profile& profile) { auto& ret = ptr->modulePassManager(); // Defining the mapping RuleSet rule_set; auto factory = RuleFactory(rule_set, profile.getQubitAllocationManager(), profile.getResultAllocationManager()); factory.usingConfiguration(ptr->configurationManager().get<FactoryConfiguration>()); // Creating profile pass ret.addPass(TransformationRulesPass(std::move(rule_set), cfg, &profile)); // TODO(issue-59): Move to a separate pass. ret.addPass(createModuleToFunctionPassAdaptor(llvm::InstCombinePass(1000))); ret.addPass(createModuleToFunctionPassAdaptor(llvm::AggressiveInstCombinePass())); ret.addPass(createModuleToFunctionPassAdaptor(llvm::SCCPPass())); ret.addPass(createModuleToFunctionPassAdaptor(llvm::SimplifyCFGPass())); }); // TODO(issue-59): Causes memory sanitation issue // replicateProfileComponent(\"llvm-optimization\"); registerProfileComponent<GroupingPassConfiguration>( \"grouping\", [](GroupingPassConfiguration const& cfg, ProfileGenerator* ptr, Profile& profile) { if (cfg.circuitSeparation()) { auto& mam = profile.moduleAnalysisManager(); mam.registerPass([&] { return GroupingAnalysisPass(cfg); }); auto& ret = ptr->modulePassManager(); ret.addPass(GroupingPass(cfg)); } }); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_profile_generator_8hpp/","text":"Generators/ProfileGenerator.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ProfileGenerator Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"Profile/Profile.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { class ProfileGenerator { public: // LLVM types // using PassBuilder = llvm::PassBuilder; using OptimizationLevel = PassBuilder::OptimizationLevel; using FunctionAnalysisManager = llvm::FunctionAnalysisManager; template <typename R> using SetupFunction = std::function<void(R const&, ProfileGenerator*, Profile&)>; using SetupFunctionWrapper = std::function<void(ProfileGenerator*, Profile&)>; using Components = std::vector<std::pair<String, SetupFunctionWrapper>>; // Construction, moves and copies // ProfileGenerator() = default; ~ProfileGenerator() = default; ProfileGenerator(ProfileGenerator const&) = delete; ProfileGenerator(ProfileGenerator&&) = delete; ProfileGenerator& operator=(ProfileGenerator const&) = delete; ProfileGenerator& operator=(ProfileGenerator&&) = delete; // Profile generation interface // ConfigurationManager& configurationManager(); ConfigurationManager const& configurationManager() const; Profile newProfile(String const& name, OptimizationLevel const& optimization_level, bool debug); // Defining the generator // template <typename R> void registerProfileComponent(String const& id, SetupFunction<R> setup); template <typename R> void replaceProfileComponent(String const& id, SetupFunction<R> setup); template <typename R> void registerAnonymousProfileComponent(SetupFunction<R> setup); void replicateProfileComponent(String const& id); // Support properties for generators // llvm::ModulePassManager& modulePassManager(); llvm::FunctionPassManager& functionPassManager(); llvm::PassBuilder& passBuilder(); OptimizationLevel optimizationLevel() const; bool isDebugMode() const; void setupDefaultComponentPipeline(); protected: llvm::ModulePassManager createGenerationModulePassManager( Profile& profile, OptimizationLevel const& optimization_level, bool debug); llvm::ModulePassManager createValidationModulePass( PassBuilder& pass_builder, OptimizationLevel const& optimization_level, bool debug); private: ConfigurationManager configuration_manager_; Components components_; llvm::ModulePassManager* module_pass_manager_{nullptr}; llvm::FunctionPassManager* function_pass_manager_{nullptr}; llvm::PassBuilder* pass_builder_{nullptr}; OptimizationLevel optimization_level_{OptimizationLevel::O0}; bool debug_{false}; }; template <typename R> void ProfileGenerator::registerProfileComponent(String const& id, SetupFunction<R> setup) { configuration_manager_.addConfig<R>(id); auto setup_wrapper = [setup](ProfileGenerator* ptr, Profile& profile) { if (ptr->configuration_manager_.isActive<R>()) { auto& config = ptr->configuration_manager_.get<R>(); setup(config, ptr, profile); } }; components_.push_back({id, std::move(setup_wrapper)}); } template <typename R> void ProfileGenerator::replaceProfileComponent(String const& id, SetupFunction<R> setup) { auto setup_wrapper = [setup](ProfileGenerator* ptr, Profile& profile) { if (ptr->configuration_manager_.isActive<R>()) { auto& config = ptr->configuration_manager_.get<R>(); setup(config, ptr, profile); } }; for (auto& component : components_) { if (component.first == id) { component.second = std::move(setup_wrapper); return; } } throw std::runtime_error(\"Could not find component \" + id); } template <typename R> void ProfileGenerator::registerAnonymousProfileComponent(SetupFunction<R> setup) { if (!configuration_manager_.configWasRegistered<R>()) { throw std::runtime_error(\"Configuration '\" + static_cast<String>(typeid(R).name()) + \"' does not exist.\"); } auto setup_wrapper = [setup](ProfileGenerator* ptr, Profile& profile) { if (ptr->configuration_manager_.isActive<R>()) { auto& config = ptr->configuration_manager_.get<R>(); setup(config, ptr, profile); } }; components_.push_back({\"__unnamed__\", std::move(setup_wrapper)}); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Generators/ProfileGenerator.hpp"},{"location":"Api/Files/_profile_generator_8hpp/#generatorsprofilegeneratorhpp","text":"","title":"Generators/ProfileGenerator.hpp"},{"location":"Api/Files/_profile_generator_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_profile_generator_8hpp/#classes","text":"Name class microsoft::quantum::ProfileGenerator","title":"Classes"},{"location":"Api/Files/_profile_generator_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"Profile/Profile.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { class ProfileGenerator { public: // LLVM types // using PassBuilder = llvm::PassBuilder; using OptimizationLevel = PassBuilder::OptimizationLevel; using FunctionAnalysisManager = llvm::FunctionAnalysisManager; template <typename R> using SetupFunction = std::function<void(R const&, ProfileGenerator*, Profile&)>; using SetupFunctionWrapper = std::function<void(ProfileGenerator*, Profile&)>; using Components = std::vector<std::pair<String, SetupFunctionWrapper>>; // Construction, moves and copies // ProfileGenerator() = default; ~ProfileGenerator() = default; ProfileGenerator(ProfileGenerator const&) = delete; ProfileGenerator(ProfileGenerator&&) = delete; ProfileGenerator& operator=(ProfileGenerator const&) = delete; ProfileGenerator& operator=(ProfileGenerator&&) = delete; // Profile generation interface // ConfigurationManager& configurationManager(); ConfigurationManager const& configurationManager() const; Profile newProfile(String const& name, OptimizationLevel const& optimization_level, bool debug); // Defining the generator // template <typename R> void registerProfileComponent(String const& id, SetupFunction<R> setup); template <typename R> void replaceProfileComponent(String const& id, SetupFunction<R> setup); template <typename R> void registerAnonymousProfileComponent(SetupFunction<R> setup); void replicateProfileComponent(String const& id); // Support properties for generators // llvm::ModulePassManager& modulePassManager(); llvm::FunctionPassManager& functionPassManager(); llvm::PassBuilder& passBuilder(); OptimizationLevel optimizationLevel() const; bool isDebugMode() const; void setupDefaultComponentPipeline(); protected: llvm::ModulePassManager createGenerationModulePassManager( Profile& profile, OptimizationLevel const& optimization_level, bool debug); llvm::ModulePassManager createValidationModulePass( PassBuilder& pass_builder, OptimizationLevel const& optimization_level, bool debug); private: ConfigurationManager configuration_manager_; Components components_; llvm::ModulePassManager* module_pass_manager_{nullptr}; llvm::FunctionPassManager* function_pass_manager_{nullptr}; llvm::PassBuilder* pass_builder_{nullptr}; OptimizationLevel optimization_level_{OptimizationLevel::O0}; bool debug_{false}; }; template <typename R> void ProfileGenerator::registerProfileComponent(String const& id, SetupFunction<R> setup) { configuration_manager_.addConfig<R>(id); auto setup_wrapper = [setup](ProfileGenerator* ptr, Profile& profile) { if (ptr->configuration_manager_.isActive<R>()) { auto& config = ptr->configuration_manager_.get<R>(); setup(config, ptr, profile); } }; components_.push_back({id, std::move(setup_wrapper)}); } template <typename R> void ProfileGenerator::replaceProfileComponent(String const& id, SetupFunction<R> setup) { auto setup_wrapper = [setup](ProfileGenerator* ptr, Profile& profile) { if (ptr->configuration_manager_.isActive<R>()) { auto& config = ptr->configuration_manager_.get<R>(); setup(config, ptr, profile); } }; for (auto& component : components_) { if (component.first == id) { component.second = std::move(setup_wrapper); return; } } throw std::runtime_error(\"Could not find component \" + id); } template <typename R> void ProfileGenerator::registerAnonymousProfileComponent(SetupFunction<R> setup) { if (!configuration_manager_.configWasRegistered<R>()) { throw std::runtime_error(\"Configuration '\" + static_cast<String>(typeid(R).name()) + \"' does not exist.\"); } auto setup_wrapper = [setup](ProfileGenerator* ptr, Profile& profile) { if (ptr->configuration_manager_.isActive<R>()) { auto& config = ptr->configuration_manager_.get<R>(); setup(config, ptr, profile); } }; components_.push_back({\"__unnamed__\", std::move(setup_wrapper)}); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_qat_types_8hpp/","text":"QatTypes/QatTypes.hpp Namespaces Name microsoft microsoft::quantum Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include <string> namespace microsoft { namespace quantum { using String = std::string; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"QatTypes/QatTypes.hpp"},{"location":"Api/Files/_qat_types_8hpp/#qattypesqattypeshpp","text":"","title":"QatTypes/QatTypes.hpp"},{"location":"Api/Files/_qat_types_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_qat_types_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include <string> namespace microsoft { namespace quantum { using String = std::string; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_remove_disallowed_attributes_pass_8hpp/","text":"RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::RemoveDisallowedAttributesPass Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include \"Llvm/Llvm.hpp\" #include <functional> #include <unordered_set> #include <vector> namespace microsoft { namespace quantum { class RemoveDisallowedAttributesPass : public llvm::PassInfoMixin<RemoveDisallowedAttributesPass> { public: RemoveDisallowedAttributesPass() : allowed_attrs_{{static_cast<String>(\"EntryPoint\"), static_cast<String>(\"InteropFriendly\")}} { } llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { std::string const LLVM_FUNC_NAME = \"@llvm.\"; for (auto& fnc : module) { std::unordered_set<String> to_keep; auto name = static_cast<std::string>(fnc.getName()); // Skipping any LLVM function if (name.size() >= LLVM_FUNC_NAME.size() && name.substr(0, LLVM_FUNC_NAME.size()) == LLVM_FUNC_NAME) { continue; } // Finding all valid attributes for (auto& attrset : fnc.getAttributes()) { for (auto& attr : attrset) { auto r = static_cast<String>(attr.getAsString()); // Stripping quotes if (r.size() >= 2 && r[0] == '\"' && r[r.size() - 1] == '\"') { r = r.substr(1, r.size() - 2); } // Inserting if allowed if (allowed_attrs_.find(r) != allowed_attrs_.end()) { to_keep.insert(r); } } } // Deleting every fnc.setAttributes({}); for (auto& attr : to_keep) { fnc.addFnAttr(attr); } // Updating all users attributes for (auto user : fnc.users()) { auto call = llvm::dyn_cast<llvm::CallInst>(user); if (call != nullptr) { call->setAttributes(fnc.getAttributes()); } } } return llvm::PreservedAnalyses::none(); } private: std::unordered_set<String> allowed_attrs_; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp"},{"location":"Api/Files/_remove_disallowed_attributes_pass_8hpp/#removedisallowedattributespassremovedisallowedattributespasshpp","text":"","title":"RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp"},{"location":"Api/Files/_remove_disallowed_attributes_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_remove_disallowed_attributes_pass_8hpp/#classes","text":"Name class microsoft::quantum::RemoveDisallowedAttributesPass","title":"Classes"},{"location":"Api/Files/_remove_disallowed_attributes_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include \"Llvm/Llvm.hpp\" #include <functional> #include <unordered_set> #include <vector> namespace microsoft { namespace quantum { class RemoveDisallowedAttributesPass : public llvm::PassInfoMixin<RemoveDisallowedAttributesPass> { public: RemoveDisallowedAttributesPass() : allowed_attrs_{{static_cast<String>(\"EntryPoint\"), static_cast<String>(\"InteropFriendly\")}} { } llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { std::string const LLVM_FUNC_NAME = \"@llvm.\"; for (auto& fnc : module) { std::unordered_set<String> to_keep; auto name = static_cast<std::string>(fnc.getName()); // Skipping any LLVM function if (name.size() >= LLVM_FUNC_NAME.size() && name.substr(0, LLVM_FUNC_NAME.size()) == LLVM_FUNC_NAME) { continue; } // Finding all valid attributes for (auto& attrset : fnc.getAttributes()) { for (auto& attr : attrset) { auto r = static_cast<String>(attr.getAsString()); // Stripping quotes if (r.size() >= 2 && r[0] == '\"' && r[r.size() - 1] == '\"') { r = r.substr(1, r.size() - 2); } // Inserting if allowed if (allowed_attrs_.find(r) != allowed_attrs_.end()) { to_keep.insert(r); } } } // Deleting every fnc.setAttributes({}); for (auto& attr : to_keep) { fnc.addFnAttr(attr); } // Updating all users attributes for (auto user : fnc.users()) { auto call = llvm::dyn_cast<llvm::CallInst>(user); if (call != nullptr) { call->setAttributes(fnc.getAttributes()); } } } return llvm::PreservedAnalyses::none(); } private: std::unordered_set<String> allowed_attrs_; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_replacement_rule_8cpp/","text":"Rules/ReplacementRule.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/ReplacementRule.hpp\" namespace microsoft { namespace quantum { ReplacementRule::ReplacementRule(IOperandPrototypePtr&& pattern, ReplaceFunction&& replacer) : pattern_{std::move(pattern)} , replacer_{std::move(replacer)} { } ReplacementRule::ReplacementRule(String const& name, IOperandPrototypePtr&& pattern, ReplaceFunction&& replacer) : pattern_{std::move(pattern)} , replacer_{std::move(replacer)} , name_{name} { } void ReplacementRule::setPattern(IOperandPrototypePtr&& pattern) { pattern_ = std::move(pattern); } void ReplacementRule::setReplacer(ReplaceFunction const& replacer) { replacer_ = replacer; } bool ReplacementRule::match(Value* value, Captures& captures) const { if (pattern_ == nullptr) { return false; } return pattern_->match(value, captures); } bool ReplacementRule::replace(Builder& builder, Value* value, Captures& captures, Replacements& replacements) const { if (replacer_) { auto ret = replacer_(builder, value, captures, replacements); // In case replacement failed, the captures are deleted. if (!ret) { captures.clear(); } return ret; } return false; } String ReplacementRule::name() const { return name_; } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/ReplacementRule.cpp"},{"location":"Api/Files/_replacement_rule_8cpp/#rulesreplacementrulecpp","text":"","title":"Rules/ReplacementRule.cpp"},{"location":"Api/Files/_replacement_rule_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_replacement_rule_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/ReplacementRule.hpp\" namespace microsoft { namespace quantum { ReplacementRule::ReplacementRule(IOperandPrototypePtr&& pattern, ReplaceFunction&& replacer) : pattern_{std::move(pattern)} , replacer_{std::move(replacer)} { } ReplacementRule::ReplacementRule(String const& name, IOperandPrototypePtr&& pattern, ReplaceFunction&& replacer) : pattern_{std::move(pattern)} , replacer_{std::move(replacer)} , name_{name} { } void ReplacementRule::setPattern(IOperandPrototypePtr&& pattern) { pattern_ = std::move(pattern); } void ReplacementRule::setReplacer(ReplaceFunction const& replacer) { replacer_ = replacer; } bool ReplacementRule::match(Value* value, Captures& captures) const { if (pattern_ == nullptr) { return false; } return pattern_->match(value, captures); } bool ReplacementRule::replace(Builder& builder, Value* value, Captures& captures, Replacements& replacements) const { if (replacer_) { auto ret = replacer_(builder, value, captures, replacements); // In case replacement failed, the captures are deleted. if (!ret) { captures.clear(); } return ret; } return false; } String ReplacementRule::name() const { return name_; } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_replacement_rule_8hpp/","text":"Rules/ReplacementRule.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ReplacementRule Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class ReplacementRule { public: using Captures = IOperandPrototype::Captures; using Value = llvm::Value; using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; using Builder = llvm::IRBuilder<>; using Replacements = std::vector<std::pair<Value*, Value*>>; using ReplaceFunction = std::function<bool(Builder&, Value*, Captures&, Replacements&)>; // Constructors and destructors // ReplacementRule() = default; ReplacementRule(String const& name, IOperandPrototypePtr&& pattern, ReplaceFunction&& replacer); ReplacementRule(IOperandPrototypePtr&& pattern, ReplaceFunction&& replacer); // Rule configuration // void setPattern(IOperandPrototypePtr&& pattern); void setReplacer(ReplaceFunction const& replacer); // Operation // bool match(Value* value, Captures& captures) const; bool replace(Builder& builder, Value* value, Captures& captures, Replacements& replacements) const; String name() const; private: IOperandPrototypePtr pattern_{nullptr}; ReplaceFunction replacer_{nullptr}; String name_{\"unnamed\"}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/ReplacementRule.hpp"},{"location":"Api/Files/_replacement_rule_8hpp/#rulesreplacementrulehpp","text":"","title":"Rules/ReplacementRule.hpp"},{"location":"Api/Files/_replacement_rule_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_replacement_rule_8hpp/#classes","text":"Name class microsoft::quantum::ReplacementRule","title":"Classes"},{"location":"Api/Files/_replacement_rule_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class ReplacementRule { public: using Captures = IOperandPrototype::Captures; using Value = llvm::Value; using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; using Builder = llvm::IRBuilder<>; using Replacements = std::vector<std::pair<Value*, Value*>>; using ReplaceFunction = std::function<bool(Builder&, Value*, Captures&, Replacements&)>; // Constructors and destructors // ReplacementRule() = default; ReplacementRule(String const& name, IOperandPrototypePtr&& pattern, ReplaceFunction&& replacer); ReplacementRule(IOperandPrototypePtr&& pattern, ReplaceFunction&& replacer); // Rule configuration // void setPattern(IOperandPrototypePtr&& pattern); void setReplacer(ReplaceFunction const& replacer); // Operation // bool match(Value* value, Captures& captures) const; bool replace(Builder& builder, Value* value, Captures& captures, Replacements& replacements) const; String name() const; private: IOperandPrototypePtr pattern_{nullptr}; ReplaceFunction replacer_{nullptr}; String name_{\"unnamed\"}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_rule_set_8cpp/","text":"Rules/RuleSet.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/ReplacementRule.hpp\" #include \"Rules/RuleSet.hpp\" #include \"Llvm/Llvm.hpp\" #include <iostream> #include <vector> namespace microsoft { namespace quantum { bool RuleSet::matchAndReplace(Instruction* value, Replacements& replacements) { Captures captures; for (auto const& rule : rules_) { // Checking if the rule is matched and keep track of captured nodes if (rule->match(value, captures)) { // If it is matched, we attempt to replace it llvm::IRBuilder<> builder{value}; if (rule->replace(builder, value, captures, replacements)) { return true; } else { captures.clear(); } } } return false; } void RuleSet::addRule(ReplacementRulePtr const& rule) { rules_.push_back(rule); } void RuleSet::addRule(ReplacementRule&& rule) { addRule(std::make_shared<ReplacementRule>(std::move(rule))); } void RuleSet::clear() { rules_.clear(); } uint64_t RuleSet::size() const { return rules_.size(); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/RuleSet.cpp"},{"location":"Api/Files/_rule_set_8cpp/#rulesrulesetcpp","text":"","title":"Rules/RuleSet.cpp"},{"location":"Api/Files/_rule_set_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_rule_set_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/ReplacementRule.hpp\" #include \"Rules/RuleSet.hpp\" #include \"Llvm/Llvm.hpp\" #include <iostream> #include <vector> namespace microsoft { namespace quantum { bool RuleSet::matchAndReplace(Instruction* value, Replacements& replacements) { Captures captures; for (auto const& rule : rules_) { // Checking if the rule is matched and keep track of captured nodes if (rule->match(value, captures)) { // If it is matched, we attempt to replace it llvm::IRBuilder<> builder{value}; if (rule->replace(builder, value, captures, replacements)) { return true; } else { captures.clear(); } } } return false; } void RuleSet::addRule(ReplacementRulePtr const& rule) { rules_.push_back(rule); } void RuleSet::addRule(ReplacementRule&& rule) { addRule(std::make_shared<ReplacementRule>(std::move(rule))); } void RuleSet::clear() { rules_.clear(); } uint64_t RuleSet::size() const { return rules_.size(); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_rule_set_8hpp/","text":"Rules/RuleSet.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::RuleSet Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/IAllocationManager.hpp\" #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/ReplacementRule.hpp\" #include \"Llvm/Llvm.hpp\" #include <memory> #include <vector> namespace microsoft { namespace quantum { class RuleSet { public: using ReplacementRulePtr = std::shared_ptr<ReplacementRule>; using Rules = std::vector<ReplacementRulePtr>; using Replacements = ReplacementRule::Replacements; using Captures = IOperandPrototype::Captures; using Instruction = llvm::Instruction; using Value = llvm::Value; using Builder = ReplacementRule::Builder; using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; // Constructors // RuleSet() = default; RuleSet(RuleSet const&) = default; RuleSet(RuleSet&&) = default; ~RuleSet() = default; // Operators // RuleSet& operator=(RuleSet const&) = default; RuleSet& operator=(RuleSet&&) = default; // Operating rule sets // bool matchAndReplace(Instruction* value, Replacements& replacements); // Set up and configuration // void addRule(ReplacementRulePtr const& rule); void addRule(ReplacementRule&& rule); void clear(); uint64_t size() const; private: Rules rules_; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/RuleSet.hpp"},{"location":"Api/Files/_rule_set_8hpp/#rulesrulesethpp","text":"","title":"Rules/RuleSet.hpp"},{"location":"Api/Files/_rule_set_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_rule_set_8hpp/#classes","text":"Name class microsoft::quantum::RuleSet","title":"Classes"},{"location":"Api/Files/_rule_set_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/IAllocationManager.hpp\" #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/ReplacementRule.hpp\" #include \"Llvm/Llvm.hpp\" #include <memory> #include <vector> namespace microsoft { namespace quantum { class RuleSet { public: using ReplacementRulePtr = std::shared_ptr<ReplacementRule>; using Rules = std::vector<ReplacementRulePtr>; using Replacements = ReplacementRule::Replacements; using Captures = IOperandPrototype::Captures; using Instruction = llvm::Instruction; using Value = llvm::Value; using Builder = ReplacementRule::Builder; using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; // Constructors // RuleSet() = default; RuleSet(RuleSet const&) = default; RuleSet(RuleSet&&) = default; ~RuleSet() = default; // Operators // RuleSet& operator=(RuleSet const&) = default; RuleSet& operator=(RuleSet&&) = default; // Operating rule sets // bool matchAndReplace(Instruction* value, Replacements& replacements); // Set up and configuration // void addRule(ReplacementRulePtr const& rule); void addRule(ReplacementRule&& rule); void clear(); uint64_t size() const; private: Rules rules_; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_select_8cpp/","text":"Rules/Notation/Select.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr select( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2) { auto select_pattern = std::make_shared<SelectPattern>(); select_pattern->addChild(cond); select_pattern->addChild(arg1); select_pattern->addChild(arg2); return static_cast<IOperandPrototypePtr>(select_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Notation/Select.cpp"},{"location":"Api/Files/_select_8cpp/#rulesnotationselectcpp","text":"","title":"Rules/Notation/Select.cpp"},{"location":"Api/Files/_select_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_select_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr select( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2) { auto select_pattern = std::make_shared<SelectPattern>(); select_pattern->addChild(cond); select_pattern->addChild(arg1); select_pattern->addChild(arg2); return static_cast<IOperandPrototypePtr>(select_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_store_8cpp/","text":"Rules/Notation/Store.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr store(IOperandPrototypePtr const& target, IOperandPrototypePtr const& value) { auto ret = std::make_shared<StorePattern>(); ret->addChild(target); ret->addChild(value); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Notation/Store.cpp"},{"location":"Api/Files/_store_8cpp/#rulesnotationstorecpp","text":"","title":"Rules/Notation/Store.cpp"},{"location":"Api/Files/_store_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_store_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr store(IOperandPrototypePtr const& target, IOperandPrototypePtr const& value) { auto ret = std::make_shared<StorePattern>(); ret->addChild(target); ret->addChild(value); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_switch_8cpp/","text":"Rules/Notation/Switch.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr switchOp( IOperandPrototypePtr const& /*cond*/, IOperandPrototypePtr const& /*arg1*/, IOperandPrototypePtr const& /*arg2*/) { auto switch_pattern = std::make_shared<SwitchPattern>(); // TODO(issue-17): finish switch pattern // switch_pattern->addChild(cond); // switch_pattern->addChild(arg1); // switch_pattern->addChild(arg2); return static_cast<IOperandPrototypePtr>(switch_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Notation/Switch.cpp"},{"location":"Api/Files/_switch_8cpp/#rulesnotationswitchcpp","text":"","title":"Rules/Notation/Switch.cpp"},{"location":"Api/Files/_switch_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_switch_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr switchOp( IOperandPrototypePtr const& /*cond*/, IOperandPrototypePtr const& /*arg1*/, IOperandPrototypePtr const& /*arg2*/) { auto switch_pattern = std::make_shared<SwitchPattern>(); // TODO(issue-17): finish switch pattern // switch_pattern->addChild(cond); // switch_pattern->addChild(arg1); // switch_pattern->addChild(arg2); return static_cast<IOperandPrototypePtr>(switch_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_transformation_rules_pass_8cpp/","text":"TransformationRulesPass/TransformationRulesPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Factory.hpp\" #include \"Rules/Notation/Notation.hpp\" #include \"Rules/ReplacementRule.hpp\" #include \"TransformationRulesPass/TransformationRulesPass.hpp\" #include \"Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft { namespace quantum { TransformationRulesPass::TransformationRulesPass( RuleSet&& rule_set, TransformationRulesPassConfiguration const& config, Profile* profile) : rule_set_{std::move(rule_set)} , config_{config} , profile_{profile} { } void TransformationRulesPass::setupCopyAndExpand() { using namespace microsoft::quantum::notation; addConstExprRule( {branch(\"cond\"_cap = constInt(), \"if_false\"_cap = _, \"if_true\"_cap = _), [](Builder& builder, Value* val, Captures& captures, Replacements& replacements) { auto cst = llvm::dyn_cast<llvm::ConstantInt>(captures[\"cond\"]); auto instr = llvm::dyn_cast<llvm::Instruction>(val); if (cst == nullptr || instr == nullptr) { return false; } auto type = instr->getType(); if (type == nullptr) { return false; } auto branch_cond = cst->getValue().getZExtValue(); if (branch_cond) { auto if_true = llvm::dyn_cast<llvm::BasicBlock>(captures[\"if_true\"]); builder.CreateBr(if_true); instr->replaceAllUsesWith(llvm::UndefValue::get(type)); } else { auto if_false = llvm::dyn_cast<llvm::BasicBlock>(captures[\"if_false\"]); builder.CreateBr(if_false); instr->replaceAllUsesWith(llvm::UndefValue::get(type)); } replacements.push_back({val, nullptr}); return true; }}); if (config_.assumeNoExceptions()) { // Replacing all invokes with calls addConstExprRule({unnamedInvoke(), [](Builder& builder, Value* val, Captures&, Replacements& replacements) { auto invoke = llvm::dyn_cast<llvm::InvokeInst>(val); if (invoke == nullptr) { return false; } auto callee_function = invoke->getCalledFunction(); // List with new call arguments std::vector<llvm::Value*> new_arguments; for (unsigned i = 0; i < invoke->getNumArgOperands(); ++i) { // Getting the i'th argument llvm::Value* arg = invoke->getArgOperand(i); new_arguments.push_back(arg); } // Creating a new call auto* new_call = builder.CreateCall(callee_function, new_arguments); builder.CreateBr(invoke->getNormalDest()); new_call->takeName(invoke); // Replace all calls to old function with calls to new function invoke->replaceAllUsesWith(new_call); replacements.push_back({invoke, nullptr}); return true; }}); } } void TransformationRulesPass::addConstExprRule(ReplacementRule&& rule) { auto ret = std::make_shared<ReplacementRule>(std::move(rule)); const_expr_replacements_.addRule(ret); } void TransformationRulesPass::constantFoldFunction(llvm::Function& fnc) { std::vector<llvm::Instruction*> to_delete; // Folding all constants for (auto& basic_block : fnc) { for (auto& instr : basic_block) { auto module = instr.getModule(); auto const& dl = module->getDataLayout(); auto cst = llvm::ConstantFoldInstruction(&instr, dl, nullptr); if (cst != nullptr) { instr.replaceAllUsesWith(cst); to_delete.push_back(&instr); } } } // Deleting constants for (auto& x : to_delete) { x->eraseFromParent(); } // Folding constant expressions Replacements replacements; for (auto& basic_block : fnc) { for (auto& instr : basic_block) { const_expr_replacements_.matchAndReplace(&instr, replacements); } } for (auto& r : replacements) { if (r.second != nullptr) { throw std::runtime_error(\"Real replacements not implemented.\"); } auto instr = llvm::dyn_cast<llvm::Instruction>(r.first); if (instr != nullptr) { instr->eraseFromParent(); continue; } auto block = llvm::dyn_cast<llvm::BasicBlock>(r.first); if (block != nullptr) { llvm::DeleteDeadBlock(block); } } } llvm::Value* TransformationRulesPass::copyAndExpand( llvm::Value* input, DeletableInstructions& schedule_instruction_deletion) { llvm::Value* ret = input; auto* call_instr = llvm::dyn_cast<llvm::CallInst>(input); auto instr_ptr = llvm::dyn_cast<llvm::Instruction>(input); if (call_instr != nullptr && instr_ptr != nullptr) { auto& instr = *instr_ptr; auto callee_function = call_instr->getCalledFunction(); if (callee_function != nullptr && !callee_function->isDeclaration()) { ConstantArguments argument_constants{}; std::vector<uint32_t> remaining_arguments{}; uint32_t idx = 0; auto n = static_cast<uint32_t>(callee_function->arg_size()); // Finding argument constants while (idx < n) { auto arg = callee_function->getArg(idx); auto value = call_instr->getArgOperand(idx); auto cst = llvm::dyn_cast<llvm::ConstantInt>(value); if (cst != nullptr) { argument_constants[arg->getName().str()] = cst; } else { remaining_arguments.push_back(idx); } ++idx; } // Making a function copy auto new_callee = expandFunctionCall(*callee_function, argument_constants); // Replacing call if a new function was created if (new_callee != nullptr) { llvm::IRBuilder<> builder(call_instr); // List with new call arguments std::vector<llvm::Value*> new_arguments; for (auto const& i : remaining_arguments) { // Getting the i'th argument llvm::Value* arg = call_instr->getArgOperand(i); // Adding arguments that were not constant if (argument_constants.find(arg->getName().str()) == argument_constants.end()) { new_arguments.push_back(arg); } } // Creating a new call auto* new_call = builder.CreateCall(new_callee, new_arguments); new_call->takeName(call_instr); new_call->setTailCall(call_instr->isTailCall()); new_call->setTailCallKind(call_instr->getTailCallKind()); if (call_instr->canReturnTwice()) { new_call->setCanReturnTwice(); } new_call->setCallingConv(call_instr->getCallingConv()); new_call->setAttributes(call_instr->getAttributes()); // Replace all calls to old function with calls to new function instr.replaceAllUsesWith(new_call); // Deleting instruction schedule_instruction_deletion.push_back(&instr); // Folding constants in the new function as we may have replaced some of // the arguments with constants constantFoldFunction(*new_callee); // Recursion: Returning the new call as the instruction to be analysed ret = new_call; } // Deleting the function the original function if it is no longer in use if (callee_function->use_empty()) { callee_function->eraseFromParent(); } } } return ret; } llvm::Value* TransformationRulesPass::detectActiveCode(llvm::Value* input, DeletableInstructions&) { active_pieces_.insert(input); return input; } bool TransformationRulesPass::runOnFunction(llvm::Function& function, InstructionModifier const& modifier) { if (function.isDeclaration()) { return false; } if (depth_ >= config_.maxRecursion()) { llvm::outs() << \"Exceed max recursion of \" << config_.maxRecursion() << \"\\n\"; return false; } ++depth_; // Keep track of instructions scheduled for deletion DeletableInstructions schedule_instruction_deletion; // Block queue std::deque<llvm::BasicBlock*> queue; std::unordered_set<llvm::BasicBlock*> blocks_queued; queue.push_back(&function.getEntryBlock()); blocks_queued.insert(&function.getEntryBlock()); // Executing the modifier on the function itsel modifier(&function, schedule_instruction_deletion); while (!queue.empty()) { auto& basic_block = *(queue.front()); queue.pop_front(); // Executing the modifier on the block modifier(&basic_block, schedule_instruction_deletion); for (auto& instr : basic_block) { // Modifying instruction as needed auto instr_ptr = modifier(&instr, schedule_instruction_deletion); // In case the instruction was scheduled for deletion if (instr_ptr == nullptr) { continue; } // Checking if we are calling a function auto call_instr = llvm::dyn_cast<llvm::CallBase>(instr_ptr); if (call_instr != nullptr) { auto callee_function = call_instr->getCalledFunction(); if (callee_function != nullptr && !callee_function->isDeclaration()) { runOnFunction(*callee_function, modifier); } } // Following the branches to their basic blocks auto* br_instr = llvm::dyn_cast<llvm::BranchInst>(&instr); if (br_instr != nullptr) { for (uint32_t i = 0; i < br_instr->getNumOperands(); ++i) { // TODO(issue-19): This may not work on multi path branches (conditional) // as we may accidentally add the final path (contains qubit release) // and we cannot make assumptions since optimization may have rearranged // everything. In this case, we should revert to the order they appear in the // function auto bb = llvm::dyn_cast<llvm::BasicBlock>(br_instr->getOperand(i)); if (bb != nullptr) { // Ensuring that we are not scheduling the same block twice if (blocks_queued.find(bb) == blocks_queued.end()) { queue.push_back(bb); blocks_queued.insert(bb); } } } continue; } // Follow the branches of auto* switch_instr = llvm::dyn_cast<llvm::SwitchInst>(&instr); if (switch_instr != nullptr) { for (uint64_t i = 0; i < switch_instr->getNumSuccessors(); ++i) { auto bb = switch_instr->getSuccessor(static_cast<uint32_t>(i)); // Ensuring that we are not scheduling the same block twice if (blocks_queued.find(bb) == blocks_queued.end()) { queue.push_back(bb); blocks_queued.insert(bb); } } continue; } // Checking if this is an invoke call auto* invoke_inst = llvm::dyn_cast<llvm::InvokeInst>(&instr); if (invoke_inst != nullptr) { // Checking that configuration is correct if (!config_.assumeNoExceptions()) { // TODO(issue-20): Unify error reporting throw std::runtime_error(\"Exceptions paths cannot be handled at compile time. Either disable \" \"transform-execution-path-only or add assumption assume-no-except\"); } // Adding the block which is the on the \"no except\" path auto bb = invoke_inst->getNormalDest(); if (blocks_queued.find(bb) == blocks_queued.end()) { queue.push_back(bb); blocks_queued.insert(bb); } } } } // Deleting constants for (auto& x : schedule_instruction_deletion) { x->eraseFromParent(); } --depth_; return true; } bool TransformationRulesPass::isActive(llvm::Value* value) const { return active_pieces_.find(value) != active_pieces_.end(); } void TransformationRulesPass::runCopyAndExpand(llvm::Module& module, llvm::ModuleAnalysisManager&) { replacements_.clear(); // For every instruction in every block, we attempt a match // and replace. for (auto& function : module) { if (function.hasFnAttribute(config_.entryPointAttr())) { runOnFunction(function, [this](llvm::Value* value, DeletableInstructions& modifier) { return copyAndExpand(value, modifier); }); } } // Active code detection for (auto& global : module.globals()) { active_pieces_.insert(&global); for (auto& op : global.operands()) { active_pieces_.insert(op); } } for (auto& function : module) { bool is_active = false; // Checking if the function is referenced by a global variable for (auto user : function.users()) { // If the user is active, then it should be expected that the function is also active if (isActive(user)) { is_active = true; break; } } if (is_active || function.hasFnAttribute(config_.entryPointAttr())) { // Marking function as active active_pieces_.insert(&function); // Detecting active code runOnFunction(function, [this](llvm::Value* value, DeletableInstructions& modifier) { return detectActiveCode(value, modifier); }); } } processReplacements(); } void TransformationRulesPass::processReplacements() { // Applying all replacements std::unordered_set<llvm::Value*> already_removed; for (auto it = replacements_.rbegin(); it != replacements_.rend(); ++it) { auto instr1 = llvm::dyn_cast<llvm::Instruction>(it->first); if (instr1 == nullptr) { llvm::outs() << \"; WARNING: cannot deal with non-instruction replacements\\n\"; continue; } // Checking if by accident the same instruction was added if (already_removed.find(instr1) != already_removed.end()) { throw std::runtime_error(\"Instruction was already removed.\"); } already_removed.insert(instr1); // Cheking if have a replacement for the instruction if (it->second != nullptr) { // ... if so, we just replace it, auto instr2 = llvm::dyn_cast<llvm::Instruction>(it->second); if (instr2 == nullptr) { llvm::outs() << \"; WARNING: cannot replace instruction with non-instruction\\n\"; llvm::outs() << \"; \" << *it->second << \"\\n\"; continue; } llvm::ReplaceInstWithInst(instr1, instr2); } else { // ... otherwize we delete the the instruction // Removing all uses if (!instr1->use_empty()) { auto type = instr1->getType(); if (type != nullptr) { instr1->replaceAllUsesWith(llvm::UndefValue::get(type)); } } // And finally we delete the instruction. The if statement // is first and foremost a precaution which prevents the program // from seg-faulting in the unlikely case that instr1->getType() is null. if (instr1->use_empty()) { instr1->eraseFromParent(); } } } replacements_.clear(); } void TransformationRulesPass::runDetectActiveCode(llvm::Module& module, llvm::ModuleAnalysisManager&) { blocks_to_delete_.clear(); functions_to_delete_.clear(); for (auto& function : module) { if (isActive(&function)) { for (auto& block : function) { if (!isActive(&block)) { blocks_to_delete_.push_back(&block); } } } else if (!function.isDeclaration()) { functions_to_delete_.push_back(&function); } } } void TransformationRulesPass::runDeleteDeadCode(llvm::Module&, llvm::ModuleAnalysisManager&) { // Removing all function references and scheduling blocks for deletion for (auto& function : functions_to_delete_) { // Schedule for deletion function->replaceAllUsesWith(llvm::UndefValue::get(function->getType())); function->clearGC(); function->clearMetadata(); // Deleteing blocks in reverse order std::vector<llvm::BasicBlock*> blocks; for (auto& block : *function) { blocks.push_back(&block); } // Removing backwards to avoid segfault for (auto it = blocks.rbegin(); it != blocks.rend(); ++it) { auto& block = **it; // Deleting instructions in reverse order (needed because it is a DAG structure) std::vector<llvm::Instruction*> instructions; for (auto& instr : block) { instructions.push_back(&instr); } // Removing all instructions for (auto it2 = instructions.rbegin(); it2 != instructions.rend(); ++it2) { auto& instr = **it2; instr.replaceAllUsesWith(llvm::UndefValue::get(instr.getType())); instr.eraseFromParent(); } // Removing all block references block.replaceAllUsesWith(llvm::UndefValue::get(block.getType())); // Scheduling block deletion blocks_to_delete_.push_back(&block); } } // Deleting all blocks for (auto block : blocks_to_delete_) { if (block->use_empty()) { block->eraseFromParent(); } else { llvm::errs() << \"; INTERNAL ERROR: block was supposed to be unused.\\n\"; for (auto& x : block->uses()) { llvm::errs() << \" -x \" << *x << \"\\n\"; } for (auto x : block->users()) { llvm::errs() << \" -: \" << *x << \"\\n\"; } llvm::errs() << \" ----- \\n\"; llvm::errs() << *block << \"\\n\"; } } // Removing functions for (auto& function : functions_to_delete_) { if (function->isDeclaration() && function->use_empty()) { function->eraseFromParent(); } } } void TransformationRulesPass::runReplacePhi(llvm::Module& module, llvm::ModuleAnalysisManager&) { using namespace microsoft::quantum::notation; auto rule = phi(\"b1\"_cap = _, \"b2\"_cap = _); IOperandPrototype::Captures captures; std::vector<llvm::Instruction*> to_delete; std::unordered_map<llvm::Instruction*, llvm::Value*> replacements; for (auto& function : module) { for (auto& block : function) { std::vector<llvm::Instruction*> instrs; for (auto& instr : block) { if (rule->match(&instr, captures)) { auto phi = llvm::dyn_cast<llvm::PHINode>(&instr); if (phi == nullptr) { continue; } auto val1 = captures[\"b1\"]; auto val2 = captures[\"b2\"]; auto block1 = phi->getIncomingBlock(0); // TODO(issue-21): Make sure that block1 matches val1 auto block2 = phi->getIncomingBlock(1); if (!isActive(block1)) { val2->takeName(&instr); replacements[&instr] = val2; to_delete.push_back(&instr); } else if (!isActive(block2)) { val1->takeName(&instr); replacements[&instr] = val2; to_delete.push_back(&instr); } captures.clear(); } } } } for (auto& r : replacements) { r.first->replaceAllUsesWith(r.second); } for (auto& x : to_delete) { x->eraseFromParent(); } } void TransformationRulesPass::runApplyRules(llvm::Module& module, llvm::ModuleAnalysisManager&) { replacements_.clear(); std::unordered_set<llvm::Value*> already_visited; for (auto& function : module) { if (function.hasFnAttribute(config_.entryPointAttr())) { runOnFunction(function, [this, &already_visited](llvm::Value* value, DeletableInstructions&) { auto instr = llvm::dyn_cast<llvm::Instruction>(value); // Sanity check if (already_visited.find(value) != already_visited.end()) { throw std::runtime_error(\"Already visited\"); } already_visited.insert(value); // Checking if we should analyse if (instr != nullptr) { rule_set_.matchAndReplace(instr, replacements_); } return value; }); if (config_.shouldAnnotateQubitUse()) { std::stringstream ss{\"\"}; ss << profile_->getQubitAllocationManager()->maxAllocationsUsed(); function.addFnAttr(\"requiredQubits\", ss.str()); } if (config_.shouldAnnotateResultUse()) { std::stringstream ss{\"\"}; ss << profile_->getResultAllocationManager()->maxAllocationsUsed(); function.addFnAttr(\"requiredResults\", ss.str()); } } } processReplacements(); } llvm::PreservedAnalyses TransformationRulesPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& mam) { // In case the module is istructed to clone functions, if (config_.shouldCloneFunctions()) { setupCopyAndExpand(); runCopyAndExpand(module, mam); } // Deleting dead code if configured to do so. This process consists // of three steps: detecting dead code, removing phi nodes (and references) // and finally deleting the code. This implementation is aggressive in the sense // that any code that we cannot prove to be active is considered dead. if (config_.shouldDeleteDeadCode()) { runDetectActiveCode(module, mam); runReplacePhi(module, mam); runDeleteDeadCode(module, mam); } // Applying rule set if (config_.shouldTransformExecutionPathOnly()) { // We only apply transformation rules to code which is reachable // via the execution path. runApplyRules(module, mam); } else { // Otherwize we apply to all sections of the code. replacements_.clear(); for (auto& function : module) { for (auto& block : function) { for (auto& instr : block) { rule_set_.matchAndReplace(&instr, replacements_); } } } processReplacements(); } return llvm::PreservedAnalyses::none(); } llvm::Function* TransformationRulesPass::expandFunctionCall( llvm::Function& callee, ConstantArguments const& const_args) { auto module = callee.getParent(); auto& context = module->getContext(); llvm::IRBuilder<> builder(context); // Copying the original function llvm::ValueToValueMapTy remapper; std::vector<llvm::Type*> arg_types; // The user might be deleting arguments to the function by specifying them in // the VMap. If so, we need to not add the arguments to the arg ty vector // for (auto const& arg : callee.args()) { // Skipping constant arguments if (const_args.find(arg.getName().str()) != const_args.end()) { continue; } arg_types.push_back(arg.getType()); } // Creating a new function llvm::FunctionType* function_type = llvm::FunctionType::get( callee.getFunctionType()->getReturnType(), arg_types, callee.getFunctionType()->isVarArg()); auto function = llvm::Function::Create( function_type, callee.getLinkage(), callee.getAddressSpace(), callee.getName(), module); // Copying the non-const arguments auto dest_args_it = function->arg_begin(); for (auto const& arg : callee.args()) { auto const_it = const_args.find(arg.getName().str()); if (const_it == const_args.end()) { // Mapping remaining function arguments dest_args_it->setName(arg.getName()); remapper[&arg] = &*dest_args_it++; } else { remapper[&arg] = llvm::ConstantInt::get(context, const_it->second->getValue()); } } llvm::SmallVector<llvm::ReturnInst*, 8> returns; // Ignore returns cloned. // Note: In LLVM 13 upgrade 'true' to 'llvm::CloneFunctionChangeType::LocalChangesOnly' llvm::CloneFunctionInto(function, &callee, remapper, true, returns, \"\", nullptr); verifyFunction(*function); return function; } void TransformationRulesPass::setLogger(ILoggerPtr logger) { logger_ = std::move(logger); } bool TransformationRulesPass::isRequired() { return true; } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"TransformationRulesPass/TransformationRulesPass.cpp"},{"location":"Api/Files/_transformation_rules_pass_8cpp/#transformationrulespasstransformationrulespasscpp","text":"","title":"TransformationRulesPass/TransformationRulesPass.cpp"},{"location":"Api/Files/_transformation_rules_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_transformation_rules_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Factory.hpp\" #include \"Rules/Notation/Notation.hpp\" #include \"Rules/ReplacementRule.hpp\" #include \"TransformationRulesPass/TransformationRulesPass.hpp\" #include \"Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft { namespace quantum { TransformationRulesPass::TransformationRulesPass( RuleSet&& rule_set, TransformationRulesPassConfiguration const& config, Profile* profile) : rule_set_{std::move(rule_set)} , config_{config} , profile_{profile} { } void TransformationRulesPass::setupCopyAndExpand() { using namespace microsoft::quantum::notation; addConstExprRule( {branch(\"cond\"_cap = constInt(), \"if_false\"_cap = _, \"if_true\"_cap = _), [](Builder& builder, Value* val, Captures& captures, Replacements& replacements) { auto cst = llvm::dyn_cast<llvm::ConstantInt>(captures[\"cond\"]); auto instr = llvm::dyn_cast<llvm::Instruction>(val); if (cst == nullptr || instr == nullptr) { return false; } auto type = instr->getType(); if (type == nullptr) { return false; } auto branch_cond = cst->getValue().getZExtValue(); if (branch_cond) { auto if_true = llvm::dyn_cast<llvm::BasicBlock>(captures[\"if_true\"]); builder.CreateBr(if_true); instr->replaceAllUsesWith(llvm::UndefValue::get(type)); } else { auto if_false = llvm::dyn_cast<llvm::BasicBlock>(captures[\"if_false\"]); builder.CreateBr(if_false); instr->replaceAllUsesWith(llvm::UndefValue::get(type)); } replacements.push_back({val, nullptr}); return true; }}); if (config_.assumeNoExceptions()) { // Replacing all invokes with calls addConstExprRule({unnamedInvoke(), [](Builder& builder, Value* val, Captures&, Replacements& replacements) { auto invoke = llvm::dyn_cast<llvm::InvokeInst>(val); if (invoke == nullptr) { return false; } auto callee_function = invoke->getCalledFunction(); // List with new call arguments std::vector<llvm::Value*> new_arguments; for (unsigned i = 0; i < invoke->getNumArgOperands(); ++i) { // Getting the i'th argument llvm::Value* arg = invoke->getArgOperand(i); new_arguments.push_back(arg); } // Creating a new call auto* new_call = builder.CreateCall(callee_function, new_arguments); builder.CreateBr(invoke->getNormalDest()); new_call->takeName(invoke); // Replace all calls to old function with calls to new function invoke->replaceAllUsesWith(new_call); replacements.push_back({invoke, nullptr}); return true; }}); } } void TransformationRulesPass::addConstExprRule(ReplacementRule&& rule) { auto ret = std::make_shared<ReplacementRule>(std::move(rule)); const_expr_replacements_.addRule(ret); } void TransformationRulesPass::constantFoldFunction(llvm::Function& fnc) { std::vector<llvm::Instruction*> to_delete; // Folding all constants for (auto& basic_block : fnc) { for (auto& instr : basic_block) { auto module = instr.getModule(); auto const& dl = module->getDataLayout(); auto cst = llvm::ConstantFoldInstruction(&instr, dl, nullptr); if (cst != nullptr) { instr.replaceAllUsesWith(cst); to_delete.push_back(&instr); } } } // Deleting constants for (auto& x : to_delete) { x->eraseFromParent(); } // Folding constant expressions Replacements replacements; for (auto& basic_block : fnc) { for (auto& instr : basic_block) { const_expr_replacements_.matchAndReplace(&instr, replacements); } } for (auto& r : replacements) { if (r.second != nullptr) { throw std::runtime_error(\"Real replacements not implemented.\"); } auto instr = llvm::dyn_cast<llvm::Instruction>(r.first); if (instr != nullptr) { instr->eraseFromParent(); continue; } auto block = llvm::dyn_cast<llvm::BasicBlock>(r.first); if (block != nullptr) { llvm::DeleteDeadBlock(block); } } } llvm::Value* TransformationRulesPass::copyAndExpand( llvm::Value* input, DeletableInstructions& schedule_instruction_deletion) { llvm::Value* ret = input; auto* call_instr = llvm::dyn_cast<llvm::CallInst>(input); auto instr_ptr = llvm::dyn_cast<llvm::Instruction>(input); if (call_instr != nullptr && instr_ptr != nullptr) { auto& instr = *instr_ptr; auto callee_function = call_instr->getCalledFunction(); if (callee_function != nullptr && !callee_function->isDeclaration()) { ConstantArguments argument_constants{}; std::vector<uint32_t> remaining_arguments{}; uint32_t idx = 0; auto n = static_cast<uint32_t>(callee_function->arg_size()); // Finding argument constants while (idx < n) { auto arg = callee_function->getArg(idx); auto value = call_instr->getArgOperand(idx); auto cst = llvm::dyn_cast<llvm::ConstantInt>(value); if (cst != nullptr) { argument_constants[arg->getName().str()] = cst; } else { remaining_arguments.push_back(idx); } ++idx; } // Making a function copy auto new_callee = expandFunctionCall(*callee_function, argument_constants); // Replacing call if a new function was created if (new_callee != nullptr) { llvm::IRBuilder<> builder(call_instr); // List with new call arguments std::vector<llvm::Value*> new_arguments; for (auto const& i : remaining_arguments) { // Getting the i'th argument llvm::Value* arg = call_instr->getArgOperand(i); // Adding arguments that were not constant if (argument_constants.find(arg->getName().str()) == argument_constants.end()) { new_arguments.push_back(arg); } } // Creating a new call auto* new_call = builder.CreateCall(new_callee, new_arguments); new_call->takeName(call_instr); new_call->setTailCall(call_instr->isTailCall()); new_call->setTailCallKind(call_instr->getTailCallKind()); if (call_instr->canReturnTwice()) { new_call->setCanReturnTwice(); } new_call->setCallingConv(call_instr->getCallingConv()); new_call->setAttributes(call_instr->getAttributes()); // Replace all calls to old function with calls to new function instr.replaceAllUsesWith(new_call); // Deleting instruction schedule_instruction_deletion.push_back(&instr); // Folding constants in the new function as we may have replaced some of // the arguments with constants constantFoldFunction(*new_callee); // Recursion: Returning the new call as the instruction to be analysed ret = new_call; } // Deleting the function the original function if it is no longer in use if (callee_function->use_empty()) { callee_function->eraseFromParent(); } } } return ret; } llvm::Value* TransformationRulesPass::detectActiveCode(llvm::Value* input, DeletableInstructions&) { active_pieces_.insert(input); return input; } bool TransformationRulesPass::runOnFunction(llvm::Function& function, InstructionModifier const& modifier) { if (function.isDeclaration()) { return false; } if (depth_ >= config_.maxRecursion()) { llvm::outs() << \"Exceed max recursion of \" << config_.maxRecursion() << \"\\n\"; return false; } ++depth_; // Keep track of instructions scheduled for deletion DeletableInstructions schedule_instruction_deletion; // Block queue std::deque<llvm::BasicBlock*> queue; std::unordered_set<llvm::BasicBlock*> blocks_queued; queue.push_back(&function.getEntryBlock()); blocks_queued.insert(&function.getEntryBlock()); // Executing the modifier on the function itsel modifier(&function, schedule_instruction_deletion); while (!queue.empty()) { auto& basic_block = *(queue.front()); queue.pop_front(); // Executing the modifier on the block modifier(&basic_block, schedule_instruction_deletion); for (auto& instr : basic_block) { // Modifying instruction as needed auto instr_ptr = modifier(&instr, schedule_instruction_deletion); // In case the instruction was scheduled for deletion if (instr_ptr == nullptr) { continue; } // Checking if we are calling a function auto call_instr = llvm::dyn_cast<llvm::CallBase>(instr_ptr); if (call_instr != nullptr) { auto callee_function = call_instr->getCalledFunction(); if (callee_function != nullptr && !callee_function->isDeclaration()) { runOnFunction(*callee_function, modifier); } } // Following the branches to their basic blocks auto* br_instr = llvm::dyn_cast<llvm::BranchInst>(&instr); if (br_instr != nullptr) { for (uint32_t i = 0; i < br_instr->getNumOperands(); ++i) { // TODO(issue-19): This may not work on multi path branches (conditional) // as we may accidentally add the final path (contains qubit release) // and we cannot make assumptions since optimization may have rearranged // everything. In this case, we should revert to the order they appear in the // function auto bb = llvm::dyn_cast<llvm::BasicBlock>(br_instr->getOperand(i)); if (bb != nullptr) { // Ensuring that we are not scheduling the same block twice if (blocks_queued.find(bb) == blocks_queued.end()) { queue.push_back(bb); blocks_queued.insert(bb); } } } continue; } // Follow the branches of auto* switch_instr = llvm::dyn_cast<llvm::SwitchInst>(&instr); if (switch_instr != nullptr) { for (uint64_t i = 0; i < switch_instr->getNumSuccessors(); ++i) { auto bb = switch_instr->getSuccessor(static_cast<uint32_t>(i)); // Ensuring that we are not scheduling the same block twice if (blocks_queued.find(bb) == blocks_queued.end()) { queue.push_back(bb); blocks_queued.insert(bb); } } continue; } // Checking if this is an invoke call auto* invoke_inst = llvm::dyn_cast<llvm::InvokeInst>(&instr); if (invoke_inst != nullptr) { // Checking that configuration is correct if (!config_.assumeNoExceptions()) { // TODO(issue-20): Unify error reporting throw std::runtime_error(\"Exceptions paths cannot be handled at compile time. Either disable \" \"transform-execution-path-only or add assumption assume-no-except\"); } // Adding the block which is the on the \"no except\" path auto bb = invoke_inst->getNormalDest(); if (blocks_queued.find(bb) == blocks_queued.end()) { queue.push_back(bb); blocks_queued.insert(bb); } } } } // Deleting constants for (auto& x : schedule_instruction_deletion) { x->eraseFromParent(); } --depth_; return true; } bool TransformationRulesPass::isActive(llvm::Value* value) const { return active_pieces_.find(value) != active_pieces_.end(); } void TransformationRulesPass::runCopyAndExpand(llvm::Module& module, llvm::ModuleAnalysisManager&) { replacements_.clear(); // For every instruction in every block, we attempt a match // and replace. for (auto& function : module) { if (function.hasFnAttribute(config_.entryPointAttr())) { runOnFunction(function, [this](llvm::Value* value, DeletableInstructions& modifier) { return copyAndExpand(value, modifier); }); } } // Active code detection for (auto& global : module.globals()) { active_pieces_.insert(&global); for (auto& op : global.operands()) { active_pieces_.insert(op); } } for (auto& function : module) { bool is_active = false; // Checking if the function is referenced by a global variable for (auto user : function.users()) { // If the user is active, then it should be expected that the function is also active if (isActive(user)) { is_active = true; break; } } if (is_active || function.hasFnAttribute(config_.entryPointAttr())) { // Marking function as active active_pieces_.insert(&function); // Detecting active code runOnFunction(function, [this](llvm::Value* value, DeletableInstructions& modifier) { return detectActiveCode(value, modifier); }); } } processReplacements(); } void TransformationRulesPass::processReplacements() { // Applying all replacements std::unordered_set<llvm::Value*> already_removed; for (auto it = replacements_.rbegin(); it != replacements_.rend(); ++it) { auto instr1 = llvm::dyn_cast<llvm::Instruction>(it->first); if (instr1 == nullptr) { llvm::outs() << \"; WARNING: cannot deal with non-instruction replacements\\n\"; continue; } // Checking if by accident the same instruction was added if (already_removed.find(instr1) != already_removed.end()) { throw std::runtime_error(\"Instruction was already removed.\"); } already_removed.insert(instr1); // Cheking if have a replacement for the instruction if (it->second != nullptr) { // ... if so, we just replace it, auto instr2 = llvm::dyn_cast<llvm::Instruction>(it->second); if (instr2 == nullptr) { llvm::outs() << \"; WARNING: cannot replace instruction with non-instruction\\n\"; llvm::outs() << \"; \" << *it->second << \"\\n\"; continue; } llvm::ReplaceInstWithInst(instr1, instr2); } else { // ... otherwize we delete the the instruction // Removing all uses if (!instr1->use_empty()) { auto type = instr1->getType(); if (type != nullptr) { instr1->replaceAllUsesWith(llvm::UndefValue::get(type)); } } // And finally we delete the instruction. The if statement // is first and foremost a precaution which prevents the program // from seg-faulting in the unlikely case that instr1->getType() is null. if (instr1->use_empty()) { instr1->eraseFromParent(); } } } replacements_.clear(); } void TransformationRulesPass::runDetectActiveCode(llvm::Module& module, llvm::ModuleAnalysisManager&) { blocks_to_delete_.clear(); functions_to_delete_.clear(); for (auto& function : module) { if (isActive(&function)) { for (auto& block : function) { if (!isActive(&block)) { blocks_to_delete_.push_back(&block); } } } else if (!function.isDeclaration()) { functions_to_delete_.push_back(&function); } } } void TransformationRulesPass::runDeleteDeadCode(llvm::Module&, llvm::ModuleAnalysisManager&) { // Removing all function references and scheduling blocks for deletion for (auto& function : functions_to_delete_) { // Schedule for deletion function->replaceAllUsesWith(llvm::UndefValue::get(function->getType())); function->clearGC(); function->clearMetadata(); // Deleteing blocks in reverse order std::vector<llvm::BasicBlock*> blocks; for (auto& block : *function) { blocks.push_back(&block); } // Removing backwards to avoid segfault for (auto it = blocks.rbegin(); it != blocks.rend(); ++it) { auto& block = **it; // Deleting instructions in reverse order (needed because it is a DAG structure) std::vector<llvm::Instruction*> instructions; for (auto& instr : block) { instructions.push_back(&instr); } // Removing all instructions for (auto it2 = instructions.rbegin(); it2 != instructions.rend(); ++it2) { auto& instr = **it2; instr.replaceAllUsesWith(llvm::UndefValue::get(instr.getType())); instr.eraseFromParent(); } // Removing all block references block.replaceAllUsesWith(llvm::UndefValue::get(block.getType())); // Scheduling block deletion blocks_to_delete_.push_back(&block); } } // Deleting all blocks for (auto block : blocks_to_delete_) { if (block->use_empty()) { block->eraseFromParent(); } else { llvm::errs() << \"; INTERNAL ERROR: block was supposed to be unused.\\n\"; for (auto& x : block->uses()) { llvm::errs() << \" -x \" << *x << \"\\n\"; } for (auto x : block->users()) { llvm::errs() << \" -: \" << *x << \"\\n\"; } llvm::errs() << \" ----- \\n\"; llvm::errs() << *block << \"\\n\"; } } // Removing functions for (auto& function : functions_to_delete_) { if (function->isDeclaration() && function->use_empty()) { function->eraseFromParent(); } } } void TransformationRulesPass::runReplacePhi(llvm::Module& module, llvm::ModuleAnalysisManager&) { using namespace microsoft::quantum::notation; auto rule = phi(\"b1\"_cap = _, \"b2\"_cap = _); IOperandPrototype::Captures captures; std::vector<llvm::Instruction*> to_delete; std::unordered_map<llvm::Instruction*, llvm::Value*> replacements; for (auto& function : module) { for (auto& block : function) { std::vector<llvm::Instruction*> instrs; for (auto& instr : block) { if (rule->match(&instr, captures)) { auto phi = llvm::dyn_cast<llvm::PHINode>(&instr); if (phi == nullptr) { continue; } auto val1 = captures[\"b1\"]; auto val2 = captures[\"b2\"]; auto block1 = phi->getIncomingBlock(0); // TODO(issue-21): Make sure that block1 matches val1 auto block2 = phi->getIncomingBlock(1); if (!isActive(block1)) { val2->takeName(&instr); replacements[&instr] = val2; to_delete.push_back(&instr); } else if (!isActive(block2)) { val1->takeName(&instr); replacements[&instr] = val2; to_delete.push_back(&instr); } captures.clear(); } } } } for (auto& r : replacements) { r.first->replaceAllUsesWith(r.second); } for (auto& x : to_delete) { x->eraseFromParent(); } } void TransformationRulesPass::runApplyRules(llvm::Module& module, llvm::ModuleAnalysisManager&) { replacements_.clear(); std::unordered_set<llvm::Value*> already_visited; for (auto& function : module) { if (function.hasFnAttribute(config_.entryPointAttr())) { runOnFunction(function, [this, &already_visited](llvm::Value* value, DeletableInstructions&) { auto instr = llvm::dyn_cast<llvm::Instruction>(value); // Sanity check if (already_visited.find(value) != already_visited.end()) { throw std::runtime_error(\"Already visited\"); } already_visited.insert(value); // Checking if we should analyse if (instr != nullptr) { rule_set_.matchAndReplace(instr, replacements_); } return value; }); if (config_.shouldAnnotateQubitUse()) { std::stringstream ss{\"\"}; ss << profile_->getQubitAllocationManager()->maxAllocationsUsed(); function.addFnAttr(\"requiredQubits\", ss.str()); } if (config_.shouldAnnotateResultUse()) { std::stringstream ss{\"\"}; ss << profile_->getResultAllocationManager()->maxAllocationsUsed(); function.addFnAttr(\"requiredResults\", ss.str()); } } } processReplacements(); } llvm::PreservedAnalyses TransformationRulesPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& mam) { // In case the module is istructed to clone functions, if (config_.shouldCloneFunctions()) { setupCopyAndExpand(); runCopyAndExpand(module, mam); } // Deleting dead code if configured to do so. This process consists // of three steps: detecting dead code, removing phi nodes (and references) // and finally deleting the code. This implementation is aggressive in the sense // that any code that we cannot prove to be active is considered dead. if (config_.shouldDeleteDeadCode()) { runDetectActiveCode(module, mam); runReplacePhi(module, mam); runDeleteDeadCode(module, mam); } // Applying rule set if (config_.shouldTransformExecutionPathOnly()) { // We only apply transformation rules to code which is reachable // via the execution path. runApplyRules(module, mam); } else { // Otherwize we apply to all sections of the code. replacements_.clear(); for (auto& function : module) { for (auto& block : function) { for (auto& instr : block) { rule_set_.matchAndReplace(&instr, replacements_); } } } processReplacements(); } return llvm::PreservedAnalyses::none(); } llvm::Function* TransformationRulesPass::expandFunctionCall( llvm::Function& callee, ConstantArguments const& const_args) { auto module = callee.getParent(); auto& context = module->getContext(); llvm::IRBuilder<> builder(context); // Copying the original function llvm::ValueToValueMapTy remapper; std::vector<llvm::Type*> arg_types; // The user might be deleting arguments to the function by specifying them in // the VMap. If so, we need to not add the arguments to the arg ty vector // for (auto const& arg : callee.args()) { // Skipping constant arguments if (const_args.find(arg.getName().str()) != const_args.end()) { continue; } arg_types.push_back(arg.getType()); } // Creating a new function llvm::FunctionType* function_type = llvm::FunctionType::get( callee.getFunctionType()->getReturnType(), arg_types, callee.getFunctionType()->isVarArg()); auto function = llvm::Function::Create( function_type, callee.getLinkage(), callee.getAddressSpace(), callee.getName(), module); // Copying the non-const arguments auto dest_args_it = function->arg_begin(); for (auto const& arg : callee.args()) { auto const_it = const_args.find(arg.getName().str()); if (const_it == const_args.end()) { // Mapping remaining function arguments dest_args_it->setName(arg.getName()); remapper[&arg] = &*dest_args_it++; } else { remapper[&arg] = llvm::ConstantInt::get(context, const_it->second->getValue()); } } llvm::SmallVector<llvm::ReturnInst*, 8> returns; // Ignore returns cloned. // Note: In LLVM 13 upgrade 'true' to 'llvm::CloneFunctionChangeType::LocalChangesOnly' llvm::CloneFunctionInto(function, &callee, remapper, true, returns, \"\", nullptr); verifyFunction(*function); return function; } void TransformationRulesPass::setLogger(ILoggerPtr logger) { logger_ = std::move(logger); } bool TransformationRulesPass::isRequired() { return true; } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_transformation_rules_pass_8hpp/","text":"TransformationRulesPass/TransformationRulesPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::TransformationRulesPass Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/ILogger.hpp\" #include \"Profile/Profile.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Rules/RuleSet.hpp\" #include \"TransformationRulesPass/TransformationRulesPassConfiguration.hpp\" #include \"Llvm/Llvm.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class TransformationRulesPass : public llvm::PassInfoMixin<TransformationRulesPass> { public: using Replacements = ReplacementRule::Replacements; using Instruction = llvm::Instruction; using Rules = std::vector<ReplacementRule>; using Value = llvm::Value; using Builder = ReplacementRule::Builder; using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; using Captures = RuleSet::Captures; using ConstantArguments = std::unordered_map<std::string, llvm::ConstantInt*>; using ILoggerPtr = std::shared_ptr<ILogger>; // Construction and destruction configuration. // TransformationRulesPass( RuleSet&& rule_set, TransformationRulesPassConfiguration const& config, Profile* profile); TransformationRulesPass(TransformationRulesPass const&) = delete; TransformationRulesPass(TransformationRulesPass&&) = default; ~TransformationRulesPass() = default; // Operators // TransformationRulesPass& operator=(TransformationRulesPass const&) = delete; TransformationRulesPass& operator=(TransformationRulesPass&&) = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); using DeletableInstructions = std::vector<llvm::Instruction*>; using InstructionModifier = std::function<llvm::Value*(llvm::Value*, DeletableInstructions&)>; // Generic helper functions // bool runOnFunction(llvm::Function& function, InstructionModifier const& modifier); void processReplacements(); // Copy and expand // void setupCopyAndExpand(); void runCopyAndExpand(llvm::Module& module, llvm::ModuleAnalysisManager& mam); llvm::Value* copyAndExpand(llvm::Value* input, DeletableInstructions&); llvm::Function* expandFunctionCall(llvm::Function& callee, ConstantArguments const& const_args = {}); void constantFoldFunction(llvm::Function& callee); void addConstExprRule(ReplacementRule&& rule); // Dead code detection // void runDetectActiveCode(llvm::Module& module, llvm::ModuleAnalysisManager& mam); void runDeleteDeadCode(llvm::Module& module, llvm::ModuleAnalysisManager& mam); llvm::Value* detectActiveCode(llvm::Value* input, DeletableInstructions&); llvm::Value* deleteDeadCode(llvm::Value* input, DeletableInstructions&); bool isActive(llvm::Value* value) const; void followUsers(llvm::Value* value); // Phi replacement // void runReplacePhi(llvm::Module& module, llvm::ModuleAnalysisManager& mam); // Rules // void runApplyRules(llvm::Module& module, llvm::ModuleAnalysisManager& mam); bool onQubitRelease(llvm::Instruction* instruction, Captures& captures); bool onQubitAllocate(llvm::Instruction* instruction, Captures& captures); static bool isRequired(); // Logger // void setLogger(ILoggerPtr logger); private: // Pass configuration // RuleSet rule_set_{}; TransformationRulesPassConfiguration config_{}; // Logging and data collection // ILoggerPtr logger_{nullptr}; // Execution path unrolling // uint64_t depth_{0}; // Copy and expand // RuleSet const_expr_replacements_{}; // Dead code elimination // std::unordered_set<Value*> active_pieces_{}; std::vector<llvm::BasicBlock*> blocks_to_delete_{}; std::vector<llvm::Function*> functions_to_delete_{}; // Phi detection // Replacements replacements_; // Profile // Profile* profile_{nullptr}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"TransformationRulesPass/TransformationRulesPass.hpp"},{"location":"Api/Files/_transformation_rules_pass_8hpp/#transformationrulespasstransformationrulespasshpp","text":"","title":"TransformationRulesPass/TransformationRulesPass.hpp"},{"location":"Api/Files/_transformation_rules_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_transformation_rules_pass_8hpp/#classes","text":"Name class microsoft::quantum::TransformationRulesPass","title":"Classes"},{"location":"Api/Files/_transformation_rules_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/ILogger.hpp\" #include \"Profile/Profile.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Rules/RuleSet.hpp\" #include \"TransformationRulesPass/TransformationRulesPassConfiguration.hpp\" #include \"Llvm/Llvm.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class TransformationRulesPass : public llvm::PassInfoMixin<TransformationRulesPass> { public: using Replacements = ReplacementRule::Replacements; using Instruction = llvm::Instruction; using Rules = std::vector<ReplacementRule>; using Value = llvm::Value; using Builder = ReplacementRule::Builder; using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; using Captures = RuleSet::Captures; using ConstantArguments = std::unordered_map<std::string, llvm::ConstantInt*>; using ILoggerPtr = std::shared_ptr<ILogger>; // Construction and destruction configuration. // TransformationRulesPass( RuleSet&& rule_set, TransformationRulesPassConfiguration const& config, Profile* profile); TransformationRulesPass(TransformationRulesPass const&) = delete; TransformationRulesPass(TransformationRulesPass&&) = default; ~TransformationRulesPass() = default; // Operators // TransformationRulesPass& operator=(TransformationRulesPass const&) = delete; TransformationRulesPass& operator=(TransformationRulesPass&&) = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); using DeletableInstructions = std::vector<llvm::Instruction*>; using InstructionModifier = std::function<llvm::Value*(llvm::Value*, DeletableInstructions&)>; // Generic helper functions // bool runOnFunction(llvm::Function& function, InstructionModifier const& modifier); void processReplacements(); // Copy and expand // void setupCopyAndExpand(); void runCopyAndExpand(llvm::Module& module, llvm::ModuleAnalysisManager& mam); llvm::Value* copyAndExpand(llvm::Value* input, DeletableInstructions&); llvm::Function* expandFunctionCall(llvm::Function& callee, ConstantArguments const& const_args = {}); void constantFoldFunction(llvm::Function& callee); void addConstExprRule(ReplacementRule&& rule); // Dead code detection // void runDetectActiveCode(llvm::Module& module, llvm::ModuleAnalysisManager& mam); void runDeleteDeadCode(llvm::Module& module, llvm::ModuleAnalysisManager& mam); llvm::Value* detectActiveCode(llvm::Value* input, DeletableInstructions&); llvm::Value* deleteDeadCode(llvm::Value* input, DeletableInstructions&); bool isActive(llvm::Value* value) const; void followUsers(llvm::Value* value); // Phi replacement // void runReplacePhi(llvm::Module& module, llvm::ModuleAnalysisManager& mam); // Rules // void runApplyRules(llvm::Module& module, llvm::ModuleAnalysisManager& mam); bool onQubitRelease(llvm::Instruction* instruction, Captures& captures); bool onQubitAllocate(llvm::Instruction* instruction, Captures& captures); static bool isRequired(); // Logger // void setLogger(ILoggerPtr logger); private: // Pass configuration // RuleSet rule_set_{}; TransformationRulesPassConfiguration config_{}; // Logging and data collection // ILoggerPtr logger_{nullptr}; // Execution path unrolling // uint64_t depth_{0}; // Copy and expand // RuleSet const_expr_replacements_{}; // Dead code elimination // std::unordered_set<Value*> active_pieces_{}; std::vector<llvm::BasicBlock*> blocks_to_delete_{}; std::vector<llvm::Function*> functions_to_delete_{}; // Phi detection // Replacements replacements_; // Profile // Profile* profile_{nullptr}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_transformation_rules_pass_configuration_8cpp/","text":"TransformationRulesPass/TransformationRulesPassConfiguration.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"TransformationRulesPass/TransformationRulesPassConfiguration.hpp\" namespace microsoft { namespace quantum { void TransformationRulesPassConfiguration::setup(ConfigurationManager& config) { config.setSectionName(\"Pass configuration\", \"Configuration of the pass and its corresponding optimizations.\"); // Experimental settings config.addExperimentalParameter(delete_dead_code_, true, false, \"delete-dead-code\", \"Deleted dead code.\"); config.addExperimentalParameter( clone_functions_, true, false, \"clone-functions\", \"Clone functions to ensure correct qubit allocation.\"); config.addExperimentalParameter( transform_execution_path_only_, true, false, \"transform-execution-path-only\", \"Transform execution paths only.\"); config.addExperimentalParameter( max_recursion_, max_recursion_, uint64_t(0), \"max-recursion\", \"Defines the maximum recursion when unrolling the execution path\"); config.addExperimentalParameter( assume_no_exceptions_, false, false, \"assume-no-except\", \"Assumes that no exception will occur during runtime.\"); config.addParameter(reuse_qubits_, false, \"reuse-qubits\", \"Use to define whether or not to reuse qubits.\"); config.addParameter(reuse_results_, false, \"reuse-results\", \"Use to define whether or not to reuse results.\"); // Ready settings config.addParameter( entry_point_attr_, \"entry-point-attr\", \"Specifies the attribute indicating the entry point.\"); config.addParameter(annotate_qubit_use_, \"annotate-qubit-use\", \"Annotate the number of qubits used\"); config.addParameter(annotate_result_use_, \"annotate-result-use\", \"Annotate the number of results used\"); } TransformationRulesPassConfiguration TransformationRulesPassConfiguration::createDisabled() { TransformationRulesPassConfiguration ret; ret.delete_dead_code_ = false; ret.clone_functions_ = false; ret.transform_execution_path_only_ = false; ret.max_recursion_ = 512; ret.reuse_qubits_ = false; ret.annotate_qubit_use_ = false; return ret; } TransformationRulesPassConfiguration TransformationRulesPassConfiguration::createReuseQubitsOnly() { TransformationRulesPassConfiguration ret; ret.delete_dead_code_ = false; ret.clone_functions_ = false; ret.transform_execution_path_only_ = false; ret.max_recursion_ = 512; ret.reuse_qubits_ = true; ret.annotate_qubit_use_ = false; return ret; } bool TransformationRulesPassConfiguration::shouldDeleteDeadCode() const { return delete_dead_code_; } bool TransformationRulesPassConfiguration::shouldCloneFunctions() const { return clone_functions_; } bool TransformationRulesPassConfiguration::shouldTransformExecutionPathOnly() const { return transform_execution_path_only_; } uint64_t TransformationRulesPassConfiguration::maxRecursion() const { return max_recursion_; } bool TransformationRulesPassConfiguration::shouldReuseQubits() const { return reuse_qubits_; } bool TransformationRulesPassConfiguration::shouldAnnotateQubitUse() const { return annotate_qubit_use_; } bool TransformationRulesPassConfiguration::shouldReuseResults() const { return reuse_results_; } bool TransformationRulesPassConfiguration::shouldAnnotateResultUse() const { return annotate_result_use_; } std::string TransformationRulesPassConfiguration::entryPointAttr() const { return entry_point_attr_; } bool TransformationRulesPassConfiguration::assumeNoExceptions() const { return assume_no_exceptions_; } bool TransformationRulesPassConfiguration::isDisabled() const { return ( delete_dead_code_ == false && clone_functions_ == false && transform_execution_path_only_ == false && reuse_qubits_ == false); } bool TransformationRulesPassConfiguration::operator==(TransformationRulesPassConfiguration const& ref) const { return ( delete_dead_code_ == ref.delete_dead_code_ && clone_functions_ == ref.clone_functions_ && transform_execution_path_only_ == ref.transform_execution_path_only_ && reuse_qubits_ == ref.reuse_qubits_); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"TransformationRulesPass/TransformationRulesPassConfiguration.cpp"},{"location":"Api/Files/_transformation_rules_pass_configuration_8cpp/#transformationrulespasstransformationrulespassconfigurationcpp","text":"","title":"TransformationRulesPass/TransformationRulesPassConfiguration.cpp"},{"location":"Api/Files/_transformation_rules_pass_configuration_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_transformation_rules_pass_configuration_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"TransformationRulesPass/TransformationRulesPassConfiguration.hpp\" namespace microsoft { namespace quantum { void TransformationRulesPassConfiguration::setup(ConfigurationManager& config) { config.setSectionName(\"Pass configuration\", \"Configuration of the pass and its corresponding optimizations.\"); // Experimental settings config.addExperimentalParameter(delete_dead_code_, true, false, \"delete-dead-code\", \"Deleted dead code.\"); config.addExperimentalParameter( clone_functions_, true, false, \"clone-functions\", \"Clone functions to ensure correct qubit allocation.\"); config.addExperimentalParameter( transform_execution_path_only_, true, false, \"transform-execution-path-only\", \"Transform execution paths only.\"); config.addExperimentalParameter( max_recursion_, max_recursion_, uint64_t(0), \"max-recursion\", \"Defines the maximum recursion when unrolling the execution path\"); config.addExperimentalParameter( assume_no_exceptions_, false, false, \"assume-no-except\", \"Assumes that no exception will occur during runtime.\"); config.addParameter(reuse_qubits_, false, \"reuse-qubits\", \"Use to define whether or not to reuse qubits.\"); config.addParameter(reuse_results_, false, \"reuse-results\", \"Use to define whether or not to reuse results.\"); // Ready settings config.addParameter( entry_point_attr_, \"entry-point-attr\", \"Specifies the attribute indicating the entry point.\"); config.addParameter(annotate_qubit_use_, \"annotate-qubit-use\", \"Annotate the number of qubits used\"); config.addParameter(annotate_result_use_, \"annotate-result-use\", \"Annotate the number of results used\"); } TransformationRulesPassConfiguration TransformationRulesPassConfiguration::createDisabled() { TransformationRulesPassConfiguration ret; ret.delete_dead_code_ = false; ret.clone_functions_ = false; ret.transform_execution_path_only_ = false; ret.max_recursion_ = 512; ret.reuse_qubits_ = false; ret.annotate_qubit_use_ = false; return ret; } TransformationRulesPassConfiguration TransformationRulesPassConfiguration::createReuseQubitsOnly() { TransformationRulesPassConfiguration ret; ret.delete_dead_code_ = false; ret.clone_functions_ = false; ret.transform_execution_path_only_ = false; ret.max_recursion_ = 512; ret.reuse_qubits_ = true; ret.annotate_qubit_use_ = false; return ret; } bool TransformationRulesPassConfiguration::shouldDeleteDeadCode() const { return delete_dead_code_; } bool TransformationRulesPassConfiguration::shouldCloneFunctions() const { return clone_functions_; } bool TransformationRulesPassConfiguration::shouldTransformExecutionPathOnly() const { return transform_execution_path_only_; } uint64_t TransformationRulesPassConfiguration::maxRecursion() const { return max_recursion_; } bool TransformationRulesPassConfiguration::shouldReuseQubits() const { return reuse_qubits_; } bool TransformationRulesPassConfiguration::shouldAnnotateQubitUse() const { return annotate_qubit_use_; } bool TransformationRulesPassConfiguration::shouldReuseResults() const { return reuse_results_; } bool TransformationRulesPassConfiguration::shouldAnnotateResultUse() const { return annotate_result_use_; } std::string TransformationRulesPassConfiguration::entryPointAttr() const { return entry_point_attr_; } bool TransformationRulesPassConfiguration::assumeNoExceptions() const { return assume_no_exceptions_; } bool TransformationRulesPassConfiguration::isDisabled() const { return ( delete_dead_code_ == false && clone_functions_ == false && transform_execution_path_only_ == false && reuse_qubits_ == false); } bool TransformationRulesPassConfiguration::operator==(TransformationRulesPassConfiguration const& ref) const { return ( delete_dead_code_ == ref.delete_dead_code_ && clone_functions_ == ref.clone_functions_ && transform_execution_path_only_ == ref.transform_execution_path_only_ && reuse_qubits_ == ref.reuse_qubits_); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_transformation_rules_pass_configuration_8hpp/","text":"TransformationRulesPass/TransformationRulesPassConfiguration.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::TransformationRulesPassConfiguration Configuration class for the RuleTransformation pass. Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" namespace microsoft { namespace quantum { class TransformationRulesPassConfiguration { public: // Setup and construction // void setup(ConfigurationManager& config); static TransformationRulesPassConfiguration createDisabled(); static TransformationRulesPassConfiguration createReuseQubitsOnly(); // Configuration classes // bool isDisabled() const; bool operator==(TransformationRulesPassConfiguration const& ref) const; // Properties // bool shouldDeleteDeadCode() const; bool shouldCloneFunctions() const; bool assumeNoExceptions() const; bool shouldTransformExecutionPathOnly() const; uint64_t maxRecursion() const; bool shouldReuseQubits() const; bool shouldAnnotateQubitUse() const; bool shouldReuseResults() const; bool shouldAnnotateResultUse() const; bool shouldGroupMeasurements() const; bool oneShotMeasurement() const; std::string entryPointAttr() const; private: // Code expansion and trimming // bool delete_dead_code_{true}; bool clone_functions_{true}; bool transform_execution_path_only_{true}; uint64_t max_recursion_{512}; std::string entry_point_attr_{\"InteropFriendly\"}; // Branching bool assume_no_exceptions_{false}; // Allocation options // bool reuse_qubits_{true}; bool annotate_qubit_use_{true}; bool reuse_results_{true}; bool annotate_result_use_{true}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"TransformationRulesPass/TransformationRulesPassConfiguration.hpp"},{"location":"Api/Files/_transformation_rules_pass_configuration_8hpp/#transformationrulespasstransformationrulespassconfigurationhpp","text":"","title":"TransformationRulesPass/TransformationRulesPassConfiguration.hpp"},{"location":"Api/Files/_transformation_rules_pass_configuration_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_transformation_rules_pass_configuration_8hpp/#classes","text":"Name class microsoft::quantum::TransformationRulesPassConfiguration Configuration class for the RuleTransformation pass.","title":"Classes"},{"location":"Api/Files/_transformation_rules_pass_configuration_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" namespace microsoft { namespace quantum { class TransformationRulesPassConfiguration { public: // Setup and construction // void setup(ConfigurationManager& config); static TransformationRulesPassConfiguration createDisabled(); static TransformationRulesPassConfiguration createReuseQubitsOnly(); // Configuration classes // bool isDisabled() const; bool operator==(TransformationRulesPassConfiguration const& ref) const; // Properties // bool shouldDeleteDeadCode() const; bool shouldCloneFunctions() const; bool assumeNoExceptions() const; bool shouldTransformExecutionPathOnly() const; uint64_t maxRecursion() const; bool shouldReuseQubits() const; bool shouldAnnotateQubitUse() const; bool shouldReuseResults() const; bool shouldAnnotateResultUse() const; bool shouldGroupMeasurements() const; bool oneShotMeasurement() const; std::string entryPointAttr() const; private: // Code expansion and trimming // bool delete_dead_code_{true}; bool clone_functions_{true}; bool transform_execution_path_only_{true}; uint64_t max_recursion_{512}; std::string entry_point_attr_{\"InteropFriendly\"}; // Branching bool assume_no_exceptions_{false}; // Allocation options // bool reuse_qubits_{true}; bool annotate_qubit_use_{true}; bool reuse_results_{true}; bool annotate_result_use_{true}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_trim_8hpp/","text":"Utils/Trim.hpp Namespaces Name microsoft microsoft::quantum Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include <algorithm> #include <string> namespace microsoft { namespace quantum { inline void ltrim(std::string& str) { str.erase(str.begin(), std::find_if(str.begin(), str.end(), [](uint8_t ch) { return !std::isspace(ch); })); } inline void rtrim(std::string& str) { str.erase( std::find_if(str.rbegin(), str.rend(), [](uint8_t ch) { return !std::isspace(ch); }).base(), str.end()); } inline void trim(std::string& s) { ltrim(s); rtrim(s); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Utils/Trim.hpp"},{"location":"Api/Files/_trim_8hpp/#utilstrimhpp","text":"","title":"Utils/Trim.hpp"},{"location":"Api/Files/_trim_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_trim_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include <algorithm> #include <string> namespace microsoft { namespace quantum { inline void ltrim(std::string& str) { str.erase(str.begin(), std::find_if(str.begin(), str.end(), [](uint8_t ch) { return !std::isspace(ch); })); } inline void rtrim(std::string& str) { str.erase( std::find_if(str.rbegin(), str.rend(), [](uint8_t ch) { return !std::isspace(ch); }).base(), str.end()); } inline void trim(std::string& s) { ltrim(s); rtrim(s); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_unnamed_invoke_8cpp/","text":"Rules/Notation/UnnamedInvoke.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/UnnamedInvokePattern.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr unnamedInvoke() { auto ret = std::make_shared<UnnamedInvokePattern>(); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Notation/UnnamedInvoke.cpp"},{"location":"Api/Files/_unnamed_invoke_8cpp/#rulesnotationunnamedinvokecpp","text":"","title":"Rules/Notation/UnnamedInvoke.cpp"},{"location":"Api/Files/_unnamed_invoke_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_unnamed_invoke_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/UnnamedInvokePattern.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr unnamedInvoke() { auto ret = std::make_shared<UnnamedInvokePattern>(); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_unnamed_invoke_pattern_8cpp/","text":"Rules/Patterns/UnnamedInvokePattern.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/Patterns/UnnamedInvokePattern.hpp\" namespace microsoft { namespace quantum { UnnamedInvokePattern::~UnnamedInvokePattern() = default; bool UnnamedInvokePattern::match(Value* instr, Captures& captures) const { auto* call_instr = llvm::dyn_cast<llvm::InvokeInst>(instr); if (call_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } UnnamedInvokePattern::Child UnnamedInvokePattern::copy() const { auto ret = std::make_shared<UnnamedInvokePattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Patterns/UnnamedInvokePattern.cpp"},{"location":"Api/Files/_unnamed_invoke_pattern_8cpp/#rulespatternsunnamedinvokepatterncpp","text":"","title":"Rules/Patterns/UnnamedInvokePattern.cpp"},{"location":"Api/Files/_unnamed_invoke_pattern_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_unnamed_invoke_pattern_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/Patterns/UnnamedInvokePattern.hpp\" namespace microsoft { namespace quantum { UnnamedInvokePattern::~UnnamedInvokePattern() = default; bool UnnamedInvokePattern::match(Value* instr, Captures& captures) const { auto* call_instr = llvm::dyn_cast<llvm::InvokeInst>(instr); if (call_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } UnnamedInvokePattern::Child UnnamedInvokePattern::copy() const { auto ret = std::make_shared<UnnamedInvokePattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_unnamed_invoke_pattern_8hpp/","text":"Rules/Patterns/UnnamedInvokePattern.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::UnnamedInvokePattern Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class UnnamedInvokePattern : public IOperandPrototype { public: using String = std::string; // Construction // UnnamedInvokePattern() = default; UnnamedInvokePattern(UnnamedInvokePattern const& other) = delete; UnnamedInvokePattern(UnnamedInvokePattern&& other) = default; ~UnnamedInvokePattern() override; // Call implementation of the member functions in IOperandPrototype. // bool match(Value* instr, Captures& captures) const override; Child copy() const override; private: }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Patterns/UnnamedInvokePattern.hpp"},{"location":"Api/Files/_unnamed_invoke_pattern_8hpp/#rulespatternsunnamedinvokepatternhpp","text":"","title":"Rules/Patterns/UnnamedInvokePattern.hpp"},{"location":"Api/Files/_unnamed_invoke_pattern_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_unnamed_invoke_pattern_8hpp/#classes","text":"Name class microsoft::quantum::UnnamedInvokePattern","title":"Classes"},{"location":"Api/Files/_unnamed_invoke_pattern_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class UnnamedInvokePattern : public IOperandPrototype { public: using String = std::string; // Construction // UnnamedInvokePattern() = default; UnnamedInvokePattern(UnnamedInvokePattern const& other) = delete; UnnamedInvokePattern(UnnamedInvokePattern&& other) = default; ~UnnamedInvokePattern() override; // Call implementation of the member functions in IOperandPrototype. // bool match(Value* instr, Captures& captures) const override; Child copy() const override; private: }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_validation_pass_8cpp/","text":"ValidationPass/ValidationPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"ValidationPass/ValidationPass.hpp\" #include \"Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft { namespace quantum { void ValidationPass::opcodeChecks(Instruction& instr) { auto opname = instr.getOpcodeName(); opcode_location_[opname].push_back(current_location_); if (opcodes_.find(opname) != opcodes_.end()) { ++opcodes_[opname]; } else { opcodes_[opname] = 1; } } void ValidationPass::callChecks(Instruction& instr) { auto call_instr = llvm::dyn_cast<llvm::CallBase>(&instr); if (call_instr != nullptr) { auto f = call_instr->getCalledFunction(); if (f == nullptr) { return; } auto name = static_cast<std::string>(f->getName()); if (f->isDeclaration()) { if (external_calls_.find(name) != external_calls_.end()) { ++external_calls_[name]; } else { external_calls_[name] = 1; } external_call_location_[name].push_back(current_location_); } else { if (internal_calls_.find(name) != internal_calls_.end()) { ++internal_calls_[name]; } else { internal_calls_[name] = 1; } internal_call_location_[name].push_back(current_location_); } } } void ValidationPass::pointerChecks(Instruction& instr) { for (auto& op : instr.operands()) { // Skipping function pointers auto function_pointer = llvm::dyn_cast<llvm::Function>(op); if (function_pointer) { continue; } // Skipping non-pointer types auto pointer_type = llvm::dyn_cast<llvm::PointerType>(op->getType()); if (!pointer_type) { continue; } uint64_t n = 1; llvm::Type* element_type = pointer_type->getElementType(); while (pointer_type = llvm::dyn_cast<llvm::PointerType>(element_type)) { element_type = pointer_type->getElementType(); ++n; } String name{}; if (element_type->isStructTy()) { name = static_cast<String>(element_type->getStructName()); } else { llvm::raw_string_ostream rso(name); element_type->print(rso); } // Adding indirection to the name while (n != 0) { name += \"*\"; --n; } auto it = pointers_.find(name); if (it == pointers_.end()) { pointers_[name] = 1; } else { ++it->second; } pointer_location_[name].push_back(current_location_); } } bool ValidationPass::satisfyingOpcodeRequirements() { auto ret = true; if (config_.allowlistOpcodes()) { auto const& allowed_ops = config_.allowedOpcodes(); for (auto const& k : opcodes_) { if (allowed_ops.find(k.first) == allowed_ops.end()) { logger_->setLlvmHint(\"\"); // Adding debug location if (opcode_location_.find(k.first) != opcode_location_.end()) { auto const& locs = opcode_location_[k.first]; if (!locs.empty()) { auto const& loc = locs.front(); logger_->setLocation(loc.filename, loc.row, loc.col); logger_->setLlvmHint(loc.llvm_hint); } } // Emitting error logger_->error( \"Opcode '\" + k.first + \"' is not allowed for this profile (\" + config_.profileName() + \").\"); ret = false; } } } return ret; } bool ValidationPass::satisfyingInternalCallRequirements() { if (!config_.allowInternalCalls() && !internal_calls_.empty()) { logger_->setLlvmHint(\"\"); // TODO(issue-60): Add location // Emitting error logger_->error(\"Calls to custom defined functions not allowed.\"); return false; } return true; } bool ValidationPass::satisfyingExternalCallRequirements() { auto ret = true; if (config_.allowlistExternalCalls()) { auto const& allowed_functions = config_.allowedExternalCallNames(); for (auto const& k : external_calls_) { if (allowed_functions.find(k.first) == allowed_functions.end()) { logger_->setLlvmHint(\"\"); // Adding debug location if (external_call_location_.find(k.first) != external_call_location_.end()) { auto const& locs = external_call_location_[k.first]; if (!locs.empty()) { auto const& loc = locs.front(); logger_->setLocation(loc.filename, loc.row, loc.col); logger_->setLlvmHint(loc.llvm_hint); } } // Emitting error logger_->error( \"External call '\" + k.first + \"' is not allowed for this profile (\" + config_.profileName() + \").\"); ret = false; } } } return ret; } bool ValidationPass::satisfyingPointerRequirements() { auto ret = true; if (config_.allowlistPointerTypes()) { auto const& allowed = config_.allowedPointerTypes(); for (auto const& k : pointers_) { if (allowed.find(k.first) == allowed.end()) { logger_->setLlvmHint(\"\"); // Adding debug location if (pointer_location_.find(k.first) != pointer_location_.end()) { auto const& locs = pointer_location_[k.first]; if (!locs.empty()) { auto const& loc = locs.front(); logger_->setLocation(loc.filename, loc.row, loc.col); logger_->setLlvmHint(loc.llvm_hint); } } // Emitting error logger_->error( \"Type '\" + k.first + \"' is not allowed for this profile (\" + config_.profileName() + \").\"); ret = false; } } } return ret; } llvm::PreservedAnalyses ValidationPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { for (auto& function : module) { for (auto& block : function) { for (auto& instr : block) { current_location_ = Location{}; llvm::DebugLoc dl = instr.getDebugLoc(); if (dl) { current_location_ = Location{static_cast<String>(dl->getFilename()), dl->getLine(), dl->getColumn(), \"\"}; } llvm::raw_string_ostream rso(current_location_.llvm_hint); instr.print(rso); opcodeChecks(instr); callChecks(instr); pointerChecks(instr); } } } bool raise_exception = false; raise_exception |= !satisfyingOpcodeRequirements(); raise_exception |= !satisfyingExternalCallRequirements(); raise_exception |= !satisfyingInternalCallRequirements(); raise_exception |= !satisfyingPointerRequirements(); if (raise_exception) { throw std::runtime_error(\"QIR is not valid within the defined profile\"); } return llvm::PreservedAnalyses::all(); } bool ValidationPass::isRequired() { return true; } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"ValidationPass/ValidationPass.cpp"},{"location":"Api/Files/_validation_pass_8cpp/#validationpassvalidationpasscpp","text":"","title":"ValidationPass/ValidationPass.cpp"},{"location":"Api/Files/_validation_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_validation_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"ValidationPass/ValidationPass.hpp\" #include \"Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft { namespace quantum { void ValidationPass::opcodeChecks(Instruction& instr) { auto opname = instr.getOpcodeName(); opcode_location_[opname].push_back(current_location_); if (opcodes_.find(opname) != opcodes_.end()) { ++opcodes_[opname]; } else { opcodes_[opname] = 1; } } void ValidationPass::callChecks(Instruction& instr) { auto call_instr = llvm::dyn_cast<llvm::CallBase>(&instr); if (call_instr != nullptr) { auto f = call_instr->getCalledFunction(); if (f == nullptr) { return; } auto name = static_cast<std::string>(f->getName()); if (f->isDeclaration()) { if (external_calls_.find(name) != external_calls_.end()) { ++external_calls_[name]; } else { external_calls_[name] = 1; } external_call_location_[name].push_back(current_location_); } else { if (internal_calls_.find(name) != internal_calls_.end()) { ++internal_calls_[name]; } else { internal_calls_[name] = 1; } internal_call_location_[name].push_back(current_location_); } } } void ValidationPass::pointerChecks(Instruction& instr) { for (auto& op : instr.operands()) { // Skipping function pointers auto function_pointer = llvm::dyn_cast<llvm::Function>(op); if (function_pointer) { continue; } // Skipping non-pointer types auto pointer_type = llvm::dyn_cast<llvm::PointerType>(op->getType()); if (!pointer_type) { continue; } uint64_t n = 1; llvm::Type* element_type = pointer_type->getElementType(); while (pointer_type = llvm::dyn_cast<llvm::PointerType>(element_type)) { element_type = pointer_type->getElementType(); ++n; } String name{}; if (element_type->isStructTy()) { name = static_cast<String>(element_type->getStructName()); } else { llvm::raw_string_ostream rso(name); element_type->print(rso); } // Adding indirection to the name while (n != 0) { name += \"*\"; --n; } auto it = pointers_.find(name); if (it == pointers_.end()) { pointers_[name] = 1; } else { ++it->second; } pointer_location_[name].push_back(current_location_); } } bool ValidationPass::satisfyingOpcodeRequirements() { auto ret = true; if (config_.allowlistOpcodes()) { auto const& allowed_ops = config_.allowedOpcodes(); for (auto const& k : opcodes_) { if (allowed_ops.find(k.first) == allowed_ops.end()) { logger_->setLlvmHint(\"\"); // Adding debug location if (opcode_location_.find(k.first) != opcode_location_.end()) { auto const& locs = opcode_location_[k.first]; if (!locs.empty()) { auto const& loc = locs.front(); logger_->setLocation(loc.filename, loc.row, loc.col); logger_->setLlvmHint(loc.llvm_hint); } } // Emitting error logger_->error( \"Opcode '\" + k.first + \"' is not allowed for this profile (\" + config_.profileName() + \").\"); ret = false; } } } return ret; } bool ValidationPass::satisfyingInternalCallRequirements() { if (!config_.allowInternalCalls() && !internal_calls_.empty()) { logger_->setLlvmHint(\"\"); // TODO(issue-60): Add location // Emitting error logger_->error(\"Calls to custom defined functions not allowed.\"); return false; } return true; } bool ValidationPass::satisfyingExternalCallRequirements() { auto ret = true; if (config_.allowlistExternalCalls()) { auto const& allowed_functions = config_.allowedExternalCallNames(); for (auto const& k : external_calls_) { if (allowed_functions.find(k.first) == allowed_functions.end()) { logger_->setLlvmHint(\"\"); // Adding debug location if (external_call_location_.find(k.first) != external_call_location_.end()) { auto const& locs = external_call_location_[k.first]; if (!locs.empty()) { auto const& loc = locs.front(); logger_->setLocation(loc.filename, loc.row, loc.col); logger_->setLlvmHint(loc.llvm_hint); } } // Emitting error logger_->error( \"External call '\" + k.first + \"' is not allowed for this profile (\" + config_.profileName() + \").\"); ret = false; } } } return ret; } bool ValidationPass::satisfyingPointerRequirements() { auto ret = true; if (config_.allowlistPointerTypes()) { auto const& allowed = config_.allowedPointerTypes(); for (auto const& k : pointers_) { if (allowed.find(k.first) == allowed.end()) { logger_->setLlvmHint(\"\"); // Adding debug location if (pointer_location_.find(k.first) != pointer_location_.end()) { auto const& locs = pointer_location_[k.first]; if (!locs.empty()) { auto const& loc = locs.front(); logger_->setLocation(loc.filename, loc.row, loc.col); logger_->setLlvmHint(loc.llvm_hint); } } // Emitting error logger_->error( \"Type '\" + k.first + \"' is not allowed for this profile (\" + config_.profileName() + \").\"); ret = false; } } } return ret; } llvm::PreservedAnalyses ValidationPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { for (auto& function : module) { for (auto& block : function) { for (auto& instr : block) { current_location_ = Location{}; llvm::DebugLoc dl = instr.getDebugLoc(); if (dl) { current_location_ = Location{static_cast<String>(dl->getFilename()), dl->getLine(), dl->getColumn(), \"\"}; } llvm::raw_string_ostream rso(current_location_.llvm_hint); instr.print(rso); opcodeChecks(instr); callChecks(instr); pointerChecks(instr); } } } bool raise_exception = false; raise_exception |= !satisfyingOpcodeRequirements(); raise_exception |= !satisfyingExternalCallRequirements(); raise_exception |= !satisfyingInternalCallRequirements(); raise_exception |= !satisfyingPointerRequirements(); if (raise_exception) { throw std::runtime_error(\"QIR is not valid within the defined profile\"); } return llvm::PreservedAnalyses::all(); } bool ValidationPass::isRequired() { return true; } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_validation_pass_8hpp/","text":"ValidationPass/ValidationPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ValidationPass Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/ILogger.hpp\" #include \"Profile/Profile.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"ValidationPass/ValidationPassConfiguration.hpp\" #include \"Llvm/Llvm.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class ValidationPass : public llvm::PassInfoMixin<ValidationPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = std::shared_ptr<ILogger>; // Construction and destruction configuration. // explicit ValidationPass(ValidationPassConfiguration const& cfg, ILoggerPtr const& logger = nullptr) : config_{cfg} , logger_{logger} { } ValidationPass(ValidationPass const&) = delete; ValidationPass(ValidationPass&&) = default; ~ValidationPass() = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired(); private: void opcodeChecks(Instruction& instr); void callChecks(Instruction& instr); void pointerChecks(Instruction& instr); bool satisfyingOpcodeRequirements(); bool satisfyingInternalCallRequirements(); bool satisfyingExternalCallRequirements(); bool satisfyingPointerRequirements(); struct Location { String filename{\"\"}; uint64_t row{0}; uint64_t col{0}; String llvm_hint{\"\"}; }; using Locations = std::vector<Location>; ValidationPassConfiguration config_{}; Location current_location_{}; std::unordered_map<std::string, uint64_t> opcodes_; std::unordered_map<std::string, Locations> opcode_location_; std::unordered_map<std::string, uint64_t> external_calls_; std::unordered_map<std::string, Locations> external_call_location_; std::unordered_map<std::string, uint64_t> internal_calls_; std::unordered_map<std::string, Locations> internal_call_location_; std::unordered_map<std::string, uint64_t> pointers_; std::unordered_map<std::string, Locations> pointer_location_; ILoggerPtr logger_{nullptr}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"ValidationPass/ValidationPass.hpp"},{"location":"Api/Files/_validation_pass_8hpp/#validationpassvalidationpasshpp","text":"","title":"ValidationPass/ValidationPass.hpp"},{"location":"Api/Files/_validation_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_validation_pass_8hpp/#classes","text":"Name class microsoft::quantum::ValidationPass","title":"Classes"},{"location":"Api/Files/_validation_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/ILogger.hpp\" #include \"Profile/Profile.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"ValidationPass/ValidationPassConfiguration.hpp\" #include \"Llvm/Llvm.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class ValidationPass : public llvm::PassInfoMixin<ValidationPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = std::shared_ptr<ILogger>; // Construction and destruction configuration. // explicit ValidationPass(ValidationPassConfiguration const& cfg, ILoggerPtr const& logger = nullptr) : config_{cfg} , logger_{logger} { } ValidationPass(ValidationPass const&) = delete; ValidationPass(ValidationPass&&) = default; ~ValidationPass() = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired(); private: void opcodeChecks(Instruction& instr); void callChecks(Instruction& instr); void pointerChecks(Instruction& instr); bool satisfyingOpcodeRequirements(); bool satisfyingInternalCallRequirements(); bool satisfyingExternalCallRequirements(); bool satisfyingPointerRequirements(); struct Location { String filename{\"\"}; uint64_t row{0}; uint64_t col{0}; String llvm_hint{\"\"}; }; using Locations = std::vector<Location>; ValidationPassConfiguration config_{}; Location current_location_{}; std::unordered_map<std::string, uint64_t> opcodes_; std::unordered_map<std::string, Locations> opcode_location_; std::unordered_map<std::string, uint64_t> external_calls_; std::unordered_map<std::string, Locations> external_call_location_; std::unordered_map<std::string, uint64_t> internal_calls_; std::unordered_map<std::string, Locations> internal_call_location_; std::unordered_map<std::string, uint64_t> pointers_; std::unordered_map<std::string, Locations> pointer_location_; ILoggerPtr logger_{nullptr}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_validation_pass_configuration_8cpp/","text":"ValidationPass/ValidationPassConfiguration.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"ValidationPass/ValidationPassConfiguration.hpp\" namespace microsoft { namespace quantum { void ValidationPassConfiguration::setup(ConfigurationManager& config) { config.setSectionName(\"Validation configuration\", \"\"); config.addParameter( allow_internal_calls_, \"allow-internal-calls\", \"Whether or not internal calls are allowed.\"); config.addParameter( save_report_to_, \"save-validation-report\", \"Saves the validation report to specified filename.\"); } String ValidationPassConfiguration::profileName() const { return profile_name_; } ValidationPassConfiguration ValidationPassConfiguration::fromProfileName(String const& name) { auto profile = ValidationPassConfiguration(); if (name == \"generic\") { profile.opcodes_ = Set{}; profile.external_calls_ = Set{}; profile.allowed_pointer_types_ = Set{}; profile.allowlist_opcodes_ = true; profile.allowlist_external_calls_ = false; profile.allow_internal_calls_ = true; profile.allowlist_pointer_types_ = false; profile.allow_primitive_return_ = true; profile.allow_struct_return_ = true; profile.allow_pointer_return_ = true; } else if (name == \"base\") { profile.allow_internal_calls_ = false; profile.allowlist_external_calls_ = true; profile.allowlist_opcodes_ = true; profile.opcodes_ = Set{\"br\", \"call\", \"unreachable\", \"ret\", \"inttoptr\"}; // \"phi\", \"select\", profile.external_calls_ = Set{ \"__quantum__qis__cnot__body\", \"__quantum__qis__cz__body\", \"__quantum__qis__cx__body\", \"__quantum__qis__cy__body\", \"__quantum__qis__h__body\", \"__quantum__qis__s__body\", \"__quantum__qis__s__adj\", \"__quantum__qis__t__body\", \"__quantum__qis__t__adj\", \"__quantum__qis__x__body\", \"__quantum__qis__y__body\", \"__quantum__qis__z__body\", \"__quantum__qis__rx__body\", \"__quantum__qis__ry__body\", \"__quantum__qis__rz__body\", \"__quantum__qis__reset__body\", \"__quantum__qis__mz__body\", \"__quantum__qis__read_result__body\", }; profile.allowlist_pointer_types_ = true; profile.allowed_pointer_types_ = {\"i8*\", \"i16*\", \"i32*\", \"i64*\", \"Qubit*\", \"Qubit**\", \"Result*\", \"Result**\"}; } else if (name == \"quantinuum\" || name == \"rigetti\" || name == \"qci\") { profile = ValidationPassConfiguration::fromProfileName(\"base\"); // profile.addAllowedExternalCall(\"__quantum__qis__[name]\") } else { throw std::runtime_error(\"Invalid profile \" + name); } profile.profile_name_ = name; return profile; } ValidationPassConfiguration::Set const& ValidationPassConfiguration::allowedOpcodes() const { return opcodes_; } ValidationPassConfiguration::Set const& ValidationPassConfiguration::allowedExternalCallNames() const { return external_calls_; } bool ValidationPassConfiguration::allowInternalCalls() const { return allow_internal_calls_; } bool ValidationPassConfiguration::allowlistOpcodes() const { return allowlist_opcodes_; } bool ValidationPassConfiguration::allowlistExternalCalls() const { return allowlist_external_calls_; } String const& ValidationPassConfiguration::saveReportTo() const { return save_report_to_; } bool ValidationPassConfiguration::allowlistPointerTypes() const { return allowlist_pointer_types_; } ValidationPassConfiguration::Set const& ValidationPassConfiguration::allowedPointerTypes() const { return allowed_pointer_types_; } void ValidationPassConfiguration::addAllowedExternalCall(String const& name) { external_calls_.insert(name); } void ValidationPassConfiguration::addAllowedOpcode(String const& name) { opcodes_.insert(name); } void ValidationPassConfiguration::addAllowedPointerType(String const& name) { allowed_pointer_types_.insert(name); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"ValidationPass/ValidationPassConfiguration.cpp"},{"location":"Api/Files/_validation_pass_configuration_8cpp/#validationpassvalidationpassconfigurationcpp","text":"","title":"ValidationPass/ValidationPassConfiguration.cpp"},{"location":"Api/Files/_validation_pass_configuration_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_validation_pass_configuration_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"ValidationPass/ValidationPassConfiguration.hpp\" namespace microsoft { namespace quantum { void ValidationPassConfiguration::setup(ConfigurationManager& config) { config.setSectionName(\"Validation configuration\", \"\"); config.addParameter( allow_internal_calls_, \"allow-internal-calls\", \"Whether or not internal calls are allowed.\"); config.addParameter( save_report_to_, \"save-validation-report\", \"Saves the validation report to specified filename.\"); } String ValidationPassConfiguration::profileName() const { return profile_name_; } ValidationPassConfiguration ValidationPassConfiguration::fromProfileName(String const& name) { auto profile = ValidationPassConfiguration(); if (name == \"generic\") { profile.opcodes_ = Set{}; profile.external_calls_ = Set{}; profile.allowed_pointer_types_ = Set{}; profile.allowlist_opcodes_ = true; profile.allowlist_external_calls_ = false; profile.allow_internal_calls_ = true; profile.allowlist_pointer_types_ = false; profile.allow_primitive_return_ = true; profile.allow_struct_return_ = true; profile.allow_pointer_return_ = true; } else if (name == \"base\") { profile.allow_internal_calls_ = false; profile.allowlist_external_calls_ = true; profile.allowlist_opcodes_ = true; profile.opcodes_ = Set{\"br\", \"call\", \"unreachable\", \"ret\", \"inttoptr\"}; // \"phi\", \"select\", profile.external_calls_ = Set{ \"__quantum__qis__cnot__body\", \"__quantum__qis__cz__body\", \"__quantum__qis__cx__body\", \"__quantum__qis__cy__body\", \"__quantum__qis__h__body\", \"__quantum__qis__s__body\", \"__quantum__qis__s__adj\", \"__quantum__qis__t__body\", \"__quantum__qis__t__adj\", \"__quantum__qis__x__body\", \"__quantum__qis__y__body\", \"__quantum__qis__z__body\", \"__quantum__qis__rx__body\", \"__quantum__qis__ry__body\", \"__quantum__qis__rz__body\", \"__quantum__qis__reset__body\", \"__quantum__qis__mz__body\", \"__quantum__qis__read_result__body\", }; profile.allowlist_pointer_types_ = true; profile.allowed_pointer_types_ = {\"i8*\", \"i16*\", \"i32*\", \"i64*\", \"Qubit*\", \"Qubit**\", \"Result*\", \"Result**\"}; } else if (name == \"quantinuum\" || name == \"rigetti\" || name == \"qci\") { profile = ValidationPassConfiguration::fromProfileName(\"base\"); // profile.addAllowedExternalCall(\"__quantum__qis__[name]\") } else { throw std::runtime_error(\"Invalid profile \" + name); } profile.profile_name_ = name; return profile; } ValidationPassConfiguration::Set const& ValidationPassConfiguration::allowedOpcodes() const { return opcodes_; } ValidationPassConfiguration::Set const& ValidationPassConfiguration::allowedExternalCallNames() const { return external_calls_; } bool ValidationPassConfiguration::allowInternalCalls() const { return allow_internal_calls_; } bool ValidationPassConfiguration::allowlistOpcodes() const { return allowlist_opcodes_; } bool ValidationPassConfiguration::allowlistExternalCalls() const { return allowlist_external_calls_; } String const& ValidationPassConfiguration::saveReportTo() const { return save_report_to_; } bool ValidationPassConfiguration::allowlistPointerTypes() const { return allowlist_pointer_types_; } ValidationPassConfiguration::Set const& ValidationPassConfiguration::allowedPointerTypes() const { return allowed_pointer_types_; } void ValidationPassConfiguration::addAllowedExternalCall(String const& name) { external_calls_.insert(name); } void ValidationPassConfiguration::addAllowedOpcode(String const& name) { opcodes_.insert(name); } void ValidationPassConfiguration::addAllowedPointerType(String const& name) { allowed_pointer_types_.insert(name); } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_validation_pass_configuration_8hpp/","text":"ValidationPass/ValidationPassConfiguration.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ValidationPassConfiguration Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"QatTypes/QatTypes.hpp\" namespace microsoft { namespace quantum { class ValidationPassConfiguration { public: using Set = std::unordered_set<std::string>; // Setup and construction // ValidationPassConfiguration() = default; void setup(ConfigurationManager& config); static ValidationPassConfiguration fromProfileName(String const& name); Set const& allowedOpcodes() const; Set const& allowedExternalCallNames() const; bool allowInternalCalls() const; bool allowlistOpcodes() const; bool allowlistExternalCalls() const; String const& saveReportTo() const; bool allowlistPointerTypes() const; Set const& allowedPointerTypes() const; String profileName() const; private: void addAllowedExternalCall(String const& name); void addAllowedOpcode(String const& name); void addAllowedPointerType(String const& name); String profile_name_{\"null\"}; Set opcodes_{}; Set external_calls_{}; Set allowed_pointer_types_{}; String save_report_to_{\"\"}; bool allowlist_opcodes_{true}; bool allowlist_external_calls_{true}; bool allow_internal_calls_{false}; bool allowlist_pointer_types_{false}; bool allow_primitive_return_{true}; bool allow_struct_return_{true}; bool allow_pointer_return_{true}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"ValidationPass/ValidationPassConfiguration.hpp"},{"location":"Api/Files/_validation_pass_configuration_8hpp/#validationpassvalidationpassconfigurationhpp","text":"","title":"ValidationPass/ValidationPassConfiguration.hpp"},{"location":"Api/Files/_validation_pass_configuration_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_validation_pass_configuration_8hpp/#classes","text":"Name class microsoft::quantum::ValidationPassConfiguration","title":"Classes"},{"location":"Api/Files/_validation_pass_configuration_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"QatTypes/QatTypes.hpp\" namespace microsoft { namespace quantum { class ValidationPassConfiguration { public: using Set = std::unordered_set<std::string>; // Setup and construction // ValidationPassConfiguration() = default; void setup(ConfigurationManager& config); static ValidationPassConfiguration fromProfileName(String const& name); Set const& allowedOpcodes() const; Set const& allowedExternalCallNames() const; bool allowInternalCalls() const; bool allowlistOpcodes() const; bool allowlistExternalCalls() const; String const& saveReportTo() const; bool allowlistPointerTypes() const; Set const& allowedPointerTypes() const; String profileName() const; private: void addAllowedExternalCall(String const& name); void addAllowedOpcode(String const& name); void addAllowedPointerType(String const& name); String profile_name_{\"null\"}; Set opcodes_{}; Set external_calls_{}; Set allowed_pointer_types_{}; String save_report_to_{\"\"}; bool allowlist_opcodes_{true}; bool allowlist_external_calls_{true}; bool allow_internal_calls_{false}; bool allowlist_pointer_types_{false}; bool allow_primitive_return_{true}; bool allow_struct_return_{true}; bool allow_pointer_return_{true}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_validator_8cpp/","text":"Validator/Validator.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/CommentLogger.hpp\" #include \"Logging/ILogger.hpp\" #include \"Logging/LogCollection.hpp\" #include \"ValidationPass/ValidationPass.hpp\" #include \"Validator/Validator.hpp\" #include \"Llvm/Llvm.hpp\" #include <fstream> namespace microsoft { namespace quantum { Validator::Validator( ValidationPassConfiguration const& cfg, bool force_log_collection, bool debug, llvm::TargetMachine* target_machine) : loop_analysis_manager_{debug} , function_analysis_manager_{debug} , gscc_analysis_manager_{debug} , module_analysis_manager_{debug} , logger_{nullptr} { pass_builder_ = std::make_unique<llvm::PassBuilder>(target_machine); pass_builder_->registerModuleAnalyses(module_analysis_manager_); pass_builder_->registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_->registerFunctionAnalyses(function_analysis_manager_); pass_builder_->registerLoopAnalyses(loop_analysis_manager_); pass_builder_->crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); if (force_log_collection || !cfg.saveReportTo().empty()) { logger_ = std::make_shared<LogCollection>(); } if (!cfg.saveReportTo().empty()) { save_to_filename_ = cfg.saveReportTo(); } // Checking if we need to save the log to a file if (logger_) { module_pass_manager_.addPass(ValidationPass(cfg, logger_)); } else { // Our default is a pass that logs errors via comments module_pass_manager_.addPass(ValidationPass(cfg, std::make_shared<CommentLogger>())); } } bool Validator::validate(llvm::Module& module) { llvm::VerifierAnalysis verifier; auto result = verifier.run(module, module_analysis_manager_); if (result.IRBroken) { if (logger_) { logger_->error(\"Fatal error: Invalid IR.\"); } saveReportToFileIfNeeded(); return false; } try { module_pass_manager_.run(module, module_analysis_manager_); } catch (std::exception const& e) { if (logger_) { logger_->error(\"Fatal error: \" + static_cast<std::string>(e.what())); } saveReportToFileIfNeeded(); return false; } saveReportToFileIfNeeded(); return true; } llvm::PassBuilder& Validator::passBuilder() { return *pass_builder_; } llvm::LoopAnalysisManager& Validator::loopAnalysisManager() { return loop_analysis_manager_; } llvm::FunctionAnalysisManager& Validator::functionAnalysisManager() { return function_analysis_manager_; } llvm::CGSCCAnalysisManager& Validator::gsccAnalysisManager() { return gscc_analysis_manager_; } llvm::ModuleAnalysisManager& Validator::moduleAnalysisManager() { return module_analysis_manager_; } Validator::LogColloectionPtr Validator::logger() const { return logger_; } void Validator::saveReportToFileIfNeeded() { if (!save_to_filename_.empty() && logger_) { std::fstream fout(save_to_filename_, std::ios::out); bool not_first = false; fout << \"[\"; for (auto& message : logger_->messages()) { if (not_first) { fout << \",\"; } fout << \"\\n\"; fout << \" {\\n\"; switch (message.type) { case LogCollection::Type::Debug: fout << \" \\\"type\\\": \\\"debug\\\",\\n\"; break; case LogCollection::Type::Info: fout << \" \\\"type\\\": \\\"info\\\",\\n\"; break; case LogCollection::Type::Warning: fout << \" \\\"type\\\": \\\"warning\\\",\\n\"; break; case LogCollection::Type::Error: fout << \" \\\"type\\\": \\\"error\\\",\\n\"; break; case LogCollection::Type::InternalError: fout << \" \\\"type\\\": \\\"internalError\\\",\\n\"; break; } fout << \" \\\"message\\\": \\\"\" << message.message << \"\\\",\\n\"; fout << \" \\\"location\\\": {\\n\"; fout << \" \\\"filename\\\": \\\"\" << message.location.name << \"\\\",\\n\"; fout << \" \\\"row\\\": \" << message.location.row << \",\\n\"; fout << \" \\\"col\\\": \" << message.location.col << \",\\n\"; fout << \" \\\"llvm_hint\\\": \\\"\" << message.location.llvm_hint << \"\\\",\\n\"; fout << \" \\\"frontend_hint\\\": \\\"\" << message.location.frontend_hint << \"\\\"\\n\"; fout << \" }\\n\"; fout << \" }\"; not_first = true; } fout << \"\\n]\\n\"; fout.close(); } } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Validator/Validator.cpp"},{"location":"Api/Files/_validator_8cpp/#validatorvalidatorcpp","text":"","title":"Validator/Validator.cpp"},{"location":"Api/Files/_validator_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_validator_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/CommentLogger.hpp\" #include \"Logging/ILogger.hpp\" #include \"Logging/LogCollection.hpp\" #include \"ValidationPass/ValidationPass.hpp\" #include \"Validator/Validator.hpp\" #include \"Llvm/Llvm.hpp\" #include <fstream> namespace microsoft { namespace quantum { Validator::Validator( ValidationPassConfiguration const& cfg, bool force_log_collection, bool debug, llvm::TargetMachine* target_machine) : loop_analysis_manager_{debug} , function_analysis_manager_{debug} , gscc_analysis_manager_{debug} , module_analysis_manager_{debug} , logger_{nullptr} { pass_builder_ = std::make_unique<llvm::PassBuilder>(target_machine); pass_builder_->registerModuleAnalyses(module_analysis_manager_); pass_builder_->registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_->registerFunctionAnalyses(function_analysis_manager_); pass_builder_->registerLoopAnalyses(loop_analysis_manager_); pass_builder_->crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); if (force_log_collection || !cfg.saveReportTo().empty()) { logger_ = std::make_shared<LogCollection>(); } if (!cfg.saveReportTo().empty()) { save_to_filename_ = cfg.saveReportTo(); } // Checking if we need to save the log to a file if (logger_) { module_pass_manager_.addPass(ValidationPass(cfg, logger_)); } else { // Our default is a pass that logs errors via comments module_pass_manager_.addPass(ValidationPass(cfg, std::make_shared<CommentLogger>())); } } bool Validator::validate(llvm::Module& module) { llvm::VerifierAnalysis verifier; auto result = verifier.run(module, module_analysis_manager_); if (result.IRBroken) { if (logger_) { logger_->error(\"Fatal error: Invalid IR.\"); } saveReportToFileIfNeeded(); return false; } try { module_pass_manager_.run(module, module_analysis_manager_); } catch (std::exception const& e) { if (logger_) { logger_->error(\"Fatal error: \" + static_cast<std::string>(e.what())); } saveReportToFileIfNeeded(); return false; } saveReportToFileIfNeeded(); return true; } llvm::PassBuilder& Validator::passBuilder() { return *pass_builder_; } llvm::LoopAnalysisManager& Validator::loopAnalysisManager() { return loop_analysis_manager_; } llvm::FunctionAnalysisManager& Validator::functionAnalysisManager() { return function_analysis_manager_; } llvm::CGSCCAnalysisManager& Validator::gsccAnalysisManager() { return gscc_analysis_manager_; } llvm::ModuleAnalysisManager& Validator::moduleAnalysisManager() { return module_analysis_manager_; } Validator::LogColloectionPtr Validator::logger() const { return logger_; } void Validator::saveReportToFileIfNeeded() { if (!save_to_filename_.empty() && logger_) { std::fstream fout(save_to_filename_, std::ios::out); bool not_first = false; fout << \"[\"; for (auto& message : logger_->messages()) { if (not_first) { fout << \",\"; } fout << \"\\n\"; fout << \" {\\n\"; switch (message.type) { case LogCollection::Type::Debug: fout << \" \\\"type\\\": \\\"debug\\\",\\n\"; break; case LogCollection::Type::Info: fout << \" \\\"type\\\": \\\"info\\\",\\n\"; break; case LogCollection::Type::Warning: fout << \" \\\"type\\\": \\\"warning\\\",\\n\"; break; case LogCollection::Type::Error: fout << \" \\\"type\\\": \\\"error\\\",\\n\"; break; case LogCollection::Type::InternalError: fout << \" \\\"type\\\": \\\"internalError\\\",\\n\"; break; } fout << \" \\\"message\\\": \\\"\" << message.message << \"\\\",\\n\"; fout << \" \\\"location\\\": {\\n\"; fout << \" \\\"filename\\\": \\\"\" << message.location.name << \"\\\",\\n\"; fout << \" \\\"row\\\": \" << message.location.row << \",\\n\"; fout << \" \\\"col\\\": \" << message.location.col << \",\\n\"; fout << \" \\\"llvm_hint\\\": \\\"\" << message.location.llvm_hint << \"\\\",\\n\"; fout << \" \\\"frontend_hint\\\": \\\"\" << message.location.frontend_hint << \"\\\"\\n\"; fout << \" }\\n\"; fout << \" }\"; not_first = true; } fout << \"\\n]\\n\"; fout.close(); } } } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/_validator_8hpp/","text":"Validator/Validator.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::Validator Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/AllocationManager.hpp\" #include \"AllocationManager/IAllocationManager.hpp\" #include \"Logging/ILogger.hpp\" #include \"Logging/LogCollection.hpp\" #include \"ValidationPass/ValidationPassConfiguration.hpp\" #include \"Llvm/Llvm.hpp\" #include <memory> namespace microsoft { namespace quantum { class Validator { public: using ValidatorPtr = std::unique_ptr<Validator>; using LogColloectionPtr = std::shared_ptr<LogCollection>; // Constructors // explicit Validator( ValidationPassConfiguration const& cfg, bool force_log_collection, bool debug, llvm::TargetMachine* target_machine = nullptr); // Default construction not allowed to ensure that LLVM modules and passes are set up correctly. // Copy construction is prohibited due to restriction on classes held by Validator. Validator() = delete; Validator(Validator const&) = delete; Validator(Validator&&) = default; Validator& operator=(Validator const&) = delete; Validator& operator=(Validator&&) = default; ~Validator() = default; // Validator methods // bool validate(llvm::Module& module); LogColloectionPtr logger() const; protected: using PassBuilderPtr = std::unique_ptr<llvm::PassBuilder>; llvm::PassBuilder& passBuilder(); llvm::LoopAnalysisManager& loopAnalysisManager(); llvm::FunctionAnalysisManager& functionAnalysisManager(); llvm::CGSCCAnalysisManager& gsccAnalysisManager(); llvm::ModuleAnalysisManager& moduleAnalysisManager(); private: void saveReportToFileIfNeeded(); // LLVM logic to run the passes // llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; PassBuilderPtr pass_builder_; llvm::ModulePassManager module_pass_manager_{}; LogColloectionPtr logger_{nullptr}; String save_to_filename_{\"\"}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Validator/Validator.hpp"},{"location":"Api/Files/_validator_8hpp/#validatorvalidatorhpp","text":"","title":"Validator/Validator.hpp"},{"location":"Api/Files/_validator_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_validator_8hpp/#classes","text":"Name class microsoft::quantum::Validator","title":"Classes"},{"location":"Api/Files/_validator_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/AllocationManager.hpp\" #include \"AllocationManager/IAllocationManager.hpp\" #include \"Logging/ILogger.hpp\" #include \"Logging/LogCollection.hpp\" #include \"ValidationPass/ValidationPassConfiguration.hpp\" #include \"Llvm/Llvm.hpp\" #include <memory> namespace microsoft { namespace quantum { class Validator { public: using ValidatorPtr = std::unique_ptr<Validator>; using LogColloectionPtr = std::shared_ptr<LogCollection>; // Constructors // explicit Validator( ValidationPassConfiguration const& cfg, bool force_log_collection, bool debug, llvm::TargetMachine* target_machine = nullptr); // Default construction not allowed to ensure that LLVM modules and passes are set up correctly. // Copy construction is prohibited due to restriction on classes held by Validator. Validator() = delete; Validator(Validator const&) = delete; Validator(Validator&&) = default; Validator& operator=(Validator const&) = delete; Validator& operator=(Validator&&) = default; ~Validator() = default; // Validator methods // bool validate(llvm::Module& module); LogColloectionPtr logger() const; protected: using PassBuilderPtr = std::unique_ptr<llvm::PassBuilder>; llvm::PassBuilder& passBuilder(); llvm::LoopAnalysisManager& loopAnalysisManager(); llvm::FunctionAnalysisManager& functionAnalysisManager(); llvm::CGSCCAnalysisManager& gsccAnalysisManager(); llvm::ModuleAnalysisManager& moduleAnalysisManager(); private: void saveReportToFileIfNeeded(); // LLVM logic to run the passes // llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; PassBuilderPtr pass_builder_; llvm::ModulePassManager module_pass_manager_{}; LogColloectionPtr logger_{nullptr}; String save_to_filename_{\"\"}; }; } // namespace quantum } // namespace microsoft Updated on 22 March 2022 at 08:31:22 UTC","title":"Source code"},{"location":"Api/Files/dir_057849f2a92a904b8f008cf0365e4758/","text":"TestTools Files Name TestTools/IrManipulationTestHelper.cpp TestTools/IrManipulationTestHelper.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"TestTools"},{"location":"Api/Files/dir_057849f2a92a904b8f008cf0365e4758/#testtools","text":"","title":"TestTools"},{"location":"Api/Files/dir_057849f2a92a904b8f008cf0365e4758/#files","text":"Name TestTools/IrManipulationTestHelper.cpp TestTools/IrManipulationTestHelper.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Files"},{"location":"Api/Files/dir_0a824aa1f70ce3b829ef378253b085da/","text":"Utils Files Name Utils/Trim.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Utils"},{"location":"Api/Files/dir_0a824aa1f70ce3b829ef378253b085da/#utils","text":"","title":"Utils"},{"location":"Api/Files/dir_0a824aa1f70ce3b829ef378253b085da/#files","text":"Name Utils/Trim.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Files"},{"location":"Api/Files/dir_0b342c6c6b7d2278121a0bb9c4985063/","text":"Generators Files Name Generators/ConfigurableProfileGenerator.cpp Generators/ConfigurableProfileGenerator.hpp Generators/LlvmPassesConfiguration.cpp Generators/LlvmPassesConfiguration.hpp Generators/ProfileGenerator.cpp Generators/ProfileGenerator.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Generators"},{"location":"Api/Files/dir_0b342c6c6b7d2278121a0bb9c4985063/#generators","text":"","title":"Generators"},{"location":"Api/Files/dir_0b342c6c6b7d2278121a0bb9c4985063/#files","text":"Name Generators/ConfigurableProfileGenerator.cpp Generators/ConfigurableProfileGenerator.hpp Generators/LlvmPassesConfiguration.cpp Generators/LlvmPassesConfiguration.hpp Generators/ProfileGenerator.cpp Generators/ProfileGenerator.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Files"},{"location":"Api/Files/dir_13002e6e9a3be65aeac8e1b6c1ea9008/","text":"AllocationManager Files Name AllocationManager/AllocationManager.cpp AllocationManager/AllocationManager.hpp AllocationManager/IAllocationManager.cpp AllocationManager/IAllocationManager.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"AllocationManager"},{"location":"Api/Files/dir_13002e6e9a3be65aeac8e1b6c1ea9008/#allocationmanager","text":"","title":"AllocationManager"},{"location":"Api/Files/dir_13002e6e9a3be65aeac8e1b6c1ea9008/#files","text":"Name AllocationManager/AllocationManager.cpp AllocationManager/AllocationManager.hpp AllocationManager/IAllocationManager.cpp AllocationManager/IAllocationManager.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Files"},{"location":"Api/Files/dir_46e4ac26363cdfa62d85590f6bd5db50/","text":"QatTypes Files Name QatTypes/QatTypes.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"QatTypes"},{"location":"Api/Files/dir_46e4ac26363cdfa62d85590f6bd5db50/#qattypes","text":"","title":"QatTypes"},{"location":"Api/Files/dir_46e4ac26363cdfa62d85590f6bd5db50/#files","text":"Name QatTypes/QatTypes.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Files"},{"location":"Api/Files/dir_524e0ced49e0a8528dd8fd75cd7543b6/","text":"RemoveDisallowedAttributesPass Files Name RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"RemoveDisallowedAttributesPass"},{"location":"Api/Files/dir_524e0ced49e0a8528dd8fd75cd7543b6/#removedisallowedattributespass","text":"","title":"RemoveDisallowedAttributesPass"},{"location":"Api/Files/dir_524e0ced49e0a8528dd8fd75cd7543b6/#files","text":"Name RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Files"},{"location":"Api/Files/dir_76e799bfaed323ed7497703f1980580e/","text":"Commandline Files Name Commandline/ConfigBind.hpp Commandline/ConfigurationManager.cpp Commandline/ConfigurationManager.hpp Commandline/IConfigBind.cpp Commandline/IConfigBind.hpp Commandline/ParameterParser.cpp Commandline/ParameterParser.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Commandline"},{"location":"Api/Files/dir_76e799bfaed323ed7497703f1980580e/#commandline","text":"","title":"Commandline"},{"location":"Api/Files/dir_76e799bfaed323ed7497703f1980580e/#files","text":"Name Commandline/ConfigBind.hpp Commandline/ConfigurationManager.cpp Commandline/ConfigurationManager.hpp Commandline/IConfigBind.cpp Commandline/IConfigBind.hpp Commandline/ParameterParser.cpp Commandline/ParameterParser.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Files"},{"location":"Api/Files/dir_82b5296fc6745e5fe86b01060885a57b/","text":"ValidationPass Files Name ValidationPass/ValidationPass.cpp ValidationPass/ValidationPass.hpp ValidationPass/ValidationPassConfiguration.cpp ValidationPass/ValidationPassConfiguration.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"ValidationPass"},{"location":"Api/Files/dir_82b5296fc6745e5fe86b01060885a57b/#validationpass","text":"","title":"ValidationPass"},{"location":"Api/Files/dir_82b5296fc6745e5fe86b01060885a57b/#files","text":"Name ValidationPass/ValidationPass.cpp ValidationPass/ValidationPass.hpp ValidationPass/ValidationPassConfiguration.cpp ValidationPass/ValidationPassConfiguration.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Files"},{"location":"Api/Files/dir_8f912e5e736424b0d79274234fdd791d/","text":"TransformationRulesPass Files Name TransformationRulesPass/TransformationRulesPass.cpp TransformationRulesPass/TransformationRulesPass.hpp TransformationRulesPass/TransformationRulesPassConfiguration.cpp TransformationRulesPass/TransformationRulesPassConfiguration.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"TransformationRulesPass"},{"location":"Api/Files/dir_8f912e5e736424b0d79274234fdd791d/#transformationrulespass","text":"","title":"TransformationRulesPass"},{"location":"Api/Files/dir_8f912e5e736424b0d79274234fdd791d/#files","text":"Name TransformationRulesPass/TransformationRulesPass.cpp TransformationRulesPass/TransformationRulesPass.hpp TransformationRulesPass/TransformationRulesPassConfiguration.cpp TransformationRulesPass/TransformationRulesPassConfiguration.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Files"},{"location":"Api/Files/dir_b392e36b8bc0ffd1fb6a4bd773438243/","text":"Rules/Notation Files Name Rules/Notation/BasicBlock.cpp Rules/Notation/BitCast.cpp Rules/Notation/Branch.cpp Rules/Notation/Call.hpp Rules/Notation/Call.ipp Rules/Notation/CallByNameOnly.cpp Rules/Notation/Capture.cpp Rules/Notation/ConstInt.cpp Rules/Notation/IntToPtr.cpp Rules/Notation/Load.cpp Rules/Notation/Notation.cpp Rules/Notation/Notation.hpp Rules/Notation/Phi.ipp Rules/Notation/Select.cpp Rules/Notation/Store.cpp Rules/Notation/Switch.cpp Rules/Notation/UnnamedInvoke.cpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Notation"},{"location":"Api/Files/dir_b392e36b8bc0ffd1fb6a4bd773438243/#rulesnotation","text":"","title":"Rules/Notation"},{"location":"Api/Files/dir_b392e36b8bc0ffd1fb6a4bd773438243/#files","text":"Name Rules/Notation/BasicBlock.cpp Rules/Notation/BitCast.cpp Rules/Notation/Branch.cpp Rules/Notation/Call.hpp Rules/Notation/Call.ipp Rules/Notation/CallByNameOnly.cpp Rules/Notation/Capture.cpp Rules/Notation/ConstInt.cpp Rules/Notation/IntToPtr.cpp Rules/Notation/Load.cpp Rules/Notation/Notation.cpp Rules/Notation/Notation.hpp Rules/Notation/Phi.ipp Rules/Notation/Select.cpp Rules/Notation/Store.cpp Rules/Notation/Switch.cpp Rules/Notation/UnnamedInvoke.cpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Files"},{"location":"Api/Files/dir_ba276cc22cfffca1a089fe33ae082ee3/","text":"Profile Files Name Profile/Profile.cpp Profile/Profile.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Profile"},{"location":"Api/Files/dir_ba276cc22cfffca1a089fe33ae082ee3/#profile","text":"","title":"Profile"},{"location":"Api/Files/dir_ba276cc22cfffca1a089fe33ae082ee3/#files","text":"Name Profile/Profile.cpp Profile/Profile.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Files"},{"location":"Api/Files/dir_bc70899ed1f4b37c346358e1e878ce58/","text":"GroupingPass Files Name GroupingPass/GroupingAnalysisPass.cpp GroupingPass/GroupingAnalysisPass.hpp GroupingPass/GroupingPass.cpp GroupingPass/GroupingPass.hpp GroupingPass/GroupingPassConfiguration.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"GroupingPass"},{"location":"Api/Files/dir_bc70899ed1f4b37c346358e1e878ce58/#groupingpass","text":"","title":"GroupingPass"},{"location":"Api/Files/dir_bc70899ed1f4b37c346358e1e878ce58/#files","text":"Name GroupingPass/GroupingAnalysisPass.cpp GroupingPass/GroupingAnalysisPass.hpp GroupingPass/GroupingPass.cpp GroupingPass/GroupingPass.hpp GroupingPass/GroupingPassConfiguration.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Files"},{"location":"Api/Files/dir_d31ef966b0cb1225b2b298e923bbc249/","text":"ModuleLoader Files Name ModuleLoader/ModuleLoader.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"ModuleLoader"},{"location":"Api/Files/dir_d31ef966b0cb1225b2b298e923bbc249/#moduleloader","text":"","title":"ModuleLoader"},{"location":"Api/Files/dir_d31ef966b0cb1225b2b298e923bbc249/#files","text":"Name ModuleLoader/ModuleLoader.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Files"},{"location":"Api/Files/dir_d9949a2e036493f8647151a4ab6ee0ce/","text":"Logging Files Name Logging/CommentLogger.cpp Logging/CommentLogger.hpp Logging/ILogger.cpp Logging/ILogger.hpp Logging/LogCollection.cpp Logging/LogCollection.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Logging"},{"location":"Api/Files/dir_d9949a2e036493f8647151a4ab6ee0ce/#logging","text":"","title":"Logging"},{"location":"Api/Files/dir_d9949a2e036493f8647151a4ab6ee0ce/#files","text":"Name Logging/CommentLogger.cpp Logging/CommentLogger.hpp Logging/ILogger.cpp Logging/ILogger.hpp Logging/LogCollection.cpp Logging/LogCollection.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Files"},{"location":"Api/Files/dir_ed349e2d4b607ef61e27eb2c0c0c4b3d/","text":"Rules Directories Name Rules/Notation Rules/Patterns Files Name Rules/Factory.cpp Rules/Factory.hpp Rules/FactoryConfig.hpp Rules/IOperandPrototype.cpp Rules/IOperandPrototype.hpp Rules/ReplacementRule.cpp Rules/ReplacementRule.hpp Rules/RuleSet.cpp Rules/RuleSet.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules"},{"location":"Api/Files/dir_ed349e2d4b607ef61e27eb2c0c0c4b3d/#rules","text":"","title":"Rules"},{"location":"Api/Files/dir_ed349e2d4b607ef61e27eb2c0c0c4b3d/#directories","text":"Name Rules/Notation Rules/Patterns","title":"Directories"},{"location":"Api/Files/dir_ed349e2d4b607ef61e27eb2c0c0c4b3d/#files","text":"Name Rules/Factory.cpp Rules/Factory.hpp Rules/FactoryConfig.hpp Rules/IOperandPrototype.cpp Rules/IOperandPrototype.hpp Rules/ReplacementRule.cpp Rules/ReplacementRule.hpp Rules/RuleSet.cpp Rules/RuleSet.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Files"},{"location":"Api/Files/dir_f11d3c47e762e38fcdfbd4cfb049caab/","text":"Rules/Patterns Files Name Rules/Patterns/AnyPattern.cpp Rules/Patterns/AnyPattern.hpp Rules/Patterns/CallPattern.cpp Rules/Patterns/CallPattern.hpp Rules/Patterns/Instruction.cpp Rules/Patterns/Instruction.hpp Rules/Patterns/PhiPattern.cpp Rules/Patterns/PhiPattern.hpp Rules/Patterns/UnnamedInvokePattern.cpp Rules/Patterns/UnnamedInvokePattern.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Rules/Patterns"},{"location":"Api/Files/dir_f11d3c47e762e38fcdfbd4cfb049caab/#rulespatterns","text":"","title":"Rules/Patterns"},{"location":"Api/Files/dir_f11d3c47e762e38fcdfbd4cfb049caab/#files","text":"Name Rules/Patterns/AnyPattern.cpp Rules/Patterns/AnyPattern.hpp Rules/Patterns/CallPattern.cpp Rules/Patterns/CallPattern.hpp Rules/Patterns/Instruction.cpp Rules/Patterns/Instruction.hpp Rules/Patterns/PhiPattern.cpp Rules/Patterns/PhiPattern.hpp Rules/Patterns/UnnamedInvokePattern.cpp Rules/Patterns/UnnamedInvokePattern.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Files"},{"location":"Api/Files/dir_f32fa1f684a45b73f347439bab6df68d/","text":"Validator Files Name Validator/Validator.cpp Validator/Validator.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Validator"},{"location":"Api/Files/dir_f32fa1f684a45b73f347439bab6df68d/#validator","text":"","title":"Validator"},{"location":"Api/Files/dir_f32fa1f684a45b73f347439bab6df68d/#files","text":"Name Validator/Validator.cpp Validator/Validator.hpp Updated on 22 March 2022 at 08:31:22 UTC","title":"Files"},{"location":"Api/Modules/","text":"Modules group Shorthand Notation Updated on 22 March 2022 at 08:31:22 UTC","title":"Modules"},{"location":"Api/Modules/#modules","text":"group Shorthand Notation Updated on 22 March 2022 at 08:31:22 UTC","title":"Modules"},{"location":"Api/Modules/group__shorthand_notation/","text":"Shorthand Notation More... Functions Name Capture (std::string const & name) Explicit creation using string name constructor. IOperandPrototypePtr operator= (IOperandPrototypePtr const & other) template <typename... Args> IOperandPrototypePtr call (std::string const & name, Args... args) IOperandPrototypePtr unnamedInvoke () Matches a invoke instruction. template <typename... Args> IOperandPrototypePtr phi (Args... args) Matches a phi node with N arguments. IOperandPrototypePtr callByNameOnly (std::string const & name) IOperandPrototypePtr bitCast (IOperandPrototypePtr const & arg) Matches the llvm::BitCast instructruction. IOperandPrototypePtr intToPtr (IOperandPrototypePtr const & arg) Matches the llvm::IntToPtr instructruction. IOperandPrototypePtr constInt () Matches the llvm::ConstantInt instructruction. IOperandPrototypePtr branch (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a branch instruction given a condition and two arguments. IOperandPrototypePtr switchOp (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) IOperandPrototypePtr select (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a select instruction given a condition and two arguments. IOperandPrototypePtr load (IOperandPrototypePtr const & arg) Matches a load instruction with one argument. IOperandPrototypePtr store (IOperandPrototypePtr const & target, IOperandPrototypePtr const & value) IOperandPrototypePtr basicBlock () Matches a load instruction with one argument. ReplacerFunction deleteInstruction () Capture operator\"\"_cap (char const * name, std::size_t ) Attributes Name const std::shared_ptr< AnyPattern > _ Detailed Description Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern auto get_one = call(\"__quantum__rt__result_get_one\"); addRule( {branch(\"cond\"_cap = call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), _, _), replace_branch_positive}); which matches IRs of the form %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: cond , result and one each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function). The module further has shorthand notation for often encountered patterns such as any operand. The module also implements shorthand notation for common replacers. Literals which ease the burned of capturing values and increase readibility of the code. Functions Documentation function Capture explicit Capture( std::string const & name ) Explicit creation using string name constructor. function operator= IOperandPrototypePtr operator=( IOperandPrototypePtr const & other ) function call template <typename... Args> IOperandPrototypePtr call( std::string const & name, Args... args ) Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern auto get_one = call(\"__quantum__rt__result_get_one\"); addRule( {branch(\"cond\"_cap = call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), _, _), replace_branch_positive}); which matches IRs of the form %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: cond , result and one each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function). Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments. Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments. function unnamedInvoke IOperandPrototypePtr unnamedInvoke() Matches a invoke instruction. function phi template <typename... Args> IOperandPrototypePtr phi( Args... args ) Matches a phi node with N arguments. function callByNameOnly IOperandPrototypePtr callByNameOnly( std::string const & name ) Shorthand notation to match an instruction with a specified name. Unlike call, this pattern matches by name only and ignore the arguments. addRule({callByNameOnly(\"foo\"), deleteInstruction()}); matches calls to the function foo regardless of the number of arguments. function bitCast IOperandPrototypePtr bitCast( IOperandPrototypePtr const & arg ) Matches the llvm::BitCast instructruction. function intToPtr IOperandPrototypePtr intToPtr( IOperandPrototypePtr const & arg ) Matches the llvm::IntToPtr instructruction. function constInt IOperandPrototypePtr constInt() Matches the llvm::ConstantInt instructruction. function branch IOperandPrototypePtr branch( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a branch instruction given a condition and two arguments. function switchOp IOperandPrototypePtr switchOp( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) function select IOperandPrototypePtr select( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a select instruction given a condition and two arguments. function load IOperandPrototypePtr load( IOperandPrototypePtr const & arg ) Matches a load instruction with one argument. function store IOperandPrototypePtr store( IOperandPrototypePtr const & target, IOperandPrototypePtr const & value ) Matches a store instruction with a target and a value. addRule({store(\"target\"_cap = _, \"value\"_cap = _), replaceConstExpr}); where we want to match all store instructions and do not really care about how the target or value came about. In this case, we may want to capture the values to, for instance, make assignment at compile time. function basicBlock IOperandPrototypePtr basicBlock() Matches a load instruction with one argument. function deleteInstruction ReplacerFunction deleteInstruction() Shorthand notation to delete an instruction. If passed as the replacement function, this function generates a replacer that deletes the instruction. This is a shorthand notation for deleting an instruction that can be used with a custom rule when building a ruleset. This function can be used with shorthand notation for patterns as follows: addRule({callByNameOnly(name), deleteInstruction()}); to delete the instructions that calls functions with the name name . function operator\"\"_cap Capture operator\"\"_cap( char const * name, std::size_t ) Literal for specifying the capture of a llvm::Value*. This literal calls the IOperandPrototype::enableCapture through the assignment of a IOperandPrototypePtr to the class Capture . As an example, one may want to match the pattern foo(bar(baz(x)), y) and extract the variable x to add meta data to it. The corresponding IR could look like: %1 = call %Type* @baz(%Type* %0) %2 = call %Type* @bar(%Type* %1) call void @foo(%Type* %2, %Type* %3) To match this pattern, one would create the pattern call(\"foo\", call(\"bar\", call(\"baz\", \"x\"_cap = _)), _) . This pattern would ensure that at the time where the replacer function is called, the value stored in %0 is captured under the name x . Attributes Documentation variable _ static const std::shared_ptr< AnyPattern > _ = std::make_shared<AnyPattern>(); Shorthand notation for a wildcard which matches anything. This value is useful when for instance capturing the arguments of a function call where the origin of the value does not matter to the pattern. Updated on 22 March 2022 at 08:31:22 UTC","title":"Shorthand Notation"},{"location":"Api/Modules/group__shorthand_notation/#shorthand-notation","text":"More...","title":"Shorthand Notation"},{"location":"Api/Modules/group__shorthand_notation/#functions","text":"Name Capture (std::string const & name) Explicit creation using string name constructor. IOperandPrototypePtr operator= (IOperandPrototypePtr const & other) template <typename... Args> IOperandPrototypePtr call (std::string const & name, Args... args) IOperandPrototypePtr unnamedInvoke () Matches a invoke instruction. template <typename... Args> IOperandPrototypePtr phi (Args... args) Matches a phi node with N arguments. IOperandPrototypePtr callByNameOnly (std::string const & name) IOperandPrototypePtr bitCast (IOperandPrototypePtr const & arg) Matches the llvm::BitCast instructruction. IOperandPrototypePtr intToPtr (IOperandPrototypePtr const & arg) Matches the llvm::IntToPtr instructruction. IOperandPrototypePtr constInt () Matches the llvm::ConstantInt instructruction. IOperandPrototypePtr branch (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a branch instruction given a condition and two arguments. IOperandPrototypePtr switchOp (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) IOperandPrototypePtr select (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a select instruction given a condition and two arguments. IOperandPrototypePtr load (IOperandPrototypePtr const & arg) Matches a load instruction with one argument. IOperandPrototypePtr store (IOperandPrototypePtr const & target, IOperandPrototypePtr const & value) IOperandPrototypePtr basicBlock () Matches a load instruction with one argument. ReplacerFunction deleteInstruction () Capture operator\"\"_cap (char const * name, std::size_t )","title":"Functions"},{"location":"Api/Modules/group__shorthand_notation/#attributes","text":"Name const std::shared_ptr< AnyPattern > _","title":"Attributes"},{"location":"Api/Modules/group__shorthand_notation/#detailed-description","text":"Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern auto get_one = call(\"__quantum__rt__result_get_one\"); addRule( {branch(\"cond\"_cap = call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), _, _), replace_branch_positive}); which matches IRs of the form %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: cond , result and one each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function). The module further has shorthand notation for often encountered patterns such as any operand. The module also implements shorthand notation for common replacers. Literals which ease the burned of capturing values and increase readibility of the code.","title":"Detailed Description"},{"location":"Api/Modules/group__shorthand_notation/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Modules/group__shorthand_notation/#function-capture","text":"explicit Capture( std::string const & name ) Explicit creation using string name constructor.","title":"function Capture"},{"location":"Api/Modules/group__shorthand_notation/#function-operator","text":"IOperandPrototypePtr operator=( IOperandPrototypePtr const & other )","title":"function operator="},{"location":"Api/Modules/group__shorthand_notation/#function-call","text":"template <typename... Args> IOperandPrototypePtr call( std::string const & name, Args... args ) Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern auto get_one = call(\"__quantum__rt__result_get_one\"); addRule( {branch(\"cond\"_cap = call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), _, _), replace_branch_positive}); which matches IRs of the form %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: cond , result and one each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function). Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments. Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments.","title":"function call"},{"location":"Api/Modules/group__shorthand_notation/#function-unnamedinvoke","text":"IOperandPrototypePtr unnamedInvoke() Matches a invoke instruction.","title":"function unnamedInvoke"},{"location":"Api/Modules/group__shorthand_notation/#function-phi","text":"template <typename... Args> IOperandPrototypePtr phi( Args... args ) Matches a phi node with N arguments.","title":"function phi"},{"location":"Api/Modules/group__shorthand_notation/#function-callbynameonly","text":"IOperandPrototypePtr callByNameOnly( std::string const & name ) Shorthand notation to match an instruction with a specified name. Unlike call, this pattern matches by name only and ignore the arguments. addRule({callByNameOnly(\"foo\"), deleteInstruction()}); matches calls to the function foo regardless of the number of arguments.","title":"function callByNameOnly"},{"location":"Api/Modules/group__shorthand_notation/#function-bitcast","text":"IOperandPrototypePtr bitCast( IOperandPrototypePtr const & arg ) Matches the llvm::BitCast instructruction.","title":"function bitCast"},{"location":"Api/Modules/group__shorthand_notation/#function-inttoptr","text":"IOperandPrototypePtr intToPtr( IOperandPrototypePtr const & arg ) Matches the llvm::IntToPtr instructruction.","title":"function intToPtr"},{"location":"Api/Modules/group__shorthand_notation/#function-constint","text":"IOperandPrototypePtr constInt() Matches the llvm::ConstantInt instructruction.","title":"function constInt"},{"location":"Api/Modules/group__shorthand_notation/#function-branch","text":"IOperandPrototypePtr branch( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a branch instruction given a condition and two arguments.","title":"function branch"},{"location":"Api/Modules/group__shorthand_notation/#function-switchop","text":"IOperandPrototypePtr switchOp( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 )","title":"function switchOp"},{"location":"Api/Modules/group__shorthand_notation/#function-select","text":"IOperandPrototypePtr select( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a select instruction given a condition and two arguments.","title":"function select"},{"location":"Api/Modules/group__shorthand_notation/#function-load","text":"IOperandPrototypePtr load( IOperandPrototypePtr const & arg ) Matches a load instruction with one argument.","title":"function load"},{"location":"Api/Modules/group__shorthand_notation/#function-store","text":"IOperandPrototypePtr store( IOperandPrototypePtr const & target, IOperandPrototypePtr const & value ) Matches a store instruction with a target and a value. addRule({store(\"target\"_cap = _, \"value\"_cap = _), replaceConstExpr}); where we want to match all store instructions and do not really care about how the target or value came about. In this case, we may want to capture the values to, for instance, make assignment at compile time.","title":"function store"},{"location":"Api/Modules/group__shorthand_notation/#function-basicblock","text":"IOperandPrototypePtr basicBlock() Matches a load instruction with one argument.","title":"function basicBlock"},{"location":"Api/Modules/group__shorthand_notation/#function-deleteinstruction","text":"ReplacerFunction deleteInstruction() Shorthand notation to delete an instruction. If passed as the replacement function, this function generates a replacer that deletes the instruction. This is a shorthand notation for deleting an instruction that can be used with a custom rule when building a ruleset. This function can be used with shorthand notation for patterns as follows: addRule({callByNameOnly(name), deleteInstruction()}); to delete the instructions that calls functions with the name name .","title":"function deleteInstruction"},{"location":"Api/Modules/group__shorthand_notation/#function-operator_cap","text":"Capture operator\"\"_cap( char const * name, std::size_t ) Literal for specifying the capture of a llvm::Value*. This literal calls the IOperandPrototype::enableCapture through the assignment of a IOperandPrototypePtr to the class Capture . As an example, one may want to match the pattern foo(bar(baz(x)), y) and extract the variable x to add meta data to it. The corresponding IR could look like: %1 = call %Type* @baz(%Type* %0) %2 = call %Type* @bar(%Type* %1) call void @foo(%Type* %2, %Type* %3) To match this pattern, one would create the pattern call(\"foo\", call(\"bar\", call(\"baz\", \"x\"_cap = _)), _) . This pattern would ensure that at the time where the replacer function is called, the value stored in %0 is captured under the name x .","title":"function operator\"\"_cap"},{"location":"Api/Modules/group__shorthand_notation/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Api/Modules/group__shorthand_notation/#variable-_","text":"static const std::shared_ptr< AnyPattern > _ = std::make_shared<AnyPattern>(); Shorthand notation for a wildcard which matches anything. This value is useful when for instance capturing the arguments of a function call where the origin of the value does not matter to the pattern. Updated on 22 March 2022 at 08:31:22 UTC","title":"variable _"},{"location":"Api/Namespaces/","text":"Namespaces namespace microsoft namespace quantum namespace notation namespace microsoft::quantum::@33 Updated on 22 March 2022 at 08:31:22 UTC","title":"Namespaces"},{"location":"Api/Namespaces/#namespaces","text":"namespace microsoft namespace quantum namespace notation namespace microsoft::quantum::@33 Updated on 22 March 2022 at 08:31:22 UTC","title":"Namespaces"},{"location":"Api/Namespaces/namespacemicrosoft/","text":"microsoft Namespaces Name microsoft::quantum Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft"},{"location":"Api/Namespaces/namespacemicrosoft/#microsoft","text":"","title":"microsoft"},{"location":"Api/Namespaces/namespacemicrosoft/#namespaces","text":"Name microsoft::quantum Updated on 22 March 2022 at 08:31:22 UTC","title":"Namespaces"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/","text":"microsoft::quantum Namespaces Name microsoft::quantum::notation Classes Name class microsoft::quantum::AnyPattern Pattern that matches any operand. class microsoft::quantum::BasicAllocationManager class microsoft::quantum::BasicBlockPattern class microsoft::quantum::BitCastPattern class microsoft::quantum::BranchPattern class microsoft::quantum::CallPattern class microsoft::quantum::CommentLogger Concrete ILogger implementation that prints all messages as IR comments to llvm::errs(). class microsoft::quantum::ConfigBind class microsoft::quantum::ConfigurableProfileGenerator class microsoft::quantum::ConfigurationManager class microsoft::quantum::ConstIntPattern class microsoft::quantum::FactoryConfiguration struct microsoft::quantum::GroupAnalysis class microsoft::quantum::GroupingAnalysisPass class microsoft::quantum::GroupingAnalysisPassPrinter class microsoft::quantum::GroupingPass class microsoft::quantum::GroupingPassConfiguration class microsoft::quantum::IAllocationManager class microsoft::quantum::IConfigBind class microsoft::quantum::ILogger class microsoft::quantum::IntToPtrPattern class microsoft::quantum::IOperandPrototype class microsoft::quantum::IrManipulationTestHelper class microsoft::quantum::LlvmPassesConfiguration class microsoft::quantum::LoadPattern class microsoft::quantum::LogCollection class microsoft::quantum::ModuleLoader class microsoft::quantum::ParameterParser class microsoft::quantum::PhiPattern class microsoft::quantum::Profile class microsoft::quantum::ProfileGenerator class microsoft::quantum::RemoveDisallowedAttributesPass class microsoft::quantum::ReplacementRule class microsoft::quantum::RuleFactory class microsoft::quantum::RuleSet class microsoft::quantum::SelectPattern class microsoft::quantum::StorePattern class microsoft::quantum::SwitchPattern class microsoft::quantum::TransformationRulesPass class microsoft::quantum::TransformationRulesPassConfiguration Configuration class for the RuleTransformation pass. class microsoft::quantum::UnnamedInvokePattern class microsoft::quantum::ValidationPass class microsoft::quantum::ValidationPassConfiguration class microsoft::quantum::Validator Types Name using std::string String using RuleFactory::ReplacementRulePtr ReplacementRulePtr Functions Name void ltrim (std::string & str) void rtrim (std::string & str) void trim (std::string & s) Types Documentation using String using microsoft::quantum::String = typedef std::string; using ReplacementRulePtr using microsoft::quantum::ReplacementRulePtr = typedef RuleFactory::ReplacementRulePtr; Functions Documentation function ltrim inline void ltrim( std::string & str ) function rtrim inline void rtrim( std::string & str ) function trim inline void trim( std::string & s ) Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#microsoftquantum","text":"","title":"microsoft::quantum"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#namespaces","text":"Name microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#classes","text":"Name class microsoft::quantum::AnyPattern Pattern that matches any operand. class microsoft::quantum::BasicAllocationManager class microsoft::quantum::BasicBlockPattern class microsoft::quantum::BitCastPattern class microsoft::quantum::BranchPattern class microsoft::quantum::CallPattern class microsoft::quantum::CommentLogger Concrete ILogger implementation that prints all messages as IR comments to llvm::errs(). class microsoft::quantum::ConfigBind class microsoft::quantum::ConfigurableProfileGenerator class microsoft::quantum::ConfigurationManager class microsoft::quantum::ConstIntPattern class microsoft::quantum::FactoryConfiguration struct microsoft::quantum::GroupAnalysis class microsoft::quantum::GroupingAnalysisPass class microsoft::quantum::GroupingAnalysisPassPrinter class microsoft::quantum::GroupingPass class microsoft::quantum::GroupingPassConfiguration class microsoft::quantum::IAllocationManager class microsoft::quantum::IConfigBind class microsoft::quantum::ILogger class microsoft::quantum::IntToPtrPattern class microsoft::quantum::IOperandPrototype class microsoft::quantum::IrManipulationTestHelper class microsoft::quantum::LlvmPassesConfiguration class microsoft::quantum::LoadPattern class microsoft::quantum::LogCollection class microsoft::quantum::ModuleLoader class microsoft::quantum::ParameterParser class microsoft::quantum::PhiPattern class microsoft::quantum::Profile class microsoft::quantum::ProfileGenerator class microsoft::quantum::RemoveDisallowedAttributesPass class microsoft::quantum::ReplacementRule class microsoft::quantum::RuleFactory class microsoft::quantum::RuleSet class microsoft::quantum::SelectPattern class microsoft::quantum::StorePattern class microsoft::quantum::SwitchPattern class microsoft::quantum::TransformationRulesPass class microsoft::quantum::TransformationRulesPassConfiguration Configuration class for the RuleTransformation pass. class microsoft::quantum::UnnamedInvokePattern class microsoft::quantum::ValidationPass class microsoft::quantum::ValidationPassConfiguration class microsoft::quantum::Validator","title":"Classes"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#types","text":"Name using std::string String using RuleFactory::ReplacementRulePtr ReplacementRulePtr","title":"Types"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#functions","text":"Name void ltrim (std::string & str) void rtrim (std::string & str) void trim (std::string & s)","title":"Functions"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#types-documentation","text":"","title":"Types Documentation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#using-string","text":"using microsoft::quantum::String = typedef std::string;","title":"using String"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#using-replacementruleptr","text":"using microsoft::quantum::ReplacementRulePtr = typedef RuleFactory::ReplacementRulePtr;","title":"using ReplacementRulePtr"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#function-ltrim","text":"inline void ltrim( std::string & str )","title":"function ltrim"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#function-rtrim","text":"inline void rtrim( std::string & str )","title":"function rtrim"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#function-trim","text":"inline void trim( std::string & s ) Updated on 22 March 2022 at 08:31:22 UTC","title":"function trim"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1_0d33/","text":"microsoft::quantum::@33 Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::@33"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1_0d33/#microsoftquantum33","text":"Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::@33"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/","text":"microsoft::quantum::notation More... Classes Name class microsoft::quantum::notation::Capture Types Name typedef std::shared_ptr< IOperandPrototype > IOperandPrototypePtr using std::function< bool( ReplacementRule::Builder &, ReplacementRule::Value *, ReplacementRule::Captures &, ReplacementRule::Replacements &)> ReplacerFunction Functions Name IOperandPrototypePtr basicBlock () Matches a load instruction with one argument. IOperandPrototypePtr bitCast (IOperandPrototypePtr const & arg) Matches the llvm::BitCast instructruction. IOperandPrototypePtr branch (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a branch instruction given a condition and two arguments. template <typename... Args> IOperandPrototypePtr call (std::string const & name, Args... args) IOperandPrototypePtr callByNameOnly (std::string const & name) Capture operator\"\"_cap (char const * name, std::size_t ) IOperandPrototypePtr constInt () Matches the llvm::ConstantInt instructruction. IOperandPrototypePtr intToPtr (IOperandPrototypePtr const & arg) Matches the llvm::IntToPtr instructruction. IOperandPrototypePtr load (IOperandPrototypePtr const & arg) Matches a load instruction with one argument. ReplacerFunction deleteInstruction () IOperandPrototypePtr unnamedInvoke () Matches a invoke instruction. template <typename... Args> IOperandPrototypePtr phi (Args... args) Matches a phi node with N arguments. IOperandPrototypePtr switchOp (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) IOperandPrototypePtr select (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a select instruction given a condition and two arguments. IOperandPrototypePtr store (IOperandPrototypePtr const & target, IOperandPrototypePtr const & value) Attributes Name const std::shared_ptr< AnyPattern > _ Detailed Description Shorthand notations to make it easy and readible to create patterns. Types Documentation typedef IOperandPrototypePtr typedef std::shared_ptr< IOperandPrototype > microsoft::quantum::notation::IOperandPrototypePtr; using ReplacerFunction using microsoft::quantum::notation::ReplacerFunction = typedef std::function<bool( ReplacementRule::Builder&, ReplacementRule::Value*, ReplacementRule::Captures&, ReplacementRule::Replacements&)>; Functions Documentation function basicBlock IOperandPrototypePtr basicBlock() Matches a load instruction with one argument. function bitCast IOperandPrototypePtr bitCast( IOperandPrototypePtr const & arg ) Matches the llvm::BitCast instructruction. function branch IOperandPrototypePtr branch( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a branch instruction given a condition and two arguments. function call template <typename... Args> IOperandPrototypePtr call( std::string const & name, Args... args ) Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern auto get_one = call(\"__quantum__rt__result_get_one\"); addRule( {branch(\"cond\"_cap = call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), _, _), replace_branch_positive}); which matches IRs of the form %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: cond , result and one each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function). Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments. Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments. function callByNameOnly IOperandPrototypePtr callByNameOnly( std::string const & name ) Shorthand notation to match an instruction with a specified name. Unlike call, this pattern matches by name only and ignore the arguments. addRule({callByNameOnly(\"foo\"), deleteInstruction()}); matches calls to the function foo regardless of the number of arguments. function operator\"\"_cap Capture operator\"\"_cap( char const * name, std::size_t ) Literal for specifying the capture of a llvm::Value*. This literal calls the IOperandPrototype::enableCapture through the assignment of a IOperandPrototypePtr to the class Capture . As an example, one may want to match the pattern foo(bar(baz(x)), y) and extract the variable x to add meta data to it. The corresponding IR could look like: %1 = call %Type* @baz(%Type* %0) %2 = call %Type* @bar(%Type* %1) call void @foo(%Type* %2, %Type* %3) To match this pattern, one would create the pattern call(\"foo\", call(\"bar\", call(\"baz\", \"x\"_cap = _)), _) . This pattern would ensure that at the time where the replacer function is called, the value stored in %0 is captured under the name x . function constInt IOperandPrototypePtr constInt() Matches the llvm::ConstantInt instructruction. function intToPtr IOperandPrototypePtr intToPtr( IOperandPrototypePtr const & arg ) Matches the llvm::IntToPtr instructruction. function load IOperandPrototypePtr load( IOperandPrototypePtr const & arg ) Matches a load instruction with one argument. function deleteInstruction ReplacerFunction deleteInstruction() Shorthand notation to delete an instruction. If passed as the replacement function, this function generates a replacer that deletes the instruction. This is a shorthand notation for deleting an instruction that can be used with a custom rule when building a ruleset. This function can be used with shorthand notation for patterns as follows: addRule({callByNameOnly(name), deleteInstruction()}); to delete the instructions that calls functions with the name name . function unnamedInvoke IOperandPrototypePtr unnamedInvoke() Matches a invoke instruction. function phi template <typename... Args> IOperandPrototypePtr phi( Args... args ) Matches a phi node with N arguments. function switchOp IOperandPrototypePtr switchOp( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) function select IOperandPrototypePtr select( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a select instruction given a condition and two arguments. function store IOperandPrototypePtr store( IOperandPrototypePtr const & target, IOperandPrototypePtr const & value ) Matches a store instruction with a target and a value. addRule({store(\"target\"_cap = _, \"value\"_cap = _), replaceConstExpr}); where we want to match all store instructions and do not really care about how the target or value came about. In this case, we may want to capture the values to, for instance, make assignment at compile time. Attributes Documentation variable _ static const std::shared_ptr< AnyPattern > _ = std::make_shared<[AnyPattern](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/)>(); Shorthand notation for a wildcard which matches anything. This value is useful when for instance capturing the arguments of a function call where the origin of the value does not matter to the pattern. Updated on 22 March 2022 at 08:31:22 UTC","title":"microsoft::quantum::notation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#microsoftquantumnotation","text":"More...","title":"microsoft::quantum::notation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#classes","text":"Name class microsoft::quantum::notation::Capture","title":"Classes"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#types","text":"Name typedef std::shared_ptr< IOperandPrototype > IOperandPrototypePtr using std::function< bool( ReplacementRule::Builder &, ReplacementRule::Value *, ReplacementRule::Captures &, ReplacementRule::Replacements &)> ReplacerFunction","title":"Types"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#functions","text":"Name IOperandPrototypePtr basicBlock () Matches a load instruction with one argument. IOperandPrototypePtr bitCast (IOperandPrototypePtr const & arg) Matches the llvm::BitCast instructruction. IOperandPrototypePtr branch (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a branch instruction given a condition and two arguments. template <typename... Args> IOperandPrototypePtr call (std::string const & name, Args... args) IOperandPrototypePtr callByNameOnly (std::string const & name) Capture operator\"\"_cap (char const * name, std::size_t ) IOperandPrototypePtr constInt () Matches the llvm::ConstantInt instructruction. IOperandPrototypePtr intToPtr (IOperandPrototypePtr const & arg) Matches the llvm::IntToPtr instructruction. IOperandPrototypePtr load (IOperandPrototypePtr const & arg) Matches a load instruction with one argument. ReplacerFunction deleteInstruction () IOperandPrototypePtr unnamedInvoke () Matches a invoke instruction. template <typename... Args> IOperandPrototypePtr phi (Args... args) Matches a phi node with N arguments. IOperandPrototypePtr switchOp (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) IOperandPrototypePtr select (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a select instruction given a condition and two arguments. IOperandPrototypePtr store (IOperandPrototypePtr const & target, IOperandPrototypePtr const & value)","title":"Functions"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#attributes","text":"Name const std::shared_ptr< AnyPattern > _","title":"Attributes"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#detailed-description","text":"Shorthand notations to make it easy and readible to create patterns.","title":"Detailed Description"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#types-documentation","text":"","title":"Types Documentation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#typedef-ioperandprototypeptr","text":"typedef std::shared_ptr< IOperandPrototype > microsoft::quantum::notation::IOperandPrototypePtr;","title":"typedef IOperandPrototypePtr"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#using-replacerfunction","text":"using microsoft::quantum::notation::ReplacerFunction = typedef std::function<bool( ReplacementRule::Builder&, ReplacementRule::Value*, ReplacementRule::Captures&, ReplacementRule::Replacements&)>;","title":"using ReplacerFunction"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-basicblock","text":"IOperandPrototypePtr basicBlock() Matches a load instruction with one argument.","title":"function basicBlock"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-bitcast","text":"IOperandPrototypePtr bitCast( IOperandPrototypePtr const & arg ) Matches the llvm::BitCast instructruction.","title":"function bitCast"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-branch","text":"IOperandPrototypePtr branch( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a branch instruction given a condition and two arguments.","title":"function branch"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-call","text":"template <typename... Args> IOperandPrototypePtr call( std::string const & name, Args... args ) Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern auto get_one = call(\"__quantum__rt__result_get_one\"); addRule( {branch(\"cond\"_cap = call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), _, _), replace_branch_positive}); which matches IRs of the form %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: cond , result and one each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function). Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments. Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments.","title":"function call"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-callbynameonly","text":"IOperandPrototypePtr callByNameOnly( std::string const & name ) Shorthand notation to match an instruction with a specified name. Unlike call, this pattern matches by name only and ignore the arguments. addRule({callByNameOnly(\"foo\"), deleteInstruction()}); matches calls to the function foo regardless of the number of arguments.","title":"function callByNameOnly"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-operator_cap","text":"Capture operator\"\"_cap( char const * name, std::size_t ) Literal for specifying the capture of a llvm::Value*. This literal calls the IOperandPrototype::enableCapture through the assignment of a IOperandPrototypePtr to the class Capture . As an example, one may want to match the pattern foo(bar(baz(x)), y) and extract the variable x to add meta data to it. The corresponding IR could look like: %1 = call %Type* @baz(%Type* %0) %2 = call %Type* @bar(%Type* %1) call void @foo(%Type* %2, %Type* %3) To match this pattern, one would create the pattern call(\"foo\", call(\"bar\", call(\"baz\", \"x\"_cap = _)), _) . This pattern would ensure that at the time where the replacer function is called, the value stored in %0 is captured under the name x .","title":"function operator\"\"_cap"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-constint","text":"IOperandPrototypePtr constInt() Matches the llvm::ConstantInt instructruction.","title":"function constInt"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-inttoptr","text":"IOperandPrototypePtr intToPtr( IOperandPrototypePtr const & arg ) Matches the llvm::IntToPtr instructruction.","title":"function intToPtr"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-load","text":"IOperandPrototypePtr load( IOperandPrototypePtr const & arg ) Matches a load instruction with one argument.","title":"function load"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-deleteinstruction","text":"ReplacerFunction deleteInstruction() Shorthand notation to delete an instruction. If passed as the replacement function, this function generates a replacer that deletes the instruction. This is a shorthand notation for deleting an instruction that can be used with a custom rule when building a ruleset. This function can be used with shorthand notation for patterns as follows: addRule({callByNameOnly(name), deleteInstruction()}); to delete the instructions that calls functions with the name name .","title":"function deleteInstruction"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-unnamedinvoke","text":"IOperandPrototypePtr unnamedInvoke() Matches a invoke instruction.","title":"function unnamedInvoke"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-phi","text":"template <typename... Args> IOperandPrototypePtr phi( Args... args ) Matches a phi node with N arguments.","title":"function phi"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-switchop","text":"IOperandPrototypePtr switchOp( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 )","title":"function switchOp"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-select","text":"IOperandPrototypePtr select( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a select instruction given a condition and two arguments.","title":"function select"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-store","text":"IOperandPrototypePtr store( IOperandPrototypePtr const & target, IOperandPrototypePtr const & value ) Matches a store instruction with a target and a value. addRule({store(\"target\"_cap = _, \"value\"_cap = _), replaceConstExpr}); where we want to match all store instructions and do not really care about how the target or value came about. In this case, we may want to capture the values to, for instance, make assignment at compile time.","title":"function store"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#variable-_","text":"static const std::shared_ptr< AnyPattern > _ = std::make_shared<[AnyPattern](/qat/Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/)>(); Shorthand notation for a wildcard which matches anything. This value is useful when for instance capturing the arguments of a function call where the origin of the value does not matter to the pattern. Updated on 22 March 2022 at 08:31:22 UTC","title":"variable _"},{"location":"Api/Pages/","text":"Pages Updated on 22 March 2022 at 08:31:22 UTC","title":"Pages"},{"location":"Api/Pages/#pages","text":"Updated on 22 March 2022 at 08:31:22 UTC","title":"Pages"},{"location":"DeveloperGuide/ArchitectureOverview/","text":"Architecture Overview This document assumes familiarity with LLVM, LLVM intermediate representation (IR) , LLVM passes and the opt tool which is used to apply passes to IRs. We also assume that the reader is familiar with the QIR specification , the conventions used for functions and its opaque types. We further assume that the reader is familiar with basic C++. This is in particular true later on when we dig into the details of building pass components. Throughout this document we will assume that any reference to a QIR, is a valid within the specification requirements. The aim of this document is to walk the reader through the vision and architecture of the QIR adaptor tool (QAT). To this end, we will be discussing how QAT uses both built-in and custom written LLVM passes to transform generic QIRs into ones which are targeted specific platforms and/or capabilities. We refer to any generic QIR as just \"the QIR\" or the generic QIR where as those target for specific platforms and/or capabilities, we call specialised QIRs. The description of the requirements for the specialised QIR we call a QIR profile. When we talk about applying a profile to a generic QIR, we talk about the process which transform the generic QIR into the specialised one. Likewise, when we talk about validating that a specialised QIR fulfils the description of a profile. In building QAT, we note that there are two main challenges to overcome: Applying a profile to a generic QIR, and, Validating that a QIR is compliant with a profile specification. We may on occasion refer to the former as a transformation and the latter as an analysis to clarify the similarity to LLVM passes. The architecture described in this document attempts to address both of these challenges in way that we believe to be customisable and scalable in terms of profile requirements. Before digging into the details of the design of QAT, we first note that LLVM\u00f8s opt has many of the properties that we desire: Modularised, extendable in a non-invasive manner and differentiates between analysis and transformation. The downsides to opt is that we cannot pass a configuration to the individual passes, it is difficult to control which concrete passes are ran and, under the assumption that a profile is described by a collection of passes, there is no elegant way to bundle these into a single argument. In our design, it will be our goal to preserve the good aspects of opt while adding the capabilities we miss to make profile transformations and validation. Before spelling the system requirements out, we consider a couple of examples of what we may need for functionality. Example: Function inlining Let us first consider the case of quantum architecture that does not support classical function calls. That is, a valid program must be all inlined. This is a task that can be handled by opt by supplying the command line argument --always-inline . This flag turns the inline pipeline on and attempts to inline as many function calls as possible. For QAT to be a useful tool, we would want a similar mechanism that allows to activate or deactivate existing (and new) LLVM passes. We would thus need something like qat --always-inline --apply -S filename.ll where --apply tells the tool to apply the profile and -S tells the tool to emit human readable LLVM IR code. Furthermore, if the inline pass is provided as an external module, we would need to be able load it qat --always-inline --load path/to/lib.(dylib|so|dll) --apply -S filename.ll We note that from a developer point of view, the underlying code would also need a way to let QAT know that it expects a command line argument --always-inline/--no-always-inline . Example: Static qubit allocation To get a better understanding of the problem at hand, let us examine another example: Qubit allocation. As we run our quantum program, we may use a simulator or we may deploy it on one of the hardware providers. Depending on whether we are running in one environment or the other, qubits are different entities: In a computer simulation they are often objects. They could for instance be allocated on the heap in a non-sequential manner. In this context, it makes sense to talk about a qubits life time through instructions that allocates and releases them. On hardware, on the other hand, qubits are physical entities typically sequentially enumerated from 0 to N - 1. Physical qubits may (or may not) have the constraint some qubits are unavailable to the user. Though not always, hardware may further have the constraint that user can only perform a single measurement at the end of the program execution. This means that qubits cannot be reused within one program execution. This puts requirements on what we may need from static qubit allocation. For any static allocation, we would need at least following information: Whether or not to map qubits to fixed integers Reuse qubits or not List unavailable qubits It is not hard to imagine that this could be extended even further by imposing customised allocation schemes. In contrast to the previous example, this example requires a much more detailed configuration to define the mode of operation. One could for instance imagine something along the lines of qat --use-static-allocation --reuse-qubits --defect-qubits 3,7,9 --max-qubits 10 --apply -S filename.ll Hence, unlike normal LLVM passes, we will need a detailed configuration to be passed along with the transformation. Design requirements To distinguish between LLVM passes and QAT extensions, we will refer to QAT extensions as profile components. A profile component may consist of several passes and furthermore should be accompanied by a configuration to describe its behaviour. Like LLVM opt we require that QAT must be extensible through dynamic libraries. This allow third party to easily extend the tool to their needs while benefiting from the components that QAT ships with. Architecture description TODO(issue-9): Yet to be written","title":"Architecture Overview"},{"location":"DeveloperGuide/ArchitectureOverview/#architecture-overview","text":"This document assumes familiarity with LLVM, LLVM intermediate representation (IR) , LLVM passes and the opt tool which is used to apply passes to IRs. We also assume that the reader is familiar with the QIR specification , the conventions used for functions and its opaque types. We further assume that the reader is familiar with basic C++. This is in particular true later on when we dig into the details of building pass components. Throughout this document we will assume that any reference to a QIR, is a valid within the specification requirements. The aim of this document is to walk the reader through the vision and architecture of the QIR adaptor tool (QAT). To this end, we will be discussing how QAT uses both built-in and custom written LLVM passes to transform generic QIRs into ones which are targeted specific platforms and/or capabilities. We refer to any generic QIR as just \"the QIR\" or the generic QIR where as those target for specific platforms and/or capabilities, we call specialised QIRs. The description of the requirements for the specialised QIR we call a QIR profile. When we talk about applying a profile to a generic QIR, we talk about the process which transform the generic QIR into the specialised one. Likewise, when we talk about validating that a specialised QIR fulfils the description of a profile. In building QAT, we note that there are two main challenges to overcome: Applying a profile to a generic QIR, and, Validating that a QIR is compliant with a profile specification. We may on occasion refer to the former as a transformation and the latter as an analysis to clarify the similarity to LLVM passes. The architecture described in this document attempts to address both of these challenges in way that we believe to be customisable and scalable in terms of profile requirements. Before digging into the details of the design of QAT, we first note that LLVM\u00f8s opt has many of the properties that we desire: Modularised, extendable in a non-invasive manner and differentiates between analysis and transformation. The downsides to opt is that we cannot pass a configuration to the individual passes, it is difficult to control which concrete passes are ran and, under the assumption that a profile is described by a collection of passes, there is no elegant way to bundle these into a single argument. In our design, it will be our goal to preserve the good aspects of opt while adding the capabilities we miss to make profile transformations and validation. Before spelling the system requirements out, we consider a couple of examples of what we may need for functionality.","title":"Architecture Overview"},{"location":"DeveloperGuide/ArchitectureOverview/#example-function-inlining","text":"Let us first consider the case of quantum architecture that does not support classical function calls. That is, a valid program must be all inlined. This is a task that can be handled by opt by supplying the command line argument --always-inline . This flag turns the inline pipeline on and attempts to inline as many function calls as possible. For QAT to be a useful tool, we would want a similar mechanism that allows to activate or deactivate existing (and new) LLVM passes. We would thus need something like qat --always-inline --apply -S filename.ll where --apply tells the tool to apply the profile and -S tells the tool to emit human readable LLVM IR code. Furthermore, if the inline pass is provided as an external module, we would need to be able load it qat --always-inline --load path/to/lib.(dylib|so|dll) --apply -S filename.ll We note that from a developer point of view, the underlying code would also need a way to let QAT know that it expects a command line argument --always-inline/--no-always-inline .","title":"Example: Function inlining"},{"location":"DeveloperGuide/ArchitectureOverview/#example-static-qubit-allocation","text":"To get a better understanding of the problem at hand, let us examine another example: Qubit allocation. As we run our quantum program, we may use a simulator or we may deploy it on one of the hardware providers. Depending on whether we are running in one environment or the other, qubits are different entities: In a computer simulation they are often objects. They could for instance be allocated on the heap in a non-sequential manner. In this context, it makes sense to talk about a qubits life time through instructions that allocates and releases them. On hardware, on the other hand, qubits are physical entities typically sequentially enumerated from 0 to N - 1. Physical qubits may (or may not) have the constraint some qubits are unavailable to the user. Though not always, hardware may further have the constraint that user can only perform a single measurement at the end of the program execution. This means that qubits cannot be reused within one program execution. This puts requirements on what we may need from static qubit allocation. For any static allocation, we would need at least following information: Whether or not to map qubits to fixed integers Reuse qubits or not List unavailable qubits It is not hard to imagine that this could be extended even further by imposing customised allocation schemes. In contrast to the previous example, this example requires a much more detailed configuration to define the mode of operation. One could for instance imagine something along the lines of qat --use-static-allocation --reuse-qubits --defect-qubits 3,7,9 --max-qubits 10 --apply -S filename.ll Hence, unlike normal LLVM passes, we will need a detailed configuration to be passed along with the transformation.","title":"Example: Static qubit allocation"},{"location":"DeveloperGuide/ArchitectureOverview/#design-requirements","text":"To distinguish between LLVM passes and QAT extensions, we will refer to QAT extensions as profile components. A profile component may consist of several passes and furthermore should be accompanied by a configuration to describe its behaviour. Like LLVM opt we require that QAT must be extensible through dynamic libraries. This allow third party to easily extend the tool to their needs while benefiting from the components that QAT ships with.","title":"Design requirements"},{"location":"DeveloperGuide/ArchitectureOverview/#architecture-description","text":"TODO(issue-9): Yet to be written","title":"Architecture description"},{"location":"DeveloperGuide/CodeQuality/","text":"Code quality and continuous integration Using the manage tool Before making a pull request with changes to this library, please ensure that style checks passes, that the code compiles, unit test passes and that there are no erros found by the static analyser. To setup the CI environment, run following commands virtualenv develop__venv source develop__venv/bin/activate pip install -r requirements.txt These adds the necessary environment variables to ensure that you have the tasks_ci package (contained in site-packages/ inside the repo) and all required dependencies. To check the style, run ./manage stylecheck To test that the code compiles and tests passes run ./manage test Finally, to analyse the code, run ./manage lint You can run all processes by running: ./manage runci As clang-tidy and clang-format acts slightly different from version to version and on different platforms, it is recommended that you use a Docker image to perform these steps. TODO(issue-10): The Docker image is not added yet and this will be documented in the future. Running tests In order to run the tests, you first need to build the library. Assuming that this is already done and the corresponding build is in Debug/ , run the tests from the Debug folder: lit tests/ -v -- Testing: 2 tests, 2 workers -- PASS: Quantum-Passes :: QirAllocationAnalysis/case1.ll (1 of 2) PASS: Quantum-Passes :: QirAllocationAnalysis/case2.ll (2 of 2) Testing Time: 0.27s Passed: 2 The C++ test suite can also be ran from the debug by first building all targets: cmake .. make and then running following command: ctest Writing C++ tests TODO(issue-11): Write this section Modifying code quality requirements The continuous integration component includes: Style formatting to ensure that everything looks the same. This includes checking that relevant copyright notices are in place. Static analysis Unit testing The automatic style enforcement is configurable with the ability to easily add or remove rules. Currently the source pipelines are defined as: SOURCE_PIPELINES = [ { \"name\": \"C++ Main\", \"src\": path.join(PROJECT_ROOT, \"qir/qat\"), \"pipelines\": { \"hpp\": [ require_pragma_once, enforce_cpp_license, enforce_formatting ], \"cpp\": [ enforce_cpp_license, enforce_formatting ] } }, # ... ] This part defines pipelines for .hpp files and .cpp files allowing the developer to add such requirements as having copyright in the op of the source file and ensure that formatting follows that given by .clang-format . Each of these CI stages can be executed individually using ./manage or you can run the entire CI process by invoking ./manage runci . An example of what this may look like is here: ./manage runci 2021-07-21 14:38:04,896 - FormatChecker - ERROR - /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/src/OpsCounter/OpsCounter.cpp was not correctly formatted. 2021-07-21 14:38:04,899 - FormatChecker - ERROR - Your code did not pass formatting. ./manage stylecheck --fix-issues ./manage runci -- Found LLVM 11.1.0 -- Using LLVMConfig.cmake in: /usr/local/opt/llvm@11/lib/cmake/llvm -- Configuring done -- Generating done -- Build files have been written to: /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/Debug Consolidate compiler generated dependencies of target QSharpPasses [ 50%] Building CXX object CMakeFiles/QSharpPasses.dir/src/OpsCounter/OpsCounter.cpp.o [100%] Linking CXX shared library libQSharpPasses.dylib ld: warning: directory not found for option '-L/usr/local/opt/llvm/lib' [100%] Built target QSharpPasses /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/src/OpsCounter/OpsCounter.cpp:29:7: error: invalid case style for class 'LegacyOpsCounterPass' [readability-identifier-naming,-warnings-as-errors] class LegacyOpsCounterPass : public FunctionPass ^~~~~~~~~~~~~~~~~~~~ CLegacyOpsCounterPass 113345 warnings generated. Suppressed 113345 warnings (113344 in non-user code, 1 NOLINT). Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well. 1 warning treated as error 2021-07-21 14:38:40,191 - Linter - ERROR - /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/src/OpsCounter/OpsCounter.cpp failed static analysis # ISSUES FIXED MANUALLY ./manage runci -- Found LLVM 11.1.0 -- Using LLVMConfig.cmake in: /usr/local/opt/llvm@11/lib/cmake/llvm -- Configuring done -- Generating done -- Build files have been written to: /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/Debug Consolidate compiler generated dependencies of target QSharpPasses [ 50%] Building CXX object CMakeFiles/QSharpPasses.dir/src/OpsCounter/OpsCounter.cpp.o [100%] Linking CXX shared library libQSharpPasses.dylib ld: warning: directory not found for option '-L/usr/local/opt/llvm/lib' [100%] Built target QSharpPasses -- Found LLVM 11.1.0 -- Using LLVMConfig.cmake in: /usr/local/opt/llvm@11/lib/cmake/llvm -- Configuring done -- Generating done -- Build files have been written to: /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/Debug Consolidate compiler generated dependencies of target QSharpPasses [100%] Built target QSharpPasses ********************************* No test configuration file found! ********************************* The key idea here is to make it extremely easy to be compliant with the style guide, correct any issues that might come as a result of static analysis and at the same time enforce this when a PR is made.","title":"Code quality"},{"location":"DeveloperGuide/CodeQuality/#code-quality-and-continuous-integration","text":"","title":"Code quality and continuous integration"},{"location":"DeveloperGuide/CodeQuality/#using-the-manage-tool","text":"Before making a pull request with changes to this library, please ensure that style checks passes, that the code compiles, unit test passes and that there are no erros found by the static analyser. To setup the CI environment, run following commands virtualenv develop__venv source develop__venv/bin/activate pip install -r requirements.txt These adds the necessary environment variables to ensure that you have the tasks_ci package (contained in site-packages/ inside the repo) and all required dependencies. To check the style, run ./manage stylecheck To test that the code compiles and tests passes run ./manage test Finally, to analyse the code, run ./manage lint You can run all processes by running: ./manage runci As clang-tidy and clang-format acts slightly different from version to version and on different platforms, it is recommended that you use a Docker image to perform these steps. TODO(issue-10): The Docker image is not added yet and this will be documented in the future.","title":"Using the manage tool"},{"location":"DeveloperGuide/CodeQuality/#running-tests","text":"In order to run the tests, you first need to build the library. Assuming that this is already done and the corresponding build is in Debug/ , run the tests from the Debug folder: lit tests/ -v -- Testing: 2 tests, 2 workers -- PASS: Quantum-Passes :: QirAllocationAnalysis/case1.ll (1 of 2) PASS: Quantum-Passes :: QirAllocationAnalysis/case2.ll (2 of 2) Testing Time: 0.27s Passed: 2 The C++ test suite can also be ran from the debug by first building all targets: cmake .. make and then running following command: ctest","title":"Running tests"},{"location":"DeveloperGuide/CodeQuality/#writing-c-tests","text":"TODO(issue-11): Write this section","title":"Writing C++ tests"},{"location":"DeveloperGuide/CodeQuality/#modifying-code-quality-requirements","text":"The continuous integration component includes: Style formatting to ensure that everything looks the same. This includes checking that relevant copyright notices are in place. Static analysis Unit testing The automatic style enforcement is configurable with the ability to easily add or remove rules. Currently the source pipelines are defined as: SOURCE_PIPELINES = [ { \"name\": \"C++ Main\", \"src\": path.join(PROJECT_ROOT, \"qir/qat\"), \"pipelines\": { \"hpp\": [ require_pragma_once, enforce_cpp_license, enforce_formatting ], \"cpp\": [ enforce_cpp_license, enforce_formatting ] } }, # ... ] This part defines pipelines for .hpp files and .cpp files allowing the developer to add such requirements as having copyright in the op of the source file and ensure that formatting follows that given by .clang-format . Each of these CI stages can be executed individually using ./manage or you can run the entire CI process by invoking ./manage runci . An example of what this may look like is here: ./manage runci 2021-07-21 14:38:04,896 - FormatChecker - ERROR - /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/src/OpsCounter/OpsCounter.cpp was not correctly formatted. 2021-07-21 14:38:04,899 - FormatChecker - ERROR - Your code did not pass formatting. ./manage stylecheck --fix-issues ./manage runci -- Found LLVM 11.1.0 -- Using LLVMConfig.cmake in: /usr/local/opt/llvm@11/lib/cmake/llvm -- Configuring done -- Generating done -- Build files have been written to: /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/Debug Consolidate compiler generated dependencies of target QSharpPasses [ 50%] Building CXX object CMakeFiles/QSharpPasses.dir/src/OpsCounter/OpsCounter.cpp.o [100%] Linking CXX shared library libQSharpPasses.dylib ld: warning: directory not found for option '-L/usr/local/opt/llvm/lib' [100%] Built target QSharpPasses /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/src/OpsCounter/OpsCounter.cpp:29:7: error: invalid case style for class 'LegacyOpsCounterPass' [readability-identifier-naming,-warnings-as-errors] class LegacyOpsCounterPass : public FunctionPass ^~~~~~~~~~~~~~~~~~~~ CLegacyOpsCounterPass 113345 warnings generated. Suppressed 113345 warnings (113344 in non-user code, 1 NOLINT). Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well. 1 warning treated as error 2021-07-21 14:38:40,191 - Linter - ERROR - /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/src/OpsCounter/OpsCounter.cpp failed static analysis # ISSUES FIXED MANUALLY ./manage runci -- Found LLVM 11.1.0 -- Using LLVMConfig.cmake in: /usr/local/opt/llvm@11/lib/cmake/llvm -- Configuring done -- Generating done -- Build files have been written to: /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/Debug Consolidate compiler generated dependencies of target QSharpPasses [ 50%] Building CXX object CMakeFiles/QSharpPasses.dir/src/OpsCounter/OpsCounter.cpp.o [100%] Linking CXX shared library libQSharpPasses.dylib ld: warning: directory not found for option '-L/usr/local/opt/llvm/lib' [100%] Built target QSharpPasses -- Found LLVM 11.1.0 -- Using LLVMConfig.cmake in: /usr/local/opt/llvm@11/lib/cmake/llvm -- Configuring done -- Generating done -- Build files have been written to: /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/Debug Consolidate compiler generated dependencies of target QSharpPasses [100%] Built target QSharpPasses ********************************* No test configuration file found! ********************************* The key idea here is to make it extremely easy to be compliant with the style guide, correct any issues that might come as a result of static analysis and at the same time enforce this when a PR is made.","title":"Modifying code quality requirements"},{"location":"DeveloperGuide/ConfigurationLibrary/","text":"","title":"Configuration Library"},{"location":"DeveloperGuide/DeveloperFAQ/","text":"Developer FAQ Pass does not load One error that you may encounter is that an analysis pass does not load with output similar to this: opt -load-pass-plugin ../../Debug/libQSharpPasses.dylib -enable-debugify --passes=\"operation-counter\" -disable-output classical-program.bc Failed to load passes from '../../Debug/libQSharpPasses.dylib'. Request ignored. opt: unknown pass name 'operation-counter' This is likely becuase you have forgotten to instantiate static class members. For instance, in the case of an instance of llvm::AnalysisInfoMixin you are required to have a static member Key : class COpsCounterPass : public llvm::AnalysisInfoMixin<COpsCounterPass> { private: static llvm::AnalysisKey Key; //< REQUIRED by llvm registration friend struct llvm::AnalysisInfoMixin<COpsCounterPass>; }; If you forget to instantiate this variable in your corresponding .cpp file, // llvm::AnalysisKey COpsCounterPass::Key; //< Uncomment this line to make everything work everything will compile, but the pass will fail to load. There will be no linking errors either.","title":"Developer FAQ"},{"location":"DeveloperGuide/DeveloperFAQ/#developer-faq","text":"","title":"Developer FAQ"},{"location":"DeveloperGuide/DeveloperFAQ/#pass-does-not-load","text":"One error that you may encounter is that an analysis pass does not load with output similar to this: opt -load-pass-plugin ../../Debug/libQSharpPasses.dylib -enable-debugify --passes=\"operation-counter\" -disable-output classical-program.bc Failed to load passes from '../../Debug/libQSharpPasses.dylib'. Request ignored. opt: unknown pass name 'operation-counter' This is likely becuase you have forgotten to instantiate static class members. For instance, in the case of an instance of llvm::AnalysisInfoMixin you are required to have a static member Key : class COpsCounterPass : public llvm::AnalysisInfoMixin<COpsCounterPass> { private: static llvm::AnalysisKey Key; //< REQUIRED by llvm registration friend struct llvm::AnalysisInfoMixin<COpsCounterPass>; }; If you forget to instantiate this variable in your corresponding .cpp file, // llvm::AnalysisKey COpsCounterPass::Key; //< Uncomment this line to make everything work everything will compile, but the pass will fail to load. There will be no linking errors either.","title":"Pass does not load"},{"location":"DeveloperGuide/LogicSeparation/","text":"QAT Application: Logic separation Architecture considerations In this section, we will discuss some classical architectures and then make considerations regarding quantum architectures. Motivation: Classical co-processors Before diving into quantum architectures, we first make a brief note on classical architectures: For decades we have seen classical architectures composed of multiple processing units. For instance, in the nineties it was common to have a co-processor supporting the main x86 architecture with such tasks as floating point operations. Other co-processing architectures were built to enhance the computers sound capabilities and in 2001, we saw graphical processing units (GPUs) emerge. To this day, GPUs are still an essentially co-processor for many computing tasks including gaming, physics simulation, and graphics to mention a few. While floating point operation co-processors eventually became integrated into the CPU, other co-processors such as GPU remains stand-alone units today. On a high-level, the use of a GPU for simulation roughly follows this diagram: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 Programming \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 State preparation \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Primary \u2502 \u2502 Secondary \u2502 \u2502 processing \u2502 \u2502 processing \u2502 \u2502 unit \u2502 \u2502 unit \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 Result readout \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 First the secondary processing unit (SPU) is programmed and as a part of this process the initial state (i.e. registers and memory) is prepared. The SPU then executes the program and the results are read out by the primary processing unit (PPU). Classical-quantum processing architecture While one could imagine a quantum architecture in which everything is integrated into a single processing unit that both can process classical and quantum registers, it is unlikely that this kind of architecture will emerge in the near future due to the vastly different environments in which the two processes take place. Therefore, one feasible architecture is one in which we consider the quantum processing unit (QPU) as SPU and the CPU the PPU much like is the case for CPUs and GPUs today. Disregarding the more advanced scenarios where PPUs and SPUs work in parallel, the basic flow of a classical-quantum program execution follows a pattern as given below: Classical PPU-SPU Quantum processing unit \u2502 interface \u2502 processing unit \u2502 \u2502 \u2502 \u2502 \u2502 Classical program \u2502 \u2502 \u2502 execution \u2502 \u2502 \u2502 \u2502 \u2502 State preparation \u2502 \u25bc \u2502 Programming \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Quantum program \u2502 \u2502 \u2502 execution \u2502 Result readout \u2502 \u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u25bc \u2502 \u2502 \u2502 Classical program \u2502 \u2502 \u2502 execution \u2502 \u2502 State preparation \u2502 \u2502 \u2502 Programming \u2502 \u25bc \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Quantum program \u2502 \u2502 \u2502 execution \u2502 Result readout \u2502 \u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u25bc \u2502 \u2502 \u25bc \u25bc Time We note that in some cases, either the state programming or the readout process may be not contain instructions. In these cases, blocks with state programming and/or readout will simply be empty and therefore it has no influence on the general structure. Problem definition The QIR specification does not put any requirements for a generic QIR to provide a separation of instructions intended for the CPU and QPU. However, under the assumption that quantum architectures follow the PPU-SPU pattern described in the previous section such a separation is necessary to perform the program execution. Our aim in this document will be to define how the separation should be performed and what qualifies an entity to be a CPU or QPU element. We will assume that branching is not possible within the QPU since this is a classical phenomenon. The consequence is that CPU-QPU separation must happen at the level of BasicBlocks in LLVM rather than at a function or even program level. While it may be that some QPUs have basic branching support, we note that it will be manageable to identify multi-block segments which are compatible with a given QPU target after the separation. Definitions Registers For traditional PPU-SPU architectures, registers are limited in scope to the processing unit on which they reside. That is, a register on a CPU cannot be accessed from the GPU and vice versa. The value of a given register is only available through data transport through the two units. For CPU-QPU architectures, this limitation is the same. While the CPU may hold a reference to a qubit, the physical qubit itself resides on the QPU and can only be manipulated through the CPU-QPU interface. Quantum register types LLVM type name Description Qubit* Qubit register amounting to a physical qubit or simulation data type Result* Result register Classical register types LLVM type name Description i1 i2 i8 i16 i32 i64 struct On the CPU, Qubit* and Result* are treated as integers. This means that they should never be dereferenced nor should the \"memory address\" be written to. Instructions and instruction classification The QIR specification has two high-level classes of instructions: Those which are calls to functions with names starting with __quantum__ and all other instructions. Function calls to functions starting with __quantum__ are expected to follow the QIR specification and these calls are further divided into two groups: Intrinsic functions ( __quantum__qis__ ) and runtime functions ( __quantum__rt__ ). The latter are expected to be provided by the runtime library given by the frontend and/or the target machine, whereas the former are intrinsic functions. The intrinsic functions may either run on the CPU, the QPU or serve as instruction to transfer data between the two processing units. We classify __quantum__qis__ functions into four categories: Purely CPU, purely QPU, setup/transport from CPU to QPU and result/transport from QPU to CPU. The classification happens on the basis of the function signature: The function arguments together with the return result determine where the call will be executed according to following rules: Any void function location is purely determined by its arguments: Void functions that only have quantum register types as arguments are classified as pure QPU instructions Void functions that only have classical register types as arguments are classified as pure CPU instructions Void functions that takes a mixture are classified as CPU to QPU setup/transport instructions Any function that returns a quantum register is: A pure quantum instruction if all of the function arguments are quantum registers A CPU to QPU setup/transport instruction in any other case A function that returns a classical register is: A pure classical instruction if all of the arguments are classical registers A QPU to CPU result/transport instruction in any other case Pass definition As an example we will consider following code block: define i64 @LogicGrouping(i64 %z) local_unnamed_addr #0 { entry: %0 = icmp slt i64 %z, 0 %a1.i.i = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %a2.i.i = select i1 %0, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null tail call void @__quantum__qis__x__body(%Qubit* %a1.i.i) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %a1.i.i, %Qubit* %a2.i.i) tail call void @__quantum__qis__mz__body(%Qubit* %a2.i.i, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* %a2.i.i) %1 = tail call i1 @__quantum__qis__read_result__body(%Result* null) %2 = mul i64 %z, 45 %.op.op.i.i = add i64 %2, 13 %3 = select i1 %1, i64 -7, i64 %.op.op.i.i ret i64 %3 } In the above 2-qubit ( 0 and 1 ) circuit, we use a classical parameter to decide which qubit should be the control qubit ( a1 ) and which is the target ( a2 ). We apply an X gate to the control qubit and then apply a Z gate to the qubit with id 0 regardless of whether it is the control or target qubit. This is followed by a CNOT gate and finally a measurement. The result from the measurement is used to compute a classical result. Our goal is now to separate instructions into blocks of pure quantum instructions, pure classical instructions and data transfer. The data transfer blocks can be thought of as a mix of classical and quantum instructions as these may manipulate registers on either the CPU or QPU. For the above example code, we envision a separation similar to following code snippet: define i64 @LogicGrouping(i64 %z) local_unnamed_addr #0 { entry: %0 = icmp slt i64 %z, 0 %1 = mul i64 %z, 45 %2 = add i64 %1, 13 br label %load load: ; preds = %entry %3 = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %4 = select i1 %0, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null br label %quantum quantum: ; preds = %load tail call void @__quantum__qis__x__body(%Qubit* %3) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %3, %Qubit* %4) tail call void @__quantum__qis__mz__body(%Qubit* %4, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* %4) br label %readout readout: ; preds = %quantum %5 = tail call i1 @__quantum__qis__read_result__body(%Result* null) br label %post-classical post-classical: ; preds = %readout %6 = select i1 %5, i64 -7, i64 %2 br label %exit_quantum_grouping exit_quantum_grouping: ; preds = %post-classical ret i64 %6 } In the above program, the original instructions are rearranged into blocks following the pattern previously discussed with an entry block, a load block, a quantum program block, a readout block and a post-classical processing block. Visualized as above, the blocks are executed as follows: Classical PPU-SPU Quantum processing unit \u2502 interface \u2502 processing unit \u2502 \u2502 entry\u2502 \u2502 \u2502 \u25bc \u2502 load \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 readout \u2502 \u2502 quantum \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u25bc post-classical \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 exit-grouping \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 \u25bc \u25bc Time With this separation, it becomes straight-forward to execute the program parts in accordance with the required processing unit as well as to ensure that proper setup of the QPU was performed before initiating the quantum calculation. Block Separation Strategy Our block separation strategy follows a divide-and-conquer approach: First we sort instructions into new blocks according to the source processing. Each of these blocks are then sub-divided based on the destination processing unit. We illustrate this in the following diagram: 1st split 2nd split \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502Classical \u2502 entry \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u25b6\u2502 Dest \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502Classical \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u25b6\u2502 Source \u251c\u2500\u2524 \u2502 Quantum \u2502 load \u2502 \u2502 \u2502 \u2514\u2500\u25b6\u2502 Dest \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Quantum \u2502 quantum \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u25b6\u2502 Dest \u2502 \u2502 Original \u2502 \u2502 \u2502 Quantum \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 block \u2502\u2500\u2500\u253c\u2500\u25b6\u2502 Source \u251c\u2500\u2524 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502Classical \u2502 readout \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u25b6\u2502 Dest \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502Classical \u2502 post-classical \u2502 \u2502Classical \u2502 \u250c\u2500\u25b6\u2502 Dest \u2502 \u2514\u2500\u25b6\u2502 Source \u2502\u2500\u2524 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 Empty (QD)\u2502 \u2514\u2500\u25b6\u2502 \u2500 \u2500 \u2500 \u2500 \u2500 \u2518 We note the second split is reversed depending type of instructions it contains. We order instruction blocks (during the second split) such that instructions whose source and destination processing units are the same come first. We note that the second split is technically easier to make as the blocks processed in the first split already have certain guarantees provided: We are guaranteed that we only need to make one split We are guaranteed that the order of all dependencies is preserved when splitting instructions into the two blocks The first split is more involved as we need to identify dependencies between classical and quantum circuits and may end up with an output similar to: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502Classical \u2502 \u250c\u2500\u25b6\u2502 Source \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 Quantum \u2502 \u251c\u2500\u25b6\u2502 Source \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502Classical \u2502 \u251c\u2500\u25b6\u2502 Source \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Original \u2502 \u2502 \u2502 Quantum \u2502 \u2502 block \u2502\u2500\u2500\u253c\u2500\u25b6\u2502 Source \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502Classical \u2502 \u251c\u2500\u25b6\u2502 Source \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 . \u2502 . \u2502 . \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502Classical \u2502 \u2514\u2500\u25b6\u2502 Source \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 The main reason for this is that we may make a measurement and then use that measurement to decide what the next quantum circuit looks like. As an example, consider following circuit: define i64 @LogicGrouping(i64 %z) local_unnamed_addr #0 { entry: %0 = icmp slt i64 %z, 0 %a1.i.i = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %a2.i.i = select i1 %0, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null tail call void @__quantum__qis__x__body(%Qubit* %a1.i.i) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %a1.i.i, %Qubit* %a2.i.i) tail call void @__quantum__qis__mz__body(%Qubit* %a2.i.i, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* %a2.i.i) %1 = tail call i1 @__quantum__qis__read_result__body(%Result* null) %a3.i.i = select i1 %1, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null %2 = tail call i1 @__quantum__qis__read_result__body(%Result* null) %a4.i.i = select i1 %2, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) tail call void @__quantum__qis__x__body(%Qubit* %a3.i.i) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %a3.i.i, %Qubit* %a4.i.i) tail call void @__quantum__qis__mz__body(%Qubit* %a4.i.i, %Result* nonnull inttoptr (i64 1 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* %a4.i.i) %3 = tail call i1 @__quantum__qis__read_result__body(%Result* nonnull inttoptr (i64 1 to %Result*)) %4 = mul i64 %z, 9 %5 = shl i64 %z, 1 %val.i.i = select i1 %3, i64 %5, i64 %4 %6 = mul i64 %val.i.i, 5 %7 = add i64 %6, -7 ret i64 %7 } After grouping according to the source processing unit, we arrive at define i64 @LogicGrouping(i64 %z) local_unnamed_addr #0 { entry: %0 = icmp slt i64 %z, 0 %1 = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %2 = select i1 %0, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null br label %quantum quantum: ; preds = %entry tail call void @__quantum__qis__x__body(%Qubit* %1) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %1, %Qubit* %2) tail call void @__quantum__qis__mz__body(%Qubit* %2, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* %2) %3 = tail call i1 @__quantum__qis__read_result__body(%Result* null) %4 = tail call i1 @__quantum__qis__read_result__body(%Result* null) br label %post-classical post-classical: ; preds = %quantum %5 = select i1 %3, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null %6 = select i1 %4, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %7 = mul i64 %z, 9 %8 = shl i64 %z, 1 br label %quantum2 quantum2: ; preds = %post-classical tail call void @__quantum__qis__x__body(%Qubit* %5) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %5, %Qubit* %6) tail call void @__quantum__qis__mz__body(%Qubit* %6, %Result* nonnull inttoptr (i64 1 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* %6) %9 = tail call i1 @__quantum__qis__read_result__body(%Result* nonnull inttoptr (i64 1 to %Result*)) br label %post-classical1 post-classical1: ; preds = %quantum2 %10 = select i1 %9, i64 %8, i64 %7 %11 = mul i64 %10, 5 %12 = add i64 %11, -7 br label %exit_quantum_grouping exit_quantum_grouping: ; preds = %post-classical1 ret i64 %12 } which contains two quantum circuits where the second circuit depends on the first one. That is, in the block post-classical we select which qubits to use for the execute, and hence, we would not be able to run the second circuit prior to this classical calculation. Further expanding each of the source blocks, we get the load and readout blocks: define i64 @LogicGrouping(i64 %z) local_unnamed_addr #0 { entry: %0 = icmp slt i64 %z, 0 br label %load load: ; preds = %entry %1 = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %2 = select i1 %0, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null br label %quantum quantum: ; preds = %load tail call void @__quantum__qis__x__body(%Qubit* %1) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %1, %Qubit* %2) tail call void @__quantum__qis__mz__body(%Qubit* %2, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* %2) br label %readout readout: ; preds = %quantum %3 = tail call i1 @__quantum__qis__read_result__body(%Result* null) %4 = tail call i1 @__quantum__qis__read_result__body(%Result* null) br label %post-classical post-classical: ; preds = %readout %5 = mul i64 %z, 9 %6 = shl i64 %z, 1 br label %load4 load4: ; preds = %post-classical %7 = select i1 %3, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null %8 = select i1 %4, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) br label %quantum2 quantum2: ; preds = %load4 tail call void @__quantum__qis__x__body(%Qubit* %7) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %7, %Qubit* %8) tail call void @__quantum__qis__mz__body(%Qubit* %8, %Result* nonnull inttoptr (i64 1 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* %8) br label %readout3 readout3: ; preds = %quantum2 %9 = tail call i1 @__quantum__qis__read_result__body(%Result* nonnull inttoptr (i64 1 to %Result*)) br label %post-classical1 post-classical1: ; preds = %readout3 %10 = select i1 %9, i64 %6, i64 %5 %11 = mul i64 %10, 5 %12 = add i64 %11, -7 br label %exit_quantum_grouping exit_quantum_grouping: ; preds = %post-classical1 ret i64 %12 }","title":"QAT Application: Logic separation"},{"location":"DeveloperGuide/LogicSeparation/#qat-application-logic-separation","text":"","title":"QAT Application: Logic separation"},{"location":"DeveloperGuide/LogicSeparation/#architecture-considerations","text":"In this section, we will discuss some classical architectures and then make considerations regarding quantum architectures.","title":"Architecture considerations"},{"location":"DeveloperGuide/LogicSeparation/#motivation-classical-co-processors","text":"Before diving into quantum architectures, we first make a brief note on classical architectures: For decades we have seen classical architectures composed of multiple processing units. For instance, in the nineties it was common to have a co-processor supporting the main x86 architecture with such tasks as floating point operations. Other co-processing architectures were built to enhance the computers sound capabilities and in 2001, we saw graphical processing units (GPUs) emerge. To this day, GPUs are still an essentially co-processor for many computing tasks including gaming, physics simulation, and graphics to mention a few. While floating point operation co-processors eventually became integrated into the CPU, other co-processors such as GPU remains stand-alone units today. On a high-level, the use of a GPU for simulation roughly follows this diagram: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 Programming \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 State preparation \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Primary \u2502 \u2502 Secondary \u2502 \u2502 processing \u2502 \u2502 processing \u2502 \u2502 unit \u2502 \u2502 unit \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 Result readout \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 First the secondary processing unit (SPU) is programmed and as a part of this process the initial state (i.e. registers and memory) is prepared. The SPU then executes the program and the results are read out by the primary processing unit (PPU).","title":"Motivation: Classical co-processors"},{"location":"DeveloperGuide/LogicSeparation/#classical-quantum-processing-architecture","text":"While one could imagine a quantum architecture in which everything is integrated into a single processing unit that both can process classical and quantum registers, it is unlikely that this kind of architecture will emerge in the near future due to the vastly different environments in which the two processes take place. Therefore, one feasible architecture is one in which we consider the quantum processing unit (QPU) as SPU and the CPU the PPU much like is the case for CPUs and GPUs today. Disregarding the more advanced scenarios where PPUs and SPUs work in parallel, the basic flow of a classical-quantum program execution follows a pattern as given below: Classical PPU-SPU Quantum processing unit \u2502 interface \u2502 processing unit \u2502 \u2502 \u2502 \u2502 \u2502 Classical program \u2502 \u2502 \u2502 execution \u2502 \u2502 \u2502 \u2502 \u2502 State preparation \u2502 \u25bc \u2502 Programming \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Quantum program \u2502 \u2502 \u2502 execution \u2502 Result readout \u2502 \u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u25bc \u2502 \u2502 \u2502 Classical program \u2502 \u2502 \u2502 execution \u2502 \u2502 State preparation \u2502 \u2502 \u2502 Programming \u2502 \u25bc \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Quantum program \u2502 \u2502 \u2502 execution \u2502 Result readout \u2502 \u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u25bc \u2502 \u2502 \u25bc \u25bc Time We note that in some cases, either the state programming or the readout process may be not contain instructions. In these cases, blocks with state programming and/or readout will simply be empty and therefore it has no influence on the general structure.","title":"Classical-quantum processing architecture"},{"location":"DeveloperGuide/LogicSeparation/#problem-definition","text":"The QIR specification does not put any requirements for a generic QIR to provide a separation of instructions intended for the CPU and QPU. However, under the assumption that quantum architectures follow the PPU-SPU pattern described in the previous section such a separation is necessary to perform the program execution. Our aim in this document will be to define how the separation should be performed and what qualifies an entity to be a CPU or QPU element. We will assume that branching is not possible within the QPU since this is a classical phenomenon. The consequence is that CPU-QPU separation must happen at the level of BasicBlocks in LLVM rather than at a function or even program level. While it may be that some QPUs have basic branching support, we note that it will be manageable to identify multi-block segments which are compatible with a given QPU target after the separation.","title":"Problem definition"},{"location":"DeveloperGuide/LogicSeparation/#definitions","text":"","title":"Definitions"},{"location":"DeveloperGuide/LogicSeparation/#registers","text":"For traditional PPU-SPU architectures, registers are limited in scope to the processing unit on which they reside. That is, a register on a CPU cannot be accessed from the GPU and vice versa. The value of a given register is only available through data transport through the two units. For CPU-QPU architectures, this limitation is the same. While the CPU may hold a reference to a qubit, the physical qubit itself resides on the QPU and can only be manipulated through the CPU-QPU interface. Quantum register types LLVM type name Description Qubit* Qubit register amounting to a physical qubit or simulation data type Result* Result register Classical register types LLVM type name Description i1 i2 i8 i16 i32 i64 struct On the CPU, Qubit* and Result* are treated as integers. This means that they should never be dereferenced nor should the \"memory address\" be written to.","title":"Registers"},{"location":"DeveloperGuide/LogicSeparation/#instructions-and-instruction-classification","text":"The QIR specification has two high-level classes of instructions: Those which are calls to functions with names starting with __quantum__ and all other instructions. Function calls to functions starting with __quantum__ are expected to follow the QIR specification and these calls are further divided into two groups: Intrinsic functions ( __quantum__qis__ ) and runtime functions ( __quantum__rt__ ). The latter are expected to be provided by the runtime library given by the frontend and/or the target machine, whereas the former are intrinsic functions. The intrinsic functions may either run on the CPU, the QPU or serve as instruction to transfer data between the two processing units. We classify __quantum__qis__ functions into four categories: Purely CPU, purely QPU, setup/transport from CPU to QPU and result/transport from QPU to CPU. The classification happens on the basis of the function signature: The function arguments together with the return result determine where the call will be executed according to following rules: Any void function location is purely determined by its arguments: Void functions that only have quantum register types as arguments are classified as pure QPU instructions Void functions that only have classical register types as arguments are classified as pure CPU instructions Void functions that takes a mixture are classified as CPU to QPU setup/transport instructions Any function that returns a quantum register is: A pure quantum instruction if all of the function arguments are quantum registers A CPU to QPU setup/transport instruction in any other case A function that returns a classical register is: A pure classical instruction if all of the arguments are classical registers A QPU to CPU result/transport instruction in any other case","title":"Instructions and instruction classification"},{"location":"DeveloperGuide/LogicSeparation/#pass-definition","text":"As an example we will consider following code block: define i64 @LogicGrouping(i64 %z) local_unnamed_addr #0 { entry: %0 = icmp slt i64 %z, 0 %a1.i.i = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %a2.i.i = select i1 %0, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null tail call void @__quantum__qis__x__body(%Qubit* %a1.i.i) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %a1.i.i, %Qubit* %a2.i.i) tail call void @__quantum__qis__mz__body(%Qubit* %a2.i.i, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* %a2.i.i) %1 = tail call i1 @__quantum__qis__read_result__body(%Result* null) %2 = mul i64 %z, 45 %.op.op.i.i = add i64 %2, 13 %3 = select i1 %1, i64 -7, i64 %.op.op.i.i ret i64 %3 } In the above 2-qubit ( 0 and 1 ) circuit, we use a classical parameter to decide which qubit should be the control qubit ( a1 ) and which is the target ( a2 ). We apply an X gate to the control qubit and then apply a Z gate to the qubit with id 0 regardless of whether it is the control or target qubit. This is followed by a CNOT gate and finally a measurement. The result from the measurement is used to compute a classical result. Our goal is now to separate instructions into blocks of pure quantum instructions, pure classical instructions and data transfer. The data transfer blocks can be thought of as a mix of classical and quantum instructions as these may manipulate registers on either the CPU or QPU. For the above example code, we envision a separation similar to following code snippet: define i64 @LogicGrouping(i64 %z) local_unnamed_addr #0 { entry: %0 = icmp slt i64 %z, 0 %1 = mul i64 %z, 45 %2 = add i64 %1, 13 br label %load load: ; preds = %entry %3 = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %4 = select i1 %0, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null br label %quantum quantum: ; preds = %load tail call void @__quantum__qis__x__body(%Qubit* %3) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %3, %Qubit* %4) tail call void @__quantum__qis__mz__body(%Qubit* %4, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* %4) br label %readout readout: ; preds = %quantum %5 = tail call i1 @__quantum__qis__read_result__body(%Result* null) br label %post-classical post-classical: ; preds = %readout %6 = select i1 %5, i64 -7, i64 %2 br label %exit_quantum_grouping exit_quantum_grouping: ; preds = %post-classical ret i64 %6 } In the above program, the original instructions are rearranged into blocks following the pattern previously discussed with an entry block, a load block, a quantum program block, a readout block and a post-classical processing block. Visualized as above, the blocks are executed as follows: Classical PPU-SPU Quantum processing unit \u2502 interface \u2502 processing unit \u2502 \u2502 entry\u2502 \u2502 \u2502 \u25bc \u2502 load \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 readout \u2502 \u2502 quantum \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u25bc post-classical \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 exit-grouping \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 \u25bc \u25bc Time With this separation, it becomes straight-forward to execute the program parts in accordance with the required processing unit as well as to ensure that proper setup of the QPU was performed before initiating the quantum calculation.","title":"Pass definition"},{"location":"DeveloperGuide/LogicSeparation/#block-separation-strategy","text":"Our block separation strategy follows a divide-and-conquer approach: First we sort instructions into new blocks according to the source processing. Each of these blocks are then sub-divided based on the destination processing unit. We illustrate this in the following diagram: 1st split 2nd split \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502Classical \u2502 entry \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u25b6\u2502 Dest \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502Classical \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u25b6\u2502 Source \u251c\u2500\u2524 \u2502 Quantum \u2502 load \u2502 \u2502 \u2502 \u2514\u2500\u25b6\u2502 Dest \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Quantum \u2502 quantum \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u25b6\u2502 Dest \u2502 \u2502 Original \u2502 \u2502 \u2502 Quantum \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 block \u2502\u2500\u2500\u253c\u2500\u25b6\u2502 Source \u251c\u2500\u2524 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502Classical \u2502 readout \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u25b6\u2502 Dest \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502Classical \u2502 post-classical \u2502 \u2502Classical \u2502 \u250c\u2500\u25b6\u2502 Dest \u2502 \u2514\u2500\u25b6\u2502 Source \u2502\u2500\u2524 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 Empty (QD)\u2502 \u2514\u2500\u25b6\u2502 \u2500 \u2500 \u2500 \u2500 \u2500 \u2518 We note the second split is reversed depending type of instructions it contains. We order instruction blocks (during the second split) such that instructions whose source and destination processing units are the same come first. We note that the second split is technically easier to make as the blocks processed in the first split already have certain guarantees provided: We are guaranteed that we only need to make one split We are guaranteed that the order of all dependencies is preserved when splitting instructions into the two blocks The first split is more involved as we need to identify dependencies between classical and quantum circuits and may end up with an output similar to: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502Classical \u2502 \u250c\u2500\u25b6\u2502 Source \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 Quantum \u2502 \u251c\u2500\u25b6\u2502 Source \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502Classical \u2502 \u251c\u2500\u25b6\u2502 Source \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Original \u2502 \u2502 \u2502 Quantum \u2502 \u2502 block \u2502\u2500\u2500\u253c\u2500\u25b6\u2502 Source \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502Classical \u2502 \u251c\u2500\u25b6\u2502 Source \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 . \u2502 . \u2502 . \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502Classical \u2502 \u2514\u2500\u25b6\u2502 Source \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 The main reason for this is that we may make a measurement and then use that measurement to decide what the next quantum circuit looks like. As an example, consider following circuit: define i64 @LogicGrouping(i64 %z) local_unnamed_addr #0 { entry: %0 = icmp slt i64 %z, 0 %a1.i.i = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %a2.i.i = select i1 %0, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null tail call void @__quantum__qis__x__body(%Qubit* %a1.i.i) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %a1.i.i, %Qubit* %a2.i.i) tail call void @__quantum__qis__mz__body(%Qubit* %a2.i.i, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* %a2.i.i) %1 = tail call i1 @__quantum__qis__read_result__body(%Result* null) %a3.i.i = select i1 %1, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null %2 = tail call i1 @__quantum__qis__read_result__body(%Result* null) %a4.i.i = select i1 %2, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) tail call void @__quantum__qis__x__body(%Qubit* %a3.i.i) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %a3.i.i, %Qubit* %a4.i.i) tail call void @__quantum__qis__mz__body(%Qubit* %a4.i.i, %Result* nonnull inttoptr (i64 1 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* %a4.i.i) %3 = tail call i1 @__quantum__qis__read_result__body(%Result* nonnull inttoptr (i64 1 to %Result*)) %4 = mul i64 %z, 9 %5 = shl i64 %z, 1 %val.i.i = select i1 %3, i64 %5, i64 %4 %6 = mul i64 %val.i.i, 5 %7 = add i64 %6, -7 ret i64 %7 } After grouping according to the source processing unit, we arrive at define i64 @LogicGrouping(i64 %z) local_unnamed_addr #0 { entry: %0 = icmp slt i64 %z, 0 %1 = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %2 = select i1 %0, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null br label %quantum quantum: ; preds = %entry tail call void @__quantum__qis__x__body(%Qubit* %1) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %1, %Qubit* %2) tail call void @__quantum__qis__mz__body(%Qubit* %2, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* %2) %3 = tail call i1 @__quantum__qis__read_result__body(%Result* null) %4 = tail call i1 @__quantum__qis__read_result__body(%Result* null) br label %post-classical post-classical: ; preds = %quantum %5 = select i1 %3, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null %6 = select i1 %4, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %7 = mul i64 %z, 9 %8 = shl i64 %z, 1 br label %quantum2 quantum2: ; preds = %post-classical tail call void @__quantum__qis__x__body(%Qubit* %5) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %5, %Qubit* %6) tail call void @__quantum__qis__mz__body(%Qubit* %6, %Result* nonnull inttoptr (i64 1 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* %6) %9 = tail call i1 @__quantum__qis__read_result__body(%Result* nonnull inttoptr (i64 1 to %Result*)) br label %post-classical1 post-classical1: ; preds = %quantum2 %10 = select i1 %9, i64 %8, i64 %7 %11 = mul i64 %10, 5 %12 = add i64 %11, -7 br label %exit_quantum_grouping exit_quantum_grouping: ; preds = %post-classical1 ret i64 %12 } which contains two quantum circuits where the second circuit depends on the first one. That is, in the block post-classical we select which qubits to use for the execute, and hence, we would not be able to run the second circuit prior to this classical calculation. Further expanding each of the source blocks, we get the load and readout blocks: define i64 @LogicGrouping(i64 %z) local_unnamed_addr #0 { entry: %0 = icmp slt i64 %z, 0 br label %load load: ; preds = %entry %1 = select i1 %0, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) %2 = select i1 %0, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null br label %quantum quantum: ; preds = %load tail call void @__quantum__qis__x__body(%Qubit* %1) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %1, %Qubit* %2) tail call void @__quantum__qis__mz__body(%Qubit* %2, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* %2) br label %readout readout: ; preds = %quantum %3 = tail call i1 @__quantum__qis__read_result__body(%Result* null) %4 = tail call i1 @__quantum__qis__read_result__body(%Result* null) br label %post-classical post-classical: ; preds = %readout %5 = mul i64 %z, 9 %6 = shl i64 %z, 1 br label %load4 load4: ; preds = %post-classical %7 = select i1 %3, %Qubit* inttoptr (i64 1 to %Qubit*), %Qubit* null %8 = select i1 %4, %Qubit* null, %Qubit* inttoptr (i64 1 to %Qubit*) br label %quantum2 quantum2: ; preds = %load4 tail call void @__quantum__qis__x__body(%Qubit* %7) tail call void @__quantum__qis__z__body(%Qubit* null) tail call void @__quantum__qis__cnot__body(%Qubit* %7, %Qubit* %8) tail call void @__quantum__qis__mz__body(%Qubit* %8, %Result* nonnull inttoptr (i64 1 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* %8) br label %readout3 readout3: ; preds = %quantum2 %9 = tail call i1 @__quantum__qis__read_result__body(%Result* nonnull inttoptr (i64 1 to %Result*)) br label %post-classical1 post-classical1: ; preds = %readout3 %10 = select i1 %9, i64 %6, i64 %5 %11 = mul i64 %10, 5 %12 = add i64 %11, -7 br label %exit_quantum_grouping exit_quantum_grouping: ; preds = %post-classical1 ret i64 %12 }","title":"Block Separation Strategy"},{"location":"DeveloperGuide/ProfileTransformationCpp/","text":"Creating a profile transformation in C++ Profile transformation as pass As an example of how one can implement a new profile pass, we here show the implementation details of our example pass which allows mapping the teleportation code to the base profile: pb.registerPipelineParsingCallback([](StringRef name, FunctionPassManager &fpm, ArrayRef<PassBuilder::PipelineElement> /*unused*/) { // Base profile if (name == \"restrict-qir<base-profile>\") { RuleSet rule_set; // Defining the mapping auto factory = RuleFactory(rule_set); factory.useStaticQuantumArrayAllocation(); factory.useStaticQuantumAllocation(); factory.useStaticResultAllocation(); factory.optimiseBranchQuatumOne(); // factory.optimiseBranchQuatumZero(); factory.disableReferenceCounting(); factory.disableAliasCounting(); factory.disableStringSupport(); fpm.addPass(TransformationRulePass(std::move(rule_set))); return true; } return false; }); }}; Transformations of the IR will happen on the basis of what rules are added to the rule set. The purpose of the factory is to make easy to add rules that serve a single purpose as well as making a basis for making rules unit testable. Implementing new rules Implementing new rules consists of two steps: Defining a pattern that one wish to replace and implementing the corresponding replacement logic. Inside a factory member function, this look as follows: auto get_element = Call(\"__quantum__rt__array_get_element_ptr_1d\", \"arrayName\"_cap = _, \"index\"_cap = _); auto cast_pattern = BitCast(\"getElement\"_cap = get_element); auto load_pattern = Load(\"cast\"_cap = cast_pattern); addRule({std::move(load_pattern), access_replacer}); where addRule adds the rule to the current rule set. Capturing patterns The pattern defined in this snippet matches IR like: %0 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %leftPreshared, i64 0) %1 = bitcast i8* %0 to %Qubit** %2 = load %Qubit*, %Qubit** %1, align 8 In the above rule, the first and second argument of __quantum__rt__array_get_element_ptr_1d is captured as arrayName and index , respectively. Likewise, the bitcast instruction is captured as cast . Each of these captures will be available inside the replacement function access_replacer . Implementing replacement logic After a positive match is found, the lead instruction alongside an IRBuilder , a capture table and a replacement table is passed to the replacement function. Here is an example on how one can access the captured variables to perform a transformation of the IR: auto access_replacer = [qubit_alloc_manager](Builder &builder, Value *val, Captures &cap, Replacements &replacements) { // ... auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"index\"]); // ... auto llvm_size = cst->getValue(); auto offset = qubit_alloc_manager->getOffset(cap[\"arrayName\"]->getName().str()); auto idx = llvm::APInt(llvm_size.getBitWidth(), llvm_size.getZExtValue() + offset); auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto instr = new llvm::IntToPtrInst(new_index, ptr_type); instr->takeName(val); // Replacing the lead instruction with a the new instruction replacements.push_back({llvm::dyn_cast<Instruction>(val), instr}); // Deleting the getelement and cast operations replacements.push_back({llvm::dyn_cast<Instruction>(cap[\"getElement\"]), nullptr}); replacements.push_back({llvm::dyn_cast<Instruction>(cap[\"cast\"]), nullptr}); return true; };","title":"Creating a profile transformation in C++"},{"location":"DeveloperGuide/ProfileTransformationCpp/#creating-a-profile-transformation-in-c","text":"","title":"Creating a profile transformation in C++"},{"location":"DeveloperGuide/ProfileTransformationCpp/#profile-transformation-as-pass","text":"As an example of how one can implement a new profile pass, we here show the implementation details of our example pass which allows mapping the teleportation code to the base profile: pb.registerPipelineParsingCallback([](StringRef name, FunctionPassManager &fpm, ArrayRef<PassBuilder::PipelineElement> /*unused*/) { // Base profile if (name == \"restrict-qir<base-profile>\") { RuleSet rule_set; // Defining the mapping auto factory = RuleFactory(rule_set); factory.useStaticQuantumArrayAllocation(); factory.useStaticQuantumAllocation(); factory.useStaticResultAllocation(); factory.optimiseBranchQuatumOne(); // factory.optimiseBranchQuatumZero(); factory.disableReferenceCounting(); factory.disableAliasCounting(); factory.disableStringSupport(); fpm.addPass(TransformationRulePass(std::move(rule_set))); return true; } return false; }); }}; Transformations of the IR will happen on the basis of what rules are added to the rule set. The purpose of the factory is to make easy to add rules that serve a single purpose as well as making a basis for making rules unit testable.","title":"Profile transformation as pass"},{"location":"DeveloperGuide/ProfileTransformationCpp/#implementing-new-rules","text":"Implementing new rules consists of two steps: Defining a pattern that one wish to replace and implementing the corresponding replacement logic. Inside a factory member function, this look as follows: auto get_element = Call(\"__quantum__rt__array_get_element_ptr_1d\", \"arrayName\"_cap = _, \"index\"_cap = _); auto cast_pattern = BitCast(\"getElement\"_cap = get_element); auto load_pattern = Load(\"cast\"_cap = cast_pattern); addRule({std::move(load_pattern), access_replacer}); where addRule adds the rule to the current rule set.","title":"Implementing new rules"},{"location":"DeveloperGuide/ProfileTransformationCpp/#capturing-patterns","text":"The pattern defined in this snippet matches IR like: %0 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %leftPreshared, i64 0) %1 = bitcast i8* %0 to %Qubit** %2 = load %Qubit*, %Qubit** %1, align 8 In the above rule, the first and second argument of __quantum__rt__array_get_element_ptr_1d is captured as arrayName and index , respectively. Likewise, the bitcast instruction is captured as cast . Each of these captures will be available inside the replacement function access_replacer .","title":"Capturing patterns"},{"location":"DeveloperGuide/ProfileTransformationCpp/#implementing-replacement-logic","text":"After a positive match is found, the lead instruction alongside an IRBuilder , a capture table and a replacement table is passed to the replacement function. Here is an example on how one can access the captured variables to perform a transformation of the IR: auto access_replacer = [qubit_alloc_manager](Builder &builder, Value *val, Captures &cap, Replacements &replacements) { // ... auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"index\"]); // ... auto llvm_size = cst->getValue(); auto offset = qubit_alloc_manager->getOffset(cap[\"arrayName\"]->getName().str()); auto idx = llvm::APInt(llvm_size.getBitWidth(), llvm_size.getZExtValue() + offset); auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto instr = new llvm::IntToPtrInst(new_index, ptr_type); instr->takeName(val); // Replacing the lead instruction with a the new instruction replacements.push_back({llvm::dyn_cast<Instruction>(val), instr}); // Deleting the getelement and cast operations replacements.push_back({llvm::dyn_cast<Instruction>(cap[\"getElement\"]), nullptr}); replacements.push_back({llvm::dyn_cast<Instruction>(cap[\"cast\"]), nullptr}); return true; };","title":"Implementing replacement logic"},{"location":"DeveloperGuide/WritingComponent/","text":"Tutorial: Writing a new component In this tutorial we will develop a new QAT profile component. We will make the component a separate library which is dynamically loaded through the command line interface. All examples in this tutorial can be found in ComponentExamples . Our first \"component\" will be a boilerplate hello world component which serves the purpose of giving the reader an understanding of how to define configurations for our component. We will demonstrate how to use this component from the command line. For our second component, we will use a standard LLVM pass to demonstrate how to load these. We will show how the registered configuration can be used to enable or disable the pass. To show that the effect of the pass, we use the inliner pipeline together with the QirExamples/LoopRecursion . We will see how enabling the pass results in inlining all the function calls. As QAT ships with a built-in inliner pass, it is important to remember to disable this to see the effect of our custom pass. Hello world Our first component will not do anything except for printing out a custom message upon configuring the profile. To this end, we need a configuration which allows the user to specify the message and we capture this configuration in a class which we name HelloWorldConfig : using String = std::string; class HelloWorldConfig { public: // ... private: String message_{\"Hello world\"}; }; We note the default value of our configuration is captured through the initialization of the class member. That is, if not overridden by the command line arguments, the message will be \"Hello world\" . To fulfil the concept of being a configuration, a configuration must implement a setup function taking a reference to a ConfigurationManager as its only argument. For our configuration, this looks like class HelloWorldConfig { public: void setup(ConfigurationManager &config) { config.setSectionName(\"Hello world configuration\", \"Demonstrating how configuration works.\"); config.addParameter(message_, \"message\", \"Message which is printed when setting the component up.\"); } // ... }; The purpose of the setup(config) function is to inform the configuration manager about what the name of the configuration section and its description is as well as defining all settings and bind them to C++ variables. The benefit of this approach is that all configuration parameters for the component will be available immediately after the component is loaded by the tool. The final code to manage the configuration reads: class HelloWorldConfig { public: using String = std::string; void setup(ConfigurationManager &config) { config.setSectionName(\"Hello world configuration\", \"Demonstrating how configuration works.\"); config.addParameter(message_, \"message\", \"Message which is printed when setting the component up.\"); } String const& message() const { return message_; } private: String message_{\"Hello world\"}; }; With the configuration in place, the next thing we concern ourselves with is loading the component. This is the functionality that registers the configuration together with an ID and a profile setup function. In our case, the setup function should just print a message given a HelloWorldConfig instance. The corresponding component registration reads: extern \"C\" void loadComponent(IProfileGenerator *generator) { generator->registerProfileComponent<HelloWorldConfig>( \"hello-world\", [](HelloWorldConfig const &cfg, IProfileGenerator * /*generator*/, Profile & /*profile*/) { std::cout << \"Message: \" << cfg.message() << std::endl; }); } In this example, we will only concern ourselves with how to use the configuration and we will ignore generator and profile for now. The full source code to this example can be found in ComponentExamples/HelloWorld and it can be compiled through following steps (startig from the Passes root folder): mkdir Debug cd Debug cmake .. make HelloWorld This will generate a HelloWorld dynamic library with path ./ComponentExamples/libHelloWorld.(dylib|so|dll) . Loading the component Executing qat and loading the libHelloWorld library, we see that our new settings are added to help page: % ./qir/qat/Apps/qat --load ./ComponentExamples/libHelloWorld.dylib Usage: ./qir/qat/Apps/qat [options] filename ... Hello world configuration - Demonstration configuration for building a component boilerplate. --message Message which is printed when setting the component up. Default: Hello world ... For the next part, we assume that you have a QIR located in path/to/example.ll . To test that the setup function is invoked upon setting the profile up, we run ./qir/qat/Apps/qat --load ./ComponentExamples/libHelloWorld.dylib path/to/example.ll Message: Hello world Creating a Pass Component Next, we make a component that just runs a single LLVM pass. We we will use the inline pipeline to this end. We create a single option for activating the pass: class InlinerConfig { public: using String = std::string; void setup(ConfigurationManager &config) { config.setSectionName(\"Inliner component\", \"Adds the LLVM Always Inline Pass to the profile\"); config.addParameter(inline_, \"custom-inliner\", \"Activating the custom inliner.\"); } bool shouldInline() const { return inline_; } private: bool inline_{false}; ///< Default behaviour is that we do not add the inliner pass }; The implementation itself is extern \"C\" void loadComponent(IProfileGenerator *generator) { generator->registerProfileComponent<InlinerConfig>( \"inliner\", [](InlinerConfig const &cfg, IProfileGenerator *ptr, Profile & /*profile*/) { if (cfg.shouldInline()) { auto &module_pass_manager = ptr->modulePassManager(); // Adds the inline pipeline auto &pass_builder = ptr->passBuilder(); auto inliner_pass = pass_builder.buildInlinerPipeline( ptr->optimizationLevel(), llvm::PassBuilder::ThinLTOPhase::None, ptr->debug()); module_pass_manager.addPass(std::move(inliner_pass)); } }); } To run this pass, ./qir/qat/Apps/qat --load ./ComponentExamples/libInlinePassComponent.dylib ../QirExamples/LoopRecursion/QSharpVersion/qir/Example.ll --S --apply --no-always-inline --custom-inliner Compare the output against ./qir/qat/Apps/qat --load ./ComponentExamples/libInlinePassComponent.dylib ../QirExamples/LoopRecursion/QSharpVersion/qir/Example.ll --S --apply --no-always-inline","title":"Writing a Component"},{"location":"DeveloperGuide/WritingComponent/#tutorial-writing-a-new-component","text":"In this tutorial we will develop a new QAT profile component. We will make the component a separate library which is dynamically loaded through the command line interface. All examples in this tutorial can be found in ComponentExamples . Our first \"component\" will be a boilerplate hello world component which serves the purpose of giving the reader an understanding of how to define configurations for our component. We will demonstrate how to use this component from the command line. For our second component, we will use a standard LLVM pass to demonstrate how to load these. We will show how the registered configuration can be used to enable or disable the pass. To show that the effect of the pass, we use the inliner pipeline together with the QirExamples/LoopRecursion . We will see how enabling the pass results in inlining all the function calls. As QAT ships with a built-in inliner pass, it is important to remember to disable this to see the effect of our custom pass.","title":"Tutorial: Writing a new component"},{"location":"DeveloperGuide/WritingComponent/#hello-world","text":"Our first component will not do anything except for printing out a custom message upon configuring the profile. To this end, we need a configuration which allows the user to specify the message and we capture this configuration in a class which we name HelloWorldConfig : using String = std::string; class HelloWorldConfig { public: // ... private: String message_{\"Hello world\"}; }; We note the default value of our configuration is captured through the initialization of the class member. That is, if not overridden by the command line arguments, the message will be \"Hello world\" . To fulfil the concept of being a configuration, a configuration must implement a setup function taking a reference to a ConfigurationManager as its only argument. For our configuration, this looks like class HelloWorldConfig { public: void setup(ConfigurationManager &config) { config.setSectionName(\"Hello world configuration\", \"Demonstrating how configuration works.\"); config.addParameter(message_, \"message\", \"Message which is printed when setting the component up.\"); } // ... }; The purpose of the setup(config) function is to inform the configuration manager about what the name of the configuration section and its description is as well as defining all settings and bind them to C++ variables. The benefit of this approach is that all configuration parameters for the component will be available immediately after the component is loaded by the tool. The final code to manage the configuration reads: class HelloWorldConfig { public: using String = std::string; void setup(ConfigurationManager &config) { config.setSectionName(\"Hello world configuration\", \"Demonstrating how configuration works.\"); config.addParameter(message_, \"message\", \"Message which is printed when setting the component up.\"); } String const& message() const { return message_; } private: String message_{\"Hello world\"}; }; With the configuration in place, the next thing we concern ourselves with is loading the component. This is the functionality that registers the configuration together with an ID and a profile setup function. In our case, the setup function should just print a message given a HelloWorldConfig instance. The corresponding component registration reads: extern \"C\" void loadComponent(IProfileGenerator *generator) { generator->registerProfileComponent<HelloWorldConfig>( \"hello-world\", [](HelloWorldConfig const &cfg, IProfileGenerator * /*generator*/, Profile & /*profile*/) { std::cout << \"Message: \" << cfg.message() << std::endl; }); } In this example, we will only concern ourselves with how to use the configuration and we will ignore generator and profile for now. The full source code to this example can be found in ComponentExamples/HelloWorld and it can be compiled through following steps (startig from the Passes root folder): mkdir Debug cd Debug cmake .. make HelloWorld This will generate a HelloWorld dynamic library with path ./ComponentExamples/libHelloWorld.(dylib|so|dll) .","title":"Hello world"},{"location":"DeveloperGuide/WritingComponent/#loading-the-component","text":"Executing qat and loading the libHelloWorld library, we see that our new settings are added to help page: % ./qir/qat/Apps/qat --load ./ComponentExamples/libHelloWorld.dylib Usage: ./qir/qat/Apps/qat [options] filename ... Hello world configuration - Demonstration configuration for building a component boilerplate. --message Message which is printed when setting the component up. Default: Hello world ... For the next part, we assume that you have a QIR located in path/to/example.ll . To test that the setup function is invoked upon setting the profile up, we run ./qir/qat/Apps/qat --load ./ComponentExamples/libHelloWorld.dylib path/to/example.ll Message: Hello world","title":"Loading the component"},{"location":"DeveloperGuide/WritingComponent/#creating-a-pass-component","text":"Next, we make a component that just runs a single LLVM pass. We we will use the inline pipeline to this end. We create a single option for activating the pass: class InlinerConfig { public: using String = std::string; void setup(ConfigurationManager &config) { config.setSectionName(\"Inliner component\", \"Adds the LLVM Always Inline Pass to the profile\"); config.addParameter(inline_, \"custom-inliner\", \"Activating the custom inliner.\"); } bool shouldInline() const { return inline_; } private: bool inline_{false}; ///< Default behaviour is that we do not add the inliner pass }; The implementation itself is extern \"C\" void loadComponent(IProfileGenerator *generator) { generator->registerProfileComponent<InlinerConfig>( \"inliner\", [](InlinerConfig const &cfg, IProfileGenerator *ptr, Profile & /*profile*/) { if (cfg.shouldInline()) { auto &module_pass_manager = ptr->modulePassManager(); // Adds the inline pipeline auto &pass_builder = ptr->passBuilder(); auto inliner_pass = pass_builder.buildInlinerPipeline( ptr->optimizationLevel(), llvm::PassBuilder::ThinLTOPhase::None, ptr->debug()); module_pass_manager.addPass(std::move(inliner_pass)); } }); } To run this pass, ./qir/qat/Apps/qat --load ./ComponentExamples/libInlinePassComponent.dylib ../QirExamples/LoopRecursion/QSharpVersion/qir/Example.ll --S --apply --no-always-inline --custom-inliner Compare the output against ./qir/qat/Apps/qat --load ./ComponentExamples/libInlinePassComponent.dylib ../QirExamples/LoopRecursion/QSharpVersion/qir/Example.ll --S --apply --no-always-inline","title":"Creating a Pass Component"},{"location":"DeveloperGuide/WritingRuleTests/","text":"Writing rule tests To make it easy to write tests for transformation rules, we have created two components to ease the burden of writing tests: DefaultProfileGenerator and IrManipulationTestHelper . The DefaultProfileGenerator is a profile that is dynamically defined when instatiated through a configuration lambda function. Creating the profile Creating the profile using the DefaultProfileGenerator is done by first defining the lambda function and then instantiating the DefaultProfileGenerator with the lambda function to define the profile. Using the RuleFactory , a profile for transforming the single qubit allocations is created as follows: auto configure_profile = [](RuleSet &rule_set) { auto factory = RuleFactory(rule_set); factory.useStaticQubitAllocation(); } auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); This profile is intended to transform %qubit = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %qubit) call void @__quantum__rt__qubit_release(%Qubit* %qubit) ret i8 0 by replacing all allocations with integers and stripping all release calls %qubit = inttoptr i64 0 to %Qubit* tail call void @__quantum__qis__h__body(%Qubit* %qubit) ret i8 0 Creating the IR In order to assist the testing of the above profile, we create a helper class which defines the IR we want to work on. To this end we make use of IrManipulationTestHelper which provides a number of shorthand functions to generate and test IR transformations. We start by defining the IR: auto ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareFunction(\"%Qubit* @__quantum__rt__qubit_allocate()\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); std::string script = R\"script( %qubit = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %qubit) call void @__quantum__rt__qubit_release(%Qubit* %qubit) )script\"; assert(ir_manip->fromBodyString(script)); // Will fail if the IR is invalid If we wish to verify the IR, we can print it by using the member function toString or by accessing the module directly: std::cout << ir_manip->toString() << std::endl; // OR llvm::errs() << *ir_manip->module() << \"\\n\"; Applying the profile to the IR The IrManipulationTestHelper contains a member function to run the profile on the IR to transform the module. The default behaviour of this helper function is to run without debug output at a O0 level to ensure that LLVM does not interfere with the intended test. The optimization level and debug mode can be changed through the function calls second and third argument, but for the sake of simplicity, we will assume we are using O0 here: ir_manip->applyProfile(profile); This will run the above generated rule set on the IR we have supplied. At this point, we could print the IR to the screen and use LIT to perform that actually transformation test. However, to keep this test framework self-contained and easy to use, we supply LIT-like functionality. This has the benefit that the tests do not rely on Python and the LIT framework and that the tooling around the test is substantially simpler. Testing the modified IR Like before, we can investigate the IR by printing it and as such we could write a test that compared the full IR against an expected string. However, even minor changes in the IR (such as interchanged declarations) would break the test even if the changes would not change the semantics of the code. Instead, the IrManipulationTestHelper has another helper function hasInstructionSequence which allow us to scan for a sequence of instructions in the body of the main function. In our case, we expect following two instructions (in order): %qubit = inttoptr i64 0 to %Qubit* tail call void @__quantum__qis__h__body(%Qubit* %qubit) The corresponding test code is as follows: EXPECT_TRUE(ir_manip->hasInstructionSequence({ \"%qubit = inttoptr i64 0 to %Qubit*\", \"tail call void @__quantum__qis__h__body(%Qubit* %qubit)\" })); By design, the test would pass as long as these two instructions are found (in order) within the full set of instructions of the function body. For instance, a valid IR for this test is call void printHelloWorld() %qubit = inttoptr i64 0 to %Qubit* %q2 = inttoptr i64 1 to %Qubit* %q3 = inttoptr i64 2 to %Qubit* tail call void @__quantum__qis__h__body(%Qubit* %q3) tail call void @__quantum__qis__h__body(%Qubit* %qubit) tail call void @__quantum__qis__h__body(%Qubit* %q2) but would fail tail call void @__quantum__qis__h__body(%Qubit* %qubit) %qubit = inttoptr i64 0 to %Qubit* and %qubit = inttoptr i64 0 to %Qubit* as the first has the wrong order of the calls and the second is missing one instruction.","title":"Rule based extensions"},{"location":"DeveloperGuide/WritingRuleTests/#writing-rule-tests","text":"To make it easy to write tests for transformation rules, we have created two components to ease the burden of writing tests: DefaultProfileGenerator and IrManipulationTestHelper . The DefaultProfileGenerator is a profile that is dynamically defined when instatiated through a configuration lambda function.","title":"Writing rule tests"},{"location":"DeveloperGuide/WritingRuleTests/#creating-the-profile","text":"Creating the profile using the DefaultProfileGenerator is done by first defining the lambda function and then instantiating the DefaultProfileGenerator with the lambda function to define the profile. Using the RuleFactory , a profile for transforming the single qubit allocations is created as follows: auto configure_profile = [](RuleSet &rule_set) { auto factory = RuleFactory(rule_set); factory.useStaticQubitAllocation(); } auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); This profile is intended to transform %qubit = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %qubit) call void @__quantum__rt__qubit_release(%Qubit* %qubit) ret i8 0 by replacing all allocations with integers and stripping all release calls %qubit = inttoptr i64 0 to %Qubit* tail call void @__quantum__qis__h__body(%Qubit* %qubit) ret i8 0","title":"Creating the profile"},{"location":"DeveloperGuide/WritingRuleTests/#creating-the-ir","text":"In order to assist the testing of the above profile, we create a helper class which defines the IR we want to work on. To this end we make use of IrManipulationTestHelper which provides a number of shorthand functions to generate and test IR transformations. We start by defining the IR: auto ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareFunction(\"%Qubit* @__quantum__rt__qubit_allocate()\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); std::string script = R\"script( %qubit = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %qubit) call void @__quantum__rt__qubit_release(%Qubit* %qubit) )script\"; assert(ir_manip->fromBodyString(script)); // Will fail if the IR is invalid If we wish to verify the IR, we can print it by using the member function toString or by accessing the module directly: std::cout << ir_manip->toString() << std::endl; // OR llvm::errs() << *ir_manip->module() << \"\\n\";","title":"Creating the IR"},{"location":"DeveloperGuide/WritingRuleTests/#applying-the-profile-to-the-ir","text":"The IrManipulationTestHelper contains a member function to run the profile on the IR to transform the module. The default behaviour of this helper function is to run without debug output at a O0 level to ensure that LLVM does not interfere with the intended test. The optimization level and debug mode can be changed through the function calls second and third argument, but for the sake of simplicity, we will assume we are using O0 here: ir_manip->applyProfile(profile); This will run the above generated rule set on the IR we have supplied. At this point, we could print the IR to the screen and use LIT to perform that actually transformation test. However, to keep this test framework self-contained and easy to use, we supply LIT-like functionality. This has the benefit that the tests do not rely on Python and the LIT framework and that the tooling around the test is substantially simpler.","title":"Applying the profile to the IR"},{"location":"DeveloperGuide/WritingRuleTests/#testing-the-modified-ir","text":"Like before, we can investigate the IR by printing it and as such we could write a test that compared the full IR against an expected string. However, even minor changes in the IR (such as interchanged declarations) would break the test even if the changes would not change the semantics of the code. Instead, the IrManipulationTestHelper has another helper function hasInstructionSequence which allow us to scan for a sequence of instructions in the body of the main function. In our case, we expect following two instructions (in order): %qubit = inttoptr i64 0 to %Qubit* tail call void @__quantum__qis__h__body(%Qubit* %qubit) The corresponding test code is as follows: EXPECT_TRUE(ir_manip->hasInstructionSequence({ \"%qubit = inttoptr i64 0 to %Qubit*\", \"tail call void @__quantum__qis__h__body(%Qubit* %qubit)\" })); By design, the test would pass as long as these two instructions are found (in order) within the full set of instructions of the function body. For instance, a valid IR for this test is call void printHelloWorld() %qubit = inttoptr i64 0 to %Qubit* %q2 = inttoptr i64 1 to %Qubit* %q3 = inttoptr i64 2 to %Qubit* tail call void @__quantum__qis__h__body(%Qubit* %q3) tail call void @__quantum__qis__h__body(%Qubit* %qubit) tail call void @__quantum__qis__h__body(%Qubit* %q2) but would fail tail call void @__quantum__qis__h__body(%Qubit* %qubit) %qubit = inttoptr i64 0 to %Qubit* and %qubit = inttoptr i64 0 to %Qubit* as the first has the wrong order of the calls and the second is missing one instruction.","title":"Testing the modified IR"},{"location":"UserGuide/BuildingLibrary/","text":"Build guide This document will guide you through all the requirements and steps that you need to follow to build the QIR adaptor tool (QAT). The first section of this guide helps you install the tools needed to build QAT. After you have finished with the second section of the guide, you should have the qat executable compiled and ready to run. As a part of the third part of this post, we will show you how to build and serve all of the documentation including the user guides, developer guides and API documentation. We will go through the steps of compiling the whole library as well as how to run all the tests suite that has been provided as the fourth part of this document. This part is only relevant if you intend to extend or modify the core codebase. There is no need for it when simply building an extension to QAT without having the need to change anything else in the core library. There is a lot more information about how to create a custom extension within the developers\u2019 section. Prerequisites It is necessary for you to have the following tools before you get started on making a new build from this project: C++ compiler CMake If you are compiling and using the command-line tool, these are necessary tools regardless of whether you plan to develop the library itself. The build configuration is handled by CMake, which informs you if a compiler needs to be installed. On macOS Those using macOS can install CMake through the use of a command-line tool called brew , as follows: brew install cmake It should not even be necessary to install anything else on top of macOS, since the compiler comes preinstalled. There is no need to read the next subsection ( Developer prerequisites ) if you are not intending to modify the core library and can safely jump to the section Library Dependencies On Ubuntu 20.04 Additionally to CMake, you will also require Clang in order to build on Ubuntu 20.04. You can accomplish this by following the steps below: apt install clang-11 cmake You can skip straight to Library Dependencies if you do not intend to work on developing the core library. Developer prerequisites Development of the core library requires additional tools. These are used formatting, linting and managing code quality. For this purpose, the following tools and packages are used: Python 3.6 Python packages specified in requirements.txt clang-format clang-tidy The installation process varies depending on the platform you use. The following subsections provide details on how to install these tools on each platform. On macOS TODO(issue-45): Create developer prerequisites for macOS in docs. On Ubuntu 20.04 Installing the Clang tools on Ubuntu along with Python can be accomplished by running these commands: apt install clang-format-11 clang-tidy-11 apt install python3 python3-pip We recommend that you use version 11 of Clang in order to be consistent with the version of LLVM on which the library depends. In general, the code should work with any version of clang. Make sure that the compiler environment variables are defined correctly in order to select the correct version: export CC=clang-11 export CXX=clang++-11 Common to all platforms Last but not least, we install the Python libraries that are required: pip install -r requirements.txt chmod +x manage As a result, the manage tool will be available for you to help you make sure your code is high quality. Getting a contribution merged into the code base requires the manage tools CI flow to be successful. Thus, if you plan to contribute you will most likely need to complete this step. Library Dependencies The QAT library itself is written in C++ and depends on LLVM for compilation and Google Test for testing purposes. Google Test is checked out as a submodule whereas LLVM needs to be installed on the system. To get check out all submodules run git submodule update --init --recursive Installing LLVM on macOS TODO(issue-45): Document installation process Installing LLVM on Ubuntu 20.04 For the installation of LLVM from Ubuntu we use the package manager apt . For full run installation, run the following command: apt install llvm-11 lldb-11 llvm-11-dev libllvm11 llvm-11-runtime By doing this, we will ensure that CMake can find LLVM and that all headers and libraries used by the QAT library are available. Build instructions for users From the root folder in the repository, go to src/Passes , then create a build folder Debug and use CMake to build the executable: cd Debug cmake .. make qat then ./qir/qat/Apps/qat Building the documentation To build the documentation Docker image, run: make documentation To serve the documentation locally, run: make serve-docs Building for developers To build the tool, create a new build directory and switch to that directory: mkdir Debug cd Debug/ To build the library, first configure CMake from the build directory cmake .. and then make your target make [target] The default target is all . Other valid targets are the name of the folders in libs/ found in the passes root.","title":"Building the library"},{"location":"UserGuide/BuildingLibrary/#build-guide","text":"This document will guide you through all the requirements and steps that you need to follow to build the QIR adaptor tool (QAT). The first section of this guide helps you install the tools needed to build QAT. After you have finished with the second section of the guide, you should have the qat executable compiled and ready to run. As a part of the third part of this post, we will show you how to build and serve all of the documentation including the user guides, developer guides and API documentation. We will go through the steps of compiling the whole library as well as how to run all the tests suite that has been provided as the fourth part of this document. This part is only relevant if you intend to extend or modify the core codebase. There is no need for it when simply building an extension to QAT without having the need to change anything else in the core library. There is a lot more information about how to create a custom extension within the developers\u2019 section.","title":"Build guide"},{"location":"UserGuide/BuildingLibrary/#prerequisites","text":"It is necessary for you to have the following tools before you get started on making a new build from this project: C++ compiler CMake If you are compiling and using the command-line tool, these are necessary tools regardless of whether you plan to develop the library itself. The build configuration is handled by CMake, which informs you if a compiler needs to be installed.","title":"Prerequisites"},{"location":"UserGuide/BuildingLibrary/#on-macos","text":"Those using macOS can install CMake through the use of a command-line tool called brew , as follows: brew install cmake It should not even be necessary to install anything else on top of macOS, since the compiler comes preinstalled. There is no need to read the next subsection ( Developer prerequisites ) if you are not intending to modify the core library and can safely jump to the section Library Dependencies","title":"On macOS"},{"location":"UserGuide/BuildingLibrary/#on-ubuntu-2004","text":"Additionally to CMake, you will also require Clang in order to build on Ubuntu 20.04. You can accomplish this by following the steps below: apt install clang-11 cmake You can skip straight to Library Dependencies if you do not intend to work on developing the core library.","title":"On Ubuntu 20.04"},{"location":"UserGuide/BuildingLibrary/#developer-prerequisites","text":"Development of the core library requires additional tools. These are used formatting, linting and managing code quality. For this purpose, the following tools and packages are used: Python 3.6 Python packages specified in requirements.txt clang-format clang-tidy The installation process varies depending on the platform you use. The following subsections provide details on how to install these tools on each platform.","title":"Developer prerequisites"},{"location":"UserGuide/BuildingLibrary/#on-macos_1","text":"TODO(issue-45): Create developer prerequisites for macOS in docs.","title":"On macOS"},{"location":"UserGuide/BuildingLibrary/#on-ubuntu-2004_1","text":"Installing the Clang tools on Ubuntu along with Python can be accomplished by running these commands: apt install clang-format-11 clang-tidy-11 apt install python3 python3-pip We recommend that you use version 11 of Clang in order to be consistent with the version of LLVM on which the library depends. In general, the code should work with any version of clang. Make sure that the compiler environment variables are defined correctly in order to select the correct version: export CC=clang-11 export CXX=clang++-11","title":"On Ubuntu 20.04"},{"location":"UserGuide/BuildingLibrary/#common-to-all-platforms","text":"Last but not least, we install the Python libraries that are required: pip install -r requirements.txt chmod +x manage As a result, the manage tool will be available for you to help you make sure your code is high quality. Getting a contribution merged into the code base requires the manage tools CI flow to be successful. Thus, if you plan to contribute you will most likely need to complete this step.","title":"Common to all platforms"},{"location":"UserGuide/BuildingLibrary/#library-dependencies","text":"The QAT library itself is written in C++ and depends on LLVM for compilation and Google Test for testing purposes. Google Test is checked out as a submodule whereas LLVM needs to be installed on the system. To get check out all submodules run git submodule update --init --recursive","title":"Library Dependencies"},{"location":"UserGuide/BuildingLibrary/#installing-llvm-on-macos","text":"TODO(issue-45): Document installation process","title":"Installing LLVM on macOS"},{"location":"UserGuide/BuildingLibrary/#installing-llvm-on-ubuntu-2004","text":"For the installation of LLVM from Ubuntu we use the package manager apt . For full run installation, run the following command: apt install llvm-11 lldb-11 llvm-11-dev libllvm11 llvm-11-runtime By doing this, we will ensure that CMake can find LLVM and that all headers and libraries used by the QAT library are available.","title":"Installing LLVM on Ubuntu 20.04"},{"location":"UserGuide/BuildingLibrary/#build-instructions-for-users","text":"From the root folder in the repository, go to src/Passes , then create a build folder Debug and use CMake to build the executable: cd Debug cmake .. make qat then ./qir/qat/Apps/qat","title":"Build instructions for users"},{"location":"UserGuide/BuildingLibrary/#building-the-documentation","text":"To build the documentation Docker image, run: make documentation To serve the documentation locally, run: make serve-docs","title":"Building the documentation"},{"location":"UserGuide/BuildingLibrary/#building-for-developers","text":"To build the tool, create a new build directory and switch to that directory: mkdir Debug cd Debug/ To build the library, first configure CMake from the build directory cmake .. and then make your target make [target] The default target is all . Other valid targets are the name of the folders in libs/ found in the passes root.","title":"Building for developers"},{"location":"UserGuide/IntroductionToProfiles/","text":"Introduction to profiles In this document we discuss QIR profiles. A QIR profile describes a subset of the generic QIR functionality and conventions. It is anticipated that most usages of the QIR specification will need to only use a subset of it. These subsets may further be subject to constraints such as how one allocate or acquire a qubit handle. We refer to such a subset with constraints as a profile. For instance, it is likely that early versions of quantum hardware will have a limited set of classical instructions available. With this in mind, the vendor or user of said hardware would define a profile that only contains a specified subset. One example of such a profile is the base profile, which only allows function calls and branching, but no arithmetic, classical memory, or classical registers. The generation of QIR according to the spec with no constraints would typically be performed by the frontend. A couple of examples are Q# or OpenQASM 3.0. However, for the generated QIR to be practical it is necessary to reduce it using a profile which is compatible with the target platform: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Frontend \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 QIR \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 QIR Adaptor Tool \u2502 <\u2500\u2500\u2500\u2500\u2500\u2500\u2500 QIR Profile \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 Adapted QIR \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Backend \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 As an example, a hardware based quantum platform may only have support for sequential gates with no branching or ability for subroutines. Likewise, some quantum platforms only allow for a single measurement at the end of executing the pipeline of quantum gates. Profiles suppose to express these nuances and restrictions which are absent in the generic QIR. Generic QIR specification See Quantum Intermediate Representation (QIR) Pipeline profile This profile assumes a quantum system where qubits and result registers fixed in availability. That is to say, that one target may have 25 qubits and 10 result registers. The pipeline profile is the profile with the least classical logic available. It only supports call , inttoptr , 64-bit integers i64 , qubit ids Qubit* and result ids Result* . It does not provide a runtime and only intrinsic quantum instructions are available to this profile. This profile is intended for client-host type infrastructure where a gate pipeline is uploaded to the client quantum system and executed one or more times. Measurements are always performed at the end of the execution and all available results. This profile only allows for defining a single function that takes no arguments and has no return type. As an example of how these types can be used: %0 = Qubit* inttoptr 1 to Qubit* which expresses that we store the handle to qubit with ID 1 in the variable %0 . Result registers are referred to in a similar manner. Base Profile The base profile is a slight advancement to the pipeline profile. TODO(issue-49): Finish this section","title":"Introduction to profiles"},{"location":"UserGuide/IntroductionToProfiles/#introduction-to-profiles","text":"In this document we discuss QIR profiles. A QIR profile describes a subset of the generic QIR functionality and conventions. It is anticipated that most usages of the QIR specification will need to only use a subset of it. These subsets may further be subject to constraints such as how one allocate or acquire a qubit handle. We refer to such a subset with constraints as a profile. For instance, it is likely that early versions of quantum hardware will have a limited set of classical instructions available. With this in mind, the vendor or user of said hardware would define a profile that only contains a specified subset. One example of such a profile is the base profile, which only allows function calls and branching, but no arithmetic, classical memory, or classical registers. The generation of QIR according to the spec with no constraints would typically be performed by the frontend. A couple of examples are Q# or OpenQASM 3.0. However, for the generated QIR to be practical it is necessary to reduce it using a profile which is compatible with the target platform: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Frontend \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 QIR \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 QIR Adaptor Tool \u2502 <\u2500\u2500\u2500\u2500\u2500\u2500\u2500 QIR Profile \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 Adapted QIR \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Backend \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 As an example, a hardware based quantum platform may only have support for sequential gates with no branching or ability for subroutines. Likewise, some quantum platforms only allow for a single measurement at the end of executing the pipeline of quantum gates. Profiles suppose to express these nuances and restrictions which are absent in the generic QIR.","title":"Introduction to profiles"},{"location":"UserGuide/IntroductionToProfiles/#generic-qir-specification","text":"See Quantum Intermediate Representation (QIR)","title":"Generic QIR specification"},{"location":"UserGuide/IntroductionToProfiles/#pipeline-profile","text":"This profile assumes a quantum system where qubits and result registers fixed in availability. That is to say, that one target may have 25 qubits and 10 result registers. The pipeline profile is the profile with the least classical logic available. It only supports call , inttoptr , 64-bit integers i64 , qubit ids Qubit* and result ids Result* . It does not provide a runtime and only intrinsic quantum instructions are available to this profile. This profile is intended for client-host type infrastructure where a gate pipeline is uploaded to the client quantum system and executed one or more times. Measurements are always performed at the end of the execution and all available results. This profile only allows for defining a single function that takes no arguments and has no return type. As an example of how these types can be used: %0 = Qubit* inttoptr 1 to Qubit* which expresses that we store the handle to qubit with ID 1 in the variable %0 . Result registers are referred to in a similar manner.","title":"Pipeline profile"},{"location":"UserGuide/IntroductionToProfiles/#base-profile","text":"The base profile is a slight advancement to the pipeline profile. TODO(issue-49): Finish this section","title":"Base Profile"},{"location":"UserGuide/QuickStart/","text":"Quick start Before we start, you will need to build the QAT tool. To this end, enter src/Passes from the root of the repository and create a new folder Debug . Then run cmake .. and use make to build qat : mkdir Debug cd Debug cmake .. make qat A more detailed documentation of this step is available in the build steps section . Once the build has been completed successfully, we will create a QIR in order to have an example code we can apply a profile to. The next step does not need to be completed if you already have a QIR. We will be using the Q# front end to generate the QIR and use the example SimpleLoop . However, you are free to choose another example in the QirExamples folder and/or another frontend. Go to the folder ./QirExamples/SimpleLoop/QSharpVersion and type make qir/Example.ll This will generate a QIR that will have the path ./QirExamples/SimpleLoop/QSharpVersion/qir/Example.ll relative to the project root. By using an application called QAT you can transform the QIR that was generated into a QIR that is tailored to a specific profile. Performing a transformation of the QIR from the ./Debug folder is done by typing the following commands: ./qir/qat/Apps/qat --apply --profile base -S ../QirExamples/SimpleLoop/QSharpVersion/qir/Example.ll Validation of QIR profiles is not supported by the tool at the moment. We're working on this feature, and will add the quickstart documentation here when it is available. Example: SimpleLoop For the sake of demonstration, we will look at the result of applying the profile to the previous Q# code and its corresponding QIR. However, instead of giving all the 3316 lines of the original QIR, we instead present the frontend code for the QIR. It is always possible to recreate the QIR from the step that was previously explained if you are curious: namespace SimpleLoop { open Microsoft.Quantum.Intrinsic; open Microsoft.Quantum.Measurement; function Value(r : Result) : Int { return r == Zero ? 122 | 1337; } @EntryPoint() operation RunMain() : Int { let nrIter = 5; mutable ret = 1; for _ in 1 .. nrIter { use q = Qubit(); H(q); let r = MResetZ(q); set ret = Value(r); } return ret; } } The tool was ran with three options: --apply , --profile base and -S . First, it tells the tool to apply the profile to the QIR so that it can become a profile-specific QIR according to the profile selected. By specifying the value baseProfile to the argument --profile , we select which profile to use in the tool and the third argument ensures that LLVM IR will be printed to the terminal in a human readable format. The resulting code emitted (omitting declarations) is: ; ModuleID = 'QSharpVersion/qir/Example.ll' source_filename = \"QSharpVersion/qir/Example.ll\" ; ... define void @SimpleLoop__Main() local_unnamed_addr #0 { entry: tail call void @__quantum__qis__h__body(%Qubit* null) tail call void @__quantum__qis__mz__body(%Qubit* null, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* null) %0 = tail call %Result* @__quantum__rt__result_get_zero() %1 = tail call i1 @__quantum__rt__result_equal(%Result* null, %Result* %0) tail call void @__quantum__qis__h__body(%Qubit* null) tail call void @__quantum__qis__mz__body(%Qubit* null, %Result* nonnull inttoptr (i64 1 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* null) %2 = tail call %Result* @__quantum__rt__result_get_zero() %3 = tail call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 1 to %Result*), %Result* %2) tail call void @__quantum__qis__h__body(%Qubit* null) tail call void @__quantum__qis__mz__body(%Qubit* null, %Result* nonnull inttoptr (i64 2 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* null) %4 = tail call %Result* @__quantum__rt__result_get_zero() %5 = tail call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 2 to %Result*), %Result* %4) tail call void @__quantum__qis__h__body(%Qubit* null) tail call void @__quantum__qis__mz__body(%Qubit* null, %Result* nonnull inttoptr (i64 3 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* null) %6 = tail call %Result* @__quantum__rt__result_get_zero() %7 = tail call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 3 to %Result*), %Result* %6) tail call void @__quantum__qis__h__body(%Qubit* null) tail call void @__quantum__qis__mz__body(%Qubit* null, %Result* nonnull inttoptr (i64 4 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* null) %8 = tail call %Result* @__quantum__rt__result_get_zero() %9 = tail call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 4 to %Result*), %Result* %8) %10 = select i1 %9, i64 122, i64 1337 %11 = tail call %String* @__quantum__rt__int_to_string(i64 %10) ret void } ; \u2026 attributes #0 = { \"EntryPoint\" \"requiredQubits\"=\"1\" } A notable feature of the resulting code is that there are no loops, and qubit registers are assigned at compile time, meaning that you can identify each qubit instance by its unique constant integer ID. These are features of the selected profile which does not support neither loops nor dynamic qubit allocation.","title":"Quick start"},{"location":"UserGuide/QuickStart/#quick-start","text":"Before we start, you will need to build the QAT tool. To this end, enter src/Passes from the root of the repository and create a new folder Debug . Then run cmake .. and use make to build qat : mkdir Debug cd Debug cmake .. make qat A more detailed documentation of this step is available in the build steps section . Once the build has been completed successfully, we will create a QIR in order to have an example code we can apply a profile to. The next step does not need to be completed if you already have a QIR. We will be using the Q# front end to generate the QIR and use the example SimpleLoop . However, you are free to choose another example in the QirExamples folder and/or another frontend. Go to the folder ./QirExamples/SimpleLoop/QSharpVersion and type make qir/Example.ll This will generate a QIR that will have the path ./QirExamples/SimpleLoop/QSharpVersion/qir/Example.ll relative to the project root. By using an application called QAT you can transform the QIR that was generated into a QIR that is tailored to a specific profile. Performing a transformation of the QIR from the ./Debug folder is done by typing the following commands: ./qir/qat/Apps/qat --apply --profile base -S ../QirExamples/SimpleLoop/QSharpVersion/qir/Example.ll Validation of QIR profiles is not supported by the tool at the moment. We're working on this feature, and will add the quickstart documentation here when it is available.","title":"Quick start"},{"location":"UserGuide/QuickStart/#example-simpleloop","text":"For the sake of demonstration, we will look at the result of applying the profile to the previous Q# code and its corresponding QIR. However, instead of giving all the 3316 lines of the original QIR, we instead present the frontend code for the QIR. It is always possible to recreate the QIR from the step that was previously explained if you are curious: namespace SimpleLoop { open Microsoft.Quantum.Intrinsic; open Microsoft.Quantum.Measurement; function Value(r : Result) : Int { return r == Zero ? 122 | 1337; } @EntryPoint() operation RunMain() : Int { let nrIter = 5; mutable ret = 1; for _ in 1 .. nrIter { use q = Qubit(); H(q); let r = MResetZ(q); set ret = Value(r); } return ret; } } The tool was ran with three options: --apply , --profile base and -S . First, it tells the tool to apply the profile to the QIR so that it can become a profile-specific QIR according to the profile selected. By specifying the value baseProfile to the argument --profile , we select which profile to use in the tool and the third argument ensures that LLVM IR will be printed to the terminal in a human readable format. The resulting code emitted (omitting declarations) is: ; ModuleID = 'QSharpVersion/qir/Example.ll' source_filename = \"QSharpVersion/qir/Example.ll\" ; ... define void @SimpleLoop__Main() local_unnamed_addr #0 { entry: tail call void @__quantum__qis__h__body(%Qubit* null) tail call void @__quantum__qis__mz__body(%Qubit* null, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* null) %0 = tail call %Result* @__quantum__rt__result_get_zero() %1 = tail call i1 @__quantum__rt__result_equal(%Result* null, %Result* %0) tail call void @__quantum__qis__h__body(%Qubit* null) tail call void @__quantum__qis__mz__body(%Qubit* null, %Result* nonnull inttoptr (i64 1 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* null) %2 = tail call %Result* @__quantum__rt__result_get_zero() %3 = tail call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 1 to %Result*), %Result* %2) tail call void @__quantum__qis__h__body(%Qubit* null) tail call void @__quantum__qis__mz__body(%Qubit* null, %Result* nonnull inttoptr (i64 2 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* null) %4 = tail call %Result* @__quantum__rt__result_get_zero() %5 = tail call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 2 to %Result*), %Result* %4) tail call void @__quantum__qis__h__body(%Qubit* null) tail call void @__quantum__qis__mz__body(%Qubit* null, %Result* nonnull inttoptr (i64 3 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* null) %6 = tail call %Result* @__quantum__rt__result_get_zero() %7 = tail call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 3 to %Result*), %Result* %6) tail call void @__quantum__qis__h__body(%Qubit* null) tail call void @__quantum__qis__mz__body(%Qubit* null, %Result* nonnull inttoptr (i64 4 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* null) %8 = tail call %Result* @__quantum__rt__result_get_zero() %9 = tail call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 4 to %Result*), %Result* %8) %10 = select i1 %9, i64 122, i64 1337 %11 = tail call %String* @__quantum__rt__int_to_string(i64 %10) ret void } ; \u2026 attributes #0 = { \"EntryPoint\" \"requiredQubits\"=\"1\" } A notable feature of the resulting code is that there are no loops, and qubit registers are assigned at compile time, meaning that you can identify each qubit instance by its unique constant integer ID. These are features of the selected profile which does not support neither loops nor dynamic qubit allocation.","title":"Example: SimpleLoop"}]}