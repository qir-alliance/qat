{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"QIR profile documentation Welcome to the QIR Profile SDK, a framework to manipulate QIR into specific profiles. The goal of this framework is to create tools that allow quantum hardware vendors to adapt a generic QIR to their specific hardware profile. User guide: Quick start Building the library Introduction to profiles Applying a profile (TODO(issue-8): Yet to be written) Developer guide: Architecture Overview Writing a Component Configuration Library Rule based extensions Additional developer info: Code quality Developer FAQ","title":"QIR profile documentation"},{"location":"#qir-profile-documentation","text":"Welcome to the QIR Profile SDK, a framework to manipulate QIR into specific profiles. The goal of this framework is to create tools that allow quantum hardware vendors to adapt a generic QIR to their specific hardware profile. User guide: Quick start Building the library Introduction to profiles Applying a profile (TODO(issue-8): Yet to be written) Developer guide: Architecture Overview Writing a Component Configuration Library Rule based extensions Additional developer info: Code quality Developer FAQ","title":"QIR profile documentation"},{"location":"base-profile-transformations/","text":"Proposal: QIR Adaptor Tool Specification This document discusses a tool that transforms QIR into a restricted version of the QIR (known as a profile). We aim to make a specification for a generic tool that allows the user to: Create or use an existing profile without the need of writing code. Validate that a QIR is compliant with the specific profile. Generate a profile compliant QIR from a generic unconstrained QIR (if possible). This document sets out to motivate and demonstrate feasibility of building such a tool. Motivation It is anticipated that most usages of the QIR specification will need to only use a subset of it. These subsets may further be subject to constraints such as how one allocates or acquire a qubit handle. We refer to such a subset with constraints as a profile. For instance, it is likely that early versions of quantum hardware will have a limited set of classical instructions available. With this in mind, the vendor or user of said hardware would define a profile that only contains a specified subset. One example of such a profile is the base profile, which only allows function calls and branching, but no arithmetic, classical memory, or classical registers. The generation of QIR according to the spec with no constraints would typically be performed by the frontend. A couple of examples are Q# or OpenQASM 2.0/3.0. However, for the generated QIR to be practical it is necessary to reduce it using a profile which is compatible with the target platform: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Frontend \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 QIR \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 QIR Adaptor Tool \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Restricted QIR \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 We propose that such a reduction could be done using the LLVM passes infrastructure to compose a profile which would map the QIR to a subset of the available instructions with any required constraints. Feasibility Study In order to demonstrate feasibility of this proposal, we have built a proof-of-concept prototype based on LLVM passes which allows transformation from a generic QIR into one which does not have support for dynamic qubit allocation. This transformation is considered to be the smallest, non-trivial case of QIR transformation we can perform which demonstrates the feasibility of this proposal. To demonstrate the feasibility of this proposal, we use Q# as a frontend and will attempt to map the following code namespace Feasibility { open Microsoft.Quantum.Intrinsic; @EntryPoint() operation Run() : Unit { use qs = Qubit[3]; for q in 8..10 { X(qs[q - 8]); } } } to the base profile. We will do so using a combination of existing LLVM passes and custom written passes which are specific to the QIR. The above code is interesting as it is not base profile compliant with regards to two aspects: 1) Qubit allocation is not allowed and 2) arithmetic operations are not supported. Using the Q# QIR generator, the Run functions body becomes: define internal void @Feasibility__Run__body() { entry: %qs = call %Array* @__quantum__rt__qubit_allocate_array(i64 3) call void @__quantum__rt__array_update_alias_count(%Array* %qs, i32 1) br label %header__1 header__1: ; preds = %exiting__1, %entry %q = phi i64 [ 8, %entry ], [ %4, %exiting__1 ] %0 = icmp sle i64 %q, 10 br i1 %0, label %body__1, label %exit__1 body__1: ; preds = %header__1 %1 = sub i64 %q, 8 %2 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %qs, i64 %1) %3 = bitcast i8* %2 to %Qubit** %qubit = load %Qubit*, %Qubit** %3, align 8 call void @__quantum__qis__x__body(%Qubit* %qubit) br label %exiting__1 exiting__1: ; preds = %body__1 %4 = add i64 %q, 1 br label %header__1 exit__1: ; preds = %header__1 call void @__quantum__rt__array_update_alias_count(%Array* %qs, i32 -1) call void @__quantum__rt__qubit_release_array(%Array* %qs) ret void } After applying the our demo profile transformation, the QIR is reduced to: define void @Feasibility__Run__Interop() local_unnamed_addr #0 { entry: call void @__quantum__qis__x__body(%Qubit* null) call void @__quantum__qis__x__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*)) call void @__quantum__qis__x__body(%Qubit* nonnull inttoptr (i64 2 to %Qubit*)) ret void } We note that we successfully have eliminated loops, arithmetic operations, dynamic qubit allocation and alias counting - all operations which are not supported by the base profile. Goal We envision the tool to work as a stand-alone command line tool which can either validate or generate a QIR in accordance with a given profile. To validate, one would run: qat -p profile.yaml --validate unvalidated-qir.ll In a similar fashion, generation is performed by adding --generate to the command line: qat -p profile.yaml --generate qir.ll > qir-profile.ll Default behaviour of the tool is that it always validates the generated profile. This behaviour can be disabled by qat -p profile.yaml --generate --no-validate qir.ll > qir-profile.ll Profile Specification Every profile is specified through a YAML file which defines an object at the top-level. This object must contain the fields name and displayName : name: profile-name displayName: Profile Name # ... Additionally, top level also contains the fields version and mode . The version refers to the QIR version which forms the basis for the specification and mode explains how the profile is defined. The final two top level fields are lists named specification and generation . These contains the specification and generation procedure, respectively. Specification The default mode of specification is by feature which means that specification describes the feature set available. Alternatively, one can specify a profile by limitation . As an example profile for name: profile-name displayName: Profile Name version: 1.0 mode: feature specification: functions: - __quantum__qis__toffoli__body - __quantum__qis__cnot__body - __quantum__qis__cz__body - __quantum__qis__h__body - __quantum__qis__mz__body - __quantum__qis__reset__body - __quantum__qis__rx__body - __quantum__qis__ry__body - __quantum__qis__rz__body - __quantum__qis__s__body - __quantum__qis__s__adj - __quantum__qis__t__body - __quantum__qis__t__adj - __quantum__qis__x__body - __quantum__qis__y__body - __quantum__qis__z__body instructions: - call - br - ret - inttoptr # ... This specification describes that 16 quantum instructions are available and 4 classical operations of the full QIR spec. Contrary, a specification by limitation could be as follows: name: profile-name displayName: Profile Name version: 1.0 mode: limitation specification: functions: - __quantum__rt__array_update_alias_count - __quantum__rt__array_update_reference_count instructions: - br # ... This profile specifies a system that does not allow reference and alias counting and neither have support for branching, but otherwise has the full QIR vesion 1.0 available. Generation specification To achieve the QIR generation in the feasibility section we made use of a number of different passes in order fold constants, unroll loops and map qubit allocations to static allocations. Based on this, we propose that generators are specified by creating a pipeline of LLVM passes to analyse and transform the QIR: name: profile-name displayName: Profile Name # ... generation: - passName: loopUnroll - passName: functionInline - passName: useStaticQubitAllocation - passName: eliminateClassicalMemoryUsage - passName: ignoreCall config: names: - __quantum__rt__array_update_alias_count - __quantum__rt__array_update_reference_count For those passes which are defined specifically for QIR we we allow configuration to be passed to them. This will allow the end-user to fine-tune the behaviour of profile generator. Library outline This is a placeholder for describing the outline of the QAT library. The aim is to create a dynamic library where we can add new components that allow to extend the QIR profile generation components with more passes and/or spefication options.","title":"Proposal: QIR Adaptor Tool Specification"},{"location":"base-profile-transformations/#proposal-qir-adaptor-tool-specification","text":"This document discusses a tool that transforms QIR into a restricted version of the QIR (known as a profile). We aim to make a specification for a generic tool that allows the user to: Create or use an existing profile without the need of writing code. Validate that a QIR is compliant with the specific profile. Generate a profile compliant QIR from a generic unconstrained QIR (if possible). This document sets out to motivate and demonstrate feasibility of building such a tool.","title":"Proposal: QIR Adaptor Tool Specification"},{"location":"base-profile-transformations/#motivation","text":"It is anticipated that most usages of the QIR specification will need to only use a subset of it. These subsets may further be subject to constraints such as how one allocates or acquire a qubit handle. We refer to such a subset with constraints as a profile. For instance, it is likely that early versions of quantum hardware will have a limited set of classical instructions available. With this in mind, the vendor or user of said hardware would define a profile that only contains a specified subset. One example of such a profile is the base profile, which only allows function calls and branching, but no arithmetic, classical memory, or classical registers. The generation of QIR according to the spec with no constraints would typically be performed by the frontend. A couple of examples are Q# or OpenQASM 2.0/3.0. However, for the generated QIR to be practical it is necessary to reduce it using a profile which is compatible with the target platform: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Frontend \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 QIR \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 QIR Adaptor Tool \u2502 \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Restricted QIR \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 We propose that such a reduction could be done using the LLVM passes infrastructure to compose a profile which would map the QIR to a subset of the available instructions with any required constraints.","title":"Motivation"},{"location":"base-profile-transformations/#feasibility-study","text":"In order to demonstrate feasibility of this proposal, we have built a proof-of-concept prototype based on LLVM passes which allows transformation from a generic QIR into one which does not have support for dynamic qubit allocation. This transformation is considered to be the smallest, non-trivial case of QIR transformation we can perform which demonstrates the feasibility of this proposal. To demonstrate the feasibility of this proposal, we use Q# as a frontend and will attempt to map the following code namespace Feasibility { open Microsoft.Quantum.Intrinsic; @EntryPoint() operation Run() : Unit { use qs = Qubit[3]; for q in 8..10 { X(qs[q - 8]); } } } to the base profile. We will do so using a combination of existing LLVM passes and custom written passes which are specific to the QIR. The above code is interesting as it is not base profile compliant with regards to two aspects: 1) Qubit allocation is not allowed and 2) arithmetic operations are not supported. Using the Q# QIR generator, the Run functions body becomes: define internal void @Feasibility__Run__body() { entry: %qs = call %Array* @__quantum__rt__qubit_allocate_array(i64 3) call void @__quantum__rt__array_update_alias_count(%Array* %qs, i32 1) br label %header__1 header__1: ; preds = %exiting__1, %entry %q = phi i64 [ 8, %entry ], [ %4, %exiting__1 ] %0 = icmp sle i64 %q, 10 br i1 %0, label %body__1, label %exit__1 body__1: ; preds = %header__1 %1 = sub i64 %q, 8 %2 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %qs, i64 %1) %3 = bitcast i8* %2 to %Qubit** %qubit = load %Qubit*, %Qubit** %3, align 8 call void @__quantum__qis__x__body(%Qubit* %qubit) br label %exiting__1 exiting__1: ; preds = %body__1 %4 = add i64 %q, 1 br label %header__1 exit__1: ; preds = %header__1 call void @__quantum__rt__array_update_alias_count(%Array* %qs, i32 -1) call void @__quantum__rt__qubit_release_array(%Array* %qs) ret void } After applying the our demo profile transformation, the QIR is reduced to: define void @Feasibility__Run__Interop() local_unnamed_addr #0 { entry: call void @__quantum__qis__x__body(%Qubit* null) call void @__quantum__qis__x__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*)) call void @__quantum__qis__x__body(%Qubit* nonnull inttoptr (i64 2 to %Qubit*)) ret void } We note that we successfully have eliminated loops, arithmetic operations, dynamic qubit allocation and alias counting - all operations which are not supported by the base profile.","title":"Feasibility Study"},{"location":"base-profile-transformations/#goal","text":"We envision the tool to work as a stand-alone command line tool which can either validate or generate a QIR in accordance with a given profile. To validate, one would run: qat -p profile.yaml --validate unvalidated-qir.ll In a similar fashion, generation is performed by adding --generate to the command line: qat -p profile.yaml --generate qir.ll > qir-profile.ll Default behaviour of the tool is that it always validates the generated profile. This behaviour can be disabled by qat -p profile.yaml --generate --no-validate qir.ll > qir-profile.ll","title":"Goal"},{"location":"base-profile-transformations/#profile-specification","text":"Every profile is specified through a YAML file which defines an object at the top-level. This object must contain the fields name and displayName : name: profile-name displayName: Profile Name # ... Additionally, top level also contains the fields version and mode . The version refers to the QIR version which forms the basis for the specification and mode explains how the profile is defined. The final two top level fields are lists named specification and generation . These contains the specification and generation procedure, respectively.","title":"Profile Specification"},{"location":"base-profile-transformations/#specification","text":"The default mode of specification is by feature which means that specification describes the feature set available. Alternatively, one can specify a profile by limitation . As an example profile for name: profile-name displayName: Profile Name version: 1.0 mode: feature specification: functions: - __quantum__qis__toffoli__body - __quantum__qis__cnot__body - __quantum__qis__cz__body - __quantum__qis__h__body - __quantum__qis__mz__body - __quantum__qis__reset__body - __quantum__qis__rx__body - __quantum__qis__ry__body - __quantum__qis__rz__body - __quantum__qis__s__body - __quantum__qis__s__adj - __quantum__qis__t__body - __quantum__qis__t__adj - __quantum__qis__x__body - __quantum__qis__y__body - __quantum__qis__z__body instructions: - call - br - ret - inttoptr # ... This specification describes that 16 quantum instructions are available and 4 classical operations of the full QIR spec. Contrary, a specification by limitation could be as follows: name: profile-name displayName: Profile Name version: 1.0 mode: limitation specification: functions: - __quantum__rt__array_update_alias_count - __quantum__rt__array_update_reference_count instructions: - br # ... This profile specifies a system that does not allow reference and alias counting and neither have support for branching, but otherwise has the full QIR vesion 1.0 available.","title":"Specification"},{"location":"base-profile-transformations/#generation-specification","text":"To achieve the QIR generation in the feasibility section we made use of a number of different passes in order fold constants, unroll loops and map qubit allocations to static allocations. Based on this, we propose that generators are specified by creating a pipeline of LLVM passes to analyse and transform the QIR: name: profile-name displayName: Profile Name # ... generation: - passName: loopUnroll - passName: functionInline - passName: useStaticQubitAllocation - passName: eliminateClassicalMemoryUsage - passName: ignoreCall config: names: - __quantum__rt__array_update_alias_count - __quantum__rt__array_update_reference_count For those passes which are defined specifically for QIR we we allow configuration to be passed to them. This will allow the end-user to fine-tune the behaviour of profile generator.","title":"Generation specification"},{"location":"base-profile-transformations/#library-outline","text":"This is a placeholder for describing the outline of the QAT library. The aim is to create a dynamic library where we can add new components that allow to extend the QIR profile generation components with more passes and/or spefication options.","title":"Library outline"},{"location":"Api/","text":"","title":"Index"},{"location":"Api/Classes/","text":"Classes namespace @15 namespace @22 namespace @71 namespace @72 namespace @73 namespace @74 namespace @75 namespace @76 namespace @78 namespace @79 namespace @80 namespace @81 namespace @82 namespace @86 namespace @87 namespace @88 namespace llvm namespace microsoft namespace quantum class AnyPattern Pattern that matches any operand. class BasicAllocationManager struct AllocatedMemoryBlock class BasicBlockPattern class BitCastPattern class BranchPattern class CallPattern class CommentLogger Concrete ILogger implementation that prints all messages as IR comments to llvm::errs(). class ConfigBind class ConfigurationManager struct Section class ConstIntPattern class DefaultProfileGenerator class FactoryConfiguration class IAllocationManager class IConfigBind class ILogger class IOperandPrototype class IntToPtrPattern class IrManipulationTestHelper class LlvmPassesConfiguration class LoadPattern class LogCollection struct Location Class that holds the location of where the incident happened. struct Message Struct to hold a message together with its type and location. class ModuleLoader class SingleModuleTransformation class ParameterParser struct ParsedValue Struct that contains parsed and interpreted values of command line arguments. class PhiPattern class Profile class ProfileGenerator class QatConfig Main configuration class for the qat command-line program. class RemoveDisallowedAttributesPass class ReplacementRule class RuleFactory class RuleSet class SelectPattern class StorePattern class SwitchPattern class TransformationRulesPass class TransformationRulesPassConfiguration Configuration class for the RuleTransformation pass. class UnnamedInvokePattern class ValidationPass class ValidationPassConfiguration class Validator namespace notation class Capture namespace microsoft::quantum::@35 namespace microsoft::quantum::@83 Updated on 22 November 2021 at 10:28:35 UTC","title":"Classes"},{"location":"Api/Classes/#classes","text":"namespace @15 namespace @22 namespace @71 namespace @72 namespace @73 namespace @74 namespace @75 namespace @76 namespace @78 namespace @79 namespace @80 namespace @81 namespace @82 namespace @86 namespace @87 namespace @88 namespace llvm namespace microsoft namespace quantum class AnyPattern Pattern that matches any operand. class BasicAllocationManager struct AllocatedMemoryBlock class BasicBlockPattern class BitCastPattern class BranchPattern class CallPattern class CommentLogger Concrete ILogger implementation that prints all messages as IR comments to llvm::errs(). class ConfigBind class ConfigurationManager struct Section class ConstIntPattern class DefaultProfileGenerator class FactoryConfiguration class IAllocationManager class IConfigBind class ILogger class IOperandPrototype class IntToPtrPattern class IrManipulationTestHelper class LlvmPassesConfiguration class LoadPattern class LogCollection struct Location Class that holds the location of where the incident happened. struct Message Struct to hold a message together with its type and location. class ModuleLoader class SingleModuleTransformation class ParameterParser struct ParsedValue Struct that contains parsed and interpreted values of command line arguments. class PhiPattern class Profile class ProfileGenerator class QatConfig Main configuration class for the qat command-line program. class RemoveDisallowedAttributesPass class ReplacementRule class RuleFactory class RuleSet class SelectPattern class StorePattern class SwitchPattern class TransformationRulesPass class TransformationRulesPassConfiguration Configuration class for the RuleTransformation pass. class UnnamedInvokePattern class ValidationPass class ValidationPassConfiguration class Validator namespace notation class Capture namespace microsoft::quantum::@35 namespace microsoft::quantum::@83 Updated on 22 November 2021 at 10:28:35 UTC","title":"Classes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/","text":"microsoft::quantum::AnyPattern Pattern that matches any operand. #include <Rules/Patterns/AnyPattern.hpp> Inherits from microsoft::quantum::IOperandPrototype Public Functions Name AnyPattern () ~AnyPattern () override virtual bool match (Value * instr, Captures & captures) const override Match of any operand always returns true and ignores children. virtual Child copy () const override Creates a copy of the AnyPattern instance. Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function AnyPattern AnyPattern() function ~AnyPattern ~AnyPattern() override function match virtual bool match( Value * instr, Captures & captures ) const override Match of any operand always returns true and ignores children. Reimplements : microsoft::quantum::IOperandPrototype::match function copy virtual Child copy() const override Creates a copy of the AnyPattern instance. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::AnyPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#microsoftquantumanypattern","text":"Pattern that matches any operand. #include <Rules/Patterns/AnyPattern.hpp> Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::AnyPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#public-functions","text":"Name AnyPattern () ~AnyPattern () override virtual bool match (Value * instr, Captures & captures) const override Match of any operand always returns true and ignores children. virtual Child copy () const override Creates a copy of the AnyPattern instance.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#function-anypattern","text":"AnyPattern()","title":"function AnyPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#function-anypattern_1","text":"~AnyPattern() override","title":"function ~AnyPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#function-match","text":"virtual bool match( Value * instr, Captures & captures ) const override Match of any operand always returns true and ignores children. Reimplements : microsoft::quantum::IOperandPrototype::match","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/#function-copy","text":"virtual Child copy() const override Creates a copy of the AnyPattern instance. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 22 November 2021 at 10:28:34 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/","text":"microsoft::quantum::BasicAllocationManager More... #include <AllocationManager/AllocationManager.hpp> Inherits from microsoft::quantum::IAllocationManager Public Classes Name struct AllocatedMemoryBlock Public Types Name using std::vector< AllocatedMemoryBlock > Mappings Vector of memory segments. using std::shared_ptr< BasicAllocationManager > BasicAllocationManagerPtr Allocator pointer type. Public Functions Name BasicAllocationManagerPtr createNew () virtual Address allocate (String const & name =\"\", Index const & count =1) override virtual void release ( Address const & address) override Releases the segment by address. virtual void reset () override Resets the allocation manager and all its statistics. void setReuseRegisters (bool val) Additional inherited members Public Types inherited from microsoft::quantum::IAllocationManager Name using uint64_t Address Value type for address. using uint64_t Index Index type used to access an array element. using std::shared_ptr< IAllocationManager > AllocationManagerPtr Pointer interface. Public Functions inherited from microsoft::quantum::IAllocationManager Name IAllocationManager ( IAllocationManager const & ) IAllocationManager ( IAllocationManager && ) IAllocationManager & operator= ( IAllocationManager const & ) IAllocationManager & operator= ( IAllocationManager && ) virtual ~IAllocationManager () uint64_t allocationsInUse () const uint64_t maxAllocationsUsed () const Protected Functions inherited from microsoft::quantum::IAllocationManager Name IAllocationManager () =default void updateRegistersInUse (uint64_t n) Detailed Description class microsoft::quantum::BasicAllocationManager; AllocationManager is a simple qubit and results allocator that can be used at compile-time. It is based on an assumption that all qubit allocating function calls are inlined and that qubits/results can be allocated with strictly growing IDs. Public Types Documentation using Mappings using microsoft::quantum::BasicAllocationManager::Mappings = std::vector<AllocatedMemoryBlock>; Vector of memory segments. using BasicAllocationManagerPtr using microsoft::quantum::BasicAllocationManager::BasicAllocationManagerPtr = std::shared_ptr<BasicAllocationManager>; Allocator pointer type. Public Functions Documentation function createNew static BasicAllocationManagerPtr createNew() Creates a new allocation manager. The manager is kept as a shared pointer to enable allocation across different passes and/or replacement rules. function allocate virtual Address allocate( String const & name =\"\", Index const & count =1 ) override Reimplements : microsoft::quantum::IAllocationManager::allocate Allocates a possibly named segment of a given count. Calling allocate without and arguments allocates a single anonymous resource and returns the address. In case of a larger segment, the function returns the address pointing to the first element. Allocation is guaranteed to be sequential. function release virtual void release( Address const & address ) override Releases the segment by address. Reimplements : microsoft::quantum::IAllocationManager::release function reset virtual void reset() override Resets the allocation manager and all its statistics. Reimplements : microsoft::quantum::IAllocationManager::reset function setReuseRegisters void setReuseRegisters( bool val ) Configuration function to set mode of qubit allocation. If function argument is true, the allocation manager will reuse qubits. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::BasicAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#microsoftquantumbasicallocationmanager","text":"More... #include <AllocationManager/AllocationManager.hpp> Inherits from microsoft::quantum::IAllocationManager","title":"microsoft::quantum::BasicAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#public-classes","text":"Name struct AllocatedMemoryBlock","title":"Public Classes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#public-types","text":"Name using std::vector< AllocatedMemoryBlock > Mappings Vector of memory segments. using std::shared_ptr< BasicAllocationManager > BasicAllocationManagerPtr Allocator pointer type.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#public-functions","text":"Name BasicAllocationManagerPtr createNew () virtual Address allocate (String const & name =\"\", Index const & count =1) override virtual void release ( Address const & address) override Releases the segment by address. virtual void reset () override Resets the allocation manager and all its statistics. void setReuseRegisters (bool val)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IAllocationManager Name using uint64_t Address Value type for address. using uint64_t Index Index type used to access an array element. using std::shared_ptr< IAllocationManager > AllocationManagerPtr Pointer interface. Public Functions inherited from microsoft::quantum::IAllocationManager Name IAllocationManager ( IAllocationManager const & ) IAllocationManager ( IAllocationManager && ) IAllocationManager & operator= ( IAllocationManager const & ) IAllocationManager & operator= ( IAllocationManager && ) virtual ~IAllocationManager () uint64_t allocationsInUse () const uint64_t maxAllocationsUsed () const Protected Functions inherited from microsoft::quantum::IAllocationManager Name IAllocationManager () =default void updateRegistersInUse (uint64_t n)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#detailed-description","text":"class microsoft::quantum::BasicAllocationManager; AllocationManager is a simple qubit and results allocator that can be used at compile-time. It is based on an assumption that all qubit allocating function calls are inlined and that qubits/results can be allocated with strictly growing IDs.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#using-mappings","text":"using microsoft::quantum::BasicAllocationManager::Mappings = std::vector<AllocatedMemoryBlock>; Vector of memory segments.","title":"using Mappings"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#using-basicallocationmanagerptr","text":"using microsoft::quantum::BasicAllocationManager::BasicAllocationManagerPtr = std::shared_ptr<BasicAllocationManager>; Allocator pointer type.","title":"using BasicAllocationManagerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#function-createnew","text":"static BasicAllocationManagerPtr createNew() Creates a new allocation manager. The manager is kept as a shared pointer to enable allocation across different passes and/or replacement rules.","title":"function createNew"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#function-allocate","text":"virtual Address allocate( String const & name =\"\", Index const & count =1 ) override Reimplements : microsoft::quantum::IAllocationManager::allocate Allocates a possibly named segment of a given count. Calling allocate without and arguments allocates a single anonymous resource and returns the address. In case of a larger segment, the function returns the address pointing to the first element. Allocation is guaranteed to be sequential.","title":"function allocate"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#function-release","text":"virtual void release( Address const & address ) override Releases the segment by address. Reimplements : microsoft::quantum::IAllocationManager::release","title":"function release"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#function-reset","text":"virtual void reset() override Resets the allocation manager and all its statistics. Reimplements : microsoft::quantum::IAllocationManager::reset","title":"function reset"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_allocation_manager/#function-setreuseregisters","text":"void setReuseRegisters( bool val ) Configuration function to set mode of qubit allocation. If function argument is true, the allocation manager will reuse qubits. Updated on 22 November 2021 at 10:28:34 UTC","title":"function setReuseRegisters"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_block_pattern/","text":"microsoft::quantum::BasicBlockPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::BasicBlockPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_block_pattern/#microsoftquantumbasicblockpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::BasicBlockPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_block_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_block_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_block_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_block_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_basic_block_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 November 2021 at 10:28:34 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_bit_cast_pattern/","text":"microsoft::quantum::BitCastPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::BitCastPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_bit_cast_pattern/#microsoftquantumbitcastpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::BitCastPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_bit_cast_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_bit_cast_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_bit_cast_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_bit_cast_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_bit_cast_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 November 2021 at 10:28:34 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_branch_pattern/","text":"microsoft::quantum::BranchPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::BranchPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_branch_pattern/#microsoftquantumbranchpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::BranchPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_branch_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_branch_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_branch_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_branch_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_branch_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 November 2021 at 10:28:34 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/","text":"microsoft::quantum::CallPattern Inherits from microsoft::quantum::IOperandPrototype Public Types Name using std::string String Public Functions Name CallPattern (String const & name) Construction by name. CallPattern ( CallPattern const & other) Copy construction prohibited. CallPattern ( CallPattern && other) =default Move construction allowed. ~CallPattern () override Destructor implementation. virtual bool match (Value * instr, Captures & captures) const override Matches the callee by name. virtual Child copy () const override Creates a copy of itself. Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Types Documentation using String using microsoft::quantum::CallPattern::String = std::string; Public Functions Documentation function CallPattern explicit CallPattern( String const & name ) Construction by name. function CallPattern CallPattern( CallPattern const & other ) Copy construction prohibited. function CallPattern CallPattern( CallPattern && other ) =default Move construction allowed. function ~CallPattern ~CallPattern() override Destructor implementation. function match virtual bool match( Value * instr, Captures & captures ) const override Matches the callee by name. Reimplements : microsoft::quantum::IOperandPrototype::match function copy virtual Child copy() const override Creates a copy of itself. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::CallPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#microsoftquantumcallpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::CallPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#public-types","text":"Name using std::string String","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#public-functions","text":"Name CallPattern (String const & name) Construction by name. CallPattern ( CallPattern const & other) Copy construction prohibited. CallPattern ( CallPattern && other) =default Move construction allowed. ~CallPattern () override Destructor implementation. virtual bool match (Value * instr, Captures & captures) const override Matches the callee by name. virtual Child copy () const override Creates a copy of itself.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#using-string","text":"using microsoft::quantum::CallPattern::String = std::string;","title":"using String"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#function-callpattern","text":"explicit CallPattern( String const & name ) Construction by name.","title":"function CallPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#function-callpattern_1","text":"CallPattern( CallPattern const & other ) Copy construction prohibited.","title":"function CallPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#function-callpattern_2","text":"CallPattern( CallPattern && other ) =default Move construction allowed.","title":"function CallPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#function-callpattern_3","text":"~CallPattern() override Destructor implementation.","title":"function ~CallPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#function-match","text":"virtual bool match( Value * instr, Captures & captures ) const override Matches the callee by name. Reimplements : microsoft::quantum::IOperandPrototype::match","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_call_pattern/#function-copy","text":"virtual Child copy() const override Creates a copy of itself. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 22 November 2021 at 10:28:34 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/","text":"microsoft::quantum::CommentLogger Concrete ILogger implementation that prints all messages as IR comments to llvm::errs(). #include <Logging/CommentLogger.hpp> Inherits from microsoft::quantum::ILogger Public Functions Name virtual void debug (String const & message) override Adds a debug message to the list. virtual void info (String const & message) override Adds an info message to the list. virtual void warning (String const & message) override Adds a warning message to the list. virtual void error (String const & message) override Adds an error message to the list. virtual void internalError (String const & message) override Adds an internal error message to the list. virtual void setLocation (String const & name, uint64_t row, uint64_t col) override Function that allows to set the current location. Additional inherited members Public Functions inherited from microsoft::quantum::ILogger Name ILogger () =default ILogger ( ILogger const & ) =default ILogger ( ILogger && ) =default ILogger & operator= ( ILogger const & ) =default ILogger & operator= ( ILogger && ) =default virtual ~ILogger () Public Functions Documentation function debug virtual void debug( String const & message ) override Adds a debug message to the list. Reimplements : microsoft::quantum::ILogger::debug function info virtual void info( String const & message ) override Adds an info message to the list. Reimplements : microsoft::quantum::ILogger::info function warning virtual void warning( String const & message ) override Adds a warning message to the list. Reimplements : microsoft::quantum::ILogger::warning function error virtual void error( String const & message ) override Adds an error message to the list. Reimplements : microsoft::quantum::ILogger::error function internalError virtual void internalError( String const & message ) override Adds an internal error message to the list. Reimplements : microsoft::quantum::ILogger::internalError function setLocation virtual void setLocation( String const & name, uint64_t row, uint64_t col ) override Function that allows to set the current location. Reimplements : microsoft::quantum::ILogger::setLocation Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::CommentLogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#microsoftquantumcommentlogger","text":"Concrete ILogger implementation that prints all messages as IR comments to llvm::errs(). #include <Logging/CommentLogger.hpp> Inherits from microsoft::quantum::ILogger","title":"microsoft::quantum::CommentLogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#public-functions","text":"Name virtual void debug (String const & message) override Adds a debug message to the list. virtual void info (String const & message) override Adds an info message to the list. virtual void warning (String const & message) override Adds a warning message to the list. virtual void error (String const & message) override Adds an error message to the list. virtual void internalError (String const & message) override Adds an internal error message to the list. virtual void setLocation (String const & name, uint64_t row, uint64_t col) override Function that allows to set the current location.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#additional-inherited-members","text":"Public Functions inherited from microsoft::quantum::ILogger Name ILogger () =default ILogger ( ILogger const & ) =default ILogger ( ILogger && ) =default ILogger & operator= ( ILogger const & ) =default ILogger & operator= ( ILogger && ) =default virtual ~ILogger ()","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-debug","text":"virtual void debug( String const & message ) override Adds a debug message to the list. Reimplements : microsoft::quantum::ILogger::debug","title":"function debug"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-info","text":"virtual void info( String const & message ) override Adds an info message to the list. Reimplements : microsoft::quantum::ILogger::info","title":"function info"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-warning","text":"virtual void warning( String const & message ) override Adds a warning message to the list. Reimplements : microsoft::quantum::ILogger::warning","title":"function warning"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-error","text":"virtual void error( String const & message ) override Adds an error message to the list. Reimplements : microsoft::quantum::ILogger::error","title":"function error"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-internalerror","text":"virtual void internalError( String const & message ) override Adds an internal error message to the list. Reimplements : microsoft::quantum::ILogger::internalError","title":"function internalError"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_comment_logger/#function-setlocation","text":"virtual void setLocation( String const & name, uint64_t row, uint64_t col ) override Function that allows to set the current location. Reimplements : microsoft::quantum::ILogger::setLocation Updated on 22 November 2021 at 10:28:34 UTC","title":"function setLocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/","text":"microsoft::quantum::ConfigBind More... #include <Commandline/ConfigBind.hpp> Inherits from microsoft::quantum::IConfigBind Public Types Name using T Type template <typename A ,typename B ,typename R > using typename std::enable_if< std::is_same< A, B >:: value , R >::type EnableIf Helper template to conditionally disable implementation unless a specific type is used. Public Functions Name ConfigBind () ConfigBind ( ConfigBind const & ) ConfigBind ( ConfigBind && ) ConfigBind & operator= ( ConfigBind const & ) ConfigBind & operator= ( ConfigBind && ) ~ConfigBind () override =default ConfigBind (Type & bind, T default_value, String const & name, String const & description) virtual bool setupArguments ( ParameterParser & parser) override Adds the argument to the parser. virtual bool configure ( ParameterParser const & parser) override virtual String value () override String representation of the bound value. Additional inherited members Public Functions inherited from microsoft::quantum::IConfigBind Name IConfigBind ( IConfigBind const & ) IConfigBind ( IConfigBind && ) virtual ~IConfigBind () String name () const Returns the name of the bound configuration variable. String description () const Returns the description of the configuration variable. bool isFlag () const Indicates whether or not this. String defaultValue () const Returns the default value for the flag. Protected Functions inherited from microsoft::quantum::IConfigBind Name IConfigBind (String const & name, String const & description) void setName (String const & name) Sets the name of the configuration variable. void markAsFlag () Marks the variable as a flag. void setDefault (String const & v) Sets the default value as a string. Detailed Description template <typename T > class microsoft::quantum::ConfigBind; Generic implementation of the bind interface for different types. This class holds the name of the command line parameter and a reference variable corresponding to it. It implements serialisers and deserialisers to allow transforming strings to native values and vice versa. Public Types Documentation using Type using microsoft::quantum::ConfigBind< T >::Type = T; using EnableIf template <typename A , typename B , typename R > using microsoft::quantum::ConfigBind< T >::EnableIf = typename std::enable_if<std::is_same<A, B>::value, R>::type; Helper template to conditionally disable implementation unless a specific type is used. Public Functions Documentation function ConfigBind ConfigBind() function ConfigBind ConfigBind( ConfigBind const & ) function ConfigBind ConfigBind( ConfigBind && ) function operator= ConfigBind & operator=( ConfigBind const & ) function operator= ConfigBind & operator=( ConfigBind && ) function ~ConfigBind ~ConfigBind() override =default function ConfigBind ConfigBind( Type & bind, T default_value, String const & name, String const & description ) Constructor to bind value to parameter. This class holds a reference to a variable together with the name it is expected to have when passed through the parameter parser. function setupArguments virtual bool setupArguments( ParameterParser & parser ) override Adds the argument to the parser. Reimplements : microsoft::quantum::IConfigBind::setupArguments function configure virtual bool configure( ParameterParser const & parser ) override Reimplements : microsoft::quantum::IConfigBind::configure Configures the bound value. This method examines the parsed input and use updates the bound value accordingly. function value virtual String value() override String representation of the bound value. Reimplements : microsoft::quantum::IConfigBind::value Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::ConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#microsoftquantumconfigbind","text":"More... #include <Commandline/ConfigBind.hpp> Inherits from microsoft::quantum::IConfigBind","title":"microsoft::quantum::ConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#public-types","text":"Name using T Type template <typename A ,typename B ,typename R > using typename std::enable_if< std::is_same< A, B >:: value , R >::type EnableIf Helper template to conditionally disable implementation unless a specific type is used.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#public-functions","text":"Name ConfigBind () ConfigBind ( ConfigBind const & ) ConfigBind ( ConfigBind && ) ConfigBind & operator= ( ConfigBind const & ) ConfigBind & operator= ( ConfigBind && ) ~ConfigBind () override =default ConfigBind (Type & bind, T default_value, String const & name, String const & description) virtual bool setupArguments ( ParameterParser & parser) override Adds the argument to the parser. virtual bool configure ( ParameterParser const & parser) override virtual String value () override String representation of the bound value.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#additional-inherited-members","text":"Public Functions inherited from microsoft::quantum::IConfigBind Name IConfigBind ( IConfigBind const & ) IConfigBind ( IConfigBind && ) virtual ~IConfigBind () String name () const Returns the name of the bound configuration variable. String description () const Returns the description of the configuration variable. bool isFlag () const Indicates whether or not this. String defaultValue () const Returns the default value for the flag. Protected Functions inherited from microsoft::quantum::IConfigBind Name IConfigBind (String const & name, String const & description) void setName (String const & name) Sets the name of the configuration variable. void markAsFlag () Marks the variable as a flag. void setDefault (String const & v) Sets the default value as a string.","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#detailed-description","text":"template <typename T > class microsoft::quantum::ConfigBind; Generic implementation of the bind interface for different types. This class holds the name of the command line parameter and a reference variable corresponding to it. It implements serialisers and deserialisers to allow transforming strings to native values and vice versa.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#using-type","text":"using microsoft::quantum::ConfigBind< T >::Type = T;","title":"using Type"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#using-enableif","text":"template <typename A , typename B , typename R > using microsoft::quantum::ConfigBind< T >::EnableIf = typename std::enable_if<std::is_same<A, B>::value, R>::type; Helper template to conditionally disable implementation unless a specific type is used.","title":"using EnableIf"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-configbind","text":"ConfigBind()","title":"function ConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-configbind_1","text":"ConfigBind( ConfigBind const & )","title":"function ConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-configbind_2","text":"ConfigBind( ConfigBind && )","title":"function ConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-operator","text":"ConfigBind & operator=( ConfigBind const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-operator_1","text":"ConfigBind & operator=( ConfigBind && )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-configbind_3","text":"~ConfigBind() override =default","title":"function ~ConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-configbind_4","text":"ConfigBind( Type & bind, T default_value, String const & name, String const & description ) Constructor to bind value to parameter. This class holds a reference to a variable together with the name it is expected to have when passed through the parameter parser.","title":"function ConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-setuparguments","text":"virtual bool setupArguments( ParameterParser & parser ) override Adds the argument to the parser. Reimplements : microsoft::quantum::IConfigBind::setupArguments","title":"function setupArguments"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-configure","text":"virtual bool configure( ParameterParser const & parser ) override Reimplements : microsoft::quantum::IConfigBind::configure Configures the bound value. This method examines the parsed input and use updates the bound value accordingly.","title":"function configure"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_config_bind/#function-value","text":"virtual String value() override String representation of the bound value. Reimplements : microsoft::quantum::IConfigBind::value Updated on 22 November 2021 at 10:28:34 UTC","title":"function value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/","text":"microsoft::quantum::ConfigurationManager More... #include <Commandline/ConfigurationManager.hpp> Public Classes Name struct Section Public Types Name using std::shared_ptr< IConfigBind > IConfigBindPtr Pointer class used to bind a parameter to a value. using std::vector< IConfigBindPtr > ConfigList List of bound variables. using std::shared_ptr< void > VoidPtr Type-erased configuration pointer. using std::type_index TypeId Type index class. using std::shared_ptr< bool > BoolPtr using std::vector< Section > Sections List of available sections. Public Functions Name ConfigurationManager () =default Configuration manager is default constructible, non-copyable and non-movable. ConfigurationManager ( ConfigurationManager const & ) ConfigurationManager ( ConfigurationManager && ) ConfigurationManager & operator= ( ConfigurationManager const & ) ConfigurationManager & operator= ( ConfigurationManager && ) void setupArguments ( ParameterParser & parser) Adds all bound variables as parser arguments. void configure ( ParameterParser const & parser) Configures the value of each bound variable given a parser instance. template <typename T > void setConfig (T const & value) Given an instance of the ConfigurationManager , this method override settings of class T. template <typename T > T const & get () const Gets the configuration instance of type T. void printHelp () const Prints options for configurability to the terminal. void printConfiguration () const template <typename T > void addConfig (String const & id =\"\", T const & default_value =T()) Adds a new configuration of type T. template <typename T > bool isActive () Whether or not the component associated with T is active. void setSectionName (String const & name, String const & description) template <typename T > void addParameter (T & bind, T default_value, String const & name, String const & description) template <typename T > void addParameter (T & bind, String const & name, String const & description) Detailed Description class microsoft::quantum::ConfigurationManager; ConfigurationManager is a class that holds a collection of configurations (sections). Each of these sections are embodied in their own class with a one-to-one mapping between configuration section and the configuration type. As an example, if one wishes to make a configuration for the class Foo, one would create a class FooConfig which would hold all the variables that are configurable and then add FooConfig to the ConfigurationManager using [addConfig()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addconfig) . For FooConfig to fulfill the concept of a configuration, it must implement a setup functions whose first argument is the ConfigurationManager . Public Types Documentation using IConfigBindPtr using microsoft::quantum::ConfigurationManager::IConfigBindPtr = std::shared_ptr<IConfigBind>; Pointer class used to bind a parameter to a value. using ConfigList using microsoft::quantum::ConfigurationManager::ConfigList = std::vector<IConfigBindPtr>; List of bound variables. using VoidPtr using microsoft::quantum::ConfigurationManager::VoidPtr = std::shared_ptr<void>; Type-erased configuration pointer. using TypeId using microsoft::quantum::ConfigurationManager::TypeId = std::type_index; Type index class. using BoolPtr using microsoft::quantum::ConfigurationManager::BoolPtr = std::shared_ptr<bool>; using Sections using microsoft::quantum::ConfigurationManager::Sections = std::vector<Section>; List of available sections. Public Functions Documentation function ConfigurationManager ConfigurationManager() =default Configuration manager is default constructible, non-copyable and non-movable. function ConfigurationManager ConfigurationManager( ConfigurationManager const & ) function ConfigurationManager ConfigurationManager( ConfigurationManager && ) function operator= ConfigurationManager & operator=( ConfigurationManager const & ) function operator= ConfigurationManager & operator=( ConfigurationManager && ) function setupArguments void setupArguments( ParameterParser & parser ) Adds all bound variables as parser arguments. function configure void configure( ParameterParser const & parser ) Configures the value of each bound variable given a parser instance. function setConfig template <typename T > inline void setConfig( T const & value ) Given an instance of the ConfigurationManager , this method override settings of class T. function get template <typename T > inline T const & get() const Gets the configuration instance of type T. function printHelp void printHelp() const Prints options for configurability to the terminal. function printConfiguration void printConfiguration() const Prints the configuration to the terminal. The configuration print is LLVM IR compatible meaning that every line starts with a semicolon ; to ensure that it is interpreted as a comment. function addConfig template <typename T > inline void addConfig( String const & id =\"\", T const & default_value =T() ) Adds a new configuration of type T. function isActive template <typename T > inline bool isActive() Whether or not the component associated with T is active. function setSectionName void setSectionName( String const & name, String const & description ) Sets the section name. This method is used by the configuration class to set a section name. function addParameter template <typename T > inline void addParameter( T & bind, T default_value, String const & name, String const & description ) Adds a new parameter with a default value to the configuration section. This function should be used by the configuration class. function addParameter template <typename T > inline void addParameter( T & bind, String const & name, String const & description ) Adds a new parameter to the configuration section. This method uses the bound variable value as default value. This function should be used by the configuration class. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::ConfigurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#microsoftquantumconfigurationmanager","text":"More... #include <Commandline/ConfigurationManager.hpp>","title":"microsoft::quantum::ConfigurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#public-classes","text":"Name struct Section","title":"Public Classes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#public-types","text":"Name using std::shared_ptr< IConfigBind > IConfigBindPtr Pointer class used to bind a parameter to a value. using std::vector< IConfigBindPtr > ConfigList List of bound variables. using std::shared_ptr< void > VoidPtr Type-erased configuration pointer. using std::type_index TypeId Type index class. using std::shared_ptr< bool > BoolPtr using std::vector< Section > Sections List of available sections.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#public-functions","text":"Name ConfigurationManager () =default Configuration manager is default constructible, non-copyable and non-movable. ConfigurationManager ( ConfigurationManager const & ) ConfigurationManager ( ConfigurationManager && ) ConfigurationManager & operator= ( ConfigurationManager const & ) ConfigurationManager & operator= ( ConfigurationManager && ) void setupArguments ( ParameterParser & parser) Adds all bound variables as parser arguments. void configure ( ParameterParser const & parser) Configures the value of each bound variable given a parser instance. template <typename T > void setConfig (T const & value) Given an instance of the ConfigurationManager , this method override settings of class T. template <typename T > T const & get () const Gets the configuration instance of type T. void printHelp () const Prints options for configurability to the terminal. void printConfiguration () const template <typename T > void addConfig (String const & id =\"\", T const & default_value =T()) Adds a new configuration of type T. template <typename T > bool isActive () Whether or not the component associated with T is active. void setSectionName (String const & name, String const & description) template <typename T > void addParameter (T & bind, T default_value, String const & name, String const & description) template <typename T > void addParameter (T & bind, String const & name, String const & description)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#detailed-description","text":"class microsoft::quantum::ConfigurationManager; ConfigurationManager is a class that holds a collection of configurations (sections). Each of these sections are embodied in their own class with a one-to-one mapping between configuration section and the configuration type. As an example, if one wishes to make a configuration for the class Foo, one would create a class FooConfig which would hold all the variables that are configurable and then add FooConfig to the ConfigurationManager using [addConfig()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addconfig) . For FooConfig to fulfill the concept of a configuration, it must implement a setup functions whose first argument is the ConfigurationManager .","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-iconfigbindptr","text":"using microsoft::quantum::ConfigurationManager::IConfigBindPtr = std::shared_ptr<IConfigBind>; Pointer class used to bind a parameter to a value.","title":"using IConfigBindPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-configlist","text":"using microsoft::quantum::ConfigurationManager::ConfigList = std::vector<IConfigBindPtr>; List of bound variables.","title":"using ConfigList"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-voidptr","text":"using microsoft::quantum::ConfigurationManager::VoidPtr = std::shared_ptr<void>; Type-erased configuration pointer.","title":"using VoidPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-typeid","text":"using microsoft::quantum::ConfigurationManager::TypeId = std::type_index; Type index class.","title":"using TypeId"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-boolptr","text":"using microsoft::quantum::ConfigurationManager::BoolPtr = std::shared_ptr<bool>;","title":"using BoolPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-sections","text":"using microsoft::quantum::ConfigurationManager::Sections = std::vector<Section>; List of available sections.","title":"using Sections"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-configurationmanager","text":"ConfigurationManager() =default Configuration manager is default constructible, non-copyable and non-movable.","title":"function ConfigurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-configurationmanager_1","text":"ConfigurationManager( ConfigurationManager const & )","title":"function ConfigurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-configurationmanager_2","text":"ConfigurationManager( ConfigurationManager && )","title":"function ConfigurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-operator","text":"ConfigurationManager & operator=( ConfigurationManager const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-operator_1","text":"ConfigurationManager & operator=( ConfigurationManager && )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-setuparguments","text":"void setupArguments( ParameterParser & parser ) Adds all bound variables as parser arguments.","title":"function setupArguments"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-configure","text":"void configure( ParameterParser const & parser ) Configures the value of each bound variable given a parser instance.","title":"function configure"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-setconfig","text":"template <typename T > inline void setConfig( T const & value ) Given an instance of the ConfigurationManager , this method override settings of class T.","title":"function setConfig"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-get","text":"template <typename T > inline T const & get() const Gets the configuration instance of type T.","title":"function get"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-printhelp","text":"void printHelp() const Prints options for configurability to the terminal.","title":"function printHelp"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-printconfiguration","text":"void printConfiguration() const Prints the configuration to the terminal. The configuration print is LLVM IR compatible meaning that every line starts with a semicolon ; to ensure that it is interpreted as a comment.","title":"function printConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addconfig","text":"template <typename T > inline void addConfig( String const & id =\"\", T const & default_value =T() ) Adds a new configuration of type T.","title":"function addConfig"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-isactive","text":"template <typename T > inline bool isActive() Whether or not the component associated with T is active.","title":"function isActive"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-setsectionname","text":"void setSectionName( String const & name, String const & description ) Sets the section name. This method is used by the configuration class to set a section name.","title":"function setSectionName"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addparameter","text":"template <typename T > inline void addParameter( T & bind, T default_value, String const & name, String const & description ) Adds a new parameter with a default value to the configuration section. This function should be used by the configuration class.","title":"function addParameter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#function-addparameter_1","text":"template <typename T > inline void addParameter( T & bind, String const & name, String const & description ) Adds a new parameter to the configuration section. This method uses the bound variable value as default value. This function should be used by the configuration class. Updated on 22 November 2021 at 10:28:34 UTC","title":"function addParameter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_const_int_pattern/","text":"microsoft::quantum::ConstIntPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::ConstIntPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_const_int_pattern/#microsoftquantumconstintpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::ConstIntPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_const_int_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_const_int_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_const_int_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_const_int_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_const_int_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 November 2021 at 10:28:34 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_default_profile_generator/","text":"microsoft::quantum::DefaultProfileGenerator More... #include <Generators/DefaultProfileGenerator.hpp> Inherits from microsoft::quantum::ProfileGenerator Public Types Name using std::function< void( RuleSet &)> ConfigureFunction Function type that configures a rule set. Public Functions Name DefaultProfileGenerator () DefaultProfileGenerator ( ConfigureFunction const & configure, TransformationRulesPassConfiguration const & profile_pass_config = TransformationRulesPassConfiguration::createDisabled (), LlvmPassesConfiguration const & llvm_config = LlvmPassesConfiguration ()) TransformationRulesPassConfiguration const & ruleTransformationConfig () const Returns a constant reference to the rule transformation configuration. LlvmPassesConfiguration const & llvmPassesConfig () const Returns a constant reference to the LLVM passes configuration. Additional inherited members Public Types inherited from microsoft::quantum::ProfileGenerator Name using llvm::PassBuilder PassBuilder using PassBuilder::OptimizationLevel OptimizationLevel using llvm::FunctionAnalysisManager FunctionAnalysisManager template <typename R > using std::function< void(R const &, ProfileGenerator *, Profile &)> SetupFunction using std::function< void( ProfileGenerator *, Profile &)> SetupFunctionWrapper Wrapper function type for invoking the profile setup function. using std::vector< std::pair< String, SetupFunctionWrapper > > Components List of components to be configured. Public Functions inherited from microsoft::quantum::ProfileGenerator Name ProfileGenerator () =default ~ProfileGenerator () =default ProfileGenerator ( ProfileGenerator const & ) ProfileGenerator ( ProfileGenerator && ) ProfileGenerator & operator= ( ProfileGenerator const & ) ProfileGenerator & operator= ( ProfileGenerator && ) ConfigurationManager & configurationManager () ConfigurationManager const & configurationManager () const Profile newProfile (String const & name, OptimizationLevel const & optimisation_level, bool debug) template <typename R > void registerProfileComponent (String const & id, SetupFunction < R > setup) llvm::ModulePassManager & modulePassManager () Returns the module pass manager. llvm::PassBuilder & passBuilder () Returns the pass builder. OptimizationLevel optimisationLevel () const Returns the optimisation level. bool isDebugMode () const Flag indicating whether we are operating in debug mode or not. Protected Functions inherited from microsoft::quantum::ProfileGenerator Name llvm::ModulePassManager createGenerationModulePassManager ( Profile & profile, OptimizationLevel const & optimisation_level, bool debug) llvm::ModulePassManager createValidationModulePass (PassBuilder & pass_builder, OptimizationLevel const & optimisation_level, bool debug) Detailed Description class microsoft::quantum::DefaultProfileGenerator; DefaultProfileGenerator defines a profile that configures the rule set used by the Profile pass. This profile is useful for generating dynamic profiles and is well suited for testing purposes or YAML configured transformation of the IR. Public Types Documentation using ConfigureFunction using microsoft::quantum::DefaultProfileGenerator::ConfigureFunction = std::function<void(RuleSet&)>; Function type that configures a rule set. Public Functions Documentation function DefaultProfileGenerator DefaultProfileGenerator() Default constructor. This constructor adds components for rule transformation and LLVM passes. These are configurable through the corresponding configuration classes which can be access through the configuration manager. function DefaultProfileGenerator explicit DefaultProfileGenerator( ConfigureFunction const & configure, TransformationRulesPassConfiguration const & profile_pass_config =TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration const & llvm_config =LlvmPassesConfiguration() ) The constructor takes a lambda function which configures the rule set. This function is invoked during the creation of the generation module. This constructor further overrides the default configuration function ruleTransformationConfig TransformationRulesPassConfiguration const & ruleTransformationConfig() const Returns a constant reference to the rule transformation configuration. function llvmPassesConfig LlvmPassesConfiguration const & llvmPassesConfig() const Returns a constant reference to the LLVM passes configuration. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::DefaultProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_default_profile_generator/#microsoftquantumdefaultprofilegenerator","text":"More... #include <Generators/DefaultProfileGenerator.hpp> Inherits from microsoft::quantum::ProfileGenerator","title":"microsoft::quantum::DefaultProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_default_profile_generator/#public-types","text":"Name using std::function< void( RuleSet &)> ConfigureFunction Function type that configures a rule set.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_default_profile_generator/#public-functions","text":"Name DefaultProfileGenerator () DefaultProfileGenerator ( ConfigureFunction const & configure, TransformationRulesPassConfiguration const & profile_pass_config = TransformationRulesPassConfiguration::createDisabled (), LlvmPassesConfiguration const & llvm_config = LlvmPassesConfiguration ()) TransformationRulesPassConfiguration const & ruleTransformationConfig () const Returns a constant reference to the rule transformation configuration. LlvmPassesConfiguration const & llvmPassesConfig () const Returns a constant reference to the LLVM passes configuration.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_default_profile_generator/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::ProfileGenerator Name using llvm::PassBuilder PassBuilder using PassBuilder::OptimizationLevel OptimizationLevel using llvm::FunctionAnalysisManager FunctionAnalysisManager template <typename R > using std::function< void(R const &, ProfileGenerator *, Profile &)> SetupFunction using std::function< void( ProfileGenerator *, Profile &)> SetupFunctionWrapper Wrapper function type for invoking the profile setup function. using std::vector< std::pair< String, SetupFunctionWrapper > > Components List of components to be configured. Public Functions inherited from microsoft::quantum::ProfileGenerator Name ProfileGenerator () =default ~ProfileGenerator () =default ProfileGenerator ( ProfileGenerator const & ) ProfileGenerator ( ProfileGenerator && ) ProfileGenerator & operator= ( ProfileGenerator const & ) ProfileGenerator & operator= ( ProfileGenerator && ) ConfigurationManager & configurationManager () ConfigurationManager const & configurationManager () const Profile newProfile (String const & name, OptimizationLevel const & optimisation_level, bool debug) template <typename R > void registerProfileComponent (String const & id, SetupFunction < R > setup) llvm::ModulePassManager & modulePassManager () Returns the module pass manager. llvm::PassBuilder & passBuilder () Returns the pass builder. OptimizationLevel optimisationLevel () const Returns the optimisation level. bool isDebugMode () const Flag indicating whether we are operating in debug mode or not. Protected Functions inherited from microsoft::quantum::ProfileGenerator Name llvm::ModulePassManager createGenerationModulePassManager ( Profile & profile, OptimizationLevel const & optimisation_level, bool debug) llvm::ModulePassManager createValidationModulePass (PassBuilder & pass_builder, OptimizationLevel const & optimisation_level, bool debug)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_default_profile_generator/#detailed-description","text":"class microsoft::quantum::DefaultProfileGenerator; DefaultProfileGenerator defines a profile that configures the rule set used by the Profile pass. This profile is useful for generating dynamic profiles and is well suited for testing purposes or YAML configured transformation of the IR.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_default_profile_generator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_default_profile_generator/#using-configurefunction","text":"using microsoft::quantum::DefaultProfileGenerator::ConfigureFunction = std::function<void(RuleSet&)>; Function type that configures a rule set.","title":"using ConfigureFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_default_profile_generator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_default_profile_generator/#function-defaultprofilegenerator","text":"DefaultProfileGenerator() Default constructor. This constructor adds components for rule transformation and LLVM passes. These are configurable through the corresponding configuration classes which can be access through the configuration manager.","title":"function DefaultProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_default_profile_generator/#function-defaultprofilegenerator_1","text":"explicit DefaultProfileGenerator( ConfigureFunction const & configure, TransformationRulesPassConfiguration const & profile_pass_config =TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration const & llvm_config =LlvmPassesConfiguration() ) The constructor takes a lambda function which configures the rule set. This function is invoked during the creation of the generation module. This constructor further overrides the default configuration","title":"function DefaultProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_default_profile_generator/#function-ruletransformationconfig","text":"TransformationRulesPassConfiguration const & ruleTransformationConfig() const Returns a constant reference to the rule transformation configuration.","title":"function ruleTransformationConfig"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_default_profile_generator/#function-llvmpassesconfig","text":"LlvmPassesConfiguration const & llvmPassesConfig() const Returns a constant reference to the LLVM passes configuration. Updated on 22 November 2021 at 10:28:34 UTC","title":"function llvmPassesConfig"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/","text":"microsoft::quantum::FactoryConfiguration Public Functions Name void setup ( ConfigurationManager & config) bool disableReferenceCounting () const bool disableAliasCounting () const bool disableStringSupport () const bool optimiseResultOne () const bool optimiseResultZero () const bool useStaticQubitArrayAllocation () const bool useStaticQubitAllocation () const bool useStaticResultAllocation () const uint32_t defaultIntegerWidth () const bool isDisabled () const bool isDefault () const FactoryConfiguration createDisabled () Public Functions Documentation function setup inline void setup( ConfigurationManager & config ) function disableReferenceCounting inline bool disableReferenceCounting() const function disableAliasCounting inline bool disableAliasCounting() const function disableStringSupport inline bool disableStringSupport() const function optimiseResultOne inline bool optimiseResultOne() const function optimiseResultZero inline bool optimiseResultZero() const function useStaticQubitArrayAllocation inline bool useStaticQubitArrayAllocation() const function useStaticQubitAllocation inline bool useStaticQubitAllocation() const function useStaticResultAllocation inline bool useStaticResultAllocation() const function defaultIntegerWidth inline uint32_t defaultIntegerWidth() const function isDisabled inline bool isDisabled() const function isDefault inline bool isDefault() const function createDisabled static inline FactoryConfiguration createDisabled() Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::FactoryConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#microsoftquantumfactoryconfiguration","text":"","title":"microsoft::quantum::FactoryConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#public-functions","text":"Name void setup ( ConfigurationManager & config) bool disableReferenceCounting () const bool disableAliasCounting () const bool disableStringSupport () const bool optimiseResultOne () const bool optimiseResultZero () const bool useStaticQubitArrayAllocation () const bool useStaticQubitAllocation () const bool useStaticResultAllocation () const uint32_t defaultIntegerWidth () const bool isDisabled () const bool isDefault () const FactoryConfiguration createDisabled ()","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-setup","text":"inline void setup( ConfigurationManager & config )","title":"function setup"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-disablereferencecounting","text":"inline bool disableReferenceCounting() const","title":"function disableReferenceCounting"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-disablealiascounting","text":"inline bool disableAliasCounting() const","title":"function disableAliasCounting"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-disablestringsupport","text":"inline bool disableStringSupport() const","title":"function disableStringSupport"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-optimiseresultone","text":"inline bool optimiseResultOne() const","title":"function optimiseResultOne"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-optimiseresultzero","text":"inline bool optimiseResultZero() const","title":"function optimiseResultZero"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-usestaticqubitarrayallocation","text":"inline bool useStaticQubitArrayAllocation() const","title":"function useStaticQubitArrayAllocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-usestaticqubitallocation","text":"inline bool useStaticQubitAllocation() const","title":"function useStaticQubitAllocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-usestaticresultallocation","text":"inline bool useStaticResultAllocation() const","title":"function useStaticResultAllocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-defaultintegerwidth","text":"inline uint32_t defaultIntegerWidth() const","title":"function defaultIntegerWidth"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-isdisabled","text":"inline bool isDisabled() const","title":"function isDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-isdefault","text":"inline bool isDefault() const","title":"function isDefault"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_factory_configuration/#function-createdisabled","text":"static inline FactoryConfiguration createDisabled() Updated on 22 November 2021 at 10:28:34 UTC","title":"function createDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/","text":"microsoft::quantum::IAllocationManager More... #include <AllocationManager/IAllocationManager.hpp> Inherited by microsoft::quantum::BasicAllocationManager Public Types Name using uint64_t Address Value type for address. using uint64_t Index Index type used to access an array element. using std::shared_ptr< IAllocationManager > AllocationManagerPtr Pointer interface. Public Functions Name IAllocationManager ( IAllocationManager const & ) IAllocationManager ( IAllocationManager && ) IAllocationManager & operator= ( IAllocationManager const & ) IAllocationManager & operator= ( IAllocationManager && ) virtual ~IAllocationManager () virtual Address allocate (String const & name =\"\", Index const & count =1) =0 virtual void release ( Address const & address) =0 virtual void reset () =0 uint64_t allocationsInUse () const uint64_t maxAllocationsUsed () const Protected Functions Name IAllocationManager () =default void updateRegistersInUse (uint64_t n) Detailed Description class microsoft::quantum::IAllocationManager; Interface class for allocation management. This interface provides means to allocate and release statically allocated resources such as qubits and results. In a future version, it may be extended with get and store in order to support Arrays and Tuples. Public Types Documentation using Address using microsoft::quantum::IAllocationManager::Address = uint64_t; Value type for address. using Index using microsoft::quantum::IAllocationManager::Index = uint64_t; Index type used to access an array element. using AllocationManagerPtr using microsoft::quantum::IAllocationManager::AllocationManagerPtr = std::shared_ptr<IAllocationManager>; Pointer interface. Public Functions Documentation function IAllocationManager IAllocationManager( IAllocationManager const & ) function IAllocationManager IAllocationManager( IAllocationManager && ) function operator= IAllocationManager & operator=( IAllocationManager const & ) function operator= IAllocationManager & operator=( IAllocationManager && ) function ~IAllocationManager virtual ~IAllocationManager() function allocate virtual Address allocate( String const & name =\"\", Index const & count =1 ) =0 Reimplemented by : microsoft::quantum::BasicAllocationManager::allocate Abstract member function to allocate an element or sequence of elements. The developer should not assume continuity of the address segment as this is not guaranteed. Note this function may throw if allocation is not possible. function release virtual void release( Address const & address ) =0 Reimplemented by : microsoft::quantum::BasicAllocationManager::release Abstract member function to release a previously allocated function. Note this function may throw if an invalid address is passed. function reset virtual void reset() =0 Reimplemented by : microsoft::quantum::BasicAllocationManager::reset Abstract member function to reset the allocation manager. This function clears all allocations and resets all statistics. function allocationsInUse uint64_t allocationsInUse() const Current number of registers in use. This function is used to inquire about the current number registers/resources in use. function maxAllocationsUsed uint64_t maxAllocationsUsed() const Maximum number of registers in use at any one time. The maximum number of registers used at any one time. As an example of usage, this function is useful to calculate the total number of qubits required to execute the entry function. Protected Functions Documentation function IAllocationManager IAllocationManager() =default function updateRegistersInUse void updateRegistersInUse( uint64_t n ) Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::IAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#microsoftquantumiallocationmanager","text":"More... #include <AllocationManager/IAllocationManager.hpp> Inherited by microsoft::quantum::BasicAllocationManager","title":"microsoft::quantum::IAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#public-types","text":"Name using uint64_t Address Value type for address. using uint64_t Index Index type used to access an array element. using std::shared_ptr< IAllocationManager > AllocationManagerPtr Pointer interface.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#public-functions","text":"Name IAllocationManager ( IAllocationManager const & ) IAllocationManager ( IAllocationManager && ) IAllocationManager & operator= ( IAllocationManager const & ) IAllocationManager & operator= ( IAllocationManager && ) virtual ~IAllocationManager () virtual Address allocate (String const & name =\"\", Index const & count =1) =0 virtual void release ( Address const & address) =0 virtual void reset () =0 uint64_t allocationsInUse () const uint64_t maxAllocationsUsed () const","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#protected-functions","text":"Name IAllocationManager () =default void updateRegistersInUse (uint64_t n)","title":"Protected Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#detailed-description","text":"class microsoft::quantum::IAllocationManager; Interface class for allocation management. This interface provides means to allocate and release statically allocated resources such as qubits and results. In a future version, it may be extended with get and store in order to support Arrays and Tuples.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#using-address","text":"using microsoft::quantum::IAllocationManager::Address = uint64_t; Value type for address.","title":"using Address"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#using-index","text":"using microsoft::quantum::IAllocationManager::Index = uint64_t; Index type used to access an array element.","title":"using Index"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#using-allocationmanagerptr","text":"using microsoft::quantum::IAllocationManager::AllocationManagerPtr = std::shared_ptr<IAllocationManager>; Pointer interface.","title":"using AllocationManagerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-iallocationmanager","text":"IAllocationManager( IAllocationManager const & )","title":"function IAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-iallocationmanager_1","text":"IAllocationManager( IAllocationManager && )","title":"function IAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-operator","text":"IAllocationManager & operator=( IAllocationManager const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-operator_1","text":"IAllocationManager & operator=( IAllocationManager && )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-iallocationmanager_2","text":"virtual ~IAllocationManager()","title":"function ~IAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-allocate","text":"virtual Address allocate( String const & name =\"\", Index const & count =1 ) =0 Reimplemented by : microsoft::quantum::BasicAllocationManager::allocate Abstract member function to allocate an element or sequence of elements. The developer should not assume continuity of the address segment as this is not guaranteed. Note this function may throw if allocation is not possible.","title":"function allocate"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-release","text":"virtual void release( Address const & address ) =0 Reimplemented by : microsoft::quantum::BasicAllocationManager::release Abstract member function to release a previously allocated function. Note this function may throw if an invalid address is passed.","title":"function release"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-reset","text":"virtual void reset() =0 Reimplemented by : microsoft::quantum::BasicAllocationManager::reset Abstract member function to reset the allocation manager. This function clears all allocations and resets all statistics.","title":"function reset"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-allocationsinuse","text":"uint64_t allocationsInUse() const Current number of registers in use. This function is used to inquire about the current number registers/resources in use.","title":"function allocationsInUse"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-maxallocationsused","text":"uint64_t maxAllocationsUsed() const Maximum number of registers in use at any one time. The maximum number of registers used at any one time. As an example of usage, this function is useful to calculate the total number of qubits required to execute the entry function.","title":"function maxAllocationsUsed"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-iallocationmanager_3","text":"IAllocationManager() =default","title":"function IAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_allocation_manager/#function-updateregistersinuse","text":"void updateRegistersInUse( uint64_t n ) Updated on 22 November 2021 at 10:28:34 UTC","title":"function updateRegistersInUse"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/","text":"microsoft::quantum::IConfigBind More... #include <Commandline/IConfigBind.hpp> Inherited by microsoft::quantum::ConfigBind< T > Public Functions Name IConfigBind ( IConfigBind const & ) IConfigBind ( IConfigBind && ) IConfigBind & operator= ( IConfigBind const & ) IConfigBind & operator= ( IConfigBind && ) virtual ~IConfigBind () virtual bool setupArguments ( ParameterParser & parser) =0 virtual bool configure ( ParameterParser const & parser) =0 virtual String value () =0 String name () const Returns the name of the bound configuration variable. String description () const Returns the description of the configuration variable. bool isFlag () const Indicates whether or not this. String defaultValue () const Returns the default value for the flag. Protected Functions Name IConfigBind (String const & name, String const & description) void setName (String const & name) Sets the name of the configuration variable. void markAsFlag () Marks the variable as a flag. void setDefault (String const & v) Sets the default value as a string. Detailed Description class microsoft::quantum::IConfigBind; Interface class to bind a variable to a configuration flag. This class provides the necessary interface to bind variables and populate their value based on given command-line arguments. Public Functions Documentation function IConfigBind IConfigBind( IConfigBind const & ) function IConfigBind IConfigBind( IConfigBind && ) function operator= IConfigBind & operator=( IConfigBind const & ) function operator= IConfigBind & operator=( IConfigBind && ) function ~IConfigBind virtual ~IConfigBind() function setupArguments virtual bool setupArguments( ParameterParser & parser ) =0 Reimplemented by : microsoft::quantum::ConfigBind::setupArguments Interface function to register configuration in the parser. This function register the configuration to the parameter parser. This makes the configuration available in the parameter parsers help function. This method should return true if arguments were successfully setup. function configure virtual bool configure( ParameterParser const & parser ) =0 Reimplemented by : microsoft::quantum::ConfigBind::configure Interface function to extract configuration from the command line arguments. Given an instance of the command line parameter parser, this function is meant to read the command line arguments, interpret it and set the bound variable value (if present). This method should return true if configure operation was successful. function value virtual String value() =0 Reimplemented by : microsoft::quantum::ConfigBind::value Interface function to return a string representation of the current value of the bound variable. function name String name() const Returns the name of the bound configuration variable. function description String description() const Returns the description of the configuration variable. function isFlag bool isFlag() const Indicates whether or not this. function defaultValue String defaultValue() const Returns the default value for the flag. Protected Functions Documentation function IConfigBind IConfigBind( String const & name, String const & description ) function setName void setName( String const & name ) Sets the name of the configuration variable. function markAsFlag void markAsFlag() Marks the variable as a flag. function setDefault void setDefault( String const & v ) Sets the default value as a string. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::IConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#microsoftquantumiconfigbind","text":"More... #include <Commandline/IConfigBind.hpp> Inherited by microsoft::quantum::ConfigBind< T >","title":"microsoft::quantum::IConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#public-functions","text":"Name IConfigBind ( IConfigBind const & ) IConfigBind ( IConfigBind && ) IConfigBind & operator= ( IConfigBind const & ) IConfigBind & operator= ( IConfigBind && ) virtual ~IConfigBind () virtual bool setupArguments ( ParameterParser & parser) =0 virtual bool configure ( ParameterParser const & parser) =0 virtual String value () =0 String name () const Returns the name of the bound configuration variable. String description () const Returns the description of the configuration variable. bool isFlag () const Indicates whether or not this. String defaultValue () const Returns the default value for the flag.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#protected-functions","text":"Name IConfigBind (String const & name, String const & description) void setName (String const & name) Sets the name of the configuration variable. void markAsFlag () Marks the variable as a flag. void setDefault (String const & v) Sets the default value as a string.","title":"Protected Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#detailed-description","text":"class microsoft::quantum::IConfigBind; Interface class to bind a variable to a configuration flag. This class provides the necessary interface to bind variables and populate their value based on given command-line arguments.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-iconfigbind","text":"IConfigBind( IConfigBind const & )","title":"function IConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-iconfigbind_1","text":"IConfigBind( IConfigBind && )","title":"function IConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-operator","text":"IConfigBind & operator=( IConfigBind const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-operator_1","text":"IConfigBind & operator=( IConfigBind && )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-iconfigbind_2","text":"virtual ~IConfigBind()","title":"function ~IConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-setuparguments","text":"virtual bool setupArguments( ParameterParser & parser ) =0 Reimplemented by : microsoft::quantum::ConfigBind::setupArguments Interface function to register configuration in the parser. This function register the configuration to the parameter parser. This makes the configuration available in the parameter parsers help function. This method should return true if arguments were successfully setup.","title":"function setupArguments"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-configure","text":"virtual bool configure( ParameterParser const & parser ) =0 Reimplemented by : microsoft::quantum::ConfigBind::configure Interface function to extract configuration from the command line arguments. Given an instance of the command line parameter parser, this function is meant to read the command line arguments, interpret it and set the bound variable value (if present). This method should return true if configure operation was successful.","title":"function configure"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-value","text":"virtual String value() =0 Reimplemented by : microsoft::quantum::ConfigBind::value Interface function to return a string representation of the current value of the bound variable.","title":"function value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-name","text":"String name() const Returns the name of the bound configuration variable.","title":"function name"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-description","text":"String description() const Returns the description of the configuration variable.","title":"function description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-isflag","text":"bool isFlag() const Indicates whether or not this.","title":"function isFlag"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-defaultvalue","text":"String defaultValue() const Returns the default value for the flag.","title":"function defaultValue"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-iconfigbind_3","text":"IConfigBind( String const & name, String const & description )","title":"function IConfigBind"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-setname","text":"void setName( String const & name ) Sets the name of the configuration variable.","title":"function setName"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-markasflag","text":"void markAsFlag() Marks the variable as a flag.","title":"function markAsFlag"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_config_bind/#function-setdefault","text":"void setDefault( String const & v ) Sets the default value as a string. Updated on 22 November 2021 at 10:28:34 UTC","title":"function setDefault"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/","text":"microsoft::quantum::ILogger More... #include <Logging/ILogger.hpp> Inherited by microsoft::quantum::CommentLogger , microsoft::quantum::LogCollection Public Functions Name ILogger () =default ILogger ( ILogger const & ) =default ILogger ( ILogger && ) =default ILogger & operator= ( ILogger const & ) =default ILogger & operator= ( ILogger && ) =default virtual ~ILogger () virtual void debug (String const & message) =0 Reports a debug message. virtual void info (String const & message) =0 Reports an info message. virtual void warning (String const & message) =0 Reports a warning message. virtual void error (String const & message) =0 Reports an error message. virtual void internalError (String const & message) =0 Reports an internal error message. virtual void setLocation (String const & name, uint64_t row, uint64_t col) =0 Detailed Description class microsoft::quantum::ILogger; Logger interface to allow the collection of different types of messages during QIR transformation and/or validation. Public Functions Documentation function ILogger ILogger() =default function ILogger ILogger( ILogger const & ) =default function ILogger ILogger( ILogger && ) =default function operator= ILogger & operator=( ILogger const & ) =default function operator= ILogger & operator=( ILogger && ) =default function ~ILogger virtual ~ILogger() function debug virtual void debug( String const & message ) =0 Reports a debug message. Reimplemented by : microsoft::quantum::CommentLogger::debug , microsoft::quantum::LogCollection::debug function info virtual void info( String const & message ) =0 Reports an info message. Reimplemented by : microsoft::quantum::CommentLogger::info , microsoft::quantum::LogCollection::info function warning virtual void warning( String const & message ) =0 Reports a warning message. Reimplemented by : microsoft::quantum::CommentLogger::warning , microsoft::quantum::LogCollection::warning function error virtual void error( String const & message ) =0 Reports an error message. Reimplemented by : microsoft::quantum::CommentLogger::error , microsoft::quantum::LogCollection::error function internalError virtual void internalError( String const & message ) =0 Reports an internal error message. Reimplemented by : microsoft::quantum::CommentLogger::internalError , microsoft::quantum::LogCollection::internalError function setLocation virtual void setLocation( String const & name, uint64_t row, uint64_t col ) =0 Reimplemented by : microsoft::quantum::CommentLogger::setLocation , microsoft::quantum::LogCollection::setLocation Sets the current location. Importantly, the location can be set independently of the reported messages. This allows one to update the location upon updating the cursor position without having to worry about keeping a copy of the location to pass when reporting messages. The most obvious case of this is file path (name) with a line and character (row, col). Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::ILogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#microsoftquantumilogger","text":"More... #include <Logging/ILogger.hpp> Inherited by microsoft::quantum::CommentLogger , microsoft::quantum::LogCollection","title":"microsoft::quantum::ILogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#public-functions","text":"Name ILogger () =default ILogger ( ILogger const & ) =default ILogger ( ILogger && ) =default ILogger & operator= ( ILogger const & ) =default ILogger & operator= ( ILogger && ) =default virtual ~ILogger () virtual void debug (String const & message) =0 Reports a debug message. virtual void info (String const & message) =0 Reports an info message. virtual void warning (String const & message) =0 Reports a warning message. virtual void error (String const & message) =0 Reports an error message. virtual void internalError (String const & message) =0 Reports an internal error message. virtual void setLocation (String const & name, uint64_t row, uint64_t col) =0","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#detailed-description","text":"class microsoft::quantum::ILogger; Logger interface to allow the collection of different types of messages during QIR transformation and/or validation.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-ilogger","text":"ILogger() =default","title":"function ILogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-ilogger_1","text":"ILogger( ILogger const & ) =default","title":"function ILogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-ilogger_2","text":"ILogger( ILogger && ) =default","title":"function ILogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-operator","text":"ILogger & operator=( ILogger const & ) =default","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-operator_1","text":"ILogger & operator=( ILogger && ) =default","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-ilogger_3","text":"virtual ~ILogger()","title":"function ~ILogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-debug","text":"virtual void debug( String const & message ) =0 Reports a debug message. Reimplemented by : microsoft::quantum::CommentLogger::debug , microsoft::quantum::LogCollection::debug","title":"function debug"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-info","text":"virtual void info( String const & message ) =0 Reports an info message. Reimplemented by : microsoft::quantum::CommentLogger::info , microsoft::quantum::LogCollection::info","title":"function info"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-warning","text":"virtual void warning( String const & message ) =0 Reports a warning message. Reimplemented by : microsoft::quantum::CommentLogger::warning , microsoft::quantum::LogCollection::warning","title":"function warning"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-error","text":"virtual void error( String const & message ) =0 Reports an error message. Reimplemented by : microsoft::quantum::CommentLogger::error , microsoft::quantum::LogCollection::error","title":"function error"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-internalerror","text":"virtual void internalError( String const & message ) =0 Reports an internal error message. Reimplemented by : microsoft::quantum::CommentLogger::internalError , microsoft::quantum::LogCollection::internalError","title":"function internalError"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_logger/#function-setlocation","text":"virtual void setLocation( String const & name, uint64_t row, uint64_t col ) =0 Reimplemented by : microsoft::quantum::CommentLogger::setLocation , microsoft::quantum::LogCollection::setLocation Sets the current location. Importantly, the location can be set independently of the reported messages. This allows one to update the location upon updating the cursor position without having to worry about keeping a copy of the location to pass when reporting messages. The most obvious case of this is file path (name) with a line and character (row, col). Updated on 22 November 2021 at 10:28:34 UTC","title":"function setLocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/","text":"microsoft::quantum::IOperandPrototype More... #include <Rules/IOperandPrototype.hpp> Inherited by microsoft::quantum::AnyPattern , microsoft::quantum::BasicBlockPattern , microsoft::quantum::BitCastPattern , microsoft::quantum::BranchPattern , microsoft::quantum::CallPattern , microsoft::quantum::ConstIntPattern , microsoft::quantum::IntToPtrPattern , microsoft::quantum::LoadPattern , microsoft::quantum::PhiPattern , microsoft::quantum::SelectPattern , microsoft::quantum::StorePattern , microsoft::quantum::SwitchPattern , microsoft::quantum::UnnamedInvokePattern Public Types Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions Name IOperandPrototype () =default virtual ~IOperandPrototype () virtual bool match (Value * value, Captures & captures) const =0 virtual Child copy () const =0 void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Detailed Description class microsoft::quantum::IOperandPrototype; IOperandPrototype describes an IR pattern and allows matching against LLVMs llvm::Value type. Each value may or may not be captured during the matching process which means that they are stored in a map under a given name. Capturing is enabled using captureAs(name) which sets the name the value should be stored under. Public Types Documentation using Instruction using microsoft::quantum::IOperandPrototype::Instruction = llvm::Instruction; using String using microsoft::quantum::IOperandPrototype::String = std::string; using Value using microsoft::quantum::IOperandPrototype::Value = llvm::Value; using Child using microsoft::quantum::IOperandPrototype::Child = std::shared_ptr<IOperandPrototype>; using Children using microsoft::quantum::IOperandPrototype::Children = std::vector<Child>; using Captures using microsoft::quantum::IOperandPrototype::Captures = std::unordered_map<std::string, Value*>; Public Functions Documentation function IOperandPrototype IOperandPrototype() =default function ~IOperandPrototype virtual ~IOperandPrototype() function match virtual bool match( Value * value, Captures & captures ) const =0 Reimplemented by : microsoft::quantum::StorePattern::match , microsoft::quantum::LoadPattern::match , microsoft::quantum::AnyPattern::match , microsoft::quantum::BitCastPattern::match , microsoft::quantum::UnnamedInvokePattern::match , microsoft::quantum::PhiPattern::match , microsoft::quantum::IntToPtrPattern::match , microsoft::quantum::CallPattern::match , microsoft::quantum::ConstIntPattern::match , microsoft::quantum::BranchPattern::match , microsoft::quantum::SelectPattern::match , microsoft::quantum::BasicBlockPattern::match , microsoft::quantum::SwitchPattern::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const =0 Reimplemented by : microsoft::quantum::StorePattern::copy , microsoft::quantum::LoadPattern::copy , microsoft::quantum::AnyPattern::copy , microsoft::quantum::BitCastPattern::copy , microsoft::quantum::IntToPtrPattern::copy , microsoft::quantum::UnnamedInvokePattern::copy , microsoft::quantum::PhiPattern::copy , microsoft::quantum::CallPattern::copy , microsoft::quantum::ConstIntPattern::copy , microsoft::quantum::BranchPattern::copy , microsoft::quantum::SelectPattern::copy , microsoft::quantum::BasicBlockPattern::copy , microsoft::quantum::SwitchPattern::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. function addChild void addChild( Child const & child ) Adds a child to be matched against the matches children. Children are matched in order and by size. function captureAs void captureAs( std::string capture_name ) Flags that this operand should be captured. This function ensures that the captured operand is given a name. The subsequent logic in this class is responsible for capturing (upon match) and uncapturing (upon backtrack) with specified name Protected Functions Documentation function fail bool fail( Value * value, Captures & captures ) const Function which should be called whenever a match fails. function success bool success( Value * value, Captures & captures ) const Function which should be called whenever a match is successful. function matchChildren bool matchChildren( Value * value, Captures & captures ) const Subroutine to match all children. function copyPropertiesFrom inline void copyPropertiesFrom( IOperandPrototype const & other ) Shallow copy of the operand to allow name change of the capture Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::IOperandPrototype"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#microsoftquantumioperandprototype","text":"More... #include <Rules/IOperandPrototype.hpp> Inherited by microsoft::quantum::AnyPattern , microsoft::quantum::BasicBlockPattern , microsoft::quantum::BitCastPattern , microsoft::quantum::BranchPattern , microsoft::quantum::CallPattern , microsoft::quantum::ConstIntPattern , microsoft::quantum::IntToPtrPattern , microsoft::quantum::LoadPattern , microsoft::quantum::PhiPattern , microsoft::quantum::SelectPattern , microsoft::quantum::StorePattern , microsoft::quantum::SwitchPattern , microsoft::quantum::UnnamedInvokePattern","title":"microsoft::quantum::IOperandPrototype"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#public-types","text":"Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#public-functions","text":"Name IOperandPrototype () =default virtual ~IOperandPrototype () virtual bool match (Value * value, Captures & captures) const =0 virtual Child copy () const =0 void addChild (Child const & child) void captureAs (std::string capture_name)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#protected-functions","text":"Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Protected Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#detailed-description","text":"class microsoft::quantum::IOperandPrototype; IOperandPrototype describes an IR pattern and allows matching against LLVMs llvm::Value type. Each value may or may not be captured during the matching process which means that they are stored in a map under a given name. Capturing is enabled using captureAs(name) which sets the name the value should be stored under.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#using-instruction","text":"using microsoft::quantum::IOperandPrototype::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#using-string","text":"using microsoft::quantum::IOperandPrototype::String = std::string;","title":"using String"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#using-value","text":"using microsoft::quantum::IOperandPrototype::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#using-child","text":"using microsoft::quantum::IOperandPrototype::Child = std::shared_ptr<IOperandPrototype>;","title":"using Child"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#using-children","text":"using microsoft::quantum::IOperandPrototype::Children = std::vector<Child>;","title":"using Children"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#using-captures","text":"using microsoft::quantum::IOperandPrototype::Captures = std::unordered_map<std::string, Value*>;","title":"using Captures"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-ioperandprototype","text":"IOperandPrototype() =default","title":"function IOperandPrototype"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-ioperandprototype_1","text":"virtual ~IOperandPrototype()","title":"function ~IOperandPrototype"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const =0 Reimplemented by : microsoft::quantum::StorePattern::match , microsoft::quantum::LoadPattern::match , microsoft::quantum::AnyPattern::match , microsoft::quantum::BitCastPattern::match , microsoft::quantum::UnnamedInvokePattern::match , microsoft::quantum::PhiPattern::match , microsoft::quantum::IntToPtrPattern::match , microsoft::quantum::CallPattern::match , microsoft::quantum::ConstIntPattern::match , microsoft::quantum::BranchPattern::match , microsoft::quantum::SelectPattern::match , microsoft::quantum::BasicBlockPattern::match , microsoft::quantum::SwitchPattern::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-copy","text":"virtual Child copy() const =0 Reimplemented by : microsoft::quantum::StorePattern::copy , microsoft::quantum::LoadPattern::copy , microsoft::quantum::AnyPattern::copy , microsoft::quantum::BitCastPattern::copy , microsoft::quantum::IntToPtrPattern::copy , microsoft::quantum::UnnamedInvokePattern::copy , microsoft::quantum::PhiPattern::copy , microsoft::quantum::CallPattern::copy , microsoft::quantum::ConstIntPattern::copy , microsoft::quantum::BranchPattern::copy , microsoft::quantum::SelectPattern::copy , microsoft::quantum::BasicBlockPattern::copy , microsoft::quantum::SwitchPattern::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy.","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-addchild","text":"void addChild( Child const & child ) Adds a child to be matched against the matches children. Children are matched in order and by size.","title":"function addChild"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-captureas","text":"void captureAs( std::string capture_name ) Flags that this operand should be captured. This function ensures that the captured operand is given a name. The subsequent logic in this class is responsible for capturing (upon match) and uncapturing (upon backtrack) with specified name","title":"function captureAs"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail","text":"bool fail( Value * value, Captures & captures ) const Function which should be called whenever a match fails.","title":"function fail"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success","text":"bool success( Value * value, Captures & captures ) const Function which should be called whenever a match is successful.","title":"function success"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-matchchildren","text":"bool matchChildren( Value * value, Captures & captures ) const Subroutine to match all children.","title":"function matchChildren"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-copypropertiesfrom","text":"inline void copyPropertiesFrom( IOperandPrototype const & other ) Shallow copy of the operand to allow name change of the capture Updated on 22 November 2021 at 10:28:34 UTC","title":"function copyPropertiesFrom"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_int_to_ptr_pattern/","text":"microsoft::quantum::IntToPtrPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::IntToPtrPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_int_to_ptr_pattern/#microsoftquantuminttoptrpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::IntToPtrPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_int_to_ptr_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_int_to_ptr_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_int_to_ptr_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_int_to_ptr_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_int_to_ptr_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 November 2021 at 10:28:34 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/","text":"microsoft::quantum::IrManipulationTestHelper Public Types Name using std::string String using llvm::LLVMContext LLVMContext using llvm::SMDiagnostic SMDiagnostic using llvm::Module Module using std::unique_ptr< Module > ModulePtr using std::vector< String > Strings using llvm::PassBuilder::OptimizationLevel OptimizationLevel using std::shared_ptr< ProfileGenerator > GeneratorPtr Public Functions Name IrManipulationTestHelper () IrManipulationTestHelper ( IrManipulationTestHelper const & ) IrManipulationTestHelper & operator= ( IrManipulationTestHelper const & ) IrManipulationTestHelper ( IrManipulationTestHelper && ) IrManipulationTestHelper & operator= ( IrManipulationTestHelper && ) String toString () const Generates a string for the IR currently held in the module. Strings toBodyInstructions () Generates a list of instructions for the main function in the module. bool hasInstructionSequence (Strings const & instructions) void applyProfile (GeneratorPtr const & profile, OptimizationLevel const & optimisation_level =OptimizationLevel::O0, bool debug =false) void declareOpaque (String const & name) void declareFunction (String const & declaration) bool fromBodyString (String const & body, String const & args =\"\") String generateScript (String const & body, String const & args =\"\") const Generates a script given the body of the main function. bool fromString (String const & data) String getErrorMessage () const Gets an error message if the compilation failed. bool isModuleBroken () Whether or not the module is broken. ModulePtr & module () Returns a reference to the module. Public Types Documentation using String using microsoft::quantum::IrManipulationTestHelper::String = std::string; using LLVMContext using microsoft::quantum::IrManipulationTestHelper::LLVMContext = llvm::LLVMContext; using SMDiagnostic using microsoft::quantum::IrManipulationTestHelper::SMDiagnostic = llvm::SMDiagnostic; using Module using microsoft::quantum::IrManipulationTestHelper::Module = llvm::Module; using ModulePtr using microsoft::quantum::IrManipulationTestHelper::ModulePtr = std::unique_ptr<Module>; using Strings using microsoft::quantum::IrManipulationTestHelper::Strings = std::vector<String>; using OptimizationLevel using microsoft::quantum::IrManipulationTestHelper::OptimizationLevel = llvm::PassBuilder::OptimizationLevel; using GeneratorPtr using microsoft::quantum::IrManipulationTestHelper::GeneratorPtr = std::shared_ptr<ProfileGenerator>; Public Functions Documentation function IrManipulationTestHelper IrManipulationTestHelper() function IrManipulationTestHelper IrManipulationTestHelper( IrManipulationTestHelper const & ) function operator= IrManipulationTestHelper & operator=( IrManipulationTestHelper const & ) function IrManipulationTestHelper IrManipulationTestHelper( IrManipulationTestHelper && ) function operator= IrManipulationTestHelper & operator=( IrManipulationTestHelper && ) function toString String toString() const Generates a string for the IR currently held in the module. function toBodyInstructions Strings toBodyInstructions() Generates a list of instructions for the main function in the module. function hasInstructionSequence bool hasInstructionSequence( Strings const & instructions ) Tests whether the main body contains a sequence of instructions. This function ignores instructions in-between the instruction set given. function applyProfile void applyProfile( GeneratorPtr const & profile, OptimizationLevel const & optimisation_level =OptimizationLevel::O0, bool debug =false ) Applies a profile to the module to allow which transforms the IR. This allow us to write small profiles to test a single piece of transformation. function declareOpaque void declareOpaque( String const & name ) Declares a opaque type. Only the name of the type should be supplied to this function. Example usage irmanip.declareOpaque(\"Qubit\"); function declareFunction void declareFunction( String const & declaration ) Declares a function. The full signature should be supplied to as the first argument. Example usage irmanip.declareOpaque(\"%Result* @__quantum__rt__result_get_zero()\"); function fromBodyString bool fromBodyString( String const & body, String const & args =\"\" ) Creates an LLVM module given a function body. This function makes use of the inputs from IrManipulationTestHelper::declareOpaque and IrManipulationTestHelper::declareFunction to construct the full IR. Example usage: irmanip.fromBodyString(R\"script( %leftMessage = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %leftMessage) )script\"); Returns false if the IR is invalid. function generateScript String generateScript( String const & body, String const & args =\"\" ) const Generates a script given the body of the main function. function fromString bool fromString( String const & data ) Creates an LLVM module given from a fully specified IR. This function ignores all inputs from IrManipulationTestHelper::declareOpaque and IrManipulationTestHelper::declareFunction . Returns false if the IR is invalid. function getErrorMessage String getErrorMessage() const Gets an error message if the compilation failed. function isModuleBroken bool isModuleBroken() Whether or not the module is broken. function module ModulePtr & module() Returns a reference to the module. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::IrManipulationTestHelper"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#microsoftquantumirmanipulationtesthelper","text":"","title":"microsoft::quantum::IrManipulationTestHelper"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#public-types","text":"Name using std::string String using llvm::LLVMContext LLVMContext using llvm::SMDiagnostic SMDiagnostic using llvm::Module Module using std::unique_ptr< Module > ModulePtr using std::vector< String > Strings using llvm::PassBuilder::OptimizationLevel OptimizationLevel using std::shared_ptr< ProfileGenerator > GeneratorPtr","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#public-functions","text":"Name IrManipulationTestHelper () IrManipulationTestHelper ( IrManipulationTestHelper const & ) IrManipulationTestHelper & operator= ( IrManipulationTestHelper const & ) IrManipulationTestHelper ( IrManipulationTestHelper && ) IrManipulationTestHelper & operator= ( IrManipulationTestHelper && ) String toString () const Generates a string for the IR currently held in the module. Strings toBodyInstructions () Generates a list of instructions for the main function in the module. bool hasInstructionSequence (Strings const & instructions) void applyProfile (GeneratorPtr const & profile, OptimizationLevel const & optimisation_level =OptimizationLevel::O0, bool debug =false) void declareOpaque (String const & name) void declareFunction (String const & declaration) bool fromBodyString (String const & body, String const & args =\"\") String generateScript (String const & body, String const & args =\"\") const Generates a script given the body of the main function. bool fromString (String const & data) String getErrorMessage () const Gets an error message if the compilation failed. bool isModuleBroken () Whether or not the module is broken. ModulePtr & module () Returns a reference to the module.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-string","text":"using microsoft::quantum::IrManipulationTestHelper::String = std::string;","title":"using String"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-llvmcontext","text":"using microsoft::quantum::IrManipulationTestHelper::LLVMContext = llvm::LLVMContext;","title":"using LLVMContext"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-smdiagnostic","text":"using microsoft::quantum::IrManipulationTestHelper::SMDiagnostic = llvm::SMDiagnostic;","title":"using SMDiagnostic"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-module","text":"using microsoft::quantum::IrManipulationTestHelper::Module = llvm::Module;","title":"using Module"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-moduleptr","text":"using microsoft::quantum::IrManipulationTestHelper::ModulePtr = std::unique_ptr<Module>;","title":"using ModulePtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-strings","text":"using microsoft::quantum::IrManipulationTestHelper::Strings = std::vector<String>;","title":"using Strings"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-optimizationlevel","text":"using microsoft::quantum::IrManipulationTestHelper::OptimizationLevel = llvm::PassBuilder::OptimizationLevel;","title":"using OptimizationLevel"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#using-generatorptr","text":"using microsoft::quantum::IrManipulationTestHelper::GeneratorPtr = std::shared_ptr<ProfileGenerator>;","title":"using GeneratorPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-irmanipulationtesthelper","text":"IrManipulationTestHelper()","title":"function IrManipulationTestHelper"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-irmanipulationtesthelper_1","text":"IrManipulationTestHelper( IrManipulationTestHelper const & )","title":"function IrManipulationTestHelper"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-operator","text":"IrManipulationTestHelper & operator=( IrManipulationTestHelper const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-irmanipulationtesthelper_2","text":"IrManipulationTestHelper( IrManipulationTestHelper && )","title":"function IrManipulationTestHelper"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-operator_1","text":"IrManipulationTestHelper & operator=( IrManipulationTestHelper && )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-tostring","text":"String toString() const Generates a string for the IR currently held in the module.","title":"function toString"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-tobodyinstructions","text":"Strings toBodyInstructions() Generates a list of instructions for the main function in the module.","title":"function toBodyInstructions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-hasinstructionsequence","text":"bool hasInstructionSequence( Strings const & instructions ) Tests whether the main body contains a sequence of instructions. This function ignores instructions in-between the instruction set given.","title":"function hasInstructionSequence"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-applyprofile","text":"void applyProfile( GeneratorPtr const & profile, OptimizationLevel const & optimisation_level =OptimizationLevel::O0, bool debug =false ) Applies a profile to the module to allow which transforms the IR. This allow us to write small profiles to test a single piece of transformation.","title":"function applyProfile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-declareopaque","text":"void declareOpaque( String const & name ) Declares a opaque type. Only the name of the type should be supplied to this function. Example usage irmanip.declareOpaque(\"Qubit\");","title":"function declareOpaque"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-declarefunction","text":"void declareFunction( String const & declaration ) Declares a function. The full signature should be supplied to as the first argument. Example usage irmanip.declareOpaque(\"%Result* @__quantum__rt__result_get_zero()\");","title":"function declareFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-frombodystring","text":"bool fromBodyString( String const & body, String const & args =\"\" ) Creates an LLVM module given a function body. This function makes use of the inputs from IrManipulationTestHelper::declareOpaque and IrManipulationTestHelper::declareFunction to construct the full IR. Example usage: irmanip.fromBodyString(R\"script( %leftMessage = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %leftMessage) )script\"); Returns false if the IR is invalid.","title":"function fromBodyString"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-generatescript","text":"String generateScript( String const & body, String const & args =\"\" ) const Generates a script given the body of the main function.","title":"function generateScript"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-fromstring","text":"bool fromString( String const & data ) Creates an LLVM module given from a fully specified IR. This function ignores all inputs from IrManipulationTestHelper::declareOpaque and IrManipulationTestHelper::declareFunction . Returns false if the IR is invalid.","title":"function fromString"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-geterrormessage","text":"String getErrorMessage() const Gets an error message if the compilation failed.","title":"function getErrorMessage"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-ismodulebroken","text":"bool isModuleBroken() Whether or not the module is broken.","title":"function isModuleBroken"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_ir_manipulation_test_helper/#function-module","text":"ModulePtr & module() Returns a reference to the module. Updated on 22 November 2021 at 10:28:34 UTC","title":"function module"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/","text":"microsoft::quantum::LlvmPassesConfiguration Public Functions Name LlvmPassesConfiguration () void setup ( ConfigurationManager & config) Setup function that registers the different LLVM passes available via LLVM component. bool isDisabled () const bool operator== ( LlvmPassesConfiguration const & ref) const Compares equality of two configurations. bool alwaysInline () const Whether or not the LLVM AlwaysInline pass should be added to the profile. bool disableDefaultPipeline () const Whether or not the default LLVM pipeline is disabled. std::string passPipeline () const int32_t inlineParameter () const Parameter that defines the maximum number of lines of code allowed for inlining. LlvmPassesConfiguration createDisabled () Public Functions Documentation function LlvmPassesConfiguration LlvmPassesConfiguration() function setup void setup( ConfigurationManager & config ) Setup function that registers the different LLVM passes available via LLVM component. function isDisabled bool isDisabled() const Returns true if the configuration disables all effects of this component. The effect of this function being true is that registered component should have no effect on transformation and/or validation of the QIR. function operator== bool operator==( LlvmPassesConfiguration const & ref ) const Compares equality of two configurations. function alwaysInline bool alwaysInline() const Whether or not the LLVM AlwaysInline pass should be added to the profile. function disableDefaultPipeline bool disableDefaultPipeline() const Whether or not the default LLVM pipeline is disabled. function passPipeline std::string passPipeline() const function inlineParameter int32_t inlineParameter() const Parameter that defines the maximum number of lines of code allowed for inlining. function createDisabled static LlvmPassesConfiguration createDisabled() Static function creates a new configuration where all transformations/validation requirements are disabled. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::LlvmPassesConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#microsoftquantumllvmpassesconfiguration","text":"","title":"microsoft::quantum::LlvmPassesConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#public-functions","text":"Name LlvmPassesConfiguration () void setup ( ConfigurationManager & config) Setup function that registers the different LLVM passes available via LLVM component. bool isDisabled () const bool operator== ( LlvmPassesConfiguration const & ref) const Compares equality of two configurations. bool alwaysInline () const Whether or not the LLVM AlwaysInline pass should be added to the profile. bool disableDefaultPipeline () const Whether or not the default LLVM pipeline is disabled. std::string passPipeline () const int32_t inlineParameter () const Parameter that defines the maximum number of lines of code allowed for inlining. LlvmPassesConfiguration createDisabled ()","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-llvmpassesconfiguration","text":"LlvmPassesConfiguration()","title":"function LlvmPassesConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-setup","text":"void setup( ConfigurationManager & config ) Setup function that registers the different LLVM passes available via LLVM component.","title":"function setup"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-isdisabled","text":"bool isDisabled() const Returns true if the configuration disables all effects of this component. The effect of this function being true is that registered component should have no effect on transformation and/or validation of the QIR.","title":"function isDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-operator","text":"bool operator==( LlvmPassesConfiguration const & ref ) const Compares equality of two configurations.","title":"function operator=="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-alwaysinline","text":"bool alwaysInline() const Whether or not the LLVM AlwaysInline pass should be added to the profile.","title":"function alwaysInline"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-disabledefaultpipeline","text":"bool disableDefaultPipeline() const Whether or not the default LLVM pipeline is disabled.","title":"function disableDefaultPipeline"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-passpipeline","text":"std::string passPipeline() const","title":"function passPipeline"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-inlineparameter","text":"int32_t inlineParameter() const Parameter that defines the maximum number of lines of code allowed for inlining.","title":"function inlineParameter"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_llvm_passes_configuration/#function-createdisabled","text":"static LlvmPassesConfiguration createDisabled() Static function creates a new configuration where all transformations/validation requirements are disabled. Updated on 22 November 2021 at 10:28:34 UTC","title":"function createDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_load_pattern/","text":"microsoft::quantum::LoadPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::LoadPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_load_pattern/#microsoftquantumloadpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::LoadPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_load_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_load_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_load_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_load_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_load_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 November 2021 at 10:28:34 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/","text":"microsoft::quantum::LogCollection More... #include <Logging/LogCollection.hpp> Inherits from microsoft::quantum::ILogger Public Classes Name struct Location Class that holds the location of where the incident happened. struct Message Struct to hold a message together with its type and location. Public Types Name enum class Type { Debug, Info, Warning, Error, InternalError} Enum description what type of information we are conveying. using std::vector< Message > Messages List of messages defined as alias. Public Functions Name virtual void debug (String const & message) override Adds a debug message to the list. virtual void info (String const & message) override Adds an info message to the list. virtual void warning (String const & message) override Adds a warning message to the list. virtual void error (String const & message) override Adds an error message to the list. virtual void internalError (String const & message) override Adds an internal error message to the list. virtual void setLocation (String const & name, uint64_t row, uint64_t col) override Function that allows to set the current location. Messages const & messages () const Accessor to the messages. Additional inherited members Public Functions inherited from microsoft::quantum::ILogger Name ILogger () =default ILogger ( ILogger const & ) =default ILogger ( ILogger && ) =default ILogger & operator= ( ILogger const & ) =default ILogger & operator= ( ILogger && ) =default virtual ~ILogger () Detailed Description class microsoft::quantum::LogCollection; Concrete ILogger implementation that collects all messages and their corresponding location in a list that can be traversed later on. Public Types Documentation enum Type Enumerator Value Description Debug Info Warning Error InternalError Enum description what type of information we are conveying. using Messages using microsoft::quantum::LogCollection::Messages = std::vector<Message>; List of messages defined as alias. Public Functions Documentation function debug virtual void debug( String const & message ) override Adds a debug message to the list. Reimplements : microsoft::quantum::ILogger::debug function info virtual void info( String const & message ) override Adds an info message to the list. Reimplements : microsoft::quantum::ILogger::info function warning virtual void warning( String const & message ) override Adds a warning message to the list. Reimplements : microsoft::quantum::ILogger::warning function error virtual void error( String const & message ) override Adds an error message to the list. Reimplements : microsoft::quantum::ILogger::error function internalError virtual void internalError( String const & message ) override Adds an internal error message to the list. Reimplements : microsoft::quantum::ILogger::internalError function setLocation virtual void setLocation( String const & name, uint64_t row, uint64_t col ) override Function that allows to set the current location. Reimplements : microsoft::quantum::ILogger::setLocation function messages Messages const & messages() const Accessor to the messages. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::LogCollection"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#microsoftquantumlogcollection","text":"More... #include <Logging/LogCollection.hpp> Inherits from microsoft::quantum::ILogger","title":"microsoft::quantum::LogCollection"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#public-classes","text":"Name struct Location Class that holds the location of where the incident happened. struct Message Struct to hold a message together with its type and location.","title":"Public Classes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#public-types","text":"Name enum class Type { Debug, Info, Warning, Error, InternalError} Enum description what type of information we are conveying. using std::vector< Message > Messages List of messages defined as alias.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#public-functions","text":"Name virtual void debug (String const & message) override Adds a debug message to the list. virtual void info (String const & message) override Adds an info message to the list. virtual void warning (String const & message) override Adds a warning message to the list. virtual void error (String const & message) override Adds an error message to the list. virtual void internalError (String const & message) override Adds an internal error message to the list. virtual void setLocation (String const & name, uint64_t row, uint64_t col) override Function that allows to set the current location. Messages const & messages () const Accessor to the messages.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#additional-inherited-members","text":"Public Functions inherited from microsoft::quantum::ILogger Name ILogger () =default ILogger ( ILogger const & ) =default ILogger ( ILogger && ) =default ILogger & operator= ( ILogger const & ) =default ILogger & operator= ( ILogger && ) =default virtual ~ILogger ()","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#detailed-description","text":"class microsoft::quantum::LogCollection; Concrete ILogger implementation that collects all messages and their corresponding location in a list that can be traversed later on.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#enum-type","text":"Enumerator Value Description Debug Info Warning Error InternalError Enum description what type of information we are conveying.","title":"enum Type"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#using-messages","text":"using microsoft::quantum::LogCollection::Messages = std::vector<Message>; List of messages defined as alias.","title":"using Messages"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-debug","text":"virtual void debug( String const & message ) override Adds a debug message to the list. Reimplements : microsoft::quantum::ILogger::debug","title":"function debug"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-info","text":"virtual void info( String const & message ) override Adds an info message to the list. Reimplements : microsoft::quantum::ILogger::info","title":"function info"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-warning","text":"virtual void warning( String const & message ) override Adds a warning message to the list. Reimplements : microsoft::quantum::ILogger::warning","title":"function warning"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-error","text":"virtual void error( String const & message ) override Adds an error message to the list. Reimplements : microsoft::quantum::ILogger::error","title":"function error"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-internalerror","text":"virtual void internalError( String const & message ) override Adds an internal error message to the list. Reimplements : microsoft::quantum::ILogger::internalError","title":"function internalError"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-setlocation","text":"virtual void setLocation( String const & name, uint64_t row, uint64_t col ) override Function that allows to set the current location. Reimplements : microsoft::quantum::ILogger::setLocation","title":"function setLocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_log_collection/#function-messages","text":"Messages const & messages() const Accessor to the messages. Updated on 22 November 2021 at 10:28:34 UTC","title":"function messages"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/","text":"microsoft::quantum::ModuleLoader Public Types Name using llvm::Module Module using llvm::Linker Linker using llvm::SMDiagnostic SMDiagnostic Public Functions Name ModuleLoader (Module * final_module) bool addModule (std::unique_ptr< Module > && module, String const & filename =\"unknown\") bool addIrFile (String const & filename) Public Types Documentation using Module using microsoft::quantum::ModuleLoader::Module = llvm::Module; using Linker using microsoft::quantum::ModuleLoader::Linker = llvm::Linker; using SMDiagnostic using microsoft::quantum::ModuleLoader::SMDiagnostic = llvm::SMDiagnostic; Public Functions Documentation function ModuleLoader inline explicit ModuleLoader( Module * final_module ) function addModule inline bool addModule( std::unique_ptr< Module > && module, String const & filename =\"unknown\" ) function addIrFile inline bool addIrFile( String const & filename ) Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::ModuleLoader"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#microsoftquantummoduleloader","text":"","title":"microsoft::quantum::ModuleLoader"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#public-types","text":"Name using llvm::Module Module using llvm::Linker Linker using llvm::SMDiagnostic SMDiagnostic","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#public-functions","text":"Name ModuleLoader (Module * final_module) bool addModule (std::unique_ptr< Module > && module, String const & filename =\"unknown\") bool addIrFile (String const & filename)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#using-module","text":"using microsoft::quantum::ModuleLoader::Module = llvm::Module;","title":"using Module"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#using-linker","text":"using microsoft::quantum::ModuleLoader::Linker = llvm::Linker;","title":"using Linker"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#using-smdiagnostic","text":"using microsoft::quantum::ModuleLoader::SMDiagnostic = llvm::SMDiagnostic;","title":"using SMDiagnostic"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#function-moduleloader","text":"inline explicit ModuleLoader( Module * final_module )","title":"function ModuleLoader"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#function-addmodule","text":"inline bool addModule( std::unique_ptr< Module > && module, String const & filename =\"unknown\" )","title":"function addModule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader/#function-addirfile","text":"inline bool addIrFile( String const & filename ) Updated on 22 November 2021 at 10:28:34 UTC","title":"function addIrFile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/","text":"microsoft::quantum::ModuleLoader::SingleModuleTransformation Public Types Name using llvm::PassBuilder PassBuilder using PassBuilder::OptimizationLevel OptimizationLevel using llvm::FunctionAnalysisManager FunctionAnalysisManager Public Functions Name SingleModuleTransformation (OptimizationLevel const & optimisation_level =OptimizationLevel::O0, bool debug =false) bool apply (llvm::Module * module) bool isDebugMode () const Public Types Documentation using PassBuilder using microsoft::quantum::ModuleLoader::SingleModuleTransformation::PassBuilder = llvm::PassBuilder; using OptimizationLevel using microsoft::quantum::ModuleLoader::SingleModuleTransformation::OptimizationLevel = PassBuilder::OptimizationLevel; using FunctionAnalysisManager using microsoft::quantum::ModuleLoader::SingleModuleTransformation::FunctionAnalysisManager = llvm::FunctionAnalysisManager; Public Functions Documentation function SingleModuleTransformation inline explicit SingleModuleTransformation( OptimizationLevel const & optimisation_level =OptimizationLevel::O0, bool debug =false ) function apply inline bool apply( llvm::Module * module ) function isDebugMode inline bool isDebugMode() const Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::ModuleLoader::SingleModuleTransformation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#microsoftquantummoduleloadersinglemoduletransformation","text":"","title":"microsoft::quantum::ModuleLoader::SingleModuleTransformation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#public-types","text":"Name using llvm::PassBuilder PassBuilder using PassBuilder::OptimizationLevel OptimizationLevel using llvm::FunctionAnalysisManager FunctionAnalysisManager","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#public-functions","text":"Name SingleModuleTransformation (OptimizationLevel const & optimisation_level =OptimizationLevel::O0, bool debug =false) bool apply (llvm::Module * module) bool isDebugMode () const","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#using-passbuilder","text":"using microsoft::quantum::ModuleLoader::SingleModuleTransformation::PassBuilder = llvm::PassBuilder;","title":"using PassBuilder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#using-optimizationlevel","text":"using microsoft::quantum::ModuleLoader::SingleModuleTransformation::OptimizationLevel = PassBuilder::OptimizationLevel;","title":"using OptimizationLevel"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#using-functionanalysismanager","text":"using microsoft::quantum::ModuleLoader::SingleModuleTransformation::FunctionAnalysisManager = llvm::FunctionAnalysisManager;","title":"using FunctionAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#function-singlemoduletransformation","text":"inline explicit SingleModuleTransformation( OptimizationLevel const & optimisation_level =OptimizationLevel::O0, bool debug =false )","title":"function SingleModuleTransformation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#function-apply","text":"inline bool apply( llvm::Module * module )","title":"function apply"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_module_loader_1_1_single_module_transformation/#function-isdebugmode","text":"inline bool isDebugMode() const Updated on 22 November 2021 at 10:28:34 UTC","title":"function isDebugMode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/","text":"microsoft::quantum::ParameterParser More... #include <Commandline/ParameterParser.hpp> Public Types Name using std::vector< String > Arguments using std::unordered_set< String > Flags using std::unordered_map< String, String > SettingsMap Public Functions Name ParameterParser () =default ParameterParser ( ParameterParser const & other) ParameterParser ( ParameterParser && other) =default ~ParameterParser () =default void addFlag (String const & v) void parseArgs (int argc, char ** argv) Arguments const & arguments () const String const & getArg (Arguments::size_type const & n) const Returns the n'th commandline argument. String const & get (String const & name, String const & default_value) const Gets a named setting, falling back to a default if the key is not found. String const & get (String const & name) const Gets a named setting. This method throws if the setting is not present. bool has (String const & name) const Checks whether or not a given parameter is present. void reset () Resets the state of the parser to its construction state. Detailed Description class microsoft::quantum::ParameterParser; Parameter parser class which allows the developer to specify a set of default settings and update those using the commandline argc and argv. Public Types Documentation using Arguments using microsoft::quantum::ParameterParser::Arguments = std::vector<String>; using Flags using microsoft::quantum::ParameterParser::Flags = std::unordered_set<String>; using SettingsMap using microsoft::quantum::ParameterParser::SettingsMap = std::unordered_map<String, String>; Public Functions Documentation function ParameterParser ParameterParser() =default function ParameterParser ParameterParser( ParameterParser const & other ) function ParameterParser ParameterParser( ParameterParser && other ) =default function ~ParameterParser ~ParameterParser() =default function addFlag void addFlag( String const & v ) Marks a name as a flag (as opposed to an option). This ensures that no parameter is expected after the flag is specified. For instance --debug is a flag as opposed to --log-level 3 which is an option. function parseArgs void parseArgs( int argc, char ** argv ) Parses the command line arguments given the argc and argv from the main function. function arguments Arguments const & arguments() const Returns list of arguments without flags and/or options included. function getArg String const & getArg( Arguments::size_type const & n ) const Returns the n'th commandline argument. function get String const & get( String const & name, String const & default_value ) const Gets a named setting, falling back to a default if the key is not found. function get String const & get( String const & name ) const Gets a named setting. This method throws if the setting is not present. function has bool has( String const & name ) const Checks whether or not a given parameter is present. function reset void reset() Resets the state of the parser to its construction state. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::ParameterParser"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#microsoftquantumparameterparser","text":"More... #include <Commandline/ParameterParser.hpp>","title":"microsoft::quantum::ParameterParser"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#public-types","text":"Name using std::vector< String > Arguments using std::unordered_set< String > Flags using std::unordered_map< String, String > SettingsMap","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#public-functions","text":"Name ParameterParser () =default ParameterParser ( ParameterParser const & other) ParameterParser ( ParameterParser && other) =default ~ParameterParser () =default void addFlag (String const & v) void parseArgs (int argc, char ** argv) Arguments const & arguments () const String const & getArg (Arguments::size_type const & n) const Returns the n'th commandline argument. String const & get (String const & name, String const & default_value) const Gets a named setting, falling back to a default if the key is not found. String const & get (String const & name) const Gets a named setting. This method throws if the setting is not present. bool has (String const & name) const Checks whether or not a given parameter is present. void reset () Resets the state of the parser to its construction state.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#detailed-description","text":"class microsoft::quantum::ParameterParser; Parameter parser class which allows the developer to specify a set of default settings and update those using the commandline argc and argv.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#using-arguments","text":"using microsoft::quantum::ParameterParser::Arguments = std::vector<String>;","title":"using Arguments"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#using-flags","text":"using microsoft::quantum::ParameterParser::Flags = std::unordered_set<String>;","title":"using Flags"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#using-settingsmap","text":"using microsoft::quantum::ParameterParser::SettingsMap = std::unordered_map<String, String>;","title":"using SettingsMap"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-parameterparser","text":"ParameterParser() =default","title":"function ParameterParser"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-parameterparser_1","text":"ParameterParser( ParameterParser const & other )","title":"function ParameterParser"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-parameterparser_2","text":"ParameterParser( ParameterParser && other ) =default","title":"function ParameterParser"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-parameterparser_3","text":"~ParameterParser() =default","title":"function ~ParameterParser"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-addflag","text":"void addFlag( String const & v ) Marks a name as a flag (as opposed to an option). This ensures that no parameter is expected after the flag is specified. For instance --debug is a flag as opposed to --log-level 3 which is an option.","title":"function addFlag"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-parseargs","text":"void parseArgs( int argc, char ** argv ) Parses the command line arguments given the argc and argv from the main function.","title":"function parseArgs"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-arguments","text":"Arguments const & arguments() const Returns list of arguments without flags and/or options included.","title":"function arguments"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-getarg","text":"String const & getArg( Arguments::size_type const & n ) const Returns the n'th commandline argument.","title":"function getArg"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-get","text":"String const & get( String const & name, String const & default_value ) const Gets a named setting, falling back to a default if the key is not found.","title":"function get"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-get_1","text":"String const & get( String const & name ) const Gets a named setting. This method throws if the setting is not present.","title":"function get"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-has","text":"bool has( String const & name ) const Checks whether or not a given parameter is present.","title":"function has"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_parameter_parser/#function-reset","text":"void reset() Resets the state of the parser to its construction state. Updated on 22 November 2021 at 10:28:34 UTC","title":"function reset"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/","text":"microsoft::quantum::PhiPattern Inherits from microsoft::quantum::IOperandPrototype Public Types Name using std::string String Public Functions Name PhiPattern () =default Construction by name. PhiPattern ( PhiPattern const & other) Copy construction prohibited. PhiPattern ( PhiPattern && other) =default Move construction allowed. ~PhiPattern () override Destructor implementation. virtual bool match (Value * instr, Captures & captures) const override Matches the phi node. virtual Child copy () const override Creates a copy of itself. Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Types Documentation using String using microsoft::quantum::PhiPattern::String = std::string; Public Functions Documentation function PhiPattern PhiPattern() =default Construction by name. function PhiPattern PhiPattern( PhiPattern const & other ) Copy construction prohibited. function PhiPattern PhiPattern( PhiPattern && other ) =default Move construction allowed. function ~PhiPattern ~PhiPattern() override Destructor implementation. function match virtual bool match( Value * instr, Captures & captures ) const override Matches the phi node. Reimplements : microsoft::quantum::IOperandPrototype::match function copy virtual Child copy() const override Creates a copy of itself. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::PhiPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#microsoftquantumphipattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::PhiPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#public-types","text":"Name using std::string String","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#public-functions","text":"Name PhiPattern () =default Construction by name. PhiPattern ( PhiPattern const & other) Copy construction prohibited. PhiPattern ( PhiPattern && other) =default Move construction allowed. ~PhiPattern () override Destructor implementation. virtual bool match (Value * instr, Captures & captures) const override Matches the phi node. virtual Child copy () const override Creates a copy of itself.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#using-string","text":"using microsoft::quantum::PhiPattern::String = std::string;","title":"using String"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#function-phipattern","text":"PhiPattern() =default Construction by name.","title":"function PhiPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#function-phipattern_1","text":"PhiPattern( PhiPattern const & other ) Copy construction prohibited.","title":"function PhiPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#function-phipattern_2","text":"PhiPattern( PhiPattern && other ) =default Move construction allowed.","title":"function PhiPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#function-phipattern_3","text":"~PhiPattern() override Destructor implementation.","title":"function ~PhiPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#function-match","text":"virtual bool match( Value * instr, Captures & captures ) const override Matches the phi node. Reimplements : microsoft::quantum::IOperandPrototype::match","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_phi_pattern/#function-copy","text":"virtual Child copy() const override Creates a copy of itself. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 22 November 2021 at 10:28:34 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/","text":"microsoft::quantum::Profile More... #include <Profile/Profile.hpp> Public Types Name using IAllocationManager::AllocationManagerPtr AllocationManagerPtr using Validator::ValidatorPtr ValidatorPtr Validator class used to check that an IR fulfils a given specification. Public Functions Name Profile (String const & name, bool debug, llvm::TargetMachine * target_machine =nullptr, AllocationManagerPtr qubit_allocation_manager = BasicAllocationManager::createNew (), AllocationManagerPtr result_allocation_manager = BasicAllocationManager::createNew ()) Profile () Profile ( Profile const & ) Profile ( Profile && ) =default Profile & operator= ( Profile const & ) Profile & operator= ( Profile && ) =default ~Profile () =default void apply (llvm::Module & module) Applies the profile to a module. bool verify (llvm::Module & module) Verifies that a module is a valid LLVM IR. bool validate (llvm::Module & module) Validates that a module complies with the specified QIR profile. AllocationManagerPtr getQubitAllocationManager () AllocationManagerPtr getResultAllocationManager () String const & name () const Protected Functions Name void setModulePassManager (llvm::ModulePassManager && manager) Sets the module pass manager used for the transformation of the IR. void setValidator ( ValidatorPtr && validator) Sets the validator. llvm::PassBuilder & passBuilder () Returns a reference to the pass builder. llvm::LoopAnalysisManager & loopAnalysisManager () Returns a reference to the loop analysis manager. llvm::FunctionAnalysisManager & functionAnalysisManager () Returns a reference to the function analysis manager. llvm::CGSCCAnalysisManager & gsccAnalysisManager () Returns a reference to the GSCC analysis manager. llvm::ModuleAnalysisManager & moduleAnalysisManager () Returns a reference to the module analysis manager. Friends Name class ProfileGenerator Detailed Description class microsoft::quantum::Profile; Profile class that defines a set of rules which constitutes the profile definition. Each of the rules can be used to transform a generic QIR and/or validate that the QIR is compliant with said rule. Public Types Documentation using AllocationManagerPtr using microsoft::quantum::Profile::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; Allocation manager pointer type. Used to reference to concrete allocation manager implementations which defines the allocation logic of the profile. using ValidatorPtr using microsoft::quantum::Profile::ValidatorPtr = Validator::ValidatorPtr; Validator class used to check that an IR fulfils a given specification. Public Functions Documentation function Profile explicit Profile( String const & name, bool debug, llvm::TargetMachine * target_machine =nullptr, AllocationManagerPtr qubit_allocation_manager =BasicAllocationManager::createNew(), AllocationManagerPtr result_allocation_manager =BasicAllocationManager::createNew() ) function Profile Profile() function Profile Profile( Profile const & ) function Profile Profile( Profile && ) =default function operator= Profile & operator=( Profile const & ) function operator= Profile & operator=( Profile && ) =default function ~Profile ~Profile() =default function apply void apply( llvm::Module & module ) Applies the profile to a module. function verify bool verify( llvm::Module & module ) Verifies that a module is a valid LLVM IR. function validate bool validate( llvm::Module & module ) Validates that a module complies with the specified QIR profile. function getQubitAllocationManager AllocationManagerPtr getQubitAllocationManager() function getResultAllocationManager AllocationManagerPtr getResultAllocationManager() function name String const & name() const Protected Functions Documentation function setModulePassManager void setModulePassManager( llvm::ModulePassManager && manager ) Sets the module pass manager used for the transformation of the IR. function setValidator void setValidator( ValidatorPtr && validator ) Sets the validator. function passBuilder llvm::PassBuilder & passBuilder() Returns a reference to the pass builder. function loopAnalysisManager llvm::LoopAnalysisManager & loopAnalysisManager() Returns a reference to the loop analysis manager. function functionAnalysisManager llvm::FunctionAnalysisManager & functionAnalysisManager() Returns a reference to the function analysis manager. function gsccAnalysisManager llvm::CGSCCAnalysisManager & gsccAnalysisManager() Returns a reference to the GSCC analysis manager. function moduleAnalysisManager llvm::ModuleAnalysisManager & moduleAnalysisManager() Returns a reference to the module analysis manager. Friends friend ProfileGenerator friend class ProfileGenerator; Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::Profile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#microsoftquantumprofile","text":"More... #include <Profile/Profile.hpp>","title":"microsoft::quantum::Profile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#public-types","text":"Name using IAllocationManager::AllocationManagerPtr AllocationManagerPtr using Validator::ValidatorPtr ValidatorPtr Validator class used to check that an IR fulfils a given specification.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#public-functions","text":"Name Profile (String const & name, bool debug, llvm::TargetMachine * target_machine =nullptr, AllocationManagerPtr qubit_allocation_manager = BasicAllocationManager::createNew (), AllocationManagerPtr result_allocation_manager = BasicAllocationManager::createNew ()) Profile () Profile ( Profile const & ) Profile ( Profile && ) =default Profile & operator= ( Profile const & ) Profile & operator= ( Profile && ) =default ~Profile () =default void apply (llvm::Module & module) Applies the profile to a module. bool verify (llvm::Module & module) Verifies that a module is a valid LLVM IR. bool validate (llvm::Module & module) Validates that a module complies with the specified QIR profile. AllocationManagerPtr getQubitAllocationManager () AllocationManagerPtr getResultAllocationManager () String const & name () const","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#protected-functions","text":"Name void setModulePassManager (llvm::ModulePassManager && manager) Sets the module pass manager used for the transformation of the IR. void setValidator ( ValidatorPtr && validator) Sets the validator. llvm::PassBuilder & passBuilder () Returns a reference to the pass builder. llvm::LoopAnalysisManager & loopAnalysisManager () Returns a reference to the loop analysis manager. llvm::FunctionAnalysisManager & functionAnalysisManager () Returns a reference to the function analysis manager. llvm::CGSCCAnalysisManager & gsccAnalysisManager () Returns a reference to the GSCC analysis manager. llvm::ModuleAnalysisManager & moduleAnalysisManager () Returns a reference to the module analysis manager.","title":"Protected Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#friends","text":"Name class ProfileGenerator","title":"Friends"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#detailed-description","text":"class microsoft::quantum::Profile; Profile class that defines a set of rules which constitutes the profile definition. Each of the rules can be used to transform a generic QIR and/or validate that the QIR is compliant with said rule.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#using-allocationmanagerptr","text":"using microsoft::quantum::Profile::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; Allocation manager pointer type. Used to reference to concrete allocation manager implementations which defines the allocation logic of the profile.","title":"using AllocationManagerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#using-validatorptr","text":"using microsoft::quantum::Profile::ValidatorPtr = Validator::ValidatorPtr; Validator class used to check that an IR fulfils a given specification.","title":"using ValidatorPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-profile","text":"explicit Profile( String const & name, bool debug, llvm::TargetMachine * target_machine =nullptr, AllocationManagerPtr qubit_allocation_manager =BasicAllocationManager::createNew(), AllocationManagerPtr result_allocation_manager =BasicAllocationManager::createNew() )","title":"function Profile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-profile_1","text":"Profile()","title":"function Profile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-profile_2","text":"Profile( Profile const & )","title":"function Profile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-profile_3","text":"Profile( Profile && ) =default","title":"function Profile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-operator","text":"Profile & operator=( Profile const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-operator_1","text":"Profile & operator=( Profile && ) =default","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-profile_4","text":"~Profile() =default","title":"function ~Profile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-apply","text":"void apply( llvm::Module & module ) Applies the profile to a module.","title":"function apply"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-verify","text":"bool verify( llvm::Module & module ) Verifies that a module is a valid LLVM IR.","title":"function verify"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-validate","text":"bool validate( llvm::Module & module ) Validates that a module complies with the specified QIR profile.","title":"function validate"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-getqubitallocationmanager","text":"AllocationManagerPtr getQubitAllocationManager()","title":"function getQubitAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-getresultallocationmanager","text":"AllocationManagerPtr getResultAllocationManager()","title":"function getResultAllocationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-name","text":"String const & name() const","title":"function name"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-setmodulepassmanager","text":"void setModulePassManager( llvm::ModulePassManager && manager ) Sets the module pass manager used for the transformation of the IR.","title":"function setModulePassManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-setvalidator","text":"void setValidator( ValidatorPtr && validator ) Sets the validator.","title":"function setValidator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-passbuilder","text":"llvm::PassBuilder & passBuilder() Returns a reference to the pass builder.","title":"function passBuilder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-loopanalysismanager","text":"llvm::LoopAnalysisManager & loopAnalysisManager() Returns a reference to the loop analysis manager.","title":"function loopAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-functionanalysismanager","text":"llvm::FunctionAnalysisManager & functionAnalysisManager() Returns a reference to the function analysis manager.","title":"function functionAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-gsccanalysismanager","text":"llvm::CGSCCAnalysisManager & gsccAnalysisManager() Returns a reference to the GSCC analysis manager.","title":"function gsccAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#function-moduleanalysismanager","text":"llvm::ModuleAnalysisManager & moduleAnalysisManager() Returns a reference to the module analysis manager.","title":"function moduleAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#friends_1","text":"","title":"Friends"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile/#friend-profilegenerator","text":"friend class ProfileGenerator; Updated on 22 November 2021 at 10:28:34 UTC","title":"friend ProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/","text":"microsoft::quantum::ProfileGenerator Inherited by microsoft::quantum::DefaultProfileGenerator Public Types Name using llvm::PassBuilder PassBuilder using PassBuilder::OptimizationLevel OptimizationLevel using llvm::FunctionAnalysisManager FunctionAnalysisManager template <typename R > using std::function< void(R const &, ProfileGenerator *, Profile &)> SetupFunction using std::function< void( ProfileGenerator *, Profile &)> SetupFunctionWrapper Wrapper function type for invoking the profile setup function. using std::vector< std::pair< String, SetupFunctionWrapper > > Components List of components to be configured. Public Functions Name ProfileGenerator () =default ~ProfileGenerator () =default ProfileGenerator ( ProfileGenerator const & ) ProfileGenerator ( ProfileGenerator && ) ProfileGenerator & operator= ( ProfileGenerator const & ) ProfileGenerator & operator= ( ProfileGenerator && ) ConfigurationManager & configurationManager () ConfigurationManager const & configurationManager () const Profile newProfile (String const & name, OptimizationLevel const & optimisation_level, bool debug) template <typename R > void registerProfileComponent (String const & id, SetupFunction < R > setup) llvm::ModulePassManager & modulePassManager () Returns the module pass manager. llvm::PassBuilder & passBuilder () Returns the pass builder. OptimizationLevel optimisationLevel () const Returns the optimisation level. bool isDebugMode () const Flag indicating whether we are operating in debug mode or not. Protected Functions Name llvm::ModulePassManager createGenerationModulePassManager ( Profile & profile, OptimizationLevel const & optimisation_level, bool debug) llvm::ModulePassManager createValidationModulePass (PassBuilder & pass_builder, OptimizationLevel const & optimisation_level, bool debug) Public Types Documentation using PassBuilder using microsoft::quantum::ProfileGenerator::PassBuilder = llvm::PassBuilder; using OptimizationLevel using microsoft::quantum::ProfileGenerator::OptimizationLevel = PassBuilder::OptimizationLevel; using FunctionAnalysisManager using microsoft::quantum::ProfileGenerator::FunctionAnalysisManager = llvm::FunctionAnalysisManager; using SetupFunction template <typename R > using microsoft::quantum::ProfileGenerator::SetupFunction = std::function<void(R const&, ProfileGenerator*, Profile&)>; Setup function that uses a configuration type R to configure the profile and/or generator. using SetupFunctionWrapper using microsoft::quantum::ProfileGenerator::SetupFunctionWrapper = std::function<void(ProfileGenerator*, Profile&)>; Wrapper function type for invoking the profile setup function. using Components using microsoft::quantum::ProfileGenerator::Components = std::vector<std::pair<String, SetupFunctionWrapper> >; List of components to be configured. Public Functions Documentation function ProfileGenerator ProfileGenerator() =default function ~ProfileGenerator ~ProfileGenerator() =default function ProfileGenerator ProfileGenerator( ProfileGenerator const & ) function ProfileGenerator ProfileGenerator( ProfileGenerator && ) function operator= ProfileGenerator & operator=( ProfileGenerator const & ) function operator= ProfileGenerator & operator=( ProfileGenerator && ) function configurationManager ConfigurationManager & configurationManager() Reference to configuration manager. This property allows to access and modify configurations of the generator. This property is intended for managing the configuration. function configurationManager ConfigurationManager const & configurationManager() const Constant reference to the configuration manager. This property allows read access to the configuration manager and is intended for profile generation. function newProfile Profile newProfile( String const & name, OptimizationLevel const & optimisation_level, bool debug ) Creates a new profile based on the registered components, optimisation level and debug requirements. The returned profile can be applied to an IR to transform it in accordance with the configurations given. function registerProfileComponent template <typename R > void registerProfileComponent( String const & id, SetupFunction< R > setup ) Registers a new profile component with a given configuration R. The profile component is given a name and a setup function which is responsible for configuring the profile in accordance with the configuration. function modulePassManager llvm::ModulePassManager & modulePassManager() Returns the module pass manager. function passBuilder llvm::PassBuilder & passBuilder() Returns the pass builder. function optimisationLevel OptimizationLevel optimisationLevel() const Returns the optimisation level. function isDebugMode bool isDebugMode() const Flag indicating whether we are operating in debug mode or not. Protected Functions Documentation function createGenerationModulePassManager llvm::ModulePassManager createGenerationModulePassManager( Profile & profile, OptimizationLevel const & optimisation_level, bool debug ) Internal function that creates a module pass for QIR transformation. The module pass is defined through the profile, the optimisation level and whether or not we are in debug mode. function createValidationModulePass llvm::ModulePassManager createValidationModulePass( PassBuilder & pass_builder, OptimizationLevel const & optimisation_level, bool debug ) Internal function that creates a module pass for QIR validation. At the moment, this function is a placeholder for future functionality. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::ProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#microsoftquantumprofilegenerator","text":"Inherited by microsoft::quantum::DefaultProfileGenerator","title":"microsoft::quantum::ProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#public-types","text":"Name using llvm::PassBuilder PassBuilder using PassBuilder::OptimizationLevel OptimizationLevel using llvm::FunctionAnalysisManager FunctionAnalysisManager template <typename R > using std::function< void(R const &, ProfileGenerator *, Profile &)> SetupFunction using std::function< void( ProfileGenerator *, Profile &)> SetupFunctionWrapper Wrapper function type for invoking the profile setup function. using std::vector< std::pair< String, SetupFunctionWrapper > > Components List of components to be configured.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#public-functions","text":"Name ProfileGenerator () =default ~ProfileGenerator () =default ProfileGenerator ( ProfileGenerator const & ) ProfileGenerator ( ProfileGenerator && ) ProfileGenerator & operator= ( ProfileGenerator const & ) ProfileGenerator & operator= ( ProfileGenerator && ) ConfigurationManager & configurationManager () ConfigurationManager const & configurationManager () const Profile newProfile (String const & name, OptimizationLevel const & optimisation_level, bool debug) template <typename R > void registerProfileComponent (String const & id, SetupFunction < R > setup) llvm::ModulePassManager & modulePassManager () Returns the module pass manager. llvm::PassBuilder & passBuilder () Returns the pass builder. OptimizationLevel optimisationLevel () const Returns the optimisation level. bool isDebugMode () const Flag indicating whether we are operating in debug mode or not.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#protected-functions","text":"Name llvm::ModulePassManager createGenerationModulePassManager ( Profile & profile, OptimizationLevel const & optimisation_level, bool debug) llvm::ModulePassManager createValidationModulePass (PassBuilder & pass_builder, OptimizationLevel const & optimisation_level, bool debug)","title":"Protected Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#using-passbuilder","text":"using microsoft::quantum::ProfileGenerator::PassBuilder = llvm::PassBuilder;","title":"using PassBuilder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#using-optimizationlevel","text":"using microsoft::quantum::ProfileGenerator::OptimizationLevel = PassBuilder::OptimizationLevel;","title":"using OptimizationLevel"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#using-functionanalysismanager","text":"using microsoft::quantum::ProfileGenerator::FunctionAnalysisManager = llvm::FunctionAnalysisManager;","title":"using FunctionAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#using-setupfunction","text":"template <typename R > using microsoft::quantum::ProfileGenerator::SetupFunction = std::function<void(R const&, ProfileGenerator*, Profile&)>; Setup function that uses a configuration type R to configure the profile and/or generator.","title":"using SetupFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#using-setupfunctionwrapper","text":"using microsoft::quantum::ProfileGenerator::SetupFunctionWrapper = std::function<void(ProfileGenerator*, Profile&)>; Wrapper function type for invoking the profile setup function.","title":"using SetupFunctionWrapper"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#using-components","text":"using microsoft::quantum::ProfileGenerator::Components = std::vector<std::pair<String, SetupFunctionWrapper> >; List of components to be configured.","title":"using Components"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-profilegenerator","text":"ProfileGenerator() =default","title":"function ProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-profilegenerator_1","text":"~ProfileGenerator() =default","title":"function ~ProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-profilegenerator_2","text":"ProfileGenerator( ProfileGenerator const & )","title":"function ProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-profilegenerator_3","text":"ProfileGenerator( ProfileGenerator && )","title":"function ProfileGenerator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-operator","text":"ProfileGenerator & operator=( ProfileGenerator const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-operator_1","text":"ProfileGenerator & operator=( ProfileGenerator && )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-configurationmanager","text":"ConfigurationManager & configurationManager() Reference to configuration manager. This property allows to access and modify configurations of the generator. This property is intended for managing the configuration.","title":"function configurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-configurationmanager_1","text":"ConfigurationManager const & configurationManager() const Constant reference to the configuration manager. This property allows read access to the configuration manager and is intended for profile generation.","title":"function configurationManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-newprofile","text":"Profile newProfile( String const & name, OptimizationLevel const & optimisation_level, bool debug ) Creates a new profile based on the registered components, optimisation level and debug requirements. The returned profile can be applied to an IR to transform it in accordance with the configurations given.","title":"function newProfile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-registerprofilecomponent","text":"template <typename R > void registerProfileComponent( String const & id, SetupFunction< R > setup ) Registers a new profile component with a given configuration R. The profile component is given a name and a setup function which is responsible for configuring the profile in accordance with the configuration.","title":"function registerProfileComponent"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-modulepassmanager","text":"llvm::ModulePassManager & modulePassManager() Returns the module pass manager.","title":"function modulePassManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-passbuilder","text":"llvm::PassBuilder & passBuilder() Returns the pass builder.","title":"function passBuilder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-optimisationlevel","text":"OptimizationLevel optimisationLevel() const Returns the optimisation level.","title":"function optimisationLevel"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-isdebugmode","text":"bool isDebugMode() const Flag indicating whether we are operating in debug mode or not.","title":"function isDebugMode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-creategenerationmodulepassmanager","text":"llvm::ModulePassManager createGenerationModulePassManager( Profile & profile, OptimizationLevel const & optimisation_level, bool debug ) Internal function that creates a module pass for QIR transformation. The module pass is defined through the profile, the optimisation level and whether or not we are in debug mode.","title":"function createGenerationModulePassManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_profile_generator/#function-createvalidationmodulepass","text":"llvm::ModulePassManager createValidationModulePass( PassBuilder & pass_builder, OptimizationLevel const & optimisation_level, bool debug ) Internal function that creates a module pass for QIR validation. At the moment, this function is a placeholder for future functionality. Updated on 22 November 2021 at 10:28:34 UTC","title":"function createValidationModulePass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qat_config/","text":"microsoft::quantum::QatConfig Main configuration class for the qat command-line program. #include <Apps/Qat/QatConfig.hpp> Public Functions Name void setup ( ConfigurationManager & config) String load () const List of dynamic libraries to load. bool shouldGenerate () const Flag that indicates whether or not we are generating a new QIR by applying a profile. bool verifyModule () const Flag to indicate whether or not to verify that the (Q)IR is a valid LLVM IR. bool shouldValidate () const Flag to indicate whether or not to validate the compliance with the QIR profile. String profile () const String to request a specific profile name. Default is base. bool shouldEmitLlvm () const Indicates whether or not the QIR adaptor tool should emit LLVM IR to the standard output. bool isOpt0Enabled () const Tells if the optimisation level 0 is enabled. Note higher OX override lower ones. bool isOpt1Enabled () const Tells if the optimisation level 1 is enabled. Note higher OX override lower ones. bool isOpt2Enabled () const Tells if the optimisation level 2 is enabled. Note higher OX override lower ones. bool isOpt3Enabled () const Tells if the optimisation level 3 is enabled. Note higher OX override lower ones. bool isDebugMode () const Enables debug output. bool shouldDumpConfig () const Request the full configuration to be dumped to the screen. Public Functions Documentation function setup void setup( ConfigurationManager & config ) Setup function that binds instance variables to the command-line/configuration entries. This function also provide descriptions of each of the properties below. function load String load() const List of dynamic libraries to load. function shouldGenerate bool shouldGenerate() const Flag that indicates whether or not we are generating a new QIR by applying a profile. function verifyModule bool verifyModule() const Flag to indicate whether or not to verify that the (Q)IR is a valid LLVM IR. function shouldValidate bool shouldValidate() const Flag to indicate whether or not to validate the compliance with the QIR profile. function profile String profile() const String to request a specific profile name. Default is base. function shouldEmitLlvm bool shouldEmitLlvm() const Indicates whether or not the QIR adaptor tool should emit LLVM IR to the standard output. function isOpt0Enabled bool isOpt0Enabled() const Tells if the optimisation level 0 is enabled. Note higher OX override lower ones. function isOpt1Enabled bool isOpt1Enabled() const Tells if the optimisation level 1 is enabled. Note higher OX override lower ones. function isOpt2Enabled bool isOpt2Enabled() const Tells if the optimisation level 2 is enabled. Note higher OX override lower ones. function isOpt3Enabled bool isOpt3Enabled() const Tells if the optimisation level 3 is enabled. Note higher OX override lower ones. function isDebugMode bool isDebugMode() const Enables debug output. function shouldDumpConfig bool shouldDumpConfig() const Request the full configuration to be dumped to the screen. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::QatConfig"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qat_config/#microsoftquantumqatconfig","text":"Main configuration class for the qat command-line program. #include <Apps/Qat/QatConfig.hpp>","title":"microsoft::quantum::QatConfig"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qat_config/#public-functions","text":"Name void setup ( ConfigurationManager & config) String load () const List of dynamic libraries to load. bool shouldGenerate () const Flag that indicates whether or not we are generating a new QIR by applying a profile. bool verifyModule () const Flag to indicate whether or not to verify that the (Q)IR is a valid LLVM IR. bool shouldValidate () const Flag to indicate whether or not to validate the compliance with the QIR profile. String profile () const String to request a specific profile name. Default is base. bool shouldEmitLlvm () const Indicates whether or not the QIR adaptor tool should emit LLVM IR to the standard output. bool isOpt0Enabled () const Tells if the optimisation level 0 is enabled. Note higher OX override lower ones. bool isOpt1Enabled () const Tells if the optimisation level 1 is enabled. Note higher OX override lower ones. bool isOpt2Enabled () const Tells if the optimisation level 2 is enabled. Note higher OX override lower ones. bool isOpt3Enabled () const Tells if the optimisation level 3 is enabled. Note higher OX override lower ones. bool isDebugMode () const Enables debug output. bool shouldDumpConfig () const Request the full configuration to be dumped to the screen.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qat_config/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qat_config/#function-setup","text":"void setup( ConfigurationManager & config ) Setup function that binds instance variables to the command-line/configuration entries. This function also provide descriptions of each of the properties below.","title":"function setup"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qat_config/#function-load","text":"String load() const List of dynamic libraries to load.","title":"function load"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qat_config/#function-shouldgenerate","text":"bool shouldGenerate() const Flag that indicates whether or not we are generating a new QIR by applying a profile.","title":"function shouldGenerate"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qat_config/#function-verifymodule","text":"bool verifyModule() const Flag to indicate whether or not to verify that the (Q)IR is a valid LLVM IR.","title":"function verifyModule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qat_config/#function-shouldvalidate","text":"bool shouldValidate() const Flag to indicate whether or not to validate the compliance with the QIR profile.","title":"function shouldValidate"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qat_config/#function-profile","text":"String profile() const String to request a specific profile name. Default is base.","title":"function profile"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qat_config/#function-shouldemitllvm","text":"bool shouldEmitLlvm() const Indicates whether or not the QIR adaptor tool should emit LLVM IR to the standard output.","title":"function shouldEmitLlvm"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qat_config/#function-isopt0enabled","text":"bool isOpt0Enabled() const Tells if the optimisation level 0 is enabled. Note higher OX override lower ones.","title":"function isOpt0Enabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qat_config/#function-isopt1enabled","text":"bool isOpt1Enabled() const Tells if the optimisation level 1 is enabled. Note higher OX override lower ones.","title":"function isOpt1Enabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qat_config/#function-isopt2enabled","text":"bool isOpt2Enabled() const Tells if the optimisation level 2 is enabled. Note higher OX override lower ones.","title":"function isOpt2Enabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qat_config/#function-isopt3enabled","text":"bool isOpt3Enabled() const Tells if the optimisation level 3 is enabled. Note higher OX override lower ones.","title":"function isOpt3Enabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qat_config/#function-isdebugmode","text":"bool isDebugMode() const Enables debug output.","title":"function isDebugMode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_qat_config/#function-shoulddumpconfig","text":"bool shouldDumpConfig() const Request the full configuration to be dumped to the screen. Updated on 22 November 2021 at 10:28:34 UTC","title":"function shouldDumpConfig"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_disallowed_attributes_pass/","text":"microsoft::quantum::RemoveDisallowedAttributesPass Inherits from llvm::PassInfoMixin< RemoveDisallowedAttributesPass > Public Functions Name RemoveDisallowedAttributesPass () llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & ) Public Functions Documentation function RemoveDisallowedAttributesPass inline RemoveDisallowedAttributesPass() function run inline llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & ) Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::RemoveDisallowedAttributesPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_disallowed_attributes_pass/#microsoftquantumremovedisallowedattributespass","text":"Inherits from llvm::PassInfoMixin< RemoveDisallowedAttributesPass >","title":"microsoft::quantum::RemoveDisallowedAttributesPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_disallowed_attributes_pass/#public-functions","text":"Name RemoveDisallowedAttributesPass () llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & )","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_disallowed_attributes_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_disallowed_attributes_pass/#function-removedisallowedattributespass","text":"inline RemoveDisallowedAttributesPass()","title":"function RemoveDisallowedAttributesPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_remove_disallowed_attributes_pass/#function-run","text":"inline llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & ) Updated on 22 November 2021 at 10:28:34 UTC","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/","text":"microsoft::quantum::ReplacementRule More... #include <Rules/ReplacementRule.hpp> Public Types Name using IOperandPrototype::Captures Captures Table to store LLVM values using a name. using llvm::Value Value Value alias for shorthand usage. using std::shared_ptr< IOperandPrototype > IOperandPrototypePtr Pointer to the pattern type. using llvm::IRBuilder<> Builder Builder alias for shorthand notation. using std::vector< std::pair< Value *, Value * > > Replacements List of replacements. using std::function< bool( Builder &, Value *, Captures &, Replacements &)> ReplaceFunction Function to perform replacements. Public Functions Name ReplacementRule () =default ReplacementRule ( IOperandPrototypePtr && pattern, ReplaceFunction && replacer) void setPattern ( IOperandPrototypePtr && pattern) Sets the pattern describing logic to be replaced. void setReplacer ( ReplaceFunction const & replacer) bool match ( Value * value, Captures & captures) const bool replace ( Builder & builder, Value * value, Captures & captures, Replacements & replacements) const Invokes the replacer given a matched value and its corresponding captures. Detailed Description class microsoft::quantum::ReplacementRule; Rule that describes a pattern and how to make a replacement of the matched values. The class contains a OperandPrototype which is used to test whether an LLVM IR value follows a specific pattern. The class also holds a function pointer to logic that allows replacement of the specified value. Public Types Documentation using Captures using microsoft::quantum::ReplacementRule::Captures = IOperandPrototype::Captures; Table to store LLVM values using a name. using Value using microsoft::quantum::ReplacementRule::Value = llvm::Value; Value alias for shorthand usage. using IOperandPrototypePtr using microsoft::quantum::ReplacementRule::IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; Pointer to the pattern type. using Builder using microsoft::quantum::ReplacementRule::Builder = llvm::IRBuilder<>; Builder alias for shorthand notation. using Replacements using microsoft::quantum::ReplacementRule::Replacements = std::vector<std::pair<Value*, Value*> >; List of replacements. using ReplaceFunction using microsoft::quantum::ReplacementRule::ReplaceFunction = std::function<bool(Builder&, Value*, Captures&, Replacements&)>; Function to perform replacements. Public Functions Documentation function ReplacementRule ReplacementRule() =default function ReplacementRule ReplacementRule( IOperandPrototypePtr && pattern, ReplaceFunction && replacer ) function setPattern void setPattern( IOperandPrototypePtr && pattern ) Sets the pattern describing logic to be replaced. function setReplacer void setReplacer( ReplaceFunction const & replacer ) Sets the replacer logic which given a successful match will perform a replacement on the IR. function match bool match( Value * value, Captures & captures ) const Tests whether a given value matches the rule pattern and store captures. The function returns true if the match was successful in which case captures are recorded. function replace bool replace( Builder & builder, Value * value, Captures & captures, Replacements & replacements ) const Invokes the replacer given a matched value and its corresponding captures. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::ReplacementRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#microsoftquantumreplacementrule","text":"More... #include <Rules/ReplacementRule.hpp>","title":"microsoft::quantum::ReplacementRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#public-types","text":"Name using IOperandPrototype::Captures Captures Table to store LLVM values using a name. using llvm::Value Value Value alias for shorthand usage. using std::shared_ptr< IOperandPrototype > IOperandPrototypePtr Pointer to the pattern type. using llvm::IRBuilder<> Builder Builder alias for shorthand notation. using std::vector< std::pair< Value *, Value * > > Replacements List of replacements. using std::function< bool( Builder &, Value *, Captures &, Replacements &)> ReplaceFunction Function to perform replacements.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#public-functions","text":"Name ReplacementRule () =default ReplacementRule ( IOperandPrototypePtr && pattern, ReplaceFunction && replacer) void setPattern ( IOperandPrototypePtr && pattern) Sets the pattern describing logic to be replaced. void setReplacer ( ReplaceFunction const & replacer) bool match ( Value * value, Captures & captures) const bool replace ( Builder & builder, Value * value, Captures & captures, Replacements & replacements) const Invokes the replacer given a matched value and its corresponding captures.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#detailed-description","text":"class microsoft::quantum::ReplacementRule; Rule that describes a pattern and how to make a replacement of the matched values. The class contains a OperandPrototype which is used to test whether an LLVM IR value follows a specific pattern. The class also holds a function pointer to logic that allows replacement of the specified value.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#using-captures","text":"using microsoft::quantum::ReplacementRule::Captures = IOperandPrototype::Captures; Table to store LLVM values using a name.","title":"using Captures"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#using-value","text":"using microsoft::quantum::ReplacementRule::Value = llvm::Value; Value alias for shorthand usage.","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#using-ioperandprototypeptr","text":"using microsoft::quantum::ReplacementRule::IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; Pointer to the pattern type.","title":"using IOperandPrototypePtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#using-builder","text":"using microsoft::quantum::ReplacementRule::Builder = llvm::IRBuilder<>; Builder alias for shorthand notation.","title":"using Builder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#using-replacements","text":"using microsoft::quantum::ReplacementRule::Replacements = std::vector<std::pair<Value*, Value*> >; List of replacements.","title":"using Replacements"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#using-replacefunction","text":"using microsoft::quantum::ReplacementRule::ReplaceFunction = std::function<bool(Builder&, Value*, Captures&, Replacements&)>; Function to perform replacements.","title":"using ReplaceFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-replacementrule","text":"ReplacementRule() =default","title":"function ReplacementRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-replacementrule_1","text":"ReplacementRule( IOperandPrototypePtr && pattern, ReplaceFunction && replacer )","title":"function ReplacementRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-setpattern","text":"void setPattern( IOperandPrototypePtr && pattern ) Sets the pattern describing logic to be replaced.","title":"function setPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-setreplacer","text":"void setReplacer( ReplaceFunction const & replacer ) Sets the replacer logic which given a successful match will perform a replacement on the IR.","title":"function setReplacer"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-match","text":"bool match( Value * value, Captures & captures ) const Tests whether a given value matches the rule pattern and store captures. The function returns true if the match was successful in which case captures are recorded.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_replacement_rule/#function-replace","text":"bool replace( Builder & builder, Value * value, Captures & captures, Replacements & replacements ) const Invokes the replacer given a matched value and its corresponding captures. Updated on 22 November 2021 at 10:28:34 UTC","title":"function replace"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/","text":"microsoft::quantum::RuleFactory More... #include <Rules/Factory.hpp> Public Types Name using std::shared_ptr< ReplacementRule > ReplacementRulePtr ReplacementRule pointer type used for the construction of replacement rules. using IAllocationManager::AllocationManagerPtr AllocationManagerPtr Allocation manager pointer used to hold allocation managers. Public Functions Name RuleFactory ( RuleSet & rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager) RuleFactory () RuleFactory ( RuleFactory const & ) RuleFactory ( RuleFactory && ) =default ~RuleFactory () =default void usingConfiguration ( FactoryConfiguration const & config) This takes a FactoryConfiguration as argument and enable rules accordingly. void removeFunctionCall (String const & name) void useStaticQubitArrayAllocation () void useStaticQubitAllocation () void useStaticResultAllocation () void resolveConstantArraySizes () void inlineCallables () void optimiseResultOne () void optimiseResultZero () Replaces branching of quantum results compared to zero. This method is not implemented yet. void disableReferenceCounting () void disableAliasCounting () This method disables alias counting for arrays, strings and results. void disableStringSupport () void setDefaultIntegerWidth (uint32_t v) Sets the integer width used when it cannot be deducted from the context of the transformation. Detailed Description class microsoft::quantum::RuleFactory; Rule factory provides a high-level methods to build a rule set that enforces certain aspects of QIR transformation. Public Types Documentation using ReplacementRulePtr using microsoft::quantum::RuleFactory::ReplacementRulePtr = std::shared_ptr<ReplacementRule>; ReplacementRule pointer type used for the construction of replacement rules. using AllocationManagerPtr using microsoft::quantum::RuleFactory::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; Allocation manager pointer used to hold allocation managers. Public Functions Documentation function RuleFactory RuleFactory( RuleSet & rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager ) function RuleFactory RuleFactory() function RuleFactory RuleFactory( RuleFactory const & ) function RuleFactory RuleFactory( RuleFactory && ) =default function ~RuleFactory ~RuleFactory() =default function usingConfiguration void usingConfiguration( FactoryConfiguration const & config ) This takes a FactoryConfiguration as argument and enable rules accordingly. function removeFunctionCall void removeFunctionCall( String const & name ) Removes all calls to functions with a specified name. This function matches on name alone and ignores function arguments. function useStaticQubitArrayAllocation void useStaticQubitArrayAllocation() Static qubit array allocation identifies allocations, array access and releases. Each of these are replaced with static values. Patterns recognised include %array = call %Array* @__quantum__rt__qubit_allocate_array(i64 10) which is replaced by a constant pointer %array = inttoptr i64 0 to %Array* The array allocation is managed through the qubit allocation manager. Access to qubit arrays %0 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %array, i64 7) %1 = bitcast i8* %0 to %Qubit** %qubit = load %Qubit*, %Qubit** %1, align 8 is replaced by off-setting the array value by 7 to get %qubit = inttoptr i64 7 to %Qubit* Finally, release is recognised and the allocation manager is invoked accordingly. Allocation This rule is replacing the allocate qubit array instruction leftPreshared = call Array* @__quantum__rt__qubit_allocate_array(i64 2) by changing it to a constant pointer leftPreshared = inttoptr i64 0 to Array* In this way, we use the Array access replacement Release replacement function useStaticQubitAllocation void useStaticQubitAllocation() Static qubit allocation identifies allocation and release of single qubits. It uses the qubit allocation manager to track allocation and releases of qubits. It translates %qubit1 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit2 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit3 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit4 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit5 = call %Qubit* @__quantum__rt__qubit_allocate() to %qubit1 = inttoptr i64 0 to %Qubit* %qubit2 = inttoptr i64 1 to %Qubit* %qubit3 = inttoptr i64 2 to %Qubit* %qubit4 = inttoptr i64 3 to %Qubit* %qubit5 = inttoptr i64 4 to %Qubit* if the BasicAllocationManager is used. Release replacement function useStaticResultAllocation void useStaticResultAllocation() Static allocation of results. This feature is similar to useStaticQubitAllocation but uses the result allocation manager. function resolveConstantArraySizes void resolveConstantArraySizes() Array access replacement function inlineCallables void inlineCallables() Array access replacement function optimiseResultOne void optimiseResultOne() Replaces branching of quantum results compared to one. This is a relatively advanced pattern, intended for base profile-like constructs where %1 = tail call %Result* @__quantum__rt__result_get_one() %2 = tail call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 is mapped into %1 = call i1 @__quantum__qis__read_result__body(%Result* %0) br i1 %1, label %then0__1, label %continue__1 which removes the need for constant one. function optimiseResultZero void optimiseResultZero() Replaces branching of quantum results compared to zero. This method is not implemented yet. function disableReferenceCounting void disableReferenceCounting() This method disables reference counting for arrays, strings and results. It does so by simply removing the instructions and the resulting code is expected to be executed either on a stack VM or with shared pointer logic. function disableAliasCounting void disableAliasCounting() This method disables alias counting for arrays, strings and results. function disableStringSupport void disableStringSupport() Removes string support by removing string related instructions. At the moment these include __quantum__rt__string_create , __quantum__rt__string_update_reference_count , __quantum__rt__string_update_alias_count and __quantum__rt__message . function setDefaultIntegerWidth void setDefaultIntegerWidth( uint32_t v ) Sets the integer width used when it cannot be deducted from the context of the transformation. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::RuleFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#microsoftquantumrulefactory","text":"More... #include <Rules/Factory.hpp>","title":"microsoft::quantum::RuleFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#public-types","text":"Name using std::shared_ptr< ReplacementRule > ReplacementRulePtr ReplacementRule pointer type used for the construction of replacement rules. using IAllocationManager::AllocationManagerPtr AllocationManagerPtr Allocation manager pointer used to hold allocation managers.","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#public-functions","text":"Name RuleFactory ( RuleSet & rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager) RuleFactory () RuleFactory ( RuleFactory const & ) RuleFactory ( RuleFactory && ) =default ~RuleFactory () =default void usingConfiguration ( FactoryConfiguration const & config) This takes a FactoryConfiguration as argument and enable rules accordingly. void removeFunctionCall (String const & name) void useStaticQubitArrayAllocation () void useStaticQubitAllocation () void useStaticResultAllocation () void resolveConstantArraySizes () void inlineCallables () void optimiseResultOne () void optimiseResultZero () Replaces branching of quantum results compared to zero. This method is not implemented yet. void disableReferenceCounting () void disableAliasCounting () This method disables alias counting for arrays, strings and results. void disableStringSupport () void setDefaultIntegerWidth (uint32_t v) Sets the integer width used when it cannot be deducted from the context of the transformation.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#detailed-description","text":"class microsoft::quantum::RuleFactory; Rule factory provides a high-level methods to build a rule set that enforces certain aspects of QIR transformation.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#using-replacementruleptr","text":"using microsoft::quantum::RuleFactory::ReplacementRulePtr = std::shared_ptr<ReplacementRule>; ReplacementRule pointer type used for the construction of replacement rules.","title":"using ReplacementRulePtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#using-allocationmanagerptr","text":"using microsoft::quantum::RuleFactory::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; Allocation manager pointer used to hold allocation managers.","title":"using AllocationManagerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-rulefactory","text":"RuleFactory( RuleSet & rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager )","title":"function RuleFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-rulefactory_1","text":"RuleFactory()","title":"function RuleFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-rulefactory_2","text":"RuleFactory( RuleFactory const & )","title":"function RuleFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-rulefactory_3","text":"RuleFactory( RuleFactory && ) =default","title":"function RuleFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-rulefactory_4","text":"~RuleFactory() =default","title":"function ~RuleFactory"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-usingconfiguration","text":"void usingConfiguration( FactoryConfiguration const & config ) This takes a FactoryConfiguration as argument and enable rules accordingly.","title":"function usingConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-removefunctioncall","text":"void removeFunctionCall( String const & name ) Removes all calls to functions with a specified name. This function matches on name alone and ignores function arguments.","title":"function removeFunctionCall"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-usestaticqubitarrayallocation","text":"void useStaticQubitArrayAllocation() Static qubit array allocation identifies allocations, array access and releases. Each of these are replaced with static values. Patterns recognised include %array = call %Array* @__quantum__rt__qubit_allocate_array(i64 10) which is replaced by a constant pointer %array = inttoptr i64 0 to %Array* The array allocation is managed through the qubit allocation manager. Access to qubit arrays %0 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %array, i64 7) %1 = bitcast i8* %0 to %Qubit** %qubit = load %Qubit*, %Qubit** %1, align 8 is replaced by off-setting the array value by 7 to get %qubit = inttoptr i64 7 to %Qubit* Finally, release is recognised and the allocation manager is invoked accordingly. Allocation This rule is replacing the allocate qubit array instruction leftPreshared = call Array* @__quantum__rt__qubit_allocate_array(i64 2) by changing it to a constant pointer leftPreshared = inttoptr i64 0 to Array* In this way, we use the Array access replacement Release replacement","title":"function useStaticQubitArrayAllocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-usestaticqubitallocation","text":"void useStaticQubitAllocation() Static qubit allocation identifies allocation and release of single qubits. It uses the qubit allocation manager to track allocation and releases of qubits. It translates %qubit1 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit2 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit3 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit4 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit5 = call %Qubit* @__quantum__rt__qubit_allocate() to %qubit1 = inttoptr i64 0 to %Qubit* %qubit2 = inttoptr i64 1 to %Qubit* %qubit3 = inttoptr i64 2 to %Qubit* %qubit4 = inttoptr i64 3 to %Qubit* %qubit5 = inttoptr i64 4 to %Qubit* if the BasicAllocationManager is used. Release replacement","title":"function useStaticQubitAllocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-usestaticresultallocation","text":"void useStaticResultAllocation() Static allocation of results. This feature is similar to useStaticQubitAllocation but uses the result allocation manager.","title":"function useStaticResultAllocation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-resolveconstantarraysizes","text":"void resolveConstantArraySizes() Array access replacement","title":"function resolveConstantArraySizes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-inlinecallables","text":"void inlineCallables() Array access replacement","title":"function inlineCallables"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-optimiseresultone","text":"void optimiseResultOne() Replaces branching of quantum results compared to one. This is a relatively advanced pattern, intended for base profile-like constructs where %1 = tail call %Result* @__quantum__rt__result_get_one() %2 = tail call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 is mapped into %1 = call i1 @__quantum__qis__read_result__body(%Result* %0) br i1 %1, label %then0__1, label %continue__1 which removes the need for constant one.","title":"function optimiseResultOne"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-optimiseresultzero","text":"void optimiseResultZero() Replaces branching of quantum results compared to zero. This method is not implemented yet.","title":"function optimiseResultZero"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-disablereferencecounting","text":"void disableReferenceCounting() This method disables reference counting for arrays, strings and results. It does so by simply removing the instructions and the resulting code is expected to be executed either on a stack VM or with shared pointer logic.","title":"function disableReferenceCounting"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-disablealiascounting","text":"void disableAliasCounting() This method disables alias counting for arrays, strings and results.","title":"function disableAliasCounting"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-disablestringsupport","text":"void disableStringSupport() Removes string support by removing string related instructions. At the moment these include __quantum__rt__string_create , __quantum__rt__string_update_reference_count , __quantum__rt__string_update_alias_count and __quantum__rt__message .","title":"function disableStringSupport"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_factory/#function-setdefaultintegerwidth","text":"void setDefaultIntegerWidth( uint32_t v ) Sets the integer width used when it cannot be deducted from the context of the transformation. Updated on 22 November 2021 at 10:28:34 UTC","title":"function setDefaultIntegerWidth"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/","text":"microsoft::quantum::RuleSet More... #include <Rules/RuleSet.hpp> Public Types Name using std::shared_ptr< ReplacementRule > ReplacementRulePtr using std::vector< ReplacementRulePtr > Rules using ReplacementRule::Replacements Replacements using IOperandPrototype::Captures Captures using llvm::Instruction Instruction using llvm::Value Value using ReplacementRule::Builder Builder using IAllocationManager::AllocationManagerPtr AllocationManagerPtr Public Functions Name RuleSet () =default RuleSet ( RuleSet const & ) =default RuleSet ( RuleSet && ) =default ~RuleSet () =default RuleSet & operator= ( RuleSet const & ) =default RuleSet & operator= ( RuleSet && ) =default bool matchAndReplace (Instruction * value, Replacements & replacements) void addRule (ReplacementRulePtr const & rule) Adds a new replacement rule to the set. void addRule ( ReplacementRule && rule) void clear () Clears the rule set for all rules. uint64_t size () const Returns the size of the rule set. Detailed Description class microsoft::quantum::RuleSet; RuleSet contains a set of replacement rules and the corresponding logic to apply the rules. The class allows one to apply the rules by which each rule is tested one-by-one until a successful attempt at performing a replace has happened, or the list was exhausted. Public Types Documentation using ReplacementRulePtr using microsoft::quantum::RuleSet::ReplacementRulePtr = std::shared_ptr<ReplacementRule>; using Rules using microsoft::quantum::RuleSet::Rules = std::vector<ReplacementRulePtr>; using Replacements using microsoft::quantum::RuleSet::Replacements = ReplacementRule::Replacements; using Captures using microsoft::quantum::RuleSet::Captures = IOperandPrototype::Captures; using Instruction using microsoft::quantum::RuleSet::Instruction = llvm::Instruction; using Value using microsoft::quantum::RuleSet::Value = llvm::Value; using Builder using microsoft::quantum::RuleSet::Builder = ReplacementRule::Builder; using AllocationManagerPtr using microsoft::quantum::RuleSet::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; Public Functions Documentation function RuleSet RuleSet() =default function RuleSet RuleSet( RuleSet const & ) =default function RuleSet RuleSet( RuleSet && ) =default function ~RuleSet ~RuleSet() =default function operator= RuleSet & operator=( RuleSet const & ) =default function operator= RuleSet & operator=( RuleSet && ) =default function matchAndReplace bool matchAndReplace( Instruction * value, Replacements & replacements ) Matches patterns and runs the replacement routines if a match is found. The function returns true if a pattern is matched and and the replacement was a success. In all other cases, it returns false. function addRule void addRule( ReplacementRulePtr const & rule ) Adds a new replacement rule to the set. function addRule void addRule( ReplacementRule && rule ) function clear void clear() Clears the rule set for all rules. function size uint64_t size() const Returns the size of the rule set. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::RuleSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#microsoftquantumruleset","text":"More... #include <Rules/RuleSet.hpp>","title":"microsoft::quantum::RuleSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#public-types","text":"Name using std::shared_ptr< ReplacementRule > ReplacementRulePtr using std::vector< ReplacementRulePtr > Rules using ReplacementRule::Replacements Replacements using IOperandPrototype::Captures Captures using llvm::Instruction Instruction using llvm::Value Value using ReplacementRule::Builder Builder using IAllocationManager::AllocationManagerPtr AllocationManagerPtr","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#public-functions","text":"Name RuleSet () =default RuleSet ( RuleSet const & ) =default RuleSet ( RuleSet && ) =default ~RuleSet () =default RuleSet & operator= ( RuleSet const & ) =default RuleSet & operator= ( RuleSet && ) =default bool matchAndReplace (Instruction * value, Replacements & replacements) void addRule (ReplacementRulePtr const & rule) Adds a new replacement rule to the set. void addRule ( ReplacementRule && rule) void clear () Clears the rule set for all rules. uint64_t size () const Returns the size of the rule set.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#detailed-description","text":"class microsoft::quantum::RuleSet; RuleSet contains a set of replacement rules and the corresponding logic to apply the rules. The class allows one to apply the rules by which each rule is tested one-by-one until a successful attempt at performing a replace has happened, or the list was exhausted.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-replacementruleptr","text":"using microsoft::quantum::RuleSet::ReplacementRulePtr = std::shared_ptr<ReplacementRule>;","title":"using ReplacementRulePtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-rules","text":"using microsoft::quantum::RuleSet::Rules = std::vector<ReplacementRulePtr>;","title":"using Rules"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-replacements","text":"using microsoft::quantum::RuleSet::Replacements = ReplacementRule::Replacements;","title":"using Replacements"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-captures","text":"using microsoft::quantum::RuleSet::Captures = IOperandPrototype::Captures;","title":"using Captures"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-instruction","text":"using microsoft::quantum::RuleSet::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-value","text":"using microsoft::quantum::RuleSet::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-builder","text":"using microsoft::quantum::RuleSet::Builder = ReplacementRule::Builder;","title":"using Builder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#using-allocationmanagerptr","text":"using microsoft::quantum::RuleSet::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr;","title":"using AllocationManagerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-ruleset","text":"RuleSet() =default","title":"function RuleSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-ruleset_1","text":"RuleSet( RuleSet const & ) =default","title":"function RuleSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-ruleset_2","text":"RuleSet( RuleSet && ) =default","title":"function RuleSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-ruleset_3","text":"~RuleSet() =default","title":"function ~RuleSet"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-operator","text":"RuleSet & operator=( RuleSet const & ) =default","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-operator_1","text":"RuleSet & operator=( RuleSet && ) =default","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-matchandreplace","text":"bool matchAndReplace( Instruction * value, Replacements & replacements ) Matches patterns and runs the replacement routines if a match is found. The function returns true if a pattern is matched and and the replacement was a success. In all other cases, it returns false.","title":"function matchAndReplace"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-addrule","text":"void addRule( ReplacementRulePtr const & rule ) Adds a new replacement rule to the set.","title":"function addRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-addrule_1","text":"void addRule( ReplacementRule && rule )","title":"function addRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-clear","text":"void clear() Clears the rule set for all rules.","title":"function clear"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_rule_set/#function-size","text":"uint64_t size() const Returns the size of the rule set. Updated on 22 November 2021 at 10:28:34 UTC","title":"function size"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_select_pattern/","text":"microsoft::quantum::SelectPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::SelectPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_select_pattern/#microsoftquantumselectpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::SelectPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_select_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_select_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_select_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_select_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_select_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 November 2021 at 10:28:34 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_store_pattern/","text":"microsoft::quantum::StorePattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::StorePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_store_pattern/#microsoftquantumstorepattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::StorePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_store_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_store_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_store_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_store_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_store_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 November 2021 at 10:28:34 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_switch_pattern/","text":"microsoft::quantum::SwitchPattern Inherits from microsoft::quantum::IOperandPrototype Public Functions Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Functions Documentation function match virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children. function copy virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::SwitchPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_switch_pattern/#microsoftquantumswitchpattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::SwitchPattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_switch_pattern/#public-functions","text":"Name virtual bool match (Value * value, Captures & captures) const override virtual Child copy () const override","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_switch_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using std::string String using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_switch_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_switch_pattern/#function-match","text":"virtual bool match( Value * value, Captures & captures ) const override Reimplements : microsoft::quantum::IOperandPrototype::match Interface function which determines if a given Value matches the implemented pattern. It is expected that any implementation of match will return a call to either [success()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-success) or [fail()](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype/#function-fail) . These functions will, in turn, ensure that the node is captured in the capture table (and erased upon backtracking) as well as matching children.","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_switch_pattern/#function-copy","text":"virtual Child copy() const override Reimplements : microsoft::quantum::IOperandPrototype::copy Interface function which defines a copy operation of the underlying implementation. Note that unlike normal copy operators this operation returns a shared pointer to the new copy. Updated on 22 November 2021 at 10:28:34 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/","text":"microsoft::quantum::TransformationRulesPass More... #include <TransformationRulesPass/TransformationRulesPass.hpp> Inherits from llvm::PassInfoMixin< TransformationRulesPass > Public Types Name using ReplacementRule::Replacements Replacements using llvm::Instruction Instruction using std::vector< ReplacementRule > Rules using llvm::Value Value using ReplacementRule::Builder Builder using IAllocationManager::AllocationManagerPtr AllocationManagerPtr using RuleSet::Captures Captures using std::unordered_map< std::string, llvm::ConstantInt * > ConstantArguments using std::shared_ptr< ILogger > ILoggerPtr using std::vector< llvm::Instruction * > DeletableInstructions using std::function< llvm::Value (llvm::Value , DeletableInstructions &)> InstructionModifier Public Functions Name TransformationRulesPass ( RuleSet && rule_set, TransformationRulesPassConfiguration const & config, Profile * profile) Custom default constructor. TransformationRulesPass ( TransformationRulesPass const & ) Copy construction is banned. TransformationRulesPass ( TransformationRulesPass && ) =default We allow move semantics. ~TransformationRulesPass () =default Default destruction. TransformationRulesPass & operator= ( TransformationRulesPass const & ) Copy assignment is banned. TransformationRulesPass & operator= ( TransformationRulesPass && ) =default Move assignment is permitted. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool runOnFunction (llvm::Function & function, InstructionModifier const & modifier) void processReplacements () Applies each of the replacements in the replacements_ variable. void setupCopyAndExpand () Configuration function for copy and expand to setup the necessary rules. void runCopyAndExpand (llvm::Module & module, llvm::ModuleAnalysisManager & mam) llvm::Value * copyAndExpand (llvm::Value * input, DeletableInstructions & schedule_instruction_deletion) llvm::Function * expandFunctionCall (llvm::Function & callee, ConstantArguments const & const_args ={}) Copies the function body and replace function arguments whenever arguments are constant. void constantFoldFunction (llvm::Function & callee) Folds all constant expression in function. void addConstExprRule ( ReplacementRule && rule) Helper function to create replacements for constant expressions. void runDetectActiveCode (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runDeleteDeadCode (llvm::Module & module, llvm::ModuleAnalysisManager & mam) llvm::Value * detectActiveCode (llvm::Value * input, DeletableInstructions & ) llvm::Value * deleteDeadCode (llvm::Value * input, DeletableInstructions & ) bool isActive (llvm::Value * value) const void followUsers (llvm::Value * value) void runReplacePhi (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runApplyRules (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool onQubitRelease (llvm::Instruction * instruction, Captures & captures) bool onQubitAllocate (llvm::Instruction * instruction, Captures & captures) void setLogger (ILoggerPtr logger) bool isRequired () Whether or not this pass is required to run. Detailed Description class microsoft::quantum::TransformationRulesPass; This class applies a set of transformation rules to the IR to transform it into a new IR. The rules are added using the RuleSet class which allows the developer to create one or more rules on how to transform the IR. The module executes the following steps: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Apply profile \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Copy and expand functions \u2502\u2500\u2500\u2510 \u2502 clone \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 functions? \u2502 delete dead \u2502 \u2502 \u25bc code? \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Determine active code \u2502 \u2502 \u2502 delete dead \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 code? \u2502 \u2502 leave dead \u2502 \u25bc \u2502 code? \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Simplify phi nodes \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Delete dead code \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 fallback \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Apply rules \u2502\u25c0\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Copying and expanding functions identifies function calls and identifies compile time constants passed to the function. It then copies the full implementation of the function, replacing all compile-time constants (and hence changing the function signature). That is, if a function call f(x, 9) is identified, it is replaced with f.1(x) where f.1 is a copy of f with second argument written into the function. Public Types Documentation using Replacements using microsoft::quantum::TransformationRulesPass::Replacements = ReplacementRule::Replacements; using Instruction using microsoft::quantum::TransformationRulesPass::Instruction = llvm::Instruction; using Rules using microsoft::quantum::TransformationRulesPass::Rules = std::vector<ReplacementRule>; using Value using microsoft::quantum::TransformationRulesPass::Value = llvm::Value; using Builder using microsoft::quantum::TransformationRulesPass::Builder = ReplacementRule::Builder; using AllocationManagerPtr using microsoft::quantum::TransformationRulesPass::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; using Captures using microsoft::quantum::TransformationRulesPass::Captures = RuleSet::Captures; using ConstantArguments using microsoft::quantum::TransformationRulesPass::ConstantArguments = std::unordered_map<std::string, llvm::ConstantInt*>; using ILoggerPtr using microsoft::quantum::TransformationRulesPass::ILoggerPtr = std::shared_ptr<ILogger>; using DeletableInstructions using microsoft::quantum::TransformationRulesPass::DeletableInstructions = std::vector<llvm::Instruction*>; using InstructionModifier using microsoft::quantum::TransformationRulesPass::InstructionModifier = std::function<llvm::Value*(llvm::Value*, DeletableInstructions&)>; Public Functions Documentation function TransformationRulesPass TransformationRulesPass( RuleSet && rule_set, TransformationRulesPassConfiguration const & config, Profile * profile ) Custom default constructor. function TransformationRulesPass TransformationRulesPass( TransformationRulesPass const & ) Copy construction is banned. function TransformationRulesPass TransformationRulesPass( TransformationRulesPass && ) =default We allow move semantics. function ~TransformationRulesPass ~TransformationRulesPass() =default Default destruction. function operator= TransformationRulesPass & operator=( TransformationRulesPass const & ) Copy assignment is banned. function operator= TransformationRulesPass & operator=( TransformationRulesPass && ) =default Move assignment is permitted. function run llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) Implements the transformation analysis which uses the supplied ruleset to make substitutions in each function. function runOnFunction bool runOnFunction( llvm::Function & function, InstructionModifier const & modifier ) Generic function to apply a instructionModifier (lambda function) to every instruction in the function function . This method follows the execution path to the extend possible and deals with branching if the branch statement can be evaluated at compile time. function processReplacements void processReplacements() Applies each of the replacements in the replacements_ variable. function setupCopyAndExpand void setupCopyAndExpand() Configuration function for copy and expand to setup the necessary rules. function runCopyAndExpand void runCopyAndExpand( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) Main function for running the copy and expand functionality. This function first identifies the entry point and then follows every execution path to copy the callee function for every call instruction encountered. This makes that every call in the code has its own unique callee function which ensures that when allocating qubits or results, the assigned registers are not accidentally reused. function copyAndExpand llvm::Value * copyAndExpand( llvm::Value * input, DeletableInstructions & schedule_instruction_deletion ) Test whether the instruction is a call instruction and copy the callee in case it is. This function collects instructions which are scheduled for deletion at a later point. function expandFunctionCall llvm::Function * expandFunctionCall( llvm::Function & callee, ConstantArguments const & const_args ={} ) Copies the function body and replace function arguments whenever arguments are constant. function constantFoldFunction void constantFoldFunction( llvm::Function & callee ) Folds all constant expression in function. function addConstExprRule void addConstExprRule( ReplacementRule && rule ) Helper function to create replacements for constant expressions. function runDetectActiveCode void runDetectActiveCode( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function runDeleteDeadCode void runDeleteDeadCode( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function detectActiveCode llvm::Value * detectActiveCode( llvm::Value * input, DeletableInstructions & ) function deleteDeadCode llvm::Value * deleteDeadCode( llvm::Value * input, DeletableInstructions & ) function isActive bool isActive( llvm::Value * value ) const function followUsers void followUsers( llvm::Value * value ) function runReplacePhi void runReplacePhi( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) Function which replaces phi nodes which refer to inactive blocks. That is, in cases where branch statement evaluates at compile time, only one block will be marked as active. For those case we can eliminate the phi nodes. In the case where branch statements cannot be evaluated all are marked as active. In this case, phi nodes are left unchanged. function runApplyRules void runApplyRules( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function onQubitRelease bool onQubitRelease( llvm::Instruction * instruction, Captures & captures ) function onQubitAllocate bool onQubitAllocate( llvm::Instruction * instruction, Captures & captures ) function setLogger void setLogger( ILoggerPtr logger ) function isRequired static bool isRequired() Whether or not this pass is required to run. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::TransformationRulesPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#microsoftquantumtransformationrulespass","text":"More... #include <TransformationRulesPass/TransformationRulesPass.hpp> Inherits from llvm::PassInfoMixin< TransformationRulesPass >","title":"microsoft::quantum::TransformationRulesPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#public-types","text":"Name using ReplacementRule::Replacements Replacements using llvm::Instruction Instruction using std::vector< ReplacementRule > Rules using llvm::Value Value using ReplacementRule::Builder Builder using IAllocationManager::AllocationManagerPtr AllocationManagerPtr using RuleSet::Captures Captures using std::unordered_map< std::string, llvm::ConstantInt * > ConstantArguments using std::shared_ptr< ILogger > ILoggerPtr using std::vector< llvm::Instruction * > DeletableInstructions using std::function< llvm::Value (llvm::Value , DeletableInstructions &)> InstructionModifier","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#public-functions","text":"Name TransformationRulesPass ( RuleSet && rule_set, TransformationRulesPassConfiguration const & config, Profile * profile) Custom default constructor. TransformationRulesPass ( TransformationRulesPass const & ) Copy construction is banned. TransformationRulesPass ( TransformationRulesPass && ) =default We allow move semantics. ~TransformationRulesPass () =default Default destruction. TransformationRulesPass & operator= ( TransformationRulesPass const & ) Copy assignment is banned. TransformationRulesPass & operator= ( TransformationRulesPass && ) =default Move assignment is permitted. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool runOnFunction (llvm::Function & function, InstructionModifier const & modifier) void processReplacements () Applies each of the replacements in the replacements_ variable. void setupCopyAndExpand () Configuration function for copy and expand to setup the necessary rules. void runCopyAndExpand (llvm::Module & module, llvm::ModuleAnalysisManager & mam) llvm::Value * copyAndExpand (llvm::Value * input, DeletableInstructions & schedule_instruction_deletion) llvm::Function * expandFunctionCall (llvm::Function & callee, ConstantArguments const & const_args ={}) Copies the function body and replace function arguments whenever arguments are constant. void constantFoldFunction (llvm::Function & callee) Folds all constant expression in function. void addConstExprRule ( ReplacementRule && rule) Helper function to create replacements for constant expressions. void runDetectActiveCode (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runDeleteDeadCode (llvm::Module & module, llvm::ModuleAnalysisManager & mam) llvm::Value * detectActiveCode (llvm::Value * input, DeletableInstructions & ) llvm::Value * deleteDeadCode (llvm::Value * input, DeletableInstructions & ) bool isActive (llvm::Value * value) const void followUsers (llvm::Value * value) void runReplacePhi (llvm::Module & module, llvm::ModuleAnalysisManager & mam) void runApplyRules (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool onQubitRelease (llvm::Instruction * instruction, Captures & captures) bool onQubitAllocate (llvm::Instruction * instruction, Captures & captures) void setLogger (ILoggerPtr logger) bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#detailed-description","text":"class microsoft::quantum::TransformationRulesPass; This class applies a set of transformation rules to the IR to transform it into a new IR. The rules are added using the RuleSet class which allows the developer to create one or more rules on how to transform the IR. The module executes the following steps: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Apply profile \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Copy and expand functions \u2502\u2500\u2500\u2510 \u2502 clone \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 functions? \u2502 delete dead \u2502 \u2502 \u25bc code? \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Determine active code \u2502 \u2502 \u2502 delete dead \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 code? \u2502 \u2502 leave dead \u2502 \u25bc \u2502 code? \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Simplify phi nodes \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Delete dead code \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u25bc \u2502 \u2502 fallback \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Apply rules \u2502\u25c0\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Copying and expanding functions identifies function calls and identifies compile time constants passed to the function. It then copies the full implementation of the function, replacing all compile-time constants (and hence changing the function signature). That is, if a function call f(x, 9) is identified, it is replaced with f.1(x) where f.1 is a copy of f with second argument written into the function.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-replacements","text":"using microsoft::quantum::TransformationRulesPass::Replacements = ReplacementRule::Replacements;","title":"using Replacements"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-instruction","text":"using microsoft::quantum::TransformationRulesPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-rules","text":"using microsoft::quantum::TransformationRulesPass::Rules = std::vector<ReplacementRule>;","title":"using Rules"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-value","text":"using microsoft::quantum::TransformationRulesPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-builder","text":"using microsoft::quantum::TransformationRulesPass::Builder = ReplacementRule::Builder;","title":"using Builder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-allocationmanagerptr","text":"using microsoft::quantum::TransformationRulesPass::AllocationManagerPtr = IAllocationManager::AllocationManagerPtr;","title":"using AllocationManagerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-captures","text":"using microsoft::quantum::TransformationRulesPass::Captures = RuleSet::Captures;","title":"using Captures"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-constantarguments","text":"using microsoft::quantum::TransformationRulesPass::ConstantArguments = std::unordered_map<std::string, llvm::ConstantInt*>;","title":"using ConstantArguments"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-iloggerptr","text":"using microsoft::quantum::TransformationRulesPass::ILoggerPtr = std::shared_ptr<ILogger>;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-deletableinstructions","text":"using microsoft::quantum::TransformationRulesPass::DeletableInstructions = std::vector<llvm::Instruction*>;","title":"using DeletableInstructions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#using-instructionmodifier","text":"using microsoft::quantum::TransformationRulesPass::InstructionModifier = std::function<llvm::Value*(llvm::Value*, DeletableInstructions&)>;","title":"using InstructionModifier"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-transformationrulespass","text":"TransformationRulesPass( RuleSet && rule_set, TransformationRulesPassConfiguration const & config, Profile * profile ) Custom default constructor.","title":"function TransformationRulesPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-transformationrulespass_1","text":"TransformationRulesPass( TransformationRulesPass const & ) Copy construction is banned.","title":"function TransformationRulesPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-transformationrulespass_2","text":"TransformationRulesPass( TransformationRulesPass && ) =default We allow move semantics.","title":"function TransformationRulesPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-transformationrulespass_3","text":"~TransformationRulesPass() =default Default destruction.","title":"function ~TransformationRulesPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-operator","text":"TransformationRulesPass & operator=( TransformationRulesPass const & ) Copy assignment is banned.","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-operator_1","text":"TransformationRulesPass & operator=( TransformationRulesPass && ) =default Move assignment is permitted.","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-run","text":"llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) Implements the transformation analysis which uses the supplied ruleset to make substitutions in each function.","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-runonfunction","text":"bool runOnFunction( llvm::Function & function, InstructionModifier const & modifier ) Generic function to apply a instructionModifier (lambda function) to every instruction in the function function . This method follows the execution path to the extend possible and deals with branching if the branch statement can be evaluated at compile time.","title":"function runOnFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-processreplacements","text":"void processReplacements() Applies each of the replacements in the replacements_ variable.","title":"function processReplacements"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-setupcopyandexpand","text":"void setupCopyAndExpand() Configuration function for copy and expand to setup the necessary rules.","title":"function setupCopyAndExpand"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-runcopyandexpand","text":"void runCopyAndExpand( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) Main function for running the copy and expand functionality. This function first identifies the entry point and then follows every execution path to copy the callee function for every call instruction encountered. This makes that every call in the code has its own unique callee function which ensures that when allocating qubits or results, the assigned registers are not accidentally reused.","title":"function runCopyAndExpand"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-copyandexpand","text":"llvm::Value * copyAndExpand( llvm::Value * input, DeletableInstructions & schedule_instruction_deletion ) Test whether the instruction is a call instruction and copy the callee in case it is. This function collects instructions which are scheduled for deletion at a later point.","title":"function copyAndExpand"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-expandfunctioncall","text":"llvm::Function * expandFunctionCall( llvm::Function & callee, ConstantArguments const & const_args ={} ) Copies the function body and replace function arguments whenever arguments are constant.","title":"function expandFunctionCall"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-constantfoldfunction","text":"void constantFoldFunction( llvm::Function & callee ) Folds all constant expression in function.","title":"function constantFoldFunction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-addconstexprrule","text":"void addConstExprRule( ReplacementRule && rule ) Helper function to create replacements for constant expressions.","title":"function addConstExprRule"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-rundetectactivecode","text":"void runDetectActiveCode( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function runDetectActiveCode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-rundeletedeadcode","text":"void runDeleteDeadCode( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function runDeleteDeadCode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-detectactivecode","text":"llvm::Value * detectActiveCode( llvm::Value * input, DeletableInstructions & )","title":"function detectActiveCode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-deletedeadcode","text":"llvm::Value * deleteDeadCode( llvm::Value * input, DeletableInstructions & )","title":"function deleteDeadCode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-isactive","text":"bool isActive( llvm::Value * value ) const","title":"function isActive"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-followusers","text":"void followUsers( llvm::Value * value )","title":"function followUsers"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-runreplacephi","text":"void runReplacePhi( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) Function which replaces phi nodes which refer to inactive blocks. That is, in cases where branch statement evaluates at compile time, only one block will be marked as active. For those case we can eliminate the phi nodes. In the case where branch statements cannot be evaluated all are marked as active. In this case, phi nodes are left unchanged.","title":"function runReplacePhi"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-runapplyrules","text":"void runApplyRules( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function runApplyRules"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-onqubitrelease","text":"bool onQubitRelease( llvm::Instruction * instruction, Captures & captures )","title":"function onQubitRelease"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-onqubitallocate","text":"bool onQubitAllocate( llvm::Instruction * instruction, Captures & captures )","title":"function onQubitAllocate"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-setlogger","text":"void setLogger( ILoggerPtr logger )","title":"function setLogger"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run. Updated on 22 November 2021 at 10:28:34 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/","text":"microsoft::quantum::TransformationRulesPassConfiguration Configuration class for the RuleTransformation pass. #include <TransformationRulesPass/TransformationRulesPassConfiguration.hpp> Public Functions Name void setup ( ConfigurationManager & config) Setup function that attached the configuration to the ConfigurationManager . bool isDisabled () const Tests whether all functionality is disabled for this component. bool operator== ( TransformationRulesPassConfiguration const & ref) const Testing equality of two configurations. bool shouldDeleteDeadCode () const Whether or not the component should delete dead code. bool shouldCloneFunctions () const bool assumeNoExceptions () const Whether or not we assume that the code does not throw at runtime. bool shouldTransformExecutionPathOnly () const uint64_t maxRecursion () const The maximum recursion acceptable when unrolling the execution path. bool shouldReuseQubits () const Whether or not to reuse qubits. bool shouldAnnotateQubitUse () const Whether or not to annotate entry point with the number of qubits they use. bool shouldReuseResults () const Whether or not to reuse result registers. bool shouldAnnotateResultUse () const Whether or not to annotate entry point with the number of results they use. bool shouldGroupMeasurements () const Whether or not the component should attempt to group measurements. bool oneShotMeasurement () const bool shouldSimplifyPriorTransform () const Whether or not simplify the IR using LLVM passes prior to transforming the IR. std::string entryPointAttr () const Attribute which indicate that a function is the entry point. TransformationRulesPassConfiguration createDisabled () Creates a configuration where all functionality is disabled. Public Functions Documentation function setup void setup( ConfigurationManager & config ) Setup function that attached the configuration to the ConfigurationManager . function isDisabled bool isDisabled() const Tests whether all functionality is disabled for this component. function operator== bool operator==( TransformationRulesPassConfiguration const & ref ) const Testing equality of two configurations. function shouldDeleteDeadCode bool shouldDeleteDeadCode() const Whether or not the component should delete dead code. function shouldCloneFunctions bool shouldCloneFunctions() const Whether or not the component should clone functions. This is relevant in relation to qubit allocation if execution paths are expanded. function assumeNoExceptions bool assumeNoExceptions() const Whether or not we assume that the code does not throw at runtime. function shouldTransformExecutionPathOnly bool shouldTransformExecutionPathOnly() const Whether or not the component should follow the execution path only or it should be applied to all parts of the code. For statically allocated qubits one generally wants to follow the execution path whereas it makes more sense to apply to all parts of the code for dynamic qubit allocation. function maxRecursion uint64_t maxRecursion() const The maximum recursion acceptable when unrolling the execution path. function shouldReuseQubits bool shouldReuseQubits() const Whether or not to reuse qubits. function shouldAnnotateQubitUse bool shouldAnnotateQubitUse() const Whether or not to annotate entry point with the number of qubits they use. function shouldReuseResults bool shouldReuseResults() const Whether or not to reuse result registers. function shouldAnnotateResultUse bool shouldAnnotateResultUse() const Whether or not to annotate entry point with the number of results they use. function shouldGroupMeasurements bool shouldGroupMeasurements() const Whether or not the component should attempt to group measurements. function oneShotMeasurement bool oneShotMeasurement() const Whether or not the target supports measurement (and result interpretation) during the circuit execution. function shouldSimplifyPriorTransform bool shouldSimplifyPriorTransform() const Whether or not simplify the IR using LLVM passes prior to transforming the IR. function entryPointAttr std::string entryPointAttr() const Attribute which indicate that a function is the entry point. function createDisabled static TransformationRulesPassConfiguration createDisabled() Creates a configuration where all functionality is disabled. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::TransformationRulesPassConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#microsoftquantumtransformationrulespassconfiguration","text":"Configuration class for the RuleTransformation pass. #include <TransformationRulesPass/TransformationRulesPassConfiguration.hpp>","title":"microsoft::quantum::TransformationRulesPassConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#public-functions","text":"Name void setup ( ConfigurationManager & config) Setup function that attached the configuration to the ConfigurationManager . bool isDisabled () const Tests whether all functionality is disabled for this component. bool operator== ( TransformationRulesPassConfiguration const & ref) const Testing equality of two configurations. bool shouldDeleteDeadCode () const Whether or not the component should delete dead code. bool shouldCloneFunctions () const bool assumeNoExceptions () const Whether or not we assume that the code does not throw at runtime. bool shouldTransformExecutionPathOnly () const uint64_t maxRecursion () const The maximum recursion acceptable when unrolling the execution path. bool shouldReuseQubits () const Whether or not to reuse qubits. bool shouldAnnotateQubitUse () const Whether or not to annotate entry point with the number of qubits they use. bool shouldReuseResults () const Whether or not to reuse result registers. bool shouldAnnotateResultUse () const Whether or not to annotate entry point with the number of results they use. bool shouldGroupMeasurements () const Whether or not the component should attempt to group measurements. bool oneShotMeasurement () const bool shouldSimplifyPriorTransform () const Whether or not simplify the IR using LLVM passes prior to transforming the IR. std::string entryPointAttr () const Attribute which indicate that a function is the entry point. TransformationRulesPassConfiguration createDisabled () Creates a configuration where all functionality is disabled.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-setup","text":"void setup( ConfigurationManager & config ) Setup function that attached the configuration to the ConfigurationManager .","title":"function setup"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-isdisabled","text":"bool isDisabled() const Tests whether all functionality is disabled for this component.","title":"function isDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-operator","text":"bool operator==( TransformationRulesPassConfiguration const & ref ) const Testing equality of two configurations.","title":"function operator=="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-shoulddeletedeadcode","text":"bool shouldDeleteDeadCode() const Whether or not the component should delete dead code.","title":"function shouldDeleteDeadCode"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-shouldclonefunctions","text":"bool shouldCloneFunctions() const Whether or not the component should clone functions. This is relevant in relation to qubit allocation if execution paths are expanded.","title":"function shouldCloneFunctions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-assumenoexceptions","text":"bool assumeNoExceptions() const Whether or not we assume that the code does not throw at runtime.","title":"function assumeNoExceptions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-shouldtransformexecutionpathonly","text":"bool shouldTransformExecutionPathOnly() const Whether or not the component should follow the execution path only or it should be applied to all parts of the code. For statically allocated qubits one generally wants to follow the execution path whereas it makes more sense to apply to all parts of the code for dynamic qubit allocation.","title":"function shouldTransformExecutionPathOnly"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-maxrecursion","text":"uint64_t maxRecursion() const The maximum recursion acceptable when unrolling the execution path.","title":"function maxRecursion"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-shouldreusequbits","text":"bool shouldReuseQubits() const Whether or not to reuse qubits.","title":"function shouldReuseQubits"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-shouldannotatequbituse","text":"bool shouldAnnotateQubitUse() const Whether or not to annotate entry point with the number of qubits they use.","title":"function shouldAnnotateQubitUse"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-shouldreuseresults","text":"bool shouldReuseResults() const Whether or not to reuse result registers.","title":"function shouldReuseResults"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-shouldannotateresultuse","text":"bool shouldAnnotateResultUse() const Whether or not to annotate entry point with the number of results they use.","title":"function shouldAnnotateResultUse"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-shouldgroupmeasurements","text":"bool shouldGroupMeasurements() const Whether or not the component should attempt to group measurements.","title":"function shouldGroupMeasurements"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-oneshotmeasurement","text":"bool oneShotMeasurement() const Whether or not the target supports measurement (and result interpretation) during the circuit execution.","title":"function oneShotMeasurement"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-shouldsimplifypriortransform","text":"bool shouldSimplifyPriorTransform() const Whether or not simplify the IR using LLVM passes prior to transforming the IR.","title":"function shouldSimplifyPriorTransform"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-entrypointattr","text":"std::string entryPointAttr() const Attribute which indicate that a function is the entry point.","title":"function entryPointAttr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_transformation_rules_pass_configuration/#function-createdisabled","text":"static TransformationRulesPassConfiguration createDisabled() Creates a configuration where all functionality is disabled. Updated on 22 November 2021 at 10:28:34 UTC","title":"function createDisabled"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/","text":"microsoft::quantum::UnnamedInvokePattern Inherits from microsoft::quantum::IOperandPrototype Public Types Name using std::string String Public Functions Name UnnamedInvokePattern () =default UnnamedInvokePattern ( UnnamedInvokePattern const & other) Copy construction prohibited. UnnamedInvokePattern ( UnnamedInvokePattern && other) =default Move construction allowed. ~UnnamedInvokePattern () override Destructor implementation. virtual bool match (Value * instr, Captures & captures) const override Matches the callee by name. virtual Child copy () const override Creates a copy of itself. Additional inherited members Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other) Public Types Documentation using String using microsoft::quantum::UnnamedInvokePattern::String = std::string; Public Functions Documentation function UnnamedInvokePattern UnnamedInvokePattern() =default function UnnamedInvokePattern UnnamedInvokePattern( UnnamedInvokePattern const & other ) Copy construction prohibited. function UnnamedInvokePattern UnnamedInvokePattern( UnnamedInvokePattern && other ) =default Move construction allowed. function ~UnnamedInvokePattern ~UnnamedInvokePattern() override Destructor implementation. function match virtual bool match( Value * instr, Captures & captures ) const override Matches the callee by name. Reimplements : microsoft::quantum::IOperandPrototype::match function copy virtual Child copy() const override Creates a copy of itself. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::UnnamedInvokePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#microsoftquantumunnamedinvokepattern","text":"Inherits from microsoft::quantum::IOperandPrototype","title":"microsoft::quantum::UnnamedInvokePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#public-types","text":"Name using std::string String","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#public-functions","text":"Name UnnamedInvokePattern () =default UnnamedInvokePattern ( UnnamedInvokePattern const & other) Copy construction prohibited. UnnamedInvokePattern ( UnnamedInvokePattern && other) =default Move construction allowed. ~UnnamedInvokePattern () override Destructor implementation. virtual bool match (Value * instr, Captures & captures) const override Matches the callee by name. virtual Child copy () const override Creates a copy of itself.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#additional-inherited-members","text":"Public Types inherited from microsoft::quantum::IOperandPrototype Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< IOperandPrototype > Child using std::vector< Child > Children using std::unordered_map< std::string, Value * > Captures Public Functions inherited from microsoft::quantum::IOperandPrototype Name IOperandPrototype () =default virtual ~IOperandPrototype () void addChild (Child const & child) void captureAs (std::string capture_name) Protected Functions inherited from microsoft::quantum::IOperandPrototype Name bool fail (Value * value, Captures & captures) const Function which should be called whenever a match fails. bool success (Value * value, Captures & captures) const Function which should be called whenever a match is successful. bool matchChildren (Value * value, Captures & captures) const Subroutine to match all children. void copyPropertiesFrom ( IOperandPrototype const & other)","title":"Additional inherited members"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#using-string","text":"using microsoft::quantum::UnnamedInvokePattern::String = std::string;","title":"using String"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#function-unnamedinvokepattern","text":"UnnamedInvokePattern() =default","title":"function UnnamedInvokePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#function-unnamedinvokepattern_1","text":"UnnamedInvokePattern( UnnamedInvokePattern const & other ) Copy construction prohibited.","title":"function UnnamedInvokePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#function-unnamedinvokepattern_2","text":"UnnamedInvokePattern( UnnamedInvokePattern && other ) =default Move construction allowed.","title":"function UnnamedInvokePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#function-unnamedinvokepattern_3","text":"~UnnamedInvokePattern() override Destructor implementation.","title":"function ~UnnamedInvokePattern"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#function-match","text":"virtual bool match( Value * instr, Captures & captures ) const override Matches the callee by name. Reimplements : microsoft::quantum::IOperandPrototype::match","title":"function match"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_unnamed_invoke_pattern/#function-copy","text":"virtual Child copy() const override Creates a copy of itself. Reimplements : microsoft::quantum::IOperandPrototype::copy Updated on 22 November 2021 at 10:28:34 UTC","title":"function copy"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/","text":"microsoft::quantum::ValidationPass Inherits from llvm::PassInfoMixin< ValidationPass > Public Types Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< ILogger > ILoggerPtr Public Functions Name ValidationPass ( ValidationPassConfiguration const & cfg, ILoggerPtr const & logger =nullptr) ValidationPass ( ValidationPass const & ) Copy construction is banned. ValidationPass ( ValidationPass && ) =default We allow move semantics. ~ValidationPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool isRequired () Whether or not this pass is required to run. Public Types Documentation using Instruction using microsoft::quantum::ValidationPass::Instruction = llvm::Instruction; using Value using microsoft::quantum::ValidationPass::Value = llvm::Value; using ILoggerPtr using microsoft::quantum::ValidationPass::ILoggerPtr = std::shared_ptr<ILogger>; Public Functions Documentation function ValidationPass inline explicit ValidationPass( ValidationPassConfiguration const & cfg, ILoggerPtr const & logger =nullptr ) function ValidationPass ValidationPass( ValidationPass const & ) Copy construction is banned. function ValidationPass ValidationPass( ValidationPass && ) =default We allow move semantics. function ~ValidationPass ~ValidationPass() =default Default destruction. function run llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam ) function isRequired static bool isRequired() Whether or not this pass is required to run. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::ValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#microsoftquantumvalidationpass","text":"Inherits from llvm::PassInfoMixin< ValidationPass >","title":"microsoft::quantum::ValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#public-types","text":"Name using llvm::Instruction Instruction using llvm::Value Value using std::shared_ptr< ILogger > ILoggerPtr","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#public-functions","text":"Name ValidationPass ( ValidationPassConfiguration const & cfg, ILoggerPtr const & logger =nullptr) ValidationPass ( ValidationPass const & ) Copy construction is banned. ValidationPass ( ValidationPass && ) =default We allow move semantics. ~ValidationPass () =default Default destruction. llvm::PreservedAnalyses run (llvm::Module & module, llvm::ModuleAnalysisManager & mam) bool isRequired () Whether or not this pass is required to run.","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#using-instruction","text":"using microsoft::quantum::ValidationPass::Instruction = llvm::Instruction;","title":"using Instruction"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#using-value","text":"using microsoft::quantum::ValidationPass::Value = llvm::Value;","title":"using Value"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#using-iloggerptr","text":"using microsoft::quantum::ValidationPass::ILoggerPtr = std::shared_ptr<ILogger>;","title":"using ILoggerPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#function-validationpass","text":"inline explicit ValidationPass( ValidationPassConfiguration const & cfg, ILoggerPtr const & logger =nullptr )","title":"function ValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#function-validationpass_1","text":"ValidationPass( ValidationPass const & ) Copy construction is banned.","title":"function ValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#function-validationpass_2","text":"ValidationPass( ValidationPass && ) =default We allow move semantics.","title":"function ValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#function-validationpass_3","text":"~ValidationPass() =default Default destruction.","title":"function ~ValidationPass"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#function-run","text":"llvm::PreservedAnalyses run( llvm::Module & module, llvm::ModuleAnalysisManager & mam )","title":"function run"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass/#function-isrequired","text":"static bool isRequired() Whether or not this pass is required to run. Updated on 22 November 2021 at 10:28:34 UTC","title":"function isRequired"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/","text":"microsoft::quantum::ValidationPassConfiguration Public Types Name using std::unordered_set< std::string > Set Public Functions Name void setup ( ConfigurationManager & config) Set const & allowedOpcodes () const Set const & allowedExternalCallNames () const bool allowInternalCalls () const bool allowlistOpcodes () const bool allowlistExternalCalls () const String const & saveReportTo () const ValidationPassConfiguration fromProfileName (String const & name) Public Types Documentation using Set using microsoft::quantum::ValidationPassConfiguration::Set = std::unordered_set<std::string>; Public Functions Documentation function setup inline void setup( ConfigurationManager & config ) Setup function that adds the configuration flags to the ConfigurationManager . See the ConfigurationManager documentation for more details on how the setup process is implemented. function allowedOpcodes inline Set const & allowedOpcodes() const function allowedExternalCallNames inline Set const & allowedExternalCallNames() const function allowInternalCalls inline bool allowInternalCalls() const function allowlistOpcodes inline bool allowlistOpcodes() const function allowlistExternalCalls inline bool allowlistExternalCalls() const function saveReportTo inline String const & saveReportTo() const function fromProfileName static inline ValidationPassConfiguration fromProfileName( String const & name ) Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::ValidationPassConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#microsoftquantumvalidationpassconfiguration","text":"","title":"microsoft::quantum::ValidationPassConfiguration"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#public-types","text":"Name using std::unordered_set< std::string > Set","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#public-functions","text":"Name void setup ( ConfigurationManager & config) Set const & allowedOpcodes () const Set const & allowedExternalCallNames () const bool allowInternalCalls () const bool allowlistOpcodes () const bool allowlistExternalCalls () const String const & saveReportTo () const ValidationPassConfiguration fromProfileName (String const & name)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#using-set","text":"using microsoft::quantum::ValidationPassConfiguration::Set = std::unordered_set<std::string>;","title":"using Set"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#function-setup","text":"inline void setup( ConfigurationManager & config ) Setup function that adds the configuration flags to the ConfigurationManager . See the ConfigurationManager documentation for more details on how the setup process is implemented.","title":"function setup"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#function-allowedopcodes","text":"inline Set const & allowedOpcodes() const","title":"function allowedOpcodes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#function-allowedexternalcallnames","text":"inline Set const & allowedExternalCallNames() const","title":"function allowedExternalCallNames"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#function-allowinternalcalls","text":"inline bool allowInternalCalls() const","title":"function allowInternalCalls"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#function-allowlistopcodes","text":"inline bool allowlistOpcodes() const","title":"function allowlistOpcodes"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#function-allowlistexternalcalls","text":"inline bool allowlistExternalCalls() const","title":"function allowlistExternalCalls"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#function-savereportto","text":"inline String const & saveReportTo() const","title":"function saveReportTo"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validation_pass_configuration/#function-fromprofilename","text":"static inline ValidationPassConfiguration fromProfileName( String const & name ) Updated on 22 November 2021 at 10:28:34 UTC","title":"function fromProfileName"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/","text":"microsoft::quantum::Validator More... #include <Validator/Validator.hpp> Public Types Name using std::unique_ptr< Validator > ValidatorPtr using std::shared_ptr< LogCollection > LogColloectionPtr Protected Types Name using std::unique_ptr< llvm::PassBuilder > PassBuilderPtr Public Functions Name Validator ( ValidationPassConfiguration const & cfg, bool debug, llvm::TargetMachine * target_machine =nullptr) Validator () Validator ( Validator const & ) Validator ( Validator && ) =default Validator & operator= ( Validator const & ) Validator & operator= ( Validator && ) =default ~Validator () =default bool validate (llvm::Module & module) Protected Functions Name llvm::PassBuilder & passBuilder () Returns a reference to the pass builder. llvm::LoopAnalysisManager & loopAnalysisManager () Returns a reference to the loop analysis manager. llvm::FunctionAnalysisManager & functionAnalysisManager () Returns a reference to the function analysis manager. llvm::CGSCCAnalysisManager & gsccAnalysisManager () Returns a reference to the GSCC analysis manager. llvm::ModuleAnalysisManager & moduleAnalysisManager () Returns a reference to the module analysis manager. Detailed Description class microsoft::quantum::Validator; Validator class that defines a set of rules which constitutes the profile definition. Each of the rules can be used to transform a generic QIR and/or validate that the QIR is compliant with said rule. Public Types Documentation using ValidatorPtr using microsoft::quantum::Validator::ValidatorPtr = std::unique_ptr<Validator>; using LogColloectionPtr using microsoft::quantum::Validator::LogColloectionPtr = std::shared_ptr<LogCollection>; Protected Types Documentation using PassBuilderPtr using microsoft::quantum::Validator::PassBuilderPtr = std::unique_ptr<llvm::PassBuilder>; Public Functions Documentation function Validator explicit Validator( ValidationPassConfiguration const & cfg, bool debug, llvm::TargetMachine * target_machine =nullptr ) function Validator Validator() function Validator Validator( Validator const & ) function Validator Validator( Validator && ) =default function operator= Validator & operator=( Validator const & ) function operator= Validator & operator=( Validator && ) =default function ~Validator ~Validator() =default function validate bool validate( llvm::Module & module ) Validates that a module complies with the specified QIR profile. Returns true if the module is valid and false otherwise. Protected Functions Documentation function passBuilder llvm::PassBuilder & passBuilder() Returns a reference to the pass builder. function loopAnalysisManager llvm::LoopAnalysisManager & loopAnalysisManager() Returns a reference to the loop analysis manager. function functionAnalysisManager llvm::FunctionAnalysisManager & functionAnalysisManager() Returns a reference to the function analysis manager. function gsccAnalysisManager llvm::CGSCCAnalysisManager & gsccAnalysisManager() Returns a reference to the GSCC analysis manager. function moduleAnalysisManager llvm::ModuleAnalysisManager & moduleAnalysisManager() Returns a reference to the module analysis manager. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::Validator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#microsoftquantumvalidator","text":"More... #include <Validator/Validator.hpp>","title":"microsoft::quantum::Validator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#public-types","text":"Name using std::unique_ptr< Validator > ValidatorPtr using std::shared_ptr< LogCollection > LogColloectionPtr","title":"Public Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#protected-types","text":"Name using std::unique_ptr< llvm::PassBuilder > PassBuilderPtr","title":"Protected Types"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#public-functions","text":"Name Validator ( ValidationPassConfiguration const & cfg, bool debug, llvm::TargetMachine * target_machine =nullptr) Validator () Validator ( Validator const & ) Validator ( Validator && ) =default Validator & operator= ( Validator const & ) Validator & operator= ( Validator && ) =default ~Validator () =default bool validate (llvm::Module & module)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#protected-functions","text":"Name llvm::PassBuilder & passBuilder () Returns a reference to the pass builder. llvm::LoopAnalysisManager & loopAnalysisManager () Returns a reference to the loop analysis manager. llvm::FunctionAnalysisManager & functionAnalysisManager () Returns a reference to the function analysis manager. llvm::CGSCCAnalysisManager & gsccAnalysisManager () Returns a reference to the GSCC analysis manager. llvm::ModuleAnalysisManager & moduleAnalysisManager () Returns a reference to the module analysis manager.","title":"Protected Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#detailed-description","text":"class microsoft::quantum::Validator; Validator class that defines a set of rules which constitutes the profile definition. Each of the rules can be used to transform a generic QIR and/or validate that the QIR is compliant with said rule.","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#using-validatorptr","text":"using microsoft::quantum::Validator::ValidatorPtr = std::unique_ptr<Validator>;","title":"using ValidatorPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#using-logcolloectionptr","text":"using microsoft::quantum::Validator::LogColloectionPtr = std::shared_ptr<LogCollection>;","title":"using LogColloectionPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#protected-types-documentation","text":"","title":"Protected Types Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#using-passbuilderptr","text":"using microsoft::quantum::Validator::PassBuilderPtr = std::unique_ptr<llvm::PassBuilder>;","title":"using PassBuilderPtr"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-validator","text":"explicit Validator( ValidationPassConfiguration const & cfg, bool debug, llvm::TargetMachine * target_machine =nullptr )","title":"function Validator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-validator_1","text":"Validator()","title":"function Validator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-validator_2","text":"Validator( Validator const & )","title":"function Validator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-validator_3","text":"Validator( Validator && ) =default","title":"function Validator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-operator","text":"Validator & operator=( Validator const & )","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-operator_1","text":"Validator & operator=( Validator && ) =default","title":"function operator="},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-validator_4","text":"~Validator() =default","title":"function ~Validator"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-validate","text":"bool validate( llvm::Module & module ) Validates that a module complies with the specified QIR profile. Returns true if the module is valid and false otherwise.","title":"function validate"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-passbuilder","text":"llvm::PassBuilder & passBuilder() Returns a reference to the pass builder.","title":"function passBuilder"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-loopanalysismanager","text":"llvm::LoopAnalysisManager & loopAnalysisManager() Returns a reference to the loop analysis manager.","title":"function loopAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-functionanalysismanager","text":"llvm::FunctionAnalysisManager & functionAnalysisManager() Returns a reference to the function analysis manager.","title":"function functionAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-gsccanalysismanager","text":"llvm::CGSCCAnalysisManager & gsccAnalysisManager() Returns a reference to the GSCC analysis manager.","title":"function gsccAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1_validator/#function-moduleanalysismanager","text":"llvm::ModuleAnalysisManager & moduleAnalysisManager() Returns a reference to the module analysis manager. Updated on 22 November 2021 at 10:28:34 UTC","title":"function moduleAnalysisManager"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture/","text":"microsoft::quantum::notation::Capture More... #include <Rules/Notation/Notation.hpp> Public Functions Name Capture (std::string const & name) Explicit creation using string name constructor. IOperandPrototypePtr operator= (IOperandPrototypePtr const & other) Detailed Description class microsoft::quantum::notation::Capture; Helper class to enable literals for IR patterns. The main purpose of this class is to enable notation that allows one write \"name\"_cap = operandGenerator() where the operand generator is a function which creates a IOperandPrototypePtr. This notation means that whenever a operand is matched, the matched value is stored under \"name\". Public Functions Documentation function Capture explicit Capture( std::string const & name ) Explicit creation using string name constructor. function operator= IOperandPrototypePtr operator=( IOperandPrototypePtr const & other ) Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::notation::Capture"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture/#microsoftquantumnotationcapture","text":"More... #include <Rules/Notation/Notation.hpp>","title":"microsoft::quantum::notation::Capture"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture/#public-functions","text":"Name Capture (std::string const & name) Explicit creation using string name constructor. IOperandPrototypePtr operator= (IOperandPrototypePtr const & other)","title":"Public Functions"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture/#detailed-description","text":"class microsoft::quantum::notation::Capture; Helper class to enable literals for IR patterns. The main purpose of this class is to enable notation that allows one write \"name\"_cap = operandGenerator() where the operand generator is a function which creates a IOperandPrototypePtr. This notation means that whenever a operand is matched, the matched value is stored under \"name\".","title":"Detailed Description"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture/#function-capture","text":"explicit Capture( std::string const & name ) Explicit creation using string name constructor.","title":"function Capture"},{"location":"Api/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture/#function-operator","text":"IOperandPrototypePtr operator=( IOperandPrototypePtr const & other ) Updated on 22 November 2021 at 10:28:34 UTC","title":"function operator="},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/","text":"microsoft::quantum::BasicAllocationManager::AllocatedMemoryBlock More... #include <AllocationManager/AllocationManager.hpp> Public Attributes Name String name Name of the segment, if any given. Index count Number of elements contained within memory address segment. Address start Start address of memory address segment. Address end End address (not included in memory address segment) Detailed Description struct microsoft::quantum::BasicAllocationManager::AllocatedMemoryBlock; Defines a named register/memory address segment with start position, end position and count. We think of the address space as a continuous sequence of spaces that can store values and we refer to a bounded continuous sequence memory addresses as a segment (or memory address segment): start end \u2502 \u2502 \u25bc \u25bc \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u250c \u2500 \u2500 \u252c \u2500 \u2500 \u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u253c \u2500 \u2500 \u252c \u2500 \u2500 \u2510 0 1 \u2502 2 \u2502 3 \u2502... \u2502 N+1 \u2502 N+2 N+3 \u2514 \u2500 \u2500 \u2534 \u2500 \u2500 \u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2534 \u2500 \u2500 \u2534 \u2500 \u2500 \u2518 Address \u2502 space \u2502 Memory address segment of N elements \u2502 \u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 Public Attributes Documentation variable name String name {\"\"}; Name of the segment, if any given. variable count Index count {0}; Number of elements contained within memory address segment. variable start Address start {0}; Start address of memory address segment. variable end Address end {0}; End address (not included in memory address segment) Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::BasicAllocationManager::AllocatedMemoryBlock"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#microsoftquantumbasicallocationmanagerallocatedmemoryblock","text":"More... #include <AllocationManager/AllocationManager.hpp>","title":"microsoft::quantum::BasicAllocationManager::AllocatedMemoryBlock"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#public-attributes","text":"Name String name Name of the segment, if any given. Index count Number of elements contained within memory address segment. Address start Start address of memory address segment. Address end End address (not included in memory address segment)","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#detailed-description","text":"struct microsoft::quantum::BasicAllocationManager::AllocatedMemoryBlock; Defines a named register/memory address segment with start position, end position and count. We think of the address space as a continuous sequence of spaces that can store values and we refer to a bounded continuous sequence memory addresses as a segment (or memory address segment): start end \u2502 \u2502 \u25bc \u25bc \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u250c \u2500 \u2500 \u252c \u2500 \u2500 \u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u253c \u2500 \u2500 \u252c \u2500 \u2500 \u2510 0 1 \u2502 2 \u2502 3 \u2502... \u2502 N+1 \u2502 N+2 N+3 \u2514 \u2500 \u2500 \u2534 \u2500 \u2500 \u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2534 \u2500 \u2500 \u2534 \u2500 \u2500 \u2518 Address \u2502 space \u2502 Memory address segment of N elements \u2502 \u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500","title":"Detailed Description"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#variable-name","text":"String name {\"\"}; Name of the segment, if any given.","title":"variable name"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#variable-count","text":"Index count {0}; Number of elements contained within memory address segment.","title":"variable count"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#variable-start","text":"Address start {0}; Start address of memory address segment.","title":"variable start"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_basic_allocation_manager_1_1_allocated_memory_block/#variable-end","text":"Address end {0}; End address (not included in memory address segment) Updated on 22 November 2021 at 10:28:34 UTC","title":"variable end"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/","text":"microsoft::quantum::ConfigurationManager::Section More... #include <Commandline/ConfigurationManager.hpp> Public Attributes Name TypeId type Type of the configuration. String name Name of the section. String description Description of the section. VoidPtr configuration Configuration class instance. ConfigList settings List of parameter bindings. BoolPtr active Whether or not this component is active;. String id Id referring to this component. Detailed Description struct microsoft::quantum::ConfigurationManager::Section; Section defines a section in the configuration. It holds the type of the configuration class, the name of the section a description, the instance of the configuration class itself and list of parameter bindings. Public Attributes Documentation variable type TypeId type {[TypeId](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-typeid)(typeid(std::nullptr_t))}; Type of the configuration. variable name String name {}; Name of the section. variable description String description {}; Description of the section. variable configuration VoidPtr configuration {}; Configuration class instance. variable settings ConfigList settings {}; List of parameter bindings. variable active BoolPtr active {nullptr}; Whether or not this component is active;. variable id String id {}; Id referring to this component. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::ConfigurationManager::Section"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#microsoftquantumconfigurationmanagersection","text":"More... #include <Commandline/ConfigurationManager.hpp>","title":"microsoft::quantum::ConfigurationManager::Section"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#public-attributes","text":"Name TypeId type Type of the configuration. String name Name of the section. String description Description of the section. VoidPtr configuration Configuration class instance. ConfigList settings List of parameter bindings. BoolPtr active Whether or not this component is active;. String id Id referring to this component.","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#detailed-description","text":"struct microsoft::quantum::ConfigurationManager::Section; Section defines a section in the configuration. It holds the type of the configuration class, the name of the section a description, the instance of the configuration class itself and list of parameter bindings.","title":"Detailed Description"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-type","text":"TypeId type {[TypeId](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_configuration_manager/#using-typeid)(typeid(std::nullptr_t))}; Type of the configuration.","title":"variable type"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-name","text":"String name {}; Name of the section.","title":"variable name"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-description","text":"String description {}; Description of the section.","title":"variable description"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-configuration","text":"VoidPtr configuration {}; Configuration class instance.","title":"variable configuration"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-settings","text":"ConfigList settings {}; List of parameter bindings.","title":"variable settings"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-active","text":"BoolPtr active {nullptr}; Whether or not this component is active;.","title":"variable active"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_configuration_manager_1_1_section/#variable-id","text":"String id {}; Id referring to this component. Updated on 22 November 2021 at 10:28:34 UTC","title":"variable id"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_location/","text":"microsoft::quantum::LogCollection::Location Class that holds the location of where the incident happened. #include <Logging/LogCollection.hpp> Public Attributes Name String name uint64_t row uint64_t col Public Attributes Documentation variable name String name {}; variable row uint64_t row {0}; variable col uint64_t col {0}; Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::LogCollection::Location"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_location/#microsoftquantumlogcollectionlocation","text":"Class that holds the location of where the incident happened. #include <Logging/LogCollection.hpp>","title":"microsoft::quantum::LogCollection::Location"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_location/#public-attributes","text":"Name String name uint64_t row uint64_t col","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_location/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_location/#variable-name","text":"String name {};","title":"variable name"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_location/#variable-row","text":"uint64_t row {0};","title":"variable row"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_location/#variable-col","text":"uint64_t col {0}; Updated on 22 November 2021 at 10:28:34 UTC","title":"variable col"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_message/","text":"microsoft::quantum::LogCollection::Message Struct to hold a message together with its type and location. #include <Logging/LogCollection.hpp> Public Attributes Name Type type Location location String message Public Attributes Documentation variable type Type type; variable location Location location; variable message String message; Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::LogCollection::Message"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_message/#microsoftquantumlogcollectionmessage","text":"Struct to hold a message together with its type and location. #include <Logging/LogCollection.hpp>","title":"microsoft::quantum::LogCollection::Message"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_message/#public-attributes","text":"Name Type type Location location String message","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_message/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_message/#variable-type","text":"Type type;","title":"variable type"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_message/#variable-location","text":"Location location;","title":"variable location"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_log_collection_1_1_message/#variable-message","text":"String message; Updated on 22 November 2021 at 10:28:34 UTC","title":"variable message"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_parameter_parser_1_1_parsed_value/","text":"microsoft::quantum::ParameterParser::ParsedValue Struct that contains parsed and interpreted values of command line arguments. Public Attributes Name bool is_key Whether or not a parsed value should be considered a key. String value Value after parsing. Public Attributes Documentation variable is_key bool is_key {false}; Whether or not a parsed value should be considered a key. variable value String value; Value after parsing. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::ParameterParser::ParsedValue"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_parameter_parser_1_1_parsed_value/#microsoftquantumparameterparserparsedvalue","text":"Struct that contains parsed and interpreted values of command line arguments.","title":"microsoft::quantum::ParameterParser::ParsedValue"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_parameter_parser_1_1_parsed_value/#public-attributes","text":"Name bool is_key Whether or not a parsed value should be considered a key. String value Value after parsing.","title":"Public Attributes"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_parameter_parser_1_1_parsed_value/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_parameter_parser_1_1_parsed_value/#variable-is_key","text":"bool is_key {false}; Whether or not a parsed value should be considered a key.","title":"variable is_key"},{"location":"Api/Classes/structmicrosoft_1_1quantum_1_1_parameter_parser_1_1_parsed_value/#variable-value","text":"String value; Value after parsing. Updated on 22 November 2021 at 10:28:34 UTC","title":"variable value"},{"location":"Api/Examples/","text":"Examples Updated on 22 November 2021 at 10:28:35 UTC","title":"Examples"},{"location":"Api/Examples/#examples","text":"Updated on 22 November 2021 at 10:28:35 UTC","title":"Examples"},{"location":"Api/Files/","text":"Files dir AllocationManager file AllocationManager/AllocationManager.cpp file AllocationManager/AllocationManager.hpp dir AllocationManager/Tests dir AllocationManager/Tests/Unit file AllocationManager/Tests/Unit/main.cpp file AllocationManager/IAllocationManager.cpp file AllocationManager/IAllocationManager.hpp dir Apps dir Apps/Qat file Apps/Qat/Qat.cpp file Apps/Qat/QatConfig.cpp file Apps/Qat/QatConfig.hpp dir Commandline dir Commandline/Tests dir Commandline/Tests/Unit file Commandline/Tests/Unit/configuration.cpp file Commandline/ConfigBind.hpp file Commandline/ConfigurationManager.cpp file Commandline/ConfigurationManager.hpp file Commandline/IConfigBind.cpp file Commandline/IConfigBind.hpp file Commandline/ParameterParser.cpp file Commandline/ParameterParser.hpp dir Generators file Generators/DefaultProfileGenerator.cpp file Generators/DefaultProfileGenerator.hpp dir Generators/Tests dir Generators/Tests/Unit file Generators/Tests/Unit/main.cpp file Generators/LlvmPassesConfiguration.cpp file Generators/LlvmPassesConfiguration.hpp file Generators/ProfileGenerator.cpp file Generators/ProfileGenerator.hpp dir Llvm file Llvm/Llvm.hpp dir Logging file Logging/CommentLogger.cpp file Logging/CommentLogger.hpp file Logging/ILogger.cpp file Logging/ILogger.hpp file Logging/LogCollection.cpp file Logging/LogCollection.hpp dir ModuleLoader file ModuleLoader/ModuleLoader.hpp dir Profile file Profile/Profile.cpp file Profile/Profile.hpp dir QatTypes file QatTypes/QatTypes.hpp dir RemoveDisallowedAttributesPass file RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp dir Rules file Rules/Factory.cpp file Rules/Factory.hpp file Rules/FactoryConfig.hpp file Rules/IOperandPrototype.cpp file Rules/IOperandPrototype.hpp file Rules/ReplacementRule.cpp file Rules/ReplacementRule.hpp file Rules/RuleSet.cpp file Rules/RuleSet.hpp dir Rules/Notation file Rules/Notation/BasicBlock.cpp file Rules/Notation/BitCast.cpp file Rules/Notation/Branch.cpp file Rules/Notation/Call.hpp file Rules/Notation/Call.ipp file Rules/Notation/CallByNameOnly.cpp file Rules/Notation/Capture.cpp file Rules/Notation/ConstInt.cpp file Rules/Notation/IntToPtr.cpp file Rules/Notation/Load.cpp file Rules/Notation/Notation.cpp file Rules/Notation/Notation.hpp file Rules/Notation/Phi.ipp file Rules/Notation/Select.cpp file Rules/Notation/Store.cpp file Rules/Notation/Switch.cpp file Rules/Notation/UnnamedInvoke.cpp dir Rules/Patterns file Rules/Patterns/AnyPattern.cpp file Rules/Patterns/AnyPattern.hpp file Rules/Patterns/CallPattern.cpp file Rules/Patterns/CallPattern.hpp file Rules/Patterns/Instruction.cpp file Rules/Patterns/Instruction.hpp file Rules/Patterns/PhiPattern.cpp file Rules/Patterns/PhiPattern.hpp file Rules/Patterns/UnnamedInvokePattern.cpp file Rules/Patterns/UnnamedInvokePattern.hpp dir Rules/Tests dir Rules/Tests/Unit file Rules/Tests/Unit/BasicRuleSetOps.cpp file Rules/Tests/Unit/BranchOnOne.cpp file Rules/Tests/Unit/BranchOnZero.cpp file Rules/Tests/Unit/DisableAliasCounting.cpp file Rules/Tests/Unit/DisableReferenceCounting.cpp file Rules/Tests/Unit/DisableStrings.cpp file Rules/Tests/Unit/FactoryConfiguration.cpp file Rules/Tests/Unit/RemoveFunctionCall.cpp file Rules/Tests/Unit/SelectOnOne.cpp file Rules/Tests/Unit/SingleQubitAllocation.cpp file Rules/Tests/Unit/StaticQubitArrayAllocation.cpp file Rules/Tests/Unit/StaticResultAllocation.cpp dir TestTools file TestTools/IrManipulationTestHelper.cpp file TestTools/IrManipulationTestHelper.hpp dir TestTools/Tests dir TestTools/Tests/Unit file TestTools/Tests/Unit/main.cpp dir TransformationRulesPass file TransformationRulesPass/TransformationRulesPass.cpp file TransformationRulesPass/TransformationRulesPass.hpp dir TransformationRulesPass/Tests dir TransformationRulesPass/Tests/Unit file TransformationRulesPass/Tests/Unit/LoopUnrolling.cpp file TransformationRulesPass/Tests/Unit/MiniTeleChain.cpp file TransformationRulesPass/Tests/Unit/PhiElimination.cpp file TransformationRulesPass/TransformationRulesPassConfiguration.cpp file TransformationRulesPass/TransformationRulesPassConfiguration.hpp dir ValidationPass file ValidationPass/ValidationPass.cpp file ValidationPass/ValidationPass.hpp file ValidationPass/ValidationPassConfiguration.hpp dir Validator file Validator/Validator.cpp file Validator/Validator.hpp Updated on 22 November 2021 at 10:28:35 UTC","title":"Files"},{"location":"Api/Files/#files","text":"dir AllocationManager file AllocationManager/AllocationManager.cpp file AllocationManager/AllocationManager.hpp dir AllocationManager/Tests dir AllocationManager/Tests/Unit file AllocationManager/Tests/Unit/main.cpp file AllocationManager/IAllocationManager.cpp file AllocationManager/IAllocationManager.hpp dir Apps dir Apps/Qat file Apps/Qat/Qat.cpp file Apps/Qat/QatConfig.cpp file Apps/Qat/QatConfig.hpp dir Commandline dir Commandline/Tests dir Commandline/Tests/Unit file Commandline/Tests/Unit/configuration.cpp file Commandline/ConfigBind.hpp file Commandline/ConfigurationManager.cpp file Commandline/ConfigurationManager.hpp file Commandline/IConfigBind.cpp file Commandline/IConfigBind.hpp file Commandline/ParameterParser.cpp file Commandline/ParameterParser.hpp dir Generators file Generators/DefaultProfileGenerator.cpp file Generators/DefaultProfileGenerator.hpp dir Generators/Tests dir Generators/Tests/Unit file Generators/Tests/Unit/main.cpp file Generators/LlvmPassesConfiguration.cpp file Generators/LlvmPassesConfiguration.hpp file Generators/ProfileGenerator.cpp file Generators/ProfileGenerator.hpp dir Llvm file Llvm/Llvm.hpp dir Logging file Logging/CommentLogger.cpp file Logging/CommentLogger.hpp file Logging/ILogger.cpp file Logging/ILogger.hpp file Logging/LogCollection.cpp file Logging/LogCollection.hpp dir ModuleLoader file ModuleLoader/ModuleLoader.hpp dir Profile file Profile/Profile.cpp file Profile/Profile.hpp dir QatTypes file QatTypes/QatTypes.hpp dir RemoveDisallowedAttributesPass file RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp dir Rules file Rules/Factory.cpp file Rules/Factory.hpp file Rules/FactoryConfig.hpp file Rules/IOperandPrototype.cpp file Rules/IOperandPrototype.hpp file Rules/ReplacementRule.cpp file Rules/ReplacementRule.hpp file Rules/RuleSet.cpp file Rules/RuleSet.hpp dir Rules/Notation file Rules/Notation/BasicBlock.cpp file Rules/Notation/BitCast.cpp file Rules/Notation/Branch.cpp file Rules/Notation/Call.hpp file Rules/Notation/Call.ipp file Rules/Notation/CallByNameOnly.cpp file Rules/Notation/Capture.cpp file Rules/Notation/ConstInt.cpp file Rules/Notation/IntToPtr.cpp file Rules/Notation/Load.cpp file Rules/Notation/Notation.cpp file Rules/Notation/Notation.hpp file Rules/Notation/Phi.ipp file Rules/Notation/Select.cpp file Rules/Notation/Store.cpp file Rules/Notation/Switch.cpp file Rules/Notation/UnnamedInvoke.cpp dir Rules/Patterns file Rules/Patterns/AnyPattern.cpp file Rules/Patterns/AnyPattern.hpp file Rules/Patterns/CallPattern.cpp file Rules/Patterns/CallPattern.hpp file Rules/Patterns/Instruction.cpp file Rules/Patterns/Instruction.hpp file Rules/Patterns/PhiPattern.cpp file Rules/Patterns/PhiPattern.hpp file Rules/Patterns/UnnamedInvokePattern.cpp file Rules/Patterns/UnnamedInvokePattern.hpp dir Rules/Tests dir Rules/Tests/Unit file Rules/Tests/Unit/BasicRuleSetOps.cpp file Rules/Tests/Unit/BranchOnOne.cpp file Rules/Tests/Unit/BranchOnZero.cpp file Rules/Tests/Unit/DisableAliasCounting.cpp file Rules/Tests/Unit/DisableReferenceCounting.cpp file Rules/Tests/Unit/DisableStrings.cpp file Rules/Tests/Unit/FactoryConfiguration.cpp file Rules/Tests/Unit/RemoveFunctionCall.cpp file Rules/Tests/Unit/SelectOnOne.cpp file Rules/Tests/Unit/SingleQubitAllocation.cpp file Rules/Tests/Unit/StaticQubitArrayAllocation.cpp file Rules/Tests/Unit/StaticResultAllocation.cpp dir TestTools file TestTools/IrManipulationTestHelper.cpp file TestTools/IrManipulationTestHelper.hpp dir TestTools/Tests dir TestTools/Tests/Unit file TestTools/Tests/Unit/main.cpp dir TransformationRulesPass file TransformationRulesPass/TransformationRulesPass.cpp file TransformationRulesPass/TransformationRulesPass.hpp dir TransformationRulesPass/Tests dir TransformationRulesPass/Tests/Unit file TransformationRulesPass/Tests/Unit/LoopUnrolling.cpp file TransformationRulesPass/Tests/Unit/MiniTeleChain.cpp file TransformationRulesPass/Tests/Unit/PhiElimination.cpp file TransformationRulesPass/TransformationRulesPassConfiguration.cpp file TransformationRulesPass/TransformationRulesPassConfiguration.hpp dir ValidationPass file ValidationPass/ValidationPass.cpp file ValidationPass/ValidationPass.hpp file ValidationPass/ValidationPassConfiguration.hpp dir Validator file Validator/Validator.cpp file Validator/Validator.hpp Updated on 22 November 2021 at 10:28:35 UTC","title":"Files"},{"location":"Api/Files/_allocation_manager_2_tests_2_unit_2main_8cpp/","text":"AllocationManager/Tests/Unit/main.cpp Functions Name TEST (AllocationManagerTestSuite , LinearAllocationTestReuse ) TEST (AllocationManagerTestSuite , LinearAllocationTestNoReuse ) TEST (AllocationManagerTestSuite , InvalidRelease ) Functions Documentation function TEST TEST( AllocationManagerTestSuite , LinearAllocationTestReuse ) function TEST TEST( AllocationManagerTestSuite , LinearAllocationTestNoReuse ) function TEST TEST( AllocationManagerTestSuite , InvalidRelease ) Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/AllocationManager.hpp\" #include \"gtest/gtest.h\" TEST(AllocationManagerTestSuite, LinearAllocationTestReuse) { auto manager = microsoft::quantum::BasicAllocationManager::createNew(); manager->setReuseRegisters(true); // Expecting ids to be allocated linearly for single // allocations auto q1 = manager->allocate(); EXPECT_EQ(q1, 0); auto q2 = manager->allocate(); EXPECT_EQ(q2, 1); auto q3 = manager->allocate(); EXPECT_EQ(q3, 2); auto q4 = manager->allocate(); EXPECT_EQ(q4, 3); auto q5 = manager->allocate(); EXPECT_EQ(q5, 4); // We expect that allocating auto arr1 = manager->allocate(\"test\", 10); EXPECT_EQ(arr1, 5); auto arr2 = manager->allocate(\"test2\", 10); EXPECT_EQ(arr2, 15); // Testing reusing manager->release(arr2); arr2 = manager->allocate(\"test2\", 10); EXPECT_EQ(arr2, 15); manager->release(arr2); manager->release(q1); manager->release(q2); manager->release(q3); manager->release(q4); manager->release(q5); arr2 = manager->allocate(\"test2\", 10); EXPECT_EQ(arr2, 15); manager->release(arr1); manager->release(arr2); arr2 = manager->allocate(\"test2\", 10); EXPECT_EQ(arr2, 0); } TEST(AllocationManagerTestSuite, LinearAllocationTestNoReuse) { auto manager = microsoft::quantum::BasicAllocationManager::createNew(); manager->setReuseRegisters(false); auto q1 = manager->allocate(); EXPECT_EQ(q1, 0); auto q2 = manager->allocate(); EXPECT_EQ(q2, 1); auto q3 = manager->allocate(); EXPECT_EQ(q3, 2); auto q4 = manager->allocate(); EXPECT_EQ(q4, 3); auto q5 = manager->allocate(); EXPECT_EQ(q5, 4); // We expect that allocating auto arr1 = manager->allocate(\"test\", 10); EXPECT_EQ(arr1, 5); auto arr2 = manager->allocate(\"test2\", 10); EXPECT_EQ(arr2, 15); // Testing reusing manager->release(arr2); arr2 = manager->allocate(\"test2\", 10); EXPECT_EQ(arr2, 25); manager->release(arr2); manager->release(q1); manager->release(q2); manager->release(q3); manager->release(q4); manager->release(q5); arr2 = manager->allocate(\"test2\", 10); EXPECT_EQ(arr2, 35); manager->release(arr1); manager->release(arr2); arr2 = manager->allocate(\"test2\", 10); EXPECT_EQ(arr2, 45); } TEST(AllocationManagerTestSuite, InvalidRelease) { auto manager = microsoft::quantum::BasicAllocationManager::createNew(); auto q1 = manager->allocate(); EXPECT_EQ(q1, 0); auto q2 = manager->allocate(); EXPECT_EQ(q2, 1); EXPECT_THROW(manager->release(28837), std::runtime_error); } Updated on 22 November 2021 at 10:28:35 UTC","title":"AllocationManager/Tests/Unit/main.cpp"},{"location":"Api/Files/_allocation_manager_2_tests_2_unit_2main_8cpp/#allocationmanagertestsunitmaincpp","text":"","title":"AllocationManager/Tests/Unit/main.cpp"},{"location":"Api/Files/_allocation_manager_2_tests_2_unit_2main_8cpp/#functions","text":"Name TEST (AllocationManagerTestSuite , LinearAllocationTestReuse ) TEST (AllocationManagerTestSuite , LinearAllocationTestNoReuse ) TEST (AllocationManagerTestSuite , InvalidRelease )","title":"Functions"},{"location":"Api/Files/_allocation_manager_2_tests_2_unit_2main_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Files/_allocation_manager_2_tests_2_unit_2main_8cpp/#function-test","text":"TEST( AllocationManagerTestSuite , LinearAllocationTestReuse )","title":"function TEST"},{"location":"Api/Files/_allocation_manager_2_tests_2_unit_2main_8cpp/#function-test_1","text":"TEST( AllocationManagerTestSuite , LinearAllocationTestNoReuse )","title":"function TEST"},{"location":"Api/Files/_allocation_manager_2_tests_2_unit_2main_8cpp/#function-test_2","text":"TEST( AllocationManagerTestSuite , InvalidRelease )","title":"function TEST"},{"location":"Api/Files/_allocation_manager_2_tests_2_unit_2main_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/AllocationManager.hpp\" #include \"gtest/gtest.h\" TEST(AllocationManagerTestSuite, LinearAllocationTestReuse) { auto manager = microsoft::quantum::BasicAllocationManager::createNew(); manager->setReuseRegisters(true); // Expecting ids to be allocated linearly for single // allocations auto q1 = manager->allocate(); EXPECT_EQ(q1, 0); auto q2 = manager->allocate(); EXPECT_EQ(q2, 1); auto q3 = manager->allocate(); EXPECT_EQ(q3, 2); auto q4 = manager->allocate(); EXPECT_EQ(q4, 3); auto q5 = manager->allocate(); EXPECT_EQ(q5, 4); // We expect that allocating auto arr1 = manager->allocate(\"test\", 10); EXPECT_EQ(arr1, 5); auto arr2 = manager->allocate(\"test2\", 10); EXPECT_EQ(arr2, 15); // Testing reusing manager->release(arr2); arr2 = manager->allocate(\"test2\", 10); EXPECT_EQ(arr2, 15); manager->release(arr2); manager->release(q1); manager->release(q2); manager->release(q3); manager->release(q4); manager->release(q5); arr2 = manager->allocate(\"test2\", 10); EXPECT_EQ(arr2, 15); manager->release(arr1); manager->release(arr2); arr2 = manager->allocate(\"test2\", 10); EXPECT_EQ(arr2, 0); } TEST(AllocationManagerTestSuite, LinearAllocationTestNoReuse) { auto manager = microsoft::quantum::BasicAllocationManager::createNew(); manager->setReuseRegisters(false); auto q1 = manager->allocate(); EXPECT_EQ(q1, 0); auto q2 = manager->allocate(); EXPECT_EQ(q2, 1); auto q3 = manager->allocate(); EXPECT_EQ(q3, 2); auto q4 = manager->allocate(); EXPECT_EQ(q4, 3); auto q5 = manager->allocate(); EXPECT_EQ(q5, 4); // We expect that allocating auto arr1 = manager->allocate(\"test\", 10); EXPECT_EQ(arr1, 5); auto arr2 = manager->allocate(\"test2\", 10); EXPECT_EQ(arr2, 15); // Testing reusing manager->release(arr2); arr2 = manager->allocate(\"test2\", 10); EXPECT_EQ(arr2, 25); manager->release(arr2); manager->release(q1); manager->release(q2); manager->release(q3); manager->release(q4); manager->release(q5); arr2 = manager->allocate(\"test2\", 10); EXPECT_EQ(arr2, 35); manager->release(arr1); manager->release(arr2); arr2 = manager->allocate(\"test2\", 10); EXPECT_EQ(arr2, 45); } TEST(AllocationManagerTestSuite, InvalidRelease) { auto manager = microsoft::quantum::BasicAllocationManager::createNew(); auto q1 = manager->allocate(); EXPECT_EQ(q1, 0); auto q2 = manager->allocate(); EXPECT_EQ(q2, 1); EXPECT_THROW(manager->release(28837), std::runtime_error); } Updated on 22 November 2021 at 10:28:35 UTC","title":"Source code"},{"location":"Api/Files/_allocation_manager_8cpp/","text":"AllocationManager/AllocationManager.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/AllocationManager.hpp\" #include <memory> #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { BasicAllocationManager::BasicAllocationManagerPtr BasicAllocationManager::createNew() { BasicAllocationManagerPtr ret; ret.reset(new BasicAllocationManager()); return ret; } BasicAllocationManager::Index BasicAllocationManager::allocate(String const& name, Index const& count) { auto ret = next_qubit_index_; // Creating a memory segment mapping in case we are dealing with qubits AllocatedMemoryBlock map; map.name = name; map.count = count; map.start = next_qubit_index_; // Advancing start next_qubit_index_ += count; map.end = map.start + count; mappings_.emplace_back(std::move(map)); // Advancing the allocation index ++allocation_index_; updateRegistersInUse(allocationsInUse() + count); return ret; } void BasicAllocationManager::release(Address const& address) { --allocation_index_; auto it = mappings_.begin(); // Finding the element. Note that we could implement binary // search but assume that we are dealing with few allocations while (it != mappings_.end() && it->start != address) { ++it; } if (it == mappings_.end()) { throw std::runtime_error(\"Qubit segment not found.\"); } if (!reuse_qubits_) { mappings_.erase(it); } else { if (it->count > allocationsInUse()) { throw std::runtime_error(\"Attempting to release more qubits than what is currently allocated.\"); } // In case we are reusing registers, we update how many we are currently using updateRegistersInUse(allocationsInUse() - it->count); mappings_.erase(it); // Updating the next qubit index with naive algorithm that guarantees // 1. Continuous allocation // 2. No overlap in address if (mappings_.empty()) { next_qubit_index_ = 0; } else { auto& b = mappings_.back(); next_qubit_index_ = b.end; } } } void BasicAllocationManager::setReuseRegisters(bool val) { reuse_qubits_ = val; } void BasicAllocationManager::reset() { updateRegistersInUse(0); mappings_.clear(); allocation_index_ = 0; next_qubit_index_ = 0; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:35 UTC","title":"AllocationManager/AllocationManager.cpp"},{"location":"Api/Files/_allocation_manager_8cpp/#allocationmanagerallocationmanagercpp","text":"","title":"AllocationManager/AllocationManager.cpp"},{"location":"Api/Files/_allocation_manager_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_allocation_manager_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/AllocationManager.hpp\" #include <memory> #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { BasicAllocationManager::BasicAllocationManagerPtr BasicAllocationManager::createNew() { BasicAllocationManagerPtr ret; ret.reset(new BasicAllocationManager()); return ret; } BasicAllocationManager::Index BasicAllocationManager::allocate(String const& name, Index const& count) { auto ret = next_qubit_index_; // Creating a memory segment mapping in case we are dealing with qubits AllocatedMemoryBlock map; map.name = name; map.count = count; map.start = next_qubit_index_; // Advancing start next_qubit_index_ += count; map.end = map.start + count; mappings_.emplace_back(std::move(map)); // Advancing the allocation index ++allocation_index_; updateRegistersInUse(allocationsInUse() + count); return ret; } void BasicAllocationManager::release(Address const& address) { --allocation_index_; auto it = mappings_.begin(); // Finding the element. Note that we could implement binary // search but assume that we are dealing with few allocations while (it != mappings_.end() && it->start != address) { ++it; } if (it == mappings_.end()) { throw std::runtime_error(\"Qubit segment not found.\"); } if (!reuse_qubits_) { mappings_.erase(it); } else { if (it->count > allocationsInUse()) { throw std::runtime_error(\"Attempting to release more qubits than what is currently allocated.\"); } // In case we are reusing registers, we update how many we are currently using updateRegistersInUse(allocationsInUse() - it->count); mappings_.erase(it); // Updating the next qubit index with naive algorithm that guarantees // 1. Continuous allocation // 2. No overlap in address if (mappings_.empty()) { next_qubit_index_ = 0; } else { auto& b = mappings_.back(); next_qubit_index_ = b.end; } } } void BasicAllocationManager::setReuseRegisters(bool val) { reuse_qubits_ = val; } void BasicAllocationManager::reset() { updateRegistersInUse(0); mappings_.clear(); allocation_index_ = 0; next_qubit_index_ = 0; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:35 UTC","title":"Source code"},{"location":"Api/Files/_allocation_manager_8hpp/","text":"AllocationManager/AllocationManager.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::BasicAllocationManager struct microsoft::quantum::BasicAllocationManager::AllocatedMemoryBlock Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/IAllocationManager.hpp\" #include \"Llvm/Llvm.hpp\" #include <memory> #include <string> #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class BasicAllocationManager : public IAllocationManager { public: struct AllocatedMemoryBlock { String name{\"\"}; Index count{0}; Address start{0}; Address end{0}; }; using Mappings = std::vector<AllocatedMemoryBlock>; using BasicAllocationManagerPtr = std::shared_ptr<BasicAllocationManager>; // Construction only allowed using smart pointer allocation through static functions. // Constructors are private to prevent // static BasicAllocationManagerPtr createNew(); // Allocation and release functions // Address allocate(String const& name = \"\", Index const& count = 1) override; void release(Address const& address) override; void reset() override; void setReuseRegisters(bool val); private: // Private constructors // BasicAllocationManager() = default; Index next_qubit_index_{0}; // Memory mapping // Mappings mappings_{}; Index allocation_index_{0}; // Configuration // bool reuse_qubits_{true}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:35 UTC","title":"AllocationManager/AllocationManager.hpp"},{"location":"Api/Files/_allocation_manager_8hpp/#allocationmanagerallocationmanagerhpp","text":"","title":"AllocationManager/AllocationManager.hpp"},{"location":"Api/Files/_allocation_manager_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_allocation_manager_8hpp/#classes","text":"Name class microsoft::quantum::BasicAllocationManager struct microsoft::quantum::BasicAllocationManager::AllocatedMemoryBlock","title":"Classes"},{"location":"Api/Files/_allocation_manager_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/IAllocationManager.hpp\" #include \"Llvm/Llvm.hpp\" #include <memory> #include <string> #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class BasicAllocationManager : public IAllocationManager { public: struct AllocatedMemoryBlock { String name{\"\"}; Index count{0}; Address start{0}; Address end{0}; }; using Mappings = std::vector<AllocatedMemoryBlock>; using BasicAllocationManagerPtr = std::shared_ptr<BasicAllocationManager>; // Construction only allowed using smart pointer allocation through static functions. // Constructors are private to prevent // static BasicAllocationManagerPtr createNew(); // Allocation and release functions // Address allocate(String const& name = \"\", Index const& count = 1) override; void release(Address const& address) override; void reset() override; void setReuseRegisters(bool val); private: // Private constructors // BasicAllocationManager() = default; Index next_qubit_index_{0}; // Memory mapping // Mappings mappings_{}; Index allocation_index_{0}; // Configuration // bool reuse_qubits_{true}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:35 UTC","title":"Source code"},{"location":"Api/Files/_any_pattern_8cpp/","text":"Rules/Patterns/AnyPattern.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" namespace microsoft { namespace quantum { AnyPattern::AnyPattern() = default; AnyPattern::~AnyPattern() = default; bool AnyPattern::match(Value* instr, Captures& captures) const { return success(instr, captures); } AnyPattern::Child AnyPattern::copy() const { return std::make_shared<AnyPattern>(); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Patterns/AnyPattern.cpp"},{"location":"Api/Files/_any_pattern_8cpp/#rulespatternsanypatterncpp","text":"","title":"Rules/Patterns/AnyPattern.cpp"},{"location":"Api/Files/_any_pattern_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_any_pattern_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" namespace microsoft { namespace quantum { AnyPattern::AnyPattern() = default; AnyPattern::~AnyPattern() = default; bool AnyPattern::match(Value* instr, Captures& captures) const { return success(instr, captures); } AnyPattern::Child AnyPattern::copy() const { return std::make_shared<AnyPattern>(); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_any_pattern_8hpp/","text":"Rules/Patterns/AnyPattern.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::AnyPattern Pattern that matches any operand. Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class AnyPattern : public IOperandPrototype { public: // Constructors. // AnyPattern(); ~AnyPattern() override; // \"Any\" implementation of the member functions in IOperandPrototype. bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Patterns/AnyPattern.hpp"},{"location":"Api/Files/_any_pattern_8hpp/#rulespatternsanypatternhpp","text":"","title":"Rules/Patterns/AnyPattern.hpp"},{"location":"Api/Files/_any_pattern_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_any_pattern_8hpp/#classes","text":"Name class microsoft::quantum::AnyPattern Pattern that matches any operand.","title":"Classes"},{"location":"Api/Files/_any_pattern_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class AnyPattern : public IOperandPrototype { public: // Constructors. // AnyPattern(); ~AnyPattern() override; // \"Any\" implementation of the member functions in IOperandPrototype. bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_basic_block_8cpp/","text":"Rules/Notation/BasicBlock.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr basicBlock() { auto ret = std::make_shared<BasicBlockPattern>(); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Notation/BasicBlock.cpp"},{"location":"Api/Files/_basic_block_8cpp/#rulesnotationbasicblockcpp","text":"","title":"Rules/Notation/BasicBlock.cpp"},{"location":"Api/Files/_basic_block_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_basic_block_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr basicBlock() { auto ret = std::make_shared<BasicBlockPattern>(); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_basic_rule_set_ops_8cpp/","text":"Rules/Tests/Unit/BasicRuleSetOps.cpp Functions Name TEST (RuleSetTestSuite , BasicOperations ) TEST (RuleSetTestSuite , SetReplacerAndPattern ) TEST (RuleSetTestSuite , NullPattern ) TEST (RuleSetTestSuite , NullReplacer ) Functions Documentation function TEST TEST( RuleSetTestSuite , BasicOperations ) function TEST TEST( RuleSetTestSuite , SetReplacerAndPattern ) function TEST TEST( RuleSetTestSuite , NullPattern ) function TEST TEST( RuleSetTestSuite , NullReplacer ) Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Notation/Notation.hpp\" #include \"Rules/ReplacementRule.hpp\" #include \"Rules/RuleSet.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include <functional> #include <memory> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareFunction(\"%Qubit* @__quantum__rt__qubit_allocate()\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(RuleSetTestSuite, BasicOperations) { using namespace microsoft::quantum::notation; RuleSet rule_set; EXPECT_EQ(rule_set.size(), 0); auto deleter = deleteInstruction(); ReplacementRule rule{callByNameOnly(\"__quantum__rt__qubit_release_array\"), std::move(deleter)}; auto ret = std::make_shared<ReplacementRule>(rule); rule_set.addRule(ret); EXPECT_EQ(rule_set.size(), 1); rule_set.clear(); EXPECT_EQ(rule_set.size(), 0); } TEST(RuleSetTestSuite, SetReplacerAndPattern) { using namespace microsoft::quantum::notation; auto ir_manip = newIrManip(R\"script( %qubit = inttoptr i64 0 to %Qubit* call void @__quantum__rt__qubit_release(%Qubit* %qubit) )script\"); auto configure_profile = [](RuleSet& rule_set) { ReplacementRule rule{nullptr, nullptr}; auto ret = std::make_shared<ReplacementRule>(rule); ret->setReplacer(deleteInstruction()); ret->setPattern(callByNameOnly(\"__quantum__rt__qubit_release\")); rule_set.addRule(ret); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); EXPECT_TRUE( ir_manip->hasInstructionSequence({\"tail call void @__quantum__rt__qubit_release(%Qubit* %qubit)\"}) || ir_manip->hasInstructionSequence({\"call void @__quantum__rt__qubit_release(%Qubit* %qubit)\"})); ir_manip->applyProfile(profile); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"tail call void @__quantum__rt__qubit_release(%Qubit* null)\"}) || ir_manip->hasInstructionSequence({\"call void @__quantum__rt__qubit_release(%Qubit* %qubit)\"})); } TEST(RuleSetTestSuite, NullPattern) { using namespace microsoft::quantum::notation; auto ir_manip = newIrManip(R\"script( %qubit = inttoptr i64 0 to %Qubit* call void @__quantum__rt__qubit_release(%Qubit* %qubit) )script\"); auto configure_profile = [](RuleSet& rule_set) { ReplacementRule rule{nullptr, deleteInstruction()}; auto ret = std::make_shared<ReplacementRule>(rule); rule_set.addRule(ret); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); EXPECT_TRUE( ir_manip->hasInstructionSequence({\"tail call void @__quantum__rt__qubit_release(%Qubit* %qubit)\"}) || ir_manip->hasInstructionSequence({\"call void @__quantum__rt__qubit_release(%Qubit* %qubit)\"})); ir_manip->applyProfile(profile); EXPECT_TRUE( ir_manip->hasInstructionSequence({\"tail call void @__quantum__rt__qubit_release(%Qubit* null)\"}) || ir_manip->hasInstructionSequence({\"call void @__quantum__rt__qubit_release(%Qubit* %qubit)\"})); } TEST(RuleSetTestSuite, NullReplacer) { using namespace microsoft::quantum::notation; auto ir_manip = newIrManip(R\"script( %qubit = inttoptr i64 0 to %Qubit* call void @__quantum__rt__qubit_release(%Qubit* %qubit) )script\"); auto configure_profile = [](RuleSet& rule_set) { ReplacementRule rule{callByNameOnly(\"__quantum__rt__qubit_release\"), nullptr}; auto ret = std::make_shared<ReplacementRule>(rule); rule_set.addRule(ret); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); EXPECT_TRUE( ir_manip->hasInstructionSequence({\"tail call void @__quantum__rt__qubit_release(%Qubit* %qubit)\"}) || ir_manip->hasInstructionSequence({\"call void @__quantum__rt__qubit_release(%Qubit* %qubit)\"})); ir_manip->applyProfile(profile); EXPECT_TRUE( ir_manip->hasInstructionSequence({\"tail call void @__quantum__rt__qubit_release(%Qubit* null)\"}) || ir_manip->hasInstructionSequence({\"call void @__quantum__rt__qubit_release(%Qubit* %qubit)\"})); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Tests/Unit/BasicRuleSetOps.cpp"},{"location":"Api/Files/_basic_rule_set_ops_8cpp/#rulestestsunitbasicrulesetopscpp","text":"","title":"Rules/Tests/Unit/BasicRuleSetOps.cpp"},{"location":"Api/Files/_basic_rule_set_ops_8cpp/#functions","text":"Name TEST (RuleSetTestSuite , BasicOperations ) TEST (RuleSetTestSuite , SetReplacerAndPattern ) TEST (RuleSetTestSuite , NullPattern ) TEST (RuleSetTestSuite , NullReplacer )","title":"Functions"},{"location":"Api/Files/_basic_rule_set_ops_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Files/_basic_rule_set_ops_8cpp/#function-test","text":"TEST( RuleSetTestSuite , BasicOperations )","title":"function TEST"},{"location":"Api/Files/_basic_rule_set_ops_8cpp/#function-test_1","text":"TEST( RuleSetTestSuite , SetReplacerAndPattern )","title":"function TEST"},{"location":"Api/Files/_basic_rule_set_ops_8cpp/#function-test_2","text":"TEST( RuleSetTestSuite , NullPattern )","title":"function TEST"},{"location":"Api/Files/_basic_rule_set_ops_8cpp/#function-test_3","text":"TEST( RuleSetTestSuite , NullReplacer )","title":"function TEST"},{"location":"Api/Files/_basic_rule_set_ops_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Notation/Notation.hpp\" #include \"Rules/ReplacementRule.hpp\" #include \"Rules/RuleSet.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include <functional> #include <memory> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareFunction(\"%Qubit* @__quantum__rt__qubit_allocate()\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(RuleSetTestSuite, BasicOperations) { using namespace microsoft::quantum::notation; RuleSet rule_set; EXPECT_EQ(rule_set.size(), 0); auto deleter = deleteInstruction(); ReplacementRule rule{callByNameOnly(\"__quantum__rt__qubit_release_array\"), std::move(deleter)}; auto ret = std::make_shared<ReplacementRule>(rule); rule_set.addRule(ret); EXPECT_EQ(rule_set.size(), 1); rule_set.clear(); EXPECT_EQ(rule_set.size(), 0); } TEST(RuleSetTestSuite, SetReplacerAndPattern) { using namespace microsoft::quantum::notation; auto ir_manip = newIrManip(R\"script( %qubit = inttoptr i64 0 to %Qubit* call void @__quantum__rt__qubit_release(%Qubit* %qubit) )script\"); auto configure_profile = [](RuleSet& rule_set) { ReplacementRule rule{nullptr, nullptr}; auto ret = std::make_shared<ReplacementRule>(rule); ret->setReplacer(deleteInstruction()); ret->setPattern(callByNameOnly(\"__quantum__rt__qubit_release\")); rule_set.addRule(ret); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); EXPECT_TRUE( ir_manip->hasInstructionSequence({\"tail call void @__quantum__rt__qubit_release(%Qubit* %qubit)\"}) || ir_manip->hasInstructionSequence({\"call void @__quantum__rt__qubit_release(%Qubit* %qubit)\"})); ir_manip->applyProfile(profile); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"tail call void @__quantum__rt__qubit_release(%Qubit* null)\"}) || ir_manip->hasInstructionSequence({\"call void @__quantum__rt__qubit_release(%Qubit* %qubit)\"})); } TEST(RuleSetTestSuite, NullPattern) { using namespace microsoft::quantum::notation; auto ir_manip = newIrManip(R\"script( %qubit = inttoptr i64 0 to %Qubit* call void @__quantum__rt__qubit_release(%Qubit* %qubit) )script\"); auto configure_profile = [](RuleSet& rule_set) { ReplacementRule rule{nullptr, deleteInstruction()}; auto ret = std::make_shared<ReplacementRule>(rule); rule_set.addRule(ret); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); EXPECT_TRUE( ir_manip->hasInstructionSequence({\"tail call void @__quantum__rt__qubit_release(%Qubit* %qubit)\"}) || ir_manip->hasInstructionSequence({\"call void @__quantum__rt__qubit_release(%Qubit* %qubit)\"})); ir_manip->applyProfile(profile); EXPECT_TRUE( ir_manip->hasInstructionSequence({\"tail call void @__quantum__rt__qubit_release(%Qubit* null)\"}) || ir_manip->hasInstructionSequence({\"call void @__quantum__rt__qubit_release(%Qubit* %qubit)\"})); } TEST(RuleSetTestSuite, NullReplacer) { using namespace microsoft::quantum::notation; auto ir_manip = newIrManip(R\"script( %qubit = inttoptr i64 0 to %Qubit* call void @__quantum__rt__qubit_release(%Qubit* %qubit) )script\"); auto configure_profile = [](RuleSet& rule_set) { ReplacementRule rule{callByNameOnly(\"__quantum__rt__qubit_release\"), nullptr}; auto ret = std::make_shared<ReplacementRule>(rule); rule_set.addRule(ret); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); EXPECT_TRUE( ir_manip->hasInstructionSequence({\"tail call void @__quantum__rt__qubit_release(%Qubit* %qubit)\"}) || ir_manip->hasInstructionSequence({\"call void @__quantum__rt__qubit_release(%Qubit* %qubit)\"})); ir_manip->applyProfile(profile); EXPECT_TRUE( ir_manip->hasInstructionSequence({\"tail call void @__quantum__rt__qubit_release(%Qubit* null)\"}) || ir_manip->hasInstructionSequence({\"call void @__quantum__rt__qubit_release(%Qubit* %qubit)\"})); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_bit_cast_8cpp/","text":"Rules/Notation/BitCast.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr bitCast(IOperandPrototypePtr const& arg) { auto cast_pattern = std::make_shared<BitCastPattern>(); cast_pattern->addChild(arg); return static_cast<IOperandPrototypePtr>(cast_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Notation/BitCast.cpp"},{"location":"Api/Files/_bit_cast_8cpp/#rulesnotationbitcastcpp","text":"","title":"Rules/Notation/BitCast.cpp"},{"location":"Api/Files/_bit_cast_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_bit_cast_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr bitCast(IOperandPrototypePtr const& arg) { auto cast_pattern = std::make_shared<BitCastPattern>(); cast_pattern->addChild(arg); return static_cast<IOperandPrototypePtr>(cast_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_branch_8cpp/","text":"Rules/Notation/Branch.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr branch( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2) { auto branch_pattern = std::make_shared<BranchPattern>(); branch_pattern->addChild(cond); branch_pattern->addChild(arg1); branch_pattern->addChild(arg2); return static_cast<IOperandPrototypePtr>(branch_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Notation/Branch.cpp"},{"location":"Api/Files/_branch_8cpp/#rulesnotationbranchcpp","text":"","title":"Rules/Notation/Branch.cpp"},{"location":"Api/Files/_branch_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_branch_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr branch( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2) { auto branch_pattern = std::make_shared<BranchPattern>(); branch_pattern->addChild(cond); branch_pattern->addChild(arg1); branch_pattern->addChild(arg2); return static_cast<IOperandPrototypePtr>(branch_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_branch_on_one_8cpp/","text":"Rules/Tests/Unit/BranchOnOne.cpp Functions Name TEST (RuleSetTestSuite , BranchOnOne ) Functions Documentation function TEST TEST( RuleSetTestSuite , BranchOnOne ) Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"Rules/ReplacementRule.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareFunction(\"%Result* @__quantum__qis__m__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__reset__body(%Qubit*)\"); ir_manip->declareFunction(\"%Result* @__quantum__rt__result_get_one()\"); ir_manip->declareFunction(\"void @__quantum__rt__result_update_reference_count(%Result*, i32)\"); ir_manip->declareFunction(\"%Result* @__quantum__rt__result_get_one()\"); ir_manip->declareFunction(\"i1 @__quantum__rt__result_equal(%Result*, %Result*)\"); ir_manip->declareFunction(\"void @send_message()\"); ir_manip->declareFunction(\"void @bye_message()\"); ir_manip->declareFunction(\"void @__quantum__qis__mz__body(%Qubit*, %Result*)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(RuleSetTestSuite, BranchOnOne) { auto ir_manip = newIrManip(R\"script( %0 = inttoptr i64 0 to %Result* call void @__quantum__qis__mz__body(%Qubit* null, %Result* %0) tail call void @__quantum__qis__reset__body(%Qubit* null) %1 = tail call %Result* @__quantum__rt__result_get_one() %2 = tail call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) tail call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 -1) br i1 %2, label %then0__1, label %continue__1 then0__1: tail call void @send_message() br label %continue__1 continue__1: tail call void @bye_message() ret i8 0 )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); // factory.useStaticResultAllocation(); factory.optimiseResultOne(); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); ir_manip->applyProfile(profile); // This optimistation is specific to the the __quantum__qis__read_result__body which // returns 1 or 0 depending on the result. We expect that // // %1 = tail call %Result* @__quantum__rt__result_get_one() // %2 = tail call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) // br i1 %2, label %then0__1, label %continue__1 // // will be mapped to using this instruction. EXPECT_TRUE(ir_manip->hasInstructionSequence( {\"%0 = tail call i1 @__quantum__qis__read_result__body(%Result* null)\", \"br i1 %0, label %then0__1, label %continue__1\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"%2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1)\"}) || ir_manip->hasInstructionSequence({\"%2 = tail call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"%2 = call i1 @__quantum__rt__result_get_one()\"}) || ir_manip->hasInstructionSequence({\"%2 = tail call i1 @__quantum__rt__result_get_one()\"})); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Tests/Unit/BranchOnOne.cpp"},{"location":"Api/Files/_branch_on_one_8cpp/#rulestestsunitbranchononecpp","text":"","title":"Rules/Tests/Unit/BranchOnOne.cpp"},{"location":"Api/Files/_branch_on_one_8cpp/#functions","text":"Name TEST (RuleSetTestSuite , BranchOnOne )","title":"Functions"},{"location":"Api/Files/_branch_on_one_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Files/_branch_on_one_8cpp/#function-test","text":"TEST( RuleSetTestSuite , BranchOnOne )","title":"function TEST"},{"location":"Api/Files/_branch_on_one_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"Rules/ReplacementRule.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareFunction(\"%Result* @__quantum__qis__m__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__reset__body(%Qubit*)\"); ir_manip->declareFunction(\"%Result* @__quantum__rt__result_get_one()\"); ir_manip->declareFunction(\"void @__quantum__rt__result_update_reference_count(%Result*, i32)\"); ir_manip->declareFunction(\"%Result* @__quantum__rt__result_get_one()\"); ir_manip->declareFunction(\"i1 @__quantum__rt__result_equal(%Result*, %Result*)\"); ir_manip->declareFunction(\"void @send_message()\"); ir_manip->declareFunction(\"void @bye_message()\"); ir_manip->declareFunction(\"void @__quantum__qis__mz__body(%Qubit*, %Result*)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(RuleSetTestSuite, BranchOnOne) { auto ir_manip = newIrManip(R\"script( %0 = inttoptr i64 0 to %Result* call void @__quantum__qis__mz__body(%Qubit* null, %Result* %0) tail call void @__quantum__qis__reset__body(%Qubit* null) %1 = tail call %Result* @__quantum__rt__result_get_one() %2 = tail call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) tail call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 -1) br i1 %2, label %then0__1, label %continue__1 then0__1: tail call void @send_message() br label %continue__1 continue__1: tail call void @bye_message() ret i8 0 )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); // factory.useStaticResultAllocation(); factory.optimiseResultOne(); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); ir_manip->applyProfile(profile); // This optimistation is specific to the the __quantum__qis__read_result__body which // returns 1 or 0 depending on the result. We expect that // // %1 = tail call %Result* @__quantum__rt__result_get_one() // %2 = tail call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) // br i1 %2, label %then0__1, label %continue__1 // // will be mapped to using this instruction. EXPECT_TRUE(ir_manip->hasInstructionSequence( {\"%0 = tail call i1 @__quantum__qis__read_result__body(%Result* null)\", \"br i1 %0, label %then0__1, label %continue__1\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"%2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1)\"}) || ir_manip->hasInstructionSequence({\"%2 = tail call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"%2 = call i1 @__quantum__rt__result_get_one()\"}) || ir_manip->hasInstructionSequence({\"%2 = tail call i1 @__quantum__rt__result_get_one()\"})); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_branch_on_zero_8cpp/","text":"Rules/Tests/Unit/BranchOnZero.cpp Functions Name TEST (RuleSetTestSuite , BranchOnZero ) Functions Documentation function TEST TEST( RuleSetTestSuite , BranchOnZero ) Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"Rules/ReplacementRule.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareFunction(\"%Result* @__quantum__qis__m__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__reset__body(%Qubit*)\"); ir_manip->declareFunction(\"%Result* @__quantum__rt__result_get_zero()\"); ir_manip->declareFunction(\"void @__quantum__rt__result_update_reference_count(%Result*, i32)\"); ir_manip->declareFunction(\"%Result* @__quantum__rt__result_get_zero()\"); ir_manip->declareFunction(\"i1 @__quantum__rt__result_equal(%Result*, %Result*)\"); ir_manip->declareFunction(\"void @send_message()\"); ir_manip->declareFunction(\"void @bye_message()\"); ir_manip->declareFunction(\"void @__quantum__qis__mz__body(%Qubit*, %Result*)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(RuleSetTestSuite, BranchOnZero) { auto ir_manip = newIrManip(R\"script( %0 = inttoptr i64 0 to %Result* call void @__quantum__qis__mz__body(%Qubit* null, %Result* %0) tail call void @__quantum__qis__reset__body(%Qubit* null) %1 = tail call %Result* @__quantum__rt__result_get_zero() %2 = tail call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) tail call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 -1) br i1 %2, label %then0__1, label %continue__1 then0__1: tail call void @send_message() br label %continue__1 continue__1: tail call void @bye_message() ret i8 0 )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); // factory.useStaticResultAllocation(); factory.optimiseResultZero(); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); ir_manip->applyProfile(profile); // This optimistation is specific to the the __quantum__qis__read_result__body which // returns 1 or 0 depending on the result. We expect that // // %1 = tail call %Result* @__quantum__rt__result_get_zero() // %2 = tail call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) // br i1 %2, label %then0__1, label %continue__1 // // will be mapped to using this pattern. EXPECT_TRUE(ir_manip->hasInstructionSequence( {\"%0 = tail call i1 @__quantum__qis__read_result__body(%Result* null)\", \"br i1 %0, label %continue__1, label %then0__1\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"%2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1)\"}) || ir_manip->hasInstructionSequence({\"%2 = tail call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"%2 = call i1 @__quantum__rt__result_get_zero()\"}) || ir_manip->hasInstructionSequence({\"%2 = tail call i1 @__quantum__rt__result_get_zero()\"})); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Tests/Unit/BranchOnZero.cpp"},{"location":"Api/Files/_branch_on_zero_8cpp/#rulestestsunitbranchonzerocpp","text":"","title":"Rules/Tests/Unit/BranchOnZero.cpp"},{"location":"Api/Files/_branch_on_zero_8cpp/#functions","text":"Name TEST (RuleSetTestSuite , BranchOnZero )","title":"Functions"},{"location":"Api/Files/_branch_on_zero_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Files/_branch_on_zero_8cpp/#function-test","text":"TEST( RuleSetTestSuite , BranchOnZero )","title":"function TEST"},{"location":"Api/Files/_branch_on_zero_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"Rules/ReplacementRule.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareFunction(\"%Result* @__quantum__qis__m__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__reset__body(%Qubit*)\"); ir_manip->declareFunction(\"%Result* @__quantum__rt__result_get_zero()\"); ir_manip->declareFunction(\"void @__quantum__rt__result_update_reference_count(%Result*, i32)\"); ir_manip->declareFunction(\"%Result* @__quantum__rt__result_get_zero()\"); ir_manip->declareFunction(\"i1 @__quantum__rt__result_equal(%Result*, %Result*)\"); ir_manip->declareFunction(\"void @send_message()\"); ir_manip->declareFunction(\"void @bye_message()\"); ir_manip->declareFunction(\"void @__quantum__qis__mz__body(%Qubit*, %Result*)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(RuleSetTestSuite, BranchOnZero) { auto ir_manip = newIrManip(R\"script( %0 = inttoptr i64 0 to %Result* call void @__quantum__qis__mz__body(%Qubit* null, %Result* %0) tail call void @__quantum__qis__reset__body(%Qubit* null) %1 = tail call %Result* @__quantum__rt__result_get_zero() %2 = tail call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) tail call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 -1) br i1 %2, label %then0__1, label %continue__1 then0__1: tail call void @send_message() br label %continue__1 continue__1: tail call void @bye_message() ret i8 0 )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); // factory.useStaticResultAllocation(); factory.optimiseResultZero(); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); ir_manip->applyProfile(profile); // This optimistation is specific to the the __quantum__qis__read_result__body which // returns 1 or 0 depending on the result. We expect that // // %1 = tail call %Result* @__quantum__rt__result_get_zero() // %2 = tail call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) // br i1 %2, label %then0__1, label %continue__1 // // will be mapped to using this pattern. EXPECT_TRUE(ir_manip->hasInstructionSequence( {\"%0 = tail call i1 @__quantum__qis__read_result__body(%Result* null)\", \"br i1 %0, label %continue__1, label %then0__1\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"%2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1)\"}) || ir_manip->hasInstructionSequence({\"%2 = tail call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"%2 = call i1 @__quantum__rt__result_get_zero()\"}) || ir_manip->hasInstructionSequence({\"%2 = tail call i1 @__quantum__rt__result_get_zero()\"})); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_call_8hpp/","text":"Rules/Notation/Call.hpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; template <typename... Args> IOperandPrototypePtr call(std::string const& name, Args... args); } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Notation/Call.hpp"},{"location":"Api/Files/_call_8hpp/#rulesnotationcallhpp","text":"","title":"Rules/Notation/Call.hpp"},{"location":"Api/Files/_call_8hpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_call_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; template <typename... Args> IOperandPrototypePtr call(std::string const& name, Args... args); } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_call_8ipp/","text":"Rules/Notation/Call.ipp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Llvm/Llvm.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; template <typename... Args> IOperandPrototypePtr call(std::string const &name, Args... args) { IOperandPrototypePtr ret = std::make_shared<CallPattern>(name); std::vector<IOperandPrototypePtr> arguments{args...}; // Adding arguments to matching for (auto &a : arguments) { ret->addChild(a); } // Function name is kept in the last operand ret->addChild(std::make_shared<AnyPattern>()); return ret; } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Notation/Call.ipp"},{"location":"Api/Files/_call_8ipp/#rulesnotationcallipp","text":"","title":"Rules/Notation/Call.ipp"},{"location":"Api/Files/_call_8ipp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_call_8ipp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Llvm/Llvm.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; template <typename... Args> IOperandPrototypePtr call(std::string const &name, Args... args) { IOperandPrototypePtr ret = std::make_shared<CallPattern>(name); std::vector<IOperandPrototypePtr> arguments{args...}; // Adding arguments to matching for (auto &a : arguments) { ret->addChild(a); } // Function name is kept in the last operand ret->addChild(std::make_shared<AnyPattern>()); return ret; } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_call_by_name_only_8cpp/","text":"Rules/Notation/CallByNameOnly.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr callByNameOnly(std::string const& name) { IOperandPrototypePtr ret = std::make_shared<CallPattern>(name); return ret; } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Notation/CallByNameOnly.cpp"},{"location":"Api/Files/_call_by_name_only_8cpp/#rulesnotationcallbynameonlycpp","text":"","title":"Rules/Notation/CallByNameOnly.cpp"},{"location":"Api/Files/_call_by_name_only_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_call_by_name_only_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr callByNameOnly(std::string const& name) { IOperandPrototypePtr ret = std::make_shared<CallPattern>(name); return ret; } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_call_pattern_8cpp/","text":"Rules/Patterns/CallPattern.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" namespace microsoft { namespace quantum { CallPattern::CallPattern(String const& name) : name_{name} { } CallPattern::~CallPattern() = default; bool CallPattern::match(Value* instr, Captures& captures) const { auto* call_instr = llvm::dyn_cast<llvm::CallBase>(instr); if (call_instr == nullptr) { return fail(instr, captures); } auto target_function = call_instr->getCalledFunction(); if (target_function == nullptr) { return fail(instr, captures); } auto name = target_function->getName(); if (name != name_) { return fail(instr, captures); } return success(instr, captures); } CallPattern::Child CallPattern::copy() const { auto ret = std::make_shared<CallPattern>(name_); ret->copyPropertiesFrom(*this); return std::move(ret); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Patterns/CallPattern.cpp"},{"location":"Api/Files/_call_pattern_8cpp/#rulespatternscallpatterncpp","text":"","title":"Rules/Patterns/CallPattern.cpp"},{"location":"Api/Files/_call_pattern_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_call_pattern_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" namespace microsoft { namespace quantum { CallPattern::CallPattern(String const& name) : name_{name} { } CallPattern::~CallPattern() = default; bool CallPattern::match(Value* instr, Captures& captures) const { auto* call_instr = llvm::dyn_cast<llvm::CallBase>(instr); if (call_instr == nullptr) { return fail(instr, captures); } auto target_function = call_instr->getCalledFunction(); if (target_function == nullptr) { return fail(instr, captures); } auto name = target_function->getName(); if (name != name_) { return fail(instr, captures); } return success(instr, captures); } CallPattern::Child CallPattern::copy() const { auto ret = std::make_shared<CallPattern>(name_); ret->copyPropertiesFrom(*this); return std::move(ret); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_call_pattern_8hpp/","text":"Rules/Patterns/CallPattern.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::CallPattern Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class CallPattern : public IOperandPrototype { public: using String = std::string; // Construction of the call pattern by name or move only. // explicit CallPattern(String const& name); CallPattern(CallPattern const& other) = delete; CallPattern(CallPattern&& other) = default; ~CallPattern() override; // Call implmenetation of the member functions in IOperandPrototype. // bool match(Value* instr, Captures& captures) const override; Child copy() const override; private: String name_{}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Patterns/CallPattern.hpp"},{"location":"Api/Files/_call_pattern_8hpp/#rulespatternscallpatternhpp","text":"","title":"Rules/Patterns/CallPattern.hpp"},{"location":"Api/Files/_call_pattern_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_call_pattern_8hpp/#classes","text":"Name class microsoft::quantum::CallPattern","title":"Classes"},{"location":"Api/Files/_call_pattern_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class CallPattern : public IOperandPrototype { public: using String = std::string; // Construction of the call pattern by name or move only. // explicit CallPattern(String const& name); CallPattern(CallPattern const& other) = delete; CallPattern(CallPattern&& other) = default; ~CallPattern() override; // Call implmenetation of the member functions in IOperandPrototype. // bool match(Value* instr, Captures& captures) const override; Child copy() const override; private: String name_{}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_capture_8cpp/","text":"Rules/Notation/Capture.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; Capture::Capture(std::string const& name) : name_{name} { } IOperandPrototypePtr Capture::operator=(IOperandPrototypePtr const& other) // NOLINT { auto ret = other->copy(); ret->captureAs(name_); return ret; } Capture operator\"\"_cap(char const* name, std::size_t) { return Capture(name); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Notation/Capture.cpp"},{"location":"Api/Files/_capture_8cpp/#rulesnotationcapturecpp","text":"","title":"Rules/Notation/Capture.cpp"},{"location":"Api/Files/_capture_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_capture_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; Capture::Capture(std::string const& name) : name_{name} { } IOperandPrototypePtr Capture::operator=(IOperandPrototypePtr const& other) // NOLINT { auto ret = other->copy(); ret->captureAs(name_); return ret; } Capture operator\"\"_cap(char const* name, std::size_t) { return Capture(name); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_comment_logger_8cpp/","text":"Logging/CommentLogger.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/CommentLogger.hpp\" #include \"Llvm/Llvm.hpp\" #include <vector> namespace microsoft { namespace quantum { void CommentLogger::debug(String const& message) { llvm::errs() << \"debug - \" << location_name_ << \":\" << location_row_ << \",\" << location_col_ << \" - \" << message << \"\\n\"; } void CommentLogger::info(String const& message) { llvm::errs() << \"info - \" << location_name_ << \":\" << location_row_ << \",\" << location_col_ << \" - \" << message << \"\\n\"; } void CommentLogger::warning(String const& message) { llvm::errs() << \"warning - \" << location_name_ << \":\" << location_row_ << \",\" << location_col_ << \" - \" << message << \"\\n\"; } void CommentLogger::error(String const& message) { llvm::errs() << \"error - \" << location_name_ << \":\" << location_row_ << \",\" << location_col_ << \" - \" << message << \"\\n\"; } void CommentLogger::internalError(String const& message) { llvm::errs() << \"internal error - \" << location_name_ << \":\" << location_row_ << \",\" << location_col_ << \" - \" << message << \"\\n\"; } void CommentLogger::setLocation(String const& name, uint64_t row, uint64_t col) { location_name_ = name; location_row_ = row; location_col_ = col; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Logging/CommentLogger.cpp"},{"location":"Api/Files/_comment_logger_8cpp/#loggingcommentloggercpp","text":"","title":"Logging/CommentLogger.cpp"},{"location":"Api/Files/_comment_logger_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_comment_logger_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/CommentLogger.hpp\" #include \"Llvm/Llvm.hpp\" #include <vector> namespace microsoft { namespace quantum { void CommentLogger::debug(String const& message) { llvm::errs() << \"debug - \" << location_name_ << \":\" << location_row_ << \",\" << location_col_ << \" - \" << message << \"\\n\"; } void CommentLogger::info(String const& message) { llvm::errs() << \"info - \" << location_name_ << \":\" << location_row_ << \",\" << location_col_ << \" - \" << message << \"\\n\"; } void CommentLogger::warning(String const& message) { llvm::errs() << \"warning - \" << location_name_ << \":\" << location_row_ << \",\" << location_col_ << \" - \" << message << \"\\n\"; } void CommentLogger::error(String const& message) { llvm::errs() << \"error - \" << location_name_ << \":\" << location_row_ << \",\" << location_col_ << \" - \" << message << \"\\n\"; } void CommentLogger::internalError(String const& message) { llvm::errs() << \"internal error - \" << location_name_ << \":\" << location_row_ << \",\" << location_col_ << \" - \" << message << \"\\n\"; } void CommentLogger::setLocation(String const& name, uint64_t row, uint64_t col) { location_name_ = name; location_row_ = row; location_col_ = col; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_comment_logger_8hpp/","text":"Logging/CommentLogger.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::CommentLogger Concrete ILogger implementation that prints all messages as IR comments to llvm::errs(). Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/ILogger.hpp\" #include <vector> namespace microsoft { namespace quantum { class CommentLogger : public ILogger { public: // Interface implementation // void debug(String const& message) override; void info(String const& message) override; void warning(String const& message) override; void error(String const& message) override; void internalError(String const& message) override; void setLocation(String const& name, uint64_t row, uint64_t col) override; private: String location_name_{\"\"}; uint64_t location_row_{0}; uint64_t location_col_{0}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Logging/CommentLogger.hpp"},{"location":"Api/Files/_comment_logger_8hpp/#loggingcommentloggerhpp","text":"","title":"Logging/CommentLogger.hpp"},{"location":"Api/Files/_comment_logger_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_comment_logger_8hpp/#classes","text":"Name class microsoft::quantum::CommentLogger Concrete ILogger implementation that prints all messages as IR comments to llvm::errs().","title":"Classes"},{"location":"Api/Files/_comment_logger_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/ILogger.hpp\" #include <vector> namespace microsoft { namespace quantum { class CommentLogger : public ILogger { public: // Interface implementation // void debug(String const& message) override; void info(String const& message) override; void warning(String const& message) override; void error(String const& message) override; void internalError(String const& message) override; void setLocation(String const& name, uint64_t row, uint64_t col) override; private: String location_name_{\"\"}; uint64_t location_row_{0}; uint64_t location_col_{0}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_config_bind_8hpp/","text":"Commandline/ConfigBind.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ConfigBind Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/IConfigBind.hpp\" #include \"Commandline/ParameterParser.hpp\" #include \"Llvm/Llvm.hpp\" #include <iomanip> #include <iostream> #include <sstream> #include <type_traits> #include <typeindex> namespace microsoft { namespace quantum { template <typename T> class ConfigBind : public IConfigBind { public: using Type = T; template <typename A, typename B, typename R> using EnableIf = typename std::enable_if<std::is_same<A, B>::value, R>::type; // Constructors, operators and destructor // ConfigBind() = delete; ConfigBind(ConfigBind const&) = delete; ConfigBind(ConfigBind&&) = delete; ConfigBind& operator=(ConfigBind const&) = delete; ConfigBind& operator=(ConfigBind&&) = delete; ~ConfigBind() override = default; ConfigBind(Type& bind, T default_value, String const& name, String const& description); // Interface implementation // bool setupArguments(ParameterParser& parser) override; bool configure(ParameterParser const& parser) override; String value() override; private: template <typename R> bool setupArguments(ParameterParser&, R const&); bool setupArguments(ParameterParser& parser, bool const&); template <typename R> void alterNameBasedOnType(R const& default_value); void alterNameBasedOnType(bool const& default_value); template <typename A> String valueAsString(A const&); template <typename A> String valueAsString(EnableIf<A, bool, A> const&); template <typename R> void loadValue(ParameterParser const& parser, R const& default_value); template <typename A> void loadValue(ParameterParser const& parser, EnableIf<A, bool, A> const& default_value); template <typename A> void loadValue(ParameterParser const& parser, EnableIf<A, String, A> const& default_value); Type& bind_; Type default_value_; }; template <typename T> ConfigBind<T>::ConfigBind(Type& bind, T default_value, String const& name, String const& description) : IConfigBind(name, description) , bind_{bind} , default_value_{std::move(default_value)} { alterNameBasedOnType(default_value_); } template <typename T> template <typename R> void ConfigBind<T>::alterNameBasedOnType(R const& default_value) { std::stringstream ss{\"\"}; ss << default_value; setDefault(static_cast<String>(ss.str())); } template <typename T> void ConfigBind<T>::alterNameBasedOnType(bool const& default_value) { markAsFlag(); if (default_value) { setDefault(\"true\"); } else { setDefault(\"false\"); } } template <typename T> bool ConfigBind<T>::setupArguments(ParameterParser& parser) { return setupArguments(parser, default_value_); } template <typename T> template <typename R> bool ConfigBind<T>::setupArguments(ParameterParser&, R const&) { return true; } template <typename T> bool ConfigBind<T>::setupArguments(ParameterParser& parser, bool const&) { parser.addFlag(name()); return true; } template <typename T> bool ConfigBind<T>::configure(ParameterParser const& parser) { loadValue<Type>(parser, default_value_); return true; } template <typename T> String ConfigBind<T>::value() { return valueAsString<Type>(default_value_); } template <typename T> template <typename A> String ConfigBind<T>::valueAsString(A const&) { std::stringstream ss{\"\"}; ss << bind_; return static_cast<String>(ss.str()); } template <typename T> template <typename A> String ConfigBind<T>::valueAsString(EnableIf<A, bool, A> const&) { std::stringstream ss{\"\"}; ss << (bind_ ? \"true\" : \"false\"); return static_cast<String>(ss.str()); } template <typename T> template <typename R> void ConfigBind<T>::loadValue(ParameterParser const& parser, R const& default_value) { bind_ = default_value; if (parser.has(name())) { std::stringstream ss{parser.get(name())}; ss >> bind_; } } template <typename T> template <typename A> void ConfigBind<T>::loadValue(ParameterParser const& parser, EnableIf<A, bool, A> const& default_value) { bind_ = default_value; if (parser.has(name())) { bind_ = true; } else if (parser.has(\"no-\" + name())) { bind_ = false; } } template <typename T> template <typename A> void ConfigBind<T>::loadValue(ParameterParser const& parser, EnableIf<A, String, A> const& default_value) { bind_ = default_value; if (parser.has(name())) { bind_ = parser.get(name()); } } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Commandline/ConfigBind.hpp"},{"location":"Api/Files/_config_bind_8hpp/#commandlineconfigbindhpp","text":"","title":"Commandline/ConfigBind.hpp"},{"location":"Api/Files/_config_bind_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_config_bind_8hpp/#classes","text":"Name class microsoft::quantum::ConfigBind","title":"Classes"},{"location":"Api/Files/_config_bind_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/IConfigBind.hpp\" #include \"Commandline/ParameterParser.hpp\" #include \"Llvm/Llvm.hpp\" #include <iomanip> #include <iostream> #include <sstream> #include <type_traits> #include <typeindex> namespace microsoft { namespace quantum { template <typename T> class ConfigBind : public IConfigBind { public: using Type = T; template <typename A, typename B, typename R> using EnableIf = typename std::enable_if<std::is_same<A, B>::value, R>::type; // Constructors, operators and destructor // ConfigBind() = delete; ConfigBind(ConfigBind const&) = delete; ConfigBind(ConfigBind&&) = delete; ConfigBind& operator=(ConfigBind const&) = delete; ConfigBind& operator=(ConfigBind&&) = delete; ~ConfigBind() override = default; ConfigBind(Type& bind, T default_value, String const& name, String const& description); // Interface implementation // bool setupArguments(ParameterParser& parser) override; bool configure(ParameterParser const& parser) override; String value() override; private: template <typename R> bool setupArguments(ParameterParser&, R const&); bool setupArguments(ParameterParser& parser, bool const&); template <typename R> void alterNameBasedOnType(R const& default_value); void alterNameBasedOnType(bool const& default_value); template <typename A> String valueAsString(A const&); template <typename A> String valueAsString(EnableIf<A, bool, A> const&); template <typename R> void loadValue(ParameterParser const& parser, R const& default_value); template <typename A> void loadValue(ParameterParser const& parser, EnableIf<A, bool, A> const& default_value); template <typename A> void loadValue(ParameterParser const& parser, EnableIf<A, String, A> const& default_value); Type& bind_; Type default_value_; }; template <typename T> ConfigBind<T>::ConfigBind(Type& bind, T default_value, String const& name, String const& description) : IConfigBind(name, description) , bind_{bind} , default_value_{std::move(default_value)} { alterNameBasedOnType(default_value_); } template <typename T> template <typename R> void ConfigBind<T>::alterNameBasedOnType(R const& default_value) { std::stringstream ss{\"\"}; ss << default_value; setDefault(static_cast<String>(ss.str())); } template <typename T> void ConfigBind<T>::alterNameBasedOnType(bool const& default_value) { markAsFlag(); if (default_value) { setDefault(\"true\"); } else { setDefault(\"false\"); } } template <typename T> bool ConfigBind<T>::setupArguments(ParameterParser& parser) { return setupArguments(parser, default_value_); } template <typename T> template <typename R> bool ConfigBind<T>::setupArguments(ParameterParser&, R const&) { return true; } template <typename T> bool ConfigBind<T>::setupArguments(ParameterParser& parser, bool const&) { parser.addFlag(name()); return true; } template <typename T> bool ConfigBind<T>::configure(ParameterParser const& parser) { loadValue<Type>(parser, default_value_); return true; } template <typename T> String ConfigBind<T>::value() { return valueAsString<Type>(default_value_); } template <typename T> template <typename A> String ConfigBind<T>::valueAsString(A const&) { std::stringstream ss{\"\"}; ss << bind_; return static_cast<String>(ss.str()); } template <typename T> template <typename A> String ConfigBind<T>::valueAsString(EnableIf<A, bool, A> const&) { std::stringstream ss{\"\"}; ss << (bind_ ? \"true\" : \"false\"); return static_cast<String>(ss.str()); } template <typename T> template <typename R> void ConfigBind<T>::loadValue(ParameterParser const& parser, R const& default_value) { bind_ = default_value; if (parser.has(name())) { std::stringstream ss{parser.get(name())}; ss >> bind_; } } template <typename T> template <typename A> void ConfigBind<T>::loadValue(ParameterParser const& parser, EnableIf<A, bool, A> const& default_value) { bind_ = default_value; if (parser.has(name())) { bind_ = true; } else if (parser.has(\"no-\" + name())) { bind_ = false; } } template <typename T> template <typename A> void ConfigBind<T>::loadValue(ParameterParser const& parser, EnableIf<A, String, A> const& default_value) { bind_ = default_value; if (parser.has(name())) { bind_ = parser.get(name()); } } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_configuration_manager_8cpp/","text":"Commandline/ConfigurationManager.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" using namespace microsoft::quantum; namespace microsoft { namespace quantum { void ConfigurationManager::setupArguments(ParameterParser& parser) { for (auto& section : config_sections_) { parser.addFlag(\"disable-\" + section.id); } for (auto& section : config_sections_) { for (auto& c : section.settings) { if (!c->setupArguments(parser)) { throw std::runtime_error(\"Failed to set parser arguments up.\"); } } } } void ConfigurationManager::configure(ParameterParser const& parser) { for (auto& section : config_sections_) { *section.active = (parser.get(\"disable-\" + section.id, \"false\") != \"true\"); } for (auto& section : config_sections_) { for (auto& c : section.settings) { if (!c->configure(parser)) { throw std::runtime_error(\"Failed configure the section.\"); } } } } void ConfigurationManager::printHelp() const { std::cout << std::setfill(' '); // Enable or disable components std::cout << std::endl; std::cout << \"Component configuration\" << \" - \"; std::cout << \"Used to disable or enable components\" << std::endl; std::cout << std::endl; for (auto& section : config_sections_) { if (!section.id.empty()) { std::cout << std::setw(50) << std::left << (\"--disable-\" + section.id) << \"Disables \" << section.name << \". \"; std::cout << \"Default: true\" << std::endl; } } // Component configuration for (auto& section : config_sections_) { std::cout << std::endl; std::cout << section.name << \" - \"; std::cout << section.description << std::endl; std::cout << std::endl; for (auto& c : section.settings) { if (c->isFlag()) { if (c->defaultValue() == \"false\") { std::cout << std::setw(50) << std::left << (\"--\" + c->name()) << c->description() << \" \"; } else { std::cout << std::setw(50) << std::left << (\"--[no-]\" + c->name()) << c->description() << \" \"; } } else { std::cout << std::setw(50) << std::left << (\"--\" + c->name()) << c->description() << \" \"; } std::cout << \"Default: \" << c->defaultValue() << std::endl; } } } void ConfigurationManager::printConfiguration() const { std::cout << std::setfill('.'); std::cout << \"; # \" << \"Components\" << \"\\n\"; for (auto& section : config_sections_) { if (!section.id.empty()) { std::cout << \"; \" << std::setw(50) << std::left << (\"disable-\" + section.id) << \": \" << (*section.active ? \"false\" : \"true\") << \"\\n\"; } } std::cout << \"; \\n\"; for (auto& section : config_sections_) { std::cout << \"; # \" << section.name << \"\\n\"; for (auto& c : section.settings) { std::cout << \"; \" << std::setw(50) << std::left << c->name() << \": \" << c->value() << \"\\n\"; } std::cout << \"; \\n\"; } } void ConfigurationManager::setSectionName(String const& name, String const& description) { config_sections_.back().name = name; config_sections_.back().description = description; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Commandline/ConfigurationManager.cpp"},{"location":"Api/Files/_configuration_manager_8cpp/#commandlineconfigurationmanagercpp","text":"","title":"Commandline/ConfigurationManager.cpp"},{"location":"Api/Files/_configuration_manager_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_configuration_manager_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" using namespace microsoft::quantum; namespace microsoft { namespace quantum { void ConfigurationManager::setupArguments(ParameterParser& parser) { for (auto& section : config_sections_) { parser.addFlag(\"disable-\" + section.id); } for (auto& section : config_sections_) { for (auto& c : section.settings) { if (!c->setupArguments(parser)) { throw std::runtime_error(\"Failed to set parser arguments up.\"); } } } } void ConfigurationManager::configure(ParameterParser const& parser) { for (auto& section : config_sections_) { *section.active = (parser.get(\"disable-\" + section.id, \"false\") != \"true\"); } for (auto& section : config_sections_) { for (auto& c : section.settings) { if (!c->configure(parser)) { throw std::runtime_error(\"Failed configure the section.\"); } } } } void ConfigurationManager::printHelp() const { std::cout << std::setfill(' '); // Enable or disable components std::cout << std::endl; std::cout << \"Component configuration\" << \" - \"; std::cout << \"Used to disable or enable components\" << std::endl; std::cout << std::endl; for (auto& section : config_sections_) { if (!section.id.empty()) { std::cout << std::setw(50) << std::left << (\"--disable-\" + section.id) << \"Disables \" << section.name << \". \"; std::cout << \"Default: true\" << std::endl; } } // Component configuration for (auto& section : config_sections_) { std::cout << std::endl; std::cout << section.name << \" - \"; std::cout << section.description << std::endl; std::cout << std::endl; for (auto& c : section.settings) { if (c->isFlag()) { if (c->defaultValue() == \"false\") { std::cout << std::setw(50) << std::left << (\"--\" + c->name()) << c->description() << \" \"; } else { std::cout << std::setw(50) << std::left << (\"--[no-]\" + c->name()) << c->description() << \" \"; } } else { std::cout << std::setw(50) << std::left << (\"--\" + c->name()) << c->description() << \" \"; } std::cout << \"Default: \" << c->defaultValue() << std::endl; } } } void ConfigurationManager::printConfiguration() const { std::cout << std::setfill('.'); std::cout << \"; # \" << \"Components\" << \"\\n\"; for (auto& section : config_sections_) { if (!section.id.empty()) { std::cout << \"; \" << std::setw(50) << std::left << (\"disable-\" + section.id) << \": \" << (*section.active ? \"false\" : \"true\") << \"\\n\"; } } std::cout << \"; \\n\"; for (auto& section : config_sections_) { std::cout << \"; # \" << section.name << \"\\n\"; for (auto& c : section.settings) { std::cout << \"; \" << std::setw(50) << std::left << c->name() << \": \" << c->value() << \"\\n\"; } std::cout << \"; \\n\"; } } void ConfigurationManager::setSectionName(String const& name, String const& description) { config_sections_.back().name = name; config_sections_.back().description = description; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_configuration_manager_8hpp/","text":"Commandline/ConfigurationManager.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ConfigurationManager struct microsoft::quantum::ConfigurationManager::Section Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigBind.hpp\" #include \"Commandline/IConfigBind.hpp\" #include \"Commandline/ParameterParser.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Llvm/Llvm.hpp\" #include <iomanip> #include <iostream> #include <sstream> #include <type_traits> #include <typeindex> namespace microsoft { namespace quantum { class ConfigurationManager { public: using IConfigBindPtr = std::shared_ptr<IConfigBind>; using ConfigList = std::vector<IConfigBindPtr>; using VoidPtr = std::shared_ptr<void>; using TypeId = std::type_index; using BoolPtr = std::shared_ptr<bool>; struct Section { TypeId type{TypeId(typeid(std::nullptr_t))}; String name{}; String description{}; VoidPtr configuration{}; ConfigList settings{}; BoolPtr active{nullptr}; String id{}; }; using Sections = std::vector<Section>; // Constructors, copy and move operators, destructor // ConfigurationManager() = default; ConfigurationManager(ConfigurationManager const&) = delete; ConfigurationManager(ConfigurationManager&&) = delete; ConfigurationManager& operator=(ConfigurationManager const&) = delete; ConfigurationManager& operator=(ConfigurationManager&&) = delete; // Configuration setup // void setupArguments(ParameterParser& parser); void configure(ParameterParser const& parser); // Managing configuration // template <typename T> inline void setConfig(T const& value); template <typename T> inline T const& get() const; // Support functions // void printHelp() const; void printConfiguration() const; // Configuration functions // template <typename T> inline void addConfig(String const& id = \"\", T const& default_value = T()); template <typename T> inline bool isActive(); void setSectionName(String const& name, String const& description); template <typename T> inline void addParameter(T& bind, T default_value, String const& name, String const& description); template <typename T> inline void addParameter(T& bind, String const& name, String const& description); private: template <typename T> inline T& getInternal() const; Sections config_sections_{}; }; template <typename T> inline void ConfigurationManager::addConfig(String const& id, T const& default_value) { Section new_section{std::type_index(typeid(T))}; auto ptr = std::make_shared<T>(default_value); new_section.configuration = ptr; new_section.active = std::make_shared<bool>(true); new_section.id = id; config_sections_.emplace_back(std::move(new_section)); ptr->setup(*this); } template <typename T> inline T& ConfigurationManager::getInternal() const { VoidPtr ptr{nullptr}; auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { ptr = section.configuration; break; } } if (ptr == nullptr) { throw std::runtime_error(\"Could not find configuration class.\"); } return *static_cast<T*>(ptr.get()); } template <typename T> inline void ConfigurationManager::setConfig(T const& value) { auto& config = getInternal<T>(); config = value; } template <typename T> inline T const& ConfigurationManager::get() const { return getInternal<T>(); } template <typename T> inline bool ConfigurationManager::isActive() { BoolPtr ptr{nullptr}; auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { ptr = section.active; break; } } if (ptr == nullptr) { throw std::runtime_error(\"Could not find configuration class.\"); } return *ptr; } template <typename T> inline void ConfigurationManager::addParameter( T& bind, T default_value, String const& name, String const& description) { auto ptr = std::make_shared<ConfigBind<T>>(bind, default_value, name, description); config_sections_.back().settings.push_back(ptr); } template <typename T> inline void ConfigurationManager::addParameter(T& bind, String const& name, String const& description) { auto ptr = std::make_shared<ConfigBind<T>>(bind, T(bind), name, description); config_sections_.back().settings.push_back(ptr); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Commandline/ConfigurationManager.hpp"},{"location":"Api/Files/_configuration_manager_8hpp/#commandlineconfigurationmanagerhpp","text":"","title":"Commandline/ConfigurationManager.hpp"},{"location":"Api/Files/_configuration_manager_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_configuration_manager_8hpp/#classes","text":"Name class microsoft::quantum::ConfigurationManager struct microsoft::quantum::ConfigurationManager::Section","title":"Classes"},{"location":"Api/Files/_configuration_manager_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigBind.hpp\" #include \"Commandline/IConfigBind.hpp\" #include \"Commandline/ParameterParser.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Llvm/Llvm.hpp\" #include <iomanip> #include <iostream> #include <sstream> #include <type_traits> #include <typeindex> namespace microsoft { namespace quantum { class ConfigurationManager { public: using IConfigBindPtr = std::shared_ptr<IConfigBind>; using ConfigList = std::vector<IConfigBindPtr>; using VoidPtr = std::shared_ptr<void>; using TypeId = std::type_index; using BoolPtr = std::shared_ptr<bool>; struct Section { TypeId type{TypeId(typeid(std::nullptr_t))}; String name{}; String description{}; VoidPtr configuration{}; ConfigList settings{}; BoolPtr active{nullptr}; String id{}; }; using Sections = std::vector<Section>; // Constructors, copy and move operators, destructor // ConfigurationManager() = default; ConfigurationManager(ConfigurationManager const&) = delete; ConfigurationManager(ConfigurationManager&&) = delete; ConfigurationManager& operator=(ConfigurationManager const&) = delete; ConfigurationManager& operator=(ConfigurationManager&&) = delete; // Configuration setup // void setupArguments(ParameterParser& parser); void configure(ParameterParser const& parser); // Managing configuration // template <typename T> inline void setConfig(T const& value); template <typename T> inline T const& get() const; // Support functions // void printHelp() const; void printConfiguration() const; // Configuration functions // template <typename T> inline void addConfig(String const& id = \"\", T const& default_value = T()); template <typename T> inline bool isActive(); void setSectionName(String const& name, String const& description); template <typename T> inline void addParameter(T& bind, T default_value, String const& name, String const& description); template <typename T> inline void addParameter(T& bind, String const& name, String const& description); private: template <typename T> inline T& getInternal() const; Sections config_sections_{}; }; template <typename T> inline void ConfigurationManager::addConfig(String const& id, T const& default_value) { Section new_section{std::type_index(typeid(T))}; auto ptr = std::make_shared<T>(default_value); new_section.configuration = ptr; new_section.active = std::make_shared<bool>(true); new_section.id = id; config_sections_.emplace_back(std::move(new_section)); ptr->setup(*this); } template <typename T> inline T& ConfigurationManager::getInternal() const { VoidPtr ptr{nullptr}; auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { ptr = section.configuration; break; } } if (ptr == nullptr) { throw std::runtime_error(\"Could not find configuration class.\"); } return *static_cast<T*>(ptr.get()); } template <typename T> inline void ConfigurationManager::setConfig(T const& value) { auto& config = getInternal<T>(); config = value; } template <typename T> inline T const& ConfigurationManager::get() const { return getInternal<T>(); } template <typename T> inline bool ConfigurationManager::isActive() { BoolPtr ptr{nullptr}; auto type = std::type_index(typeid(T)); for (auto& section : config_sections_) { if (section.type == type) { ptr = section.active; break; } } if (ptr == nullptr) { throw std::runtime_error(\"Could not find configuration class.\"); } return *ptr; } template <typename T> inline void ConfigurationManager::addParameter( T& bind, T default_value, String const& name, String const& description) { auto ptr = std::make_shared<ConfigBind<T>>(bind, default_value, name, description); config_sections_.back().settings.push_back(ptr); } template <typename T> inline void ConfigurationManager::addParameter(T& bind, String const& name, String const& description) { auto ptr = std::make_shared<ConfigBind<T>>(bind, T(bind), name, description); config_sections_.back().settings.push_back(ptr); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_const_int_8cpp/","text":"Rules/Notation/ConstInt.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr constInt() { auto cast_pattern = std::make_shared<ConstIntPattern>(); return static_cast<IOperandPrototypePtr>(cast_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Notation/ConstInt.cpp"},{"location":"Api/Files/_const_int_8cpp/#rulesnotationconstintcpp","text":"","title":"Rules/Notation/ConstInt.cpp"},{"location":"Api/Files/_const_int_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_const_int_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr constInt() { auto cast_pattern = std::make_shared<ConstIntPattern>(); return static_cast<IOperandPrototypePtr>(cast_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_default_profile_generator_8cpp/","text":"Generators/DefaultProfileGenerator.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"Rules/FactoryConfig.hpp\" #include \"Rules/RuleSet.hpp\" #include \"TransformationRulesPass/TransformationRulesPass.hpp\" #include \"Llvm/Llvm.hpp\" #include <iostream> namespace microsoft { namespace quantum { DefaultProfileGenerator::DefaultProfileGenerator() { configurationManager().addConfig<ValidationPassConfiguration>(); registerProfileComponent<TransformationRulesPassConfiguration>( \"transformation-rules\", [](TransformationRulesPassConfiguration const& config, ProfileGenerator* ptr, Profile& profile) { auto& ret = ptr->modulePassManager(); // Default optimisation pipeline if (config.shouldSimplifyPriorTransform()) { auto& pass_builder = ptr->passBuilder(); llvm::ModulePassManager pipeline = pass_builder.buildPerModuleDefaultPipeline(ptr->optimisationLevel()); ret.addPass(std::move(pipeline)); } // Defining the mapping RuleSet rule_set; auto factory = RuleFactory(rule_set, profile.getQubitAllocationManager(), profile.getResultAllocationManager()); factory.usingConfiguration(ptr->configurationManager().get<FactoryConfiguration>()); // Creating profile pass ret.addPass(TransformationRulesPass(std::move(rule_set), config, &profile)); }); registerProfileComponent<LlvmPassesConfiguration>( \"llvm-passes\", [](LlvmPassesConfiguration const& cfg, ProfileGenerator* ptr, Profile&) { auto pass_pipeline = cfg.passPipeline(); if (!pass_pipeline.empty()) { auto& pass_builder = ptr->passBuilder(); auto& npm = ptr->modulePassManager(); if (!pass_builder.parsePassPipeline(npm, pass_pipeline, false, false)) { throw std::runtime_error(\"Failed to set pass pipeline up.\"); } } else if (cfg.alwaysInline()) { auto& ret = ptr->modulePassManager(); auto& pass_builder = ptr->passBuilder(); ret.addPass(llvm::AlwaysInlinerPass()); auto inliner_pass = pass_builder.buildInlinerPipeline( ptr->optimisationLevel(), llvm::PassBuilder::ThinLTOPhase::None, ptr->isDebugMode()); ret.addPass(std::move(inliner_pass)); } else if (!cfg.disableDefaultPipeline()) { auto& mpm = ptr->modulePassManager(); // If not explicitly disabled, we fall back to the default LLVM pipeline auto& pass_builder = ptr->passBuilder(); llvm::ModulePassManager pipeline1 = pass_builder.buildPerModuleDefaultPipeline(ptr->optimisationLevel()); mpm.addPass(std::move(pipeline1)); llvm::ModulePassManager pipeline2 = pass_builder.buildModuleSimplificationPipeline( ptr->optimisationLevel(), llvm::PassBuilder::ThinLTOPhase::None); mpm.addPass(std::move(pipeline2)); } }); } DefaultProfileGenerator::DefaultProfileGenerator( ConfigureFunction const& configure, TransformationRulesPassConfiguration const& profile_pass_config, LlvmPassesConfiguration const& llvm_config) { configurationManager().addConfig<ValidationPassConfiguration>(); registerProfileComponent<TransformationRulesPassConfiguration>( \"transformation-rules\", [configure](TransformationRulesPassConfiguration const& config, ProfileGenerator* ptr, Profile& profile) { auto& ret = ptr->modulePassManager(); // Default optimisation pipeline if (config.shouldSimplifyPriorTransform()) { auto& pass_builder = ptr->passBuilder(); llvm::ModulePassManager pipeline = pass_builder.buildPerModuleDefaultPipeline(ptr->optimisationLevel()); ret.addPass(std::move(pipeline)); } // Defining the mapping RuleSet rule_set; auto factory = RuleFactory(rule_set, profile.getQubitAllocationManager(), profile.getResultAllocationManager()); configure(rule_set); // Creating profile pass ret.addPass(TransformationRulesPass(std::move(rule_set), config, &profile)); }); registerProfileComponent<LlvmPassesConfiguration>( \"llvm-passes\", [](LlvmPassesConfiguration const& cfg, ProfileGenerator* ptr, Profile&) { auto pass_pipeline = cfg.passPipeline(); if (!pass_pipeline.empty()) { auto& pass_builder = ptr->passBuilder(); auto& npm = ptr->modulePassManager(); if (!pass_builder.parsePassPipeline(npm, pass_pipeline, false, false)) { throw std::runtime_error(\"Failed to set pass pipeline up.\"); } } else if (cfg.alwaysInline()) { auto& ret = ptr->modulePassManager(); auto& pass_builder = ptr->passBuilder(); ret.addPass(llvm::AlwaysInlinerPass()); auto inliner_pass = pass_builder.buildInlinerPipeline( ptr->optimisationLevel(), llvm::PassBuilder::ThinLTOPhase::None, ptr->isDebugMode()); ret.addPass(std::move(inliner_pass)); } else if (!cfg.disableDefaultPipeline()) { auto& mpm = ptr->modulePassManager(); // If not explicitly disabled, we fall back to the default LLVM pipeline auto& pass_builder = ptr->passBuilder(); llvm::ModulePassManager pipeline1 = pass_builder.buildPerModuleDefaultPipeline(ptr->optimisationLevel()); mpm.addPass(std::move(pipeline1)); llvm::ModulePassManager pipeline2 = pass_builder.buildModuleSimplificationPipeline( ptr->optimisationLevel(), llvm::PassBuilder::ThinLTOPhase::None); mpm.addPass(std::move(pipeline2)); } }); configurationManager().setConfig(profile_pass_config); configurationManager().setConfig(llvm_config); } TransformationRulesPassConfiguration const& DefaultProfileGenerator::ruleTransformationConfig() const { return configurationManager().get<TransformationRulesPassConfiguration>(); } LlvmPassesConfiguration const& DefaultProfileGenerator::llvmPassesConfig() const { return configurationManager().get<LlvmPassesConfiguration>(); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Generators/DefaultProfileGenerator.cpp"},{"location":"Api/Files/_default_profile_generator_8cpp/#generatorsdefaultprofilegeneratorcpp","text":"","title":"Generators/DefaultProfileGenerator.cpp"},{"location":"Api/Files/_default_profile_generator_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_default_profile_generator_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"Rules/FactoryConfig.hpp\" #include \"Rules/RuleSet.hpp\" #include \"TransformationRulesPass/TransformationRulesPass.hpp\" #include \"Llvm/Llvm.hpp\" #include <iostream> namespace microsoft { namespace quantum { DefaultProfileGenerator::DefaultProfileGenerator() { configurationManager().addConfig<ValidationPassConfiguration>(); registerProfileComponent<TransformationRulesPassConfiguration>( \"transformation-rules\", [](TransformationRulesPassConfiguration const& config, ProfileGenerator* ptr, Profile& profile) { auto& ret = ptr->modulePassManager(); // Default optimisation pipeline if (config.shouldSimplifyPriorTransform()) { auto& pass_builder = ptr->passBuilder(); llvm::ModulePassManager pipeline = pass_builder.buildPerModuleDefaultPipeline(ptr->optimisationLevel()); ret.addPass(std::move(pipeline)); } // Defining the mapping RuleSet rule_set; auto factory = RuleFactory(rule_set, profile.getQubitAllocationManager(), profile.getResultAllocationManager()); factory.usingConfiguration(ptr->configurationManager().get<FactoryConfiguration>()); // Creating profile pass ret.addPass(TransformationRulesPass(std::move(rule_set), config, &profile)); }); registerProfileComponent<LlvmPassesConfiguration>( \"llvm-passes\", [](LlvmPassesConfiguration const& cfg, ProfileGenerator* ptr, Profile&) { auto pass_pipeline = cfg.passPipeline(); if (!pass_pipeline.empty()) { auto& pass_builder = ptr->passBuilder(); auto& npm = ptr->modulePassManager(); if (!pass_builder.parsePassPipeline(npm, pass_pipeline, false, false)) { throw std::runtime_error(\"Failed to set pass pipeline up.\"); } } else if (cfg.alwaysInline()) { auto& ret = ptr->modulePassManager(); auto& pass_builder = ptr->passBuilder(); ret.addPass(llvm::AlwaysInlinerPass()); auto inliner_pass = pass_builder.buildInlinerPipeline( ptr->optimisationLevel(), llvm::PassBuilder::ThinLTOPhase::None, ptr->isDebugMode()); ret.addPass(std::move(inliner_pass)); } else if (!cfg.disableDefaultPipeline()) { auto& mpm = ptr->modulePassManager(); // If not explicitly disabled, we fall back to the default LLVM pipeline auto& pass_builder = ptr->passBuilder(); llvm::ModulePassManager pipeline1 = pass_builder.buildPerModuleDefaultPipeline(ptr->optimisationLevel()); mpm.addPass(std::move(pipeline1)); llvm::ModulePassManager pipeline2 = pass_builder.buildModuleSimplificationPipeline( ptr->optimisationLevel(), llvm::PassBuilder::ThinLTOPhase::None); mpm.addPass(std::move(pipeline2)); } }); } DefaultProfileGenerator::DefaultProfileGenerator( ConfigureFunction const& configure, TransformationRulesPassConfiguration const& profile_pass_config, LlvmPassesConfiguration const& llvm_config) { configurationManager().addConfig<ValidationPassConfiguration>(); registerProfileComponent<TransformationRulesPassConfiguration>( \"transformation-rules\", [configure](TransformationRulesPassConfiguration const& config, ProfileGenerator* ptr, Profile& profile) { auto& ret = ptr->modulePassManager(); // Default optimisation pipeline if (config.shouldSimplifyPriorTransform()) { auto& pass_builder = ptr->passBuilder(); llvm::ModulePassManager pipeline = pass_builder.buildPerModuleDefaultPipeline(ptr->optimisationLevel()); ret.addPass(std::move(pipeline)); } // Defining the mapping RuleSet rule_set; auto factory = RuleFactory(rule_set, profile.getQubitAllocationManager(), profile.getResultAllocationManager()); configure(rule_set); // Creating profile pass ret.addPass(TransformationRulesPass(std::move(rule_set), config, &profile)); }); registerProfileComponent<LlvmPassesConfiguration>( \"llvm-passes\", [](LlvmPassesConfiguration const& cfg, ProfileGenerator* ptr, Profile&) { auto pass_pipeline = cfg.passPipeline(); if (!pass_pipeline.empty()) { auto& pass_builder = ptr->passBuilder(); auto& npm = ptr->modulePassManager(); if (!pass_builder.parsePassPipeline(npm, pass_pipeline, false, false)) { throw std::runtime_error(\"Failed to set pass pipeline up.\"); } } else if (cfg.alwaysInline()) { auto& ret = ptr->modulePassManager(); auto& pass_builder = ptr->passBuilder(); ret.addPass(llvm::AlwaysInlinerPass()); auto inliner_pass = pass_builder.buildInlinerPipeline( ptr->optimisationLevel(), llvm::PassBuilder::ThinLTOPhase::None, ptr->isDebugMode()); ret.addPass(std::move(inliner_pass)); } else if (!cfg.disableDefaultPipeline()) { auto& mpm = ptr->modulePassManager(); // If not explicitly disabled, we fall back to the default LLVM pipeline auto& pass_builder = ptr->passBuilder(); llvm::ModulePassManager pipeline1 = pass_builder.buildPerModuleDefaultPipeline(ptr->optimisationLevel()); mpm.addPass(std::move(pipeline1)); llvm::ModulePassManager pipeline2 = pass_builder.buildModuleSimplificationPipeline( ptr->optimisationLevel(), llvm::PassBuilder::ThinLTOPhase::None); mpm.addPass(std::move(pipeline2)); } }); configurationManager().setConfig(profile_pass_config); configurationManager().setConfig(llvm_config); } TransformationRulesPassConfiguration const& DefaultProfileGenerator::ruleTransformationConfig() const { return configurationManager().get<TransformationRulesPassConfiguration>(); } LlvmPassesConfiguration const& DefaultProfileGenerator::llvmPassesConfig() const { return configurationManager().get<LlvmPassesConfiguration>(); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_default_profile_generator_8hpp/","text":"Generators/DefaultProfileGenerator.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::DefaultProfileGenerator Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"Generators/LlvmPassesConfiguration.hpp\" #include \"Generators/ProfileGenerator.hpp\" #include \"Rules/FactoryConfig.hpp\" #include \"Rules/RuleSet.hpp\" #include \"TransformationRulesPass/TransformationRulesPassConfiguration.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { class DefaultProfileGenerator : public ProfileGenerator { public: using ConfigureFunction = std::function<void(RuleSet&)>; DefaultProfileGenerator(); explicit DefaultProfileGenerator( ConfigureFunction const& configure, TransformationRulesPassConfiguration const& profile_pass_config = TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration const& llvm_config = LlvmPassesConfiguration()); // Shorthand notation to access configurations // TransformationRulesPassConfiguration const& ruleTransformationConfig() const; LlvmPassesConfiguration const& llvmPassesConfig() const; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Generators/DefaultProfileGenerator.hpp"},{"location":"Api/Files/_default_profile_generator_8hpp/#generatorsdefaultprofilegeneratorhpp","text":"","title":"Generators/DefaultProfileGenerator.hpp"},{"location":"Api/Files/_default_profile_generator_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_default_profile_generator_8hpp/#classes","text":"Name class microsoft::quantum::DefaultProfileGenerator","title":"Classes"},{"location":"Api/Files/_default_profile_generator_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"Generators/LlvmPassesConfiguration.hpp\" #include \"Generators/ProfileGenerator.hpp\" #include \"Rules/FactoryConfig.hpp\" #include \"Rules/RuleSet.hpp\" #include \"TransformationRulesPass/TransformationRulesPassConfiguration.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { class DefaultProfileGenerator : public ProfileGenerator { public: using ConfigureFunction = std::function<void(RuleSet&)>; DefaultProfileGenerator(); explicit DefaultProfileGenerator( ConfigureFunction const& configure, TransformationRulesPassConfiguration const& profile_pass_config = TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration const& llvm_config = LlvmPassesConfiguration()); // Shorthand notation to access configurations // TransformationRulesPassConfiguration const& ruleTransformationConfig() const; LlvmPassesConfiguration const& llvmPassesConfig() const; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_disable_alias_counting_8cpp/","text":"Rules/Tests/Unit/DisableAliasCounting.cpp Functions Name TEST (RuleSetTestSuite , DISABLED_DisablingArrayhAliasCounting ) TEST (RuleSetTestSuite , DisablingStringAliasCounting ) TEST (RuleSetTestSuite , DisablingResultAliasCounting ) Functions Documentation function TEST TEST( RuleSetTestSuite , DISABLED_DisablingArrayhAliasCounting ) function TEST TEST( RuleSetTestSuite , DisablingStringAliasCounting ) function TEST TEST( RuleSetTestSuite , DisablingResultAliasCounting ) Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareOpaque(\"String\"); ir_manip->declareOpaque(\"Array\"); ir_manip->declareFunction(\"%Array* @__quantum__rt__array_create_1d(i32, i64)\"); ir_manip->declareFunction(\"%String* @__quantum__rt__string_create(i8*)\"); ir_manip->declareFunction(\"%Result* @__quantum__qis__m__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__rt__array_update_alias_count(%Array*, i32)\"); ir_manip->declareFunction(\"void @__quantum__rt__string_update_alias_count(%String*, i32)\"); ir_manip->declareFunction(\"void @__quantum__rt__result_update_alias_count(%Result*, i32)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(RuleSetTestSuite, DISABLED_DisablingArrayhAliasCounting) { auto ir_manip = newIrManip(R\"script( %0 = call %Array* @__quantum__rt__array_create_1d(i32 8, i64 2) call void @__quantum__rt__array_update_alias_count(%Array* %0, i32 1) call void @__quantum__rt__array_update_alias_count(%Array* %0, i32 -1) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.disableAliasCounting(); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); // We expect that the calls are there initially EXPECT_TRUE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__array_update_alias_count(%Array* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__array_update_alias_count(%Array* %0, i32 1)\"})); EXPECT_TRUE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__array_update_alias_count(%Array* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__array_update_alias_count(%Array* %0, i32 -1)\"})); ir_manip->applyProfile(profile); EXPECT_TRUE( ir_manip->hasInstructionSequence({\"%0 = tail call %Array* @__quantum__rt__array_create_1d(i32 8, i64 2)\"})); // We expect that the call was removed EXPECT_FALSE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__array_update_alias_count(%Array* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__array_update_alias_count(%Array* %0, i32 1)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__array_update_alias_count(%Array* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__array_update_alias_count(%Array* %0, i32 -1)\"})); } TEST(RuleSetTestSuite, DisablingStringAliasCounting) { auto ir_manip = newIrManip(R\"script( %0 = call %String* @__quantum__rt__string_create(i8* null) call void @__quantum__rt__string_update_alias_count(%String* %0, i32 1) call void @__quantum__rt__string_update_alias_count(%String* %0, i32 -1) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.disableAliasCounting(); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); // We expect that the calls are there initially EXPECT_TRUE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__string_update_alias_count(%String* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__string_update_alias_count(%String* %0, i32 1)\"})); EXPECT_TRUE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__string_update_alias_count(%String* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__string_update_alias_count(%String* %0, i32 -1)\"})); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence({\"%0 = tail call %String* @__quantum__rt__string_create(i8* null)\"})); // We expect that the call was removed EXPECT_FALSE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__string_update_alias_count(%String* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__string_update_alias_count(%String* %0, i32 1)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__string_update_alias_count(%String* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__string_update_alias_count(%String* %0, i32 -1)\"})); } TEST(RuleSetTestSuite, DisablingResultAliasCounting) { auto ir_manip = newIrManip(R\"script( %0 = call %Result* @__quantum__qis__m__body(%Qubit* null) call void @__quantum__rt__result_update_alias_count(%Result* %0, i32 1) call void @__quantum__rt__result_update_alias_count(%Result* %0, i32 -1) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.disableAliasCounting(); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); // We expect that the calls are there initially EXPECT_TRUE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__result_update_alias_count(%Result* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__result_update_alias_count(%Result* %0, i32 1)\"})); EXPECT_TRUE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__result_update_alias_count(%Result* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__result_update_alias_count(%Result* %0, i32 -1)\"})); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence({\"%0 = tail call %Result* @__quantum__qis__m__body(%Qubit* null)\"})); // We expect that the call was removed EXPECT_FALSE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__result_update_alias_count(%Result* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__result_update_alias_count(%Result* %0, i32 1)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__result_update_alias_count(%Result* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__result_update_alias_count(%Result* %0, i32 -1)\"})); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Tests/Unit/DisableAliasCounting.cpp"},{"location":"Api/Files/_disable_alias_counting_8cpp/#rulestestsunitdisablealiascountingcpp","text":"","title":"Rules/Tests/Unit/DisableAliasCounting.cpp"},{"location":"Api/Files/_disable_alias_counting_8cpp/#functions","text":"Name TEST (RuleSetTestSuite , DISABLED_DisablingArrayhAliasCounting ) TEST (RuleSetTestSuite , DisablingStringAliasCounting ) TEST (RuleSetTestSuite , DisablingResultAliasCounting )","title":"Functions"},{"location":"Api/Files/_disable_alias_counting_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Files/_disable_alias_counting_8cpp/#function-test","text":"TEST( RuleSetTestSuite , DISABLED_DisablingArrayhAliasCounting )","title":"function TEST"},{"location":"Api/Files/_disable_alias_counting_8cpp/#function-test_1","text":"TEST( RuleSetTestSuite , DisablingStringAliasCounting )","title":"function TEST"},{"location":"Api/Files/_disable_alias_counting_8cpp/#function-test_2","text":"TEST( RuleSetTestSuite , DisablingResultAliasCounting )","title":"function TEST"},{"location":"Api/Files/_disable_alias_counting_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareOpaque(\"String\"); ir_manip->declareOpaque(\"Array\"); ir_manip->declareFunction(\"%Array* @__quantum__rt__array_create_1d(i32, i64)\"); ir_manip->declareFunction(\"%String* @__quantum__rt__string_create(i8*)\"); ir_manip->declareFunction(\"%Result* @__quantum__qis__m__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__rt__array_update_alias_count(%Array*, i32)\"); ir_manip->declareFunction(\"void @__quantum__rt__string_update_alias_count(%String*, i32)\"); ir_manip->declareFunction(\"void @__quantum__rt__result_update_alias_count(%Result*, i32)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(RuleSetTestSuite, DISABLED_DisablingArrayhAliasCounting) { auto ir_manip = newIrManip(R\"script( %0 = call %Array* @__quantum__rt__array_create_1d(i32 8, i64 2) call void @__quantum__rt__array_update_alias_count(%Array* %0, i32 1) call void @__quantum__rt__array_update_alias_count(%Array* %0, i32 -1) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.disableAliasCounting(); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); // We expect that the calls are there initially EXPECT_TRUE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__array_update_alias_count(%Array* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__array_update_alias_count(%Array* %0, i32 1)\"})); EXPECT_TRUE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__array_update_alias_count(%Array* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__array_update_alias_count(%Array* %0, i32 -1)\"})); ir_manip->applyProfile(profile); EXPECT_TRUE( ir_manip->hasInstructionSequence({\"%0 = tail call %Array* @__quantum__rt__array_create_1d(i32 8, i64 2)\"})); // We expect that the call was removed EXPECT_FALSE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__array_update_alias_count(%Array* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__array_update_alias_count(%Array* %0, i32 1)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__array_update_alias_count(%Array* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__array_update_alias_count(%Array* %0, i32 -1)\"})); } TEST(RuleSetTestSuite, DisablingStringAliasCounting) { auto ir_manip = newIrManip(R\"script( %0 = call %String* @__quantum__rt__string_create(i8* null) call void @__quantum__rt__string_update_alias_count(%String* %0, i32 1) call void @__quantum__rt__string_update_alias_count(%String* %0, i32 -1) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.disableAliasCounting(); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); // We expect that the calls are there initially EXPECT_TRUE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__string_update_alias_count(%String* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__string_update_alias_count(%String* %0, i32 1)\"})); EXPECT_TRUE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__string_update_alias_count(%String* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__string_update_alias_count(%String* %0, i32 -1)\"})); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence({\"%0 = tail call %String* @__quantum__rt__string_create(i8* null)\"})); // We expect that the call was removed EXPECT_FALSE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__string_update_alias_count(%String* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__string_update_alias_count(%String* %0, i32 1)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__string_update_alias_count(%String* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__string_update_alias_count(%String* %0, i32 -1)\"})); } TEST(RuleSetTestSuite, DisablingResultAliasCounting) { auto ir_manip = newIrManip(R\"script( %0 = call %Result* @__quantum__qis__m__body(%Qubit* null) call void @__quantum__rt__result_update_alias_count(%Result* %0, i32 1) call void @__quantum__rt__result_update_alias_count(%Result* %0, i32 -1) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.disableAliasCounting(); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); // We expect that the calls are there initially EXPECT_TRUE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__result_update_alias_count(%Result* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__result_update_alias_count(%Result* %0, i32 1)\"})); EXPECT_TRUE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__result_update_alias_count(%Result* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__result_update_alias_count(%Result* %0, i32 -1)\"})); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence({\"%0 = tail call %Result* @__quantum__qis__m__body(%Qubit* null)\"})); // We expect that the call was removed EXPECT_FALSE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__result_update_alias_count(%Result* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__result_update_alias_count(%Result* %0, i32 1)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__result_update_alias_count(%Result* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__result_update_alias_count(%Result* %0, i32 -1)\"})); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_disable_reference_counting_8cpp/","text":"Rules/Tests/Unit/DisableReferenceCounting.cpp Functions Name TEST (RuleSetTestSuite , DISABLED_DisablingArrayhReferenceCounting ) TEST (RuleSetTestSuite , DisablingStringReferenceCounting ) TEST (RuleSetTestSuite , DisablingResultReferenceCounting ) Functions Documentation function TEST TEST( RuleSetTestSuite , DISABLED_DisablingArrayhReferenceCounting ) function TEST TEST( RuleSetTestSuite , DisablingStringReferenceCounting ) function TEST TEST( RuleSetTestSuite , DisablingResultReferenceCounting ) Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareOpaque(\"String\"); ir_manip->declareOpaque(\"Array\"); ir_manip->declareFunction(\"%Array* @__quantum__rt__array_create_1d(i32, i64)\"); ir_manip->declareFunction(\"%String* @__quantum__rt__string_create(i8*)\"); ir_manip->declareFunction(\"%Result* @__quantum__qis__m__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__rt__array_update_reference_count(%Array*, i32)\"); ir_manip->declareFunction(\"void @__quantum__rt__string_update_reference_count(%String*, i32)\"); ir_manip->declareFunction(\"void @__quantum__rt__result_update_reference_count(%Result*, i32)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(RuleSetTestSuite, DISABLED_DisablingArrayhReferenceCounting) { auto ir_manip = newIrManip(R\"script( %0 = call %Array* @__quantum__rt__array_create_1d(i32 8, i64 2) call void @__quantum__rt__array_update_reference_count(%Array* %0, i32 1) call void @__quantum__rt__array_update_reference_count(%Array* %0, i32 -1) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.disableReferenceCounting(); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); // We expect that the calls are there initially EXPECT_TRUE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__array_update_reference_count(%Array* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__array_update_reference_count(%Array* %0, i32 1)\"})); EXPECT_TRUE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__array_update_reference_count(%Array* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__array_update_reference_count(%Array* %0, i32 -1)\"})); ir_manip->applyProfile(profile); EXPECT_TRUE( ir_manip->hasInstructionSequence({\"%0 = tail call %Array* @__quantum__rt__array_create_1d(i32 8, i64 2)\"})); // We expect that the call was removed EXPECT_FALSE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__array_update_reference_count(%Array* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__array_update_reference_count(%Array* %0, i32 1)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__array_update_reference_count(%Array* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__array_update_reference_count(%Array* %0, i32 -1)\"})); } TEST(RuleSetTestSuite, DisablingStringReferenceCounting) { auto ir_manip = newIrManip(R\"script( %0 = call %String* @__quantum__rt__string_create(i8* null) call void @__quantum__rt__string_update_reference_count(%String* %0, i32 1) call void @__quantum__rt__string_update_reference_count(%String* %0, i32 -1) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.disableReferenceCounting(); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); // We expect that the calls are there initially EXPECT_TRUE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__string_update_reference_count(%String* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__string_update_reference_count(%String* %0, i32 1)\"})); EXPECT_TRUE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__string_update_reference_count(%String* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__string_update_reference_count(%String* %0, i32 -1)\"})); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence({\"%0 = tail call %String* @__quantum__rt__string_create(i8* null)\"})); // We expect that the call was removed EXPECT_FALSE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__string_update_reference_count(%String* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__string_update_reference_count(%String* %0, i32 1)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__string_update_reference_count(%String* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__string_update_reference_count(%String* %0, i32 -1)\"})); } TEST(RuleSetTestSuite, DisablingResultReferenceCounting) { auto ir_manip = newIrManip(R\"script( %0 = call %Result* @__quantum__qis__m__body(%Qubit* null) call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 1) call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 -1) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.disableReferenceCounting(); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); // We expect that the calls are there initially EXPECT_TRUE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 1)\"})); EXPECT_TRUE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 -1)\"})); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence({\"%0 = tail call %Result* @__quantum__qis__m__body(%Qubit* null)\"})); // We expect that the call was removed EXPECT_FALSE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 1)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 -1)\"})); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Tests/Unit/DisableReferenceCounting.cpp"},{"location":"Api/Files/_disable_reference_counting_8cpp/#rulestestsunitdisablereferencecountingcpp","text":"","title":"Rules/Tests/Unit/DisableReferenceCounting.cpp"},{"location":"Api/Files/_disable_reference_counting_8cpp/#functions","text":"Name TEST (RuleSetTestSuite , DISABLED_DisablingArrayhReferenceCounting ) TEST (RuleSetTestSuite , DisablingStringReferenceCounting ) TEST (RuleSetTestSuite , DisablingResultReferenceCounting )","title":"Functions"},{"location":"Api/Files/_disable_reference_counting_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Files/_disable_reference_counting_8cpp/#function-test","text":"TEST( RuleSetTestSuite , DISABLED_DisablingArrayhReferenceCounting )","title":"function TEST"},{"location":"Api/Files/_disable_reference_counting_8cpp/#function-test_1","text":"TEST( RuleSetTestSuite , DisablingStringReferenceCounting )","title":"function TEST"},{"location":"Api/Files/_disable_reference_counting_8cpp/#function-test_2","text":"TEST( RuleSetTestSuite , DisablingResultReferenceCounting )","title":"function TEST"},{"location":"Api/Files/_disable_reference_counting_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareOpaque(\"String\"); ir_manip->declareOpaque(\"Array\"); ir_manip->declareFunction(\"%Array* @__quantum__rt__array_create_1d(i32, i64)\"); ir_manip->declareFunction(\"%String* @__quantum__rt__string_create(i8*)\"); ir_manip->declareFunction(\"%Result* @__quantum__qis__m__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__rt__array_update_reference_count(%Array*, i32)\"); ir_manip->declareFunction(\"void @__quantum__rt__string_update_reference_count(%String*, i32)\"); ir_manip->declareFunction(\"void @__quantum__rt__result_update_reference_count(%Result*, i32)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(RuleSetTestSuite, DISABLED_DisablingArrayhReferenceCounting) { auto ir_manip = newIrManip(R\"script( %0 = call %Array* @__quantum__rt__array_create_1d(i32 8, i64 2) call void @__quantum__rt__array_update_reference_count(%Array* %0, i32 1) call void @__quantum__rt__array_update_reference_count(%Array* %0, i32 -1) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.disableReferenceCounting(); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); // We expect that the calls are there initially EXPECT_TRUE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__array_update_reference_count(%Array* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__array_update_reference_count(%Array* %0, i32 1)\"})); EXPECT_TRUE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__array_update_reference_count(%Array* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__array_update_reference_count(%Array* %0, i32 -1)\"})); ir_manip->applyProfile(profile); EXPECT_TRUE( ir_manip->hasInstructionSequence({\"%0 = tail call %Array* @__quantum__rt__array_create_1d(i32 8, i64 2)\"})); // We expect that the call was removed EXPECT_FALSE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__array_update_reference_count(%Array* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__array_update_reference_count(%Array* %0, i32 1)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__array_update_reference_count(%Array* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__array_update_reference_count(%Array* %0, i32 -1)\"})); } TEST(RuleSetTestSuite, DisablingStringReferenceCounting) { auto ir_manip = newIrManip(R\"script( %0 = call %String* @__quantum__rt__string_create(i8* null) call void @__quantum__rt__string_update_reference_count(%String* %0, i32 1) call void @__quantum__rt__string_update_reference_count(%String* %0, i32 -1) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.disableReferenceCounting(); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); // We expect that the calls are there initially EXPECT_TRUE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__string_update_reference_count(%String* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__string_update_reference_count(%String* %0, i32 1)\"})); EXPECT_TRUE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__string_update_reference_count(%String* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__string_update_reference_count(%String* %0, i32 -1)\"})); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence({\"%0 = tail call %String* @__quantum__rt__string_create(i8* null)\"})); // We expect that the call was removed EXPECT_FALSE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__string_update_reference_count(%String* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__string_update_reference_count(%String* %0, i32 1)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__string_update_reference_count(%String* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__string_update_reference_count(%String* %0, i32 -1)\"})); } TEST(RuleSetTestSuite, DisablingResultReferenceCounting) { auto ir_manip = newIrManip(R\"script( %0 = call %Result* @__quantum__qis__m__body(%Qubit* null) call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 1) call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 -1) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.disableReferenceCounting(); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); // We expect that the calls are there initially EXPECT_TRUE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 1)\"})); EXPECT_TRUE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 -1)\"})); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence({\"%0 = tail call %Result* @__quantum__qis__m__body(%Qubit* null)\"})); // We expect that the call was removed EXPECT_FALSE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 1)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence( {\"call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 -1)\"}) || ir_manip->hasInstructionSequence( {\"tail call void @__quantum__rt__result_update_reference_count(%Result* %0, i32 -1)\"})); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_disable_strings_8cpp/","text":"Rules/Tests/Unit/DisableStrings.cpp Functions Name TEST (RuleSetTestSuite , DisablingStrings ) Functions Documentation function TEST TEST( RuleSetTestSuite , DisablingStrings ) Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareOpaque(\"String\"); ir_manip->declareOpaque(\"Array\"); ir_manip->declareFunction(\"%String* @__quantum__rt__string_create(i8*)\"); ir_manip->declareFunction(\"void @__quantum__rt__message(%String*)\"); ir_manip->declareFunction(\"void @__quantum__rt__string_update_alias_count(%String*, i32)\"); ir_manip->declareFunction(\"void @__quantum__rt__string_update_reference_count(%String*, i32)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace TEST(RuleSetTestSuite, DisablingStrings) { auto ir_manip = newIrManip(R\"script( %0 = call %String* @__quantum__rt__string_create(i8* null) call void @__quantum__rt__string_update_reference_count(%String* %0, i32 1) call void @__quantum__rt__string_update_alias_count(%String* %0, i32 1) call void @__quantum__rt__message(%String* %0) call void @__quantum__rt__string_update_alias_count(%String* %0, i32 -1) call void @__quantum__rt__string_update_reference_count(%String* %0, i32 -11) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.disableStringSupport(); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); ir_manip->applyProfile(profile); // We expect that the call was removed EXPECT_EQ(ir_manip->toBodyInstructions(), IrManipulationTestHelper::Strings{\"ret i8 0\"}); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Tests/Unit/DisableStrings.cpp"},{"location":"Api/Files/_disable_strings_8cpp/#rulestestsunitdisablestringscpp","text":"","title":"Rules/Tests/Unit/DisableStrings.cpp"},{"location":"Api/Files/_disable_strings_8cpp/#functions","text":"Name TEST (RuleSetTestSuite , DisablingStrings )","title":"Functions"},{"location":"Api/Files/_disable_strings_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Files/_disable_strings_8cpp/#function-test","text":"TEST( RuleSetTestSuite , DisablingStrings )","title":"function TEST"},{"location":"Api/Files/_disable_strings_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareOpaque(\"String\"); ir_manip->declareOpaque(\"Array\"); ir_manip->declareFunction(\"%String* @__quantum__rt__string_create(i8*)\"); ir_manip->declareFunction(\"void @__quantum__rt__message(%String*)\"); ir_manip->declareFunction(\"void @__quantum__rt__string_update_alias_count(%String*, i32)\"); ir_manip->declareFunction(\"void @__quantum__rt__string_update_reference_count(%String*, i32)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace TEST(RuleSetTestSuite, DisablingStrings) { auto ir_manip = newIrManip(R\"script( %0 = call %String* @__quantum__rt__string_create(i8* null) call void @__quantum__rt__string_update_reference_count(%String* %0, i32 1) call void @__quantum__rt__string_update_alias_count(%String* %0, i32 1) call void @__quantum__rt__message(%String* %0) call void @__quantum__rt__string_update_alias_count(%String* %0, i32 -1) call void @__quantum__rt__string_update_reference_count(%String* %0, i32 -11) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.disableStringSupport(); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); ir_manip->applyProfile(profile); // We expect that the call was removed EXPECT_EQ(ir_manip->toBodyInstructions(), IrManipulationTestHelper::Strings{\"ret i8 0\"}); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_factory_8cpp/","text":"Rules/Factory.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Factory.hpp\" #include \"Rules/Notation/Notation.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { namespace { using Instruction = llvm::Instruction; using Value = llvm::Value; using Builder = ReplacementRule::Builder; using Captures = ReplacementRule::Captures; using Replacements = ReplacementRule::Replacements; } // namespace using ReplacementRulePtr = RuleFactory::ReplacementRulePtr; using namespace microsoft::quantum::notation; RuleFactory::RuleFactory( RuleSet& rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager) : rule_set_{rule_set} , qubit_alloc_manager_{std::move(qubit_alloc_manager)} , result_alloc_manager_{std::move(result_alloc_manager)} { } void RuleFactory::usingConfiguration(FactoryConfiguration const& config) { default_integer_width_ = config.defaultIntegerWidth(); if (config.disableReferenceCounting()) { disableReferenceCounting(); } if (config.disableAliasCounting()) { disableAliasCounting(); } if (config.disableStringSupport()) { disableStringSupport(); } if (config.optimiseResultOne()) { optimiseResultOne(); } if (config.optimiseResultZero()) { optimiseResultZero(); } if (config.useStaticQubitArrayAllocation()) { useStaticQubitArrayAllocation(); } if (config.useStaticQubitAllocation()) { useStaticQubitAllocation(); } if (config.useStaticResultAllocation()) { useStaticResultAllocation(); } } void RuleFactory::removeFunctionCall(String const& name) { addRule({callByNameOnly(name), deleteInstruction()}); } void RuleFactory::resolveConstantArraySizes() { auto size_replacer = [](Builder&, Value* val, Captures& cap, Replacements& replacements) { // Get the index and testing that it is a constant int auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"size\"]); if (cst == nullptr) { // ... if not, we cannot perform the mapping. return false; } val->replaceAllUsesWith(cst); replacements.push_back({llvm::dyn_cast<Instruction>(val), nullptr}); return true; }; llvm::errs() << \"Creating pattern\\n\"; auto create_array = call(\"__quantum__rt__array_create_1d\", \"elementSize\"_cap = _, \"size\"_cap = _); auto get_size = call(\"__quantum__rt__array_get_size_1d\", create_array); addRule({std::move(get_size), size_replacer}); } void RuleFactory::inlineCallables() { auto callable_replacer = [](Builder&, Value* val, Captures& captures, Replacements&) { llvm::errs() << \"FOUND CALLABLE\\n\"; llvm::errs() << *val << \"\\n\"; llvm::errs() << \"Calling \" << *captures[\"function\"] << \"\\n\"; return false; }; auto create_callable = call(\"__quantum__rt__callable_create\", \"function\"_cap = _, \"size\"_cap = _, _); auto invoke = call(\"__quantum__rt__callable_invoke\", create_callable, \"args\"_cap = _, \"ret\"_cap = _); addRule({std::move(invoke), callable_replacer}); } void RuleFactory::useStaticQubitArrayAllocation() { // TODO(issue-14): Use weak pointers to capture allocation managers auto qubit_alloc_manager = qubit_alloc_manager_; auto default_iw = default_integer_width_; auto allocation_replacer = [default_iw, qubit_alloc_manager](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"size\"]); if (cst == nullptr) { return false; } auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } if (cst == nullptr) { return false; } auto llvm_size = cst->getValue(); auto name = val->getName().str(); auto size = llvm_size.getZExtValue(); auto offset = qubit_alloc_manager->allocate(name, size); // Creating a new index APInt that is shifted by the offset of the allocation auto idx = llvm::APInt(default_iw, offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto instr = new llvm::IntToPtrInst(new_index, ptr_type); instr->takeName(val); // Replacing the instruction with new instruction auto old_instr = llvm::dyn_cast<Instruction>(val); // Safety precaution to ensure that we are dealing with a Instruction if (old_instr == nullptr) { return false; } // Ensuring that we have replaced the instruction before // identifying release old_instr->replaceAllUsesWith(instr); replacements.push_back({old_instr, instr}); return true; }; addRule({call(\"__quantum__rt__qubit_allocate_array\", \"size\"_cap = _), allocation_replacer}); auto access_replacer = [qubit_alloc_manager](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { // Getting the type pointer auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } // Get the index and testing that it is a constant int auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"index\"]); if (cst == nullptr) { // ... if not, we cannot perform the mapping. return false; } // Computing the index by getting the current index value and offsetting by // the offset at which the qubit array is allocated. auto offset_cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"arrayName\"]); if (offset_cst == nullptr) { return false; } auto llvm_offset = offset_cst->getValue(); auto offset = llvm_offset.getZExtValue(); // Creating a new index APInt that is shifted by the offset of the allocation auto llvm_size = cst->getValue(); auto idx = llvm::APInt(llvm_size.getBitWidth(), llvm_size.getZExtValue() + offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); // Converting pointer auto instr = new llvm::IntToPtrInst(new_index, ptr_type); instr->takeName(val); // Replacing the instruction with new instruction replacements.push_back({llvm::dyn_cast<Instruction>(val), instr}); // Deleting the getelement and cast operations replacements.push_back({llvm::dyn_cast<Instruction>(cap[\"getElement\"]), nullptr}); replacements.push_back({llvm::dyn_cast<Instruction>(cap[\"cast\"]), nullptr}); return true; }; auto get_element = call( \"__quantum__rt__array_get_element_ptr_1d\", intToPtr(\"arrayName\"_cap = constInt()), \"index\"_cap = constInt()); auto cast_pattern = bitCast(\"getElement\"_cap = get_element); auto load_pattern = load(\"cast\"_cap = cast_pattern); addRule({std::move(load_pattern), access_replacer}); auto deleter = deleteInstruction(); addRule( {call(\"__quantum__rt__qubit_release_array\", intToPtr(\"const\"_cap = constInt())), [qubit_alloc_manager, deleter](Builder& builder, Value* val, Captures& cap, Replacements& rep) { // Recovering the qubit id auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"const\"]); if (cst == nullptr) { return false; } auto address = cst->getValue().getZExtValue(); // Releasing qubit_alloc_manager->release(address); // Deleting instruction return deleter(builder, val, cap, rep); }}); } void RuleFactory::useStaticQubitAllocation() { auto qubit_alloc_manager = qubit_alloc_manager_; auto default_iw = default_integer_width_; auto allocation_replacer = [default_iw, qubit_alloc_manager](Builder& builder, Value* val, Captures&, Replacements& replacements) { // Getting the type pointer auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } auto qubit_name = val->getName().str(); // Computing the index by getting the current index value and offseting by // the offset at which the qubit array is allocated. auto offset = qubit_alloc_manager->allocate(qubit_name); // Creating a new index APInt that is shifted by the offset of the allocation auto idx = llvm::APInt(default_iw, offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto instr = new llvm::IntToPtrInst(new_index, ptr_type); instr->takeName(val); // Replacing the instruction with new instruction auto old_instr = llvm::dyn_cast<Instruction>(val); // Safety precaution to ensure that we are dealing with a Instruction if (old_instr == nullptr) { return false; } // Ensuring that we have replaced the instruction before // identifying release old_instr->replaceAllUsesWith(instr); replacements.push_back({old_instr, instr}); return true; }; // Dealing with qubit allocation addRule({call(\"__quantum__rt__qubit_allocate\"), allocation_replacer}); auto deleter = deleteInstruction(); // Handling the case where a constant integer is cast to a pointer and the pointer // is used in a call to qubit_release: // // %0 = inttoptr i64 0 to %Qubit* // call void @__quantum__rt__qubit_release(%Qubit* %0 // // The case of named addresses are also covered, by this pattern: // %leftMessage = inttoptr i64 0 to %Qubit* // call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) addRule( {call(\"__quantum__rt__qubit_release\", intToPtr(\"const\"_cap = constInt())), [qubit_alloc_manager, deleter](Builder& builder, Value* val, Captures& cap, Replacements& rep) { // Recovering the qubit id auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"const\"]); if (cst == nullptr) { return false; } auto address = cst->getValue().getZExtValue(); // Releasing qubit_alloc_manager->release(address); // Deleting instruction return deleter(builder, val, cap, rep); }}); // Handling where allocation is done by non-standard functions. In // this rule reports an error as we cannot reliably do a mapping. // // %leftMessage = call %Qubit* @__non_standard_allocator() // call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) addRule( {call(\"__quantum__rt__qubit_release\", \"name\"_cap = _), [qubit_alloc_manager, deleter](Builder& builder, Value* val, Captures& cap, Replacements& rep) { // Getting the name auto name = cap[\"name\"]->getName().str(); // Returning in case the name comes out empty if (name.empty()) { // TODO(issue-15): report error llvm::outs() << \"FAILED due to unnamed non standard allocation:\\n\"; llvm::outs() << *val << \"\\n\\n\"; // Deleting the instruction in order to proceed // and trying to discover as many other errors as possible return deleter(builder, val, cap, rep); } // TODO(issue-15): report error llvm::outs() << \"FAILED due to non standard allocation:\\n\"; llvm::outs() << *cap[\"name\"] << \"\\n\"; llvm::outs() << *val << \"\\n\\n\"; return deleter(builder, val, cap, rep); } }); } void RuleFactory::useStaticResultAllocation() { auto result_alloc_manager = result_alloc_manager_; auto default_iw = default_integer_width_; auto replace_measurement = [default_iw, result_alloc_manager]( Builder& builder, Value* val, Captures& cap, Replacements& replacements) { // Getting the type pointer auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } // Computing the index by getting the current index value and offseting by // the offset at which the qubit array is allocated. auto offset = result_alloc_manager->allocate(); // Creating a new index APInt that is shifted by the offset of the allocation auto idx = llvm::APInt(default_iw, offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto instr = new llvm::IntToPtrInst(new_index, ptr_type); if (instr == nullptr) { return false; } instr->takeName(val); auto orig_instr = llvm::dyn_cast<llvm::Instruction>(val); if (orig_instr == nullptr) { return false; } auto module = orig_instr->getModule(); auto fnc = module->getFunction(\"__quantum__qis__mz__body\"); std::vector<llvm::Value*> arguments; arguments.push_back(cap[\"qubit\"]); arguments.push_back(instr); if (!fnc) { std::vector<llvm::Type*> types; types.resize(arguments.size()); for (uint64_t i = 0; i < types.size(); ++i) { types[i] = arguments[i]->getType(); } auto return_type = llvm::Type::getVoidTy(val->getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create( fnc_type, llvm::Function::ExternalLinkage, \"__quantum__qis__mz__body\", module); } // Ensuring we are inserting after the instruction being deleted builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(val)->getNextNode()); builder.CreateCall(fnc, arguments); // Replacing the instruction with new instruction replacements.push_back({llvm::dyn_cast<Instruction>(val), instr}); return true; }; // This rules identifies result allocations through the function \"__quantum__qis__m__body\". // As an example, the following // // %result1 = call %Result* @__quantum__qis__m__body(%Qubit* %0) // // translates into // // %result1 = inttoptr i64 0 to %Result* // call void @__quantum__qis__mz__body(%Qubit* %0, %Result* %result1) addRule({call(\"__quantum__qis__m__body\", \"qubit\"_cap = _), std::move(replace_measurement)}); } void RuleFactory::optimiseResultZero() { auto replace_branch_negative = [](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto cond = llvm::dyn_cast<llvm::Instruction>(val); if (cond == nullptr) { return false; } auto result = cap[\"result\"]; // Replacing result auto orig_instr = llvm::dyn_cast<llvm::Instruction>(val); if (orig_instr == nullptr) { return false; } auto module = orig_instr->getModule(); auto fnc = module->getFunction(\"__quantum__qis__read_result__body\"); std::vector<llvm::Value*> arguments; arguments.push_back(result); if (!fnc) { std::vector<llvm::Type*> types; types.resize(arguments.size()); for (uint64_t i = 0; i < types.size(); ++i) { types[i] = arguments[i]->getType(); } auto return_type = llvm::Type::getInt1Ty(val->getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create( fnc_type, llvm::Function::ExternalLinkage, \"__quantum__qis__read_result__body\", module); } builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(val)); auto new_call = builder.CreateCall(fnc, arguments); auto new_cond = builder.CreateNot(new_call); new_cond->takeName(cond); for (auto& use : cond->uses()) { llvm::User* user = use.getUser(); user->setOperand(use.getOperandNo(), new_cond); } cond->replaceAllUsesWith(new_cond); // Deleting the previous condition and function to fetch one replacements.push_back({cond, nullptr}); replacements.push_back({cap[\"zero\"], nullptr}); return true; }; /* Here is an example IR for which we want to make a match: %1 = call %Result* @__quantum__rt__result_get_zero() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 */ // Variations of get_one auto get_zero = call(\"__quantum__rt__result_get_zero\"); addRule( {call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"zero\"_cap = get_zero), replace_branch_negative}); addRule( {call(\"__quantum__rt__result_equal\", \"zero\"_cap = get_zero, \"result\"_cap = _), replace_branch_negative}); } void RuleFactory::optimiseResultOne() { auto replace_branch_positive = [](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto cond = llvm::dyn_cast<llvm::Instruction>(val); if (cond == nullptr) { return false; } auto result = cap[\"result\"]; // Replacing result auto orig_instr = llvm::dyn_cast<llvm::Instruction>(val); if (orig_instr == nullptr) { return false; } auto module = orig_instr->getModule(); auto fnc = module->getFunction(\"__quantum__qis__read_result__body\"); std::vector<llvm::Value*> arguments; arguments.push_back(result); if (!fnc) { std::vector<llvm::Type*> types; types.resize(arguments.size()); for (uint64_t i = 0; i < types.size(); ++i) { types[i] = arguments[i]->getType(); } auto return_type = llvm::Type::getInt1Ty(val->getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create( fnc_type, llvm::Function::ExternalLinkage, \"__quantum__qis__read_result__body\", module); } builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(val)); auto new_call = builder.CreateCall(fnc, arguments); new_call->takeName(cond); for (auto& use : cond->uses()) { llvm::User* user = use.getUser(); user->setOperand(use.getOperandNo(), new_call); } cond->replaceAllUsesWith(new_call); // Deleting the previous condition and function to fetch one replacements.push_back({cond, nullptr}); replacements.push_back({cap[\"one\"], nullptr}); return true; }; /* Here is an example IR for which we want to make a match: %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 */ // Variations of get_one auto get_one = call(\"__quantum__rt__result_get_one\"); addRule({call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), replace_branch_positive}); addRule({call(\"__quantum__rt__result_equal\", \"one\"_cap = get_one, \"result\"_cap = _), replace_branch_positive}); } void RuleFactory::disableReferenceCounting() { // removeFunctionCall(\"__quantum__rt__array_update_reference_count\"); removeFunctionCall(\"__quantum__rt__string_update_reference_count\"); removeFunctionCall(\"__quantum__rt__result_update_reference_count\"); } void RuleFactory::disableAliasCounting() { // removeFunctionCall(\"__quantum__rt__array_update_alias_count\"); removeFunctionCall(\"__quantum__rt__string_update_alias_count\"); removeFunctionCall(\"__quantum__rt__result_update_alias_count\"); } void RuleFactory::disableStringSupport() { removeFunctionCall(\"__quantum__rt__fail\"); removeFunctionCall(\"__quantum__rt__message\"); removeFunctionCall(\"__quantum__rt__string_update_alias_count\"); removeFunctionCall(\"__quantum__rt__string_create\"); removeFunctionCall(\"__quantum__rt__string_get_data\"); removeFunctionCall(\"__quantum__rt__string_get_length\"); removeFunctionCall(\"__quantum__rt__string_update_reference_count\"); removeFunctionCall(\"__quantum__rt__string_concatenate\"); removeFunctionCall(\"__quantum__rt__string_equal\"); removeFunctionCall(\"__quantum__rt__int_to_string\"); removeFunctionCall(\"__quantum__rt__double_to_string\"); removeFunctionCall(\"__quantum__rt__bool_to_string\"); removeFunctionCall(\"__quantum__rt__result_to_string\"); removeFunctionCall(\"__quantum__rt__pauli_to_string\"); removeFunctionCall(\"__quantum__rt__qubit_to_string\"); removeFunctionCall(\"__quantum__rt__range_to_string\"); removeFunctionCall(\"__quantum__rt__bigint_to_string\"); } ReplacementRulePtr RuleFactory::addRule(ReplacementRule&& rule) { auto ret = std::make_shared<ReplacementRule>(std::move(rule)); rule_set_.addRule(ret); return ret; } void RuleFactory::setDefaultIntegerWidth(uint32_t v) { default_integer_width_ = v; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Factory.cpp"},{"location":"Api/Files/_factory_8cpp/#rulesfactorycpp","text":"","title":"Rules/Factory.cpp"},{"location":"Api/Files/_factory_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_factory_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Factory.hpp\" #include \"Rules/Notation/Notation.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { namespace { using Instruction = llvm::Instruction; using Value = llvm::Value; using Builder = ReplacementRule::Builder; using Captures = ReplacementRule::Captures; using Replacements = ReplacementRule::Replacements; } // namespace using ReplacementRulePtr = RuleFactory::ReplacementRulePtr; using namespace microsoft::quantum::notation; RuleFactory::RuleFactory( RuleSet& rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager) : rule_set_{rule_set} , qubit_alloc_manager_{std::move(qubit_alloc_manager)} , result_alloc_manager_{std::move(result_alloc_manager)} { } void RuleFactory::usingConfiguration(FactoryConfiguration const& config) { default_integer_width_ = config.defaultIntegerWidth(); if (config.disableReferenceCounting()) { disableReferenceCounting(); } if (config.disableAliasCounting()) { disableAliasCounting(); } if (config.disableStringSupport()) { disableStringSupport(); } if (config.optimiseResultOne()) { optimiseResultOne(); } if (config.optimiseResultZero()) { optimiseResultZero(); } if (config.useStaticQubitArrayAllocation()) { useStaticQubitArrayAllocation(); } if (config.useStaticQubitAllocation()) { useStaticQubitAllocation(); } if (config.useStaticResultAllocation()) { useStaticResultAllocation(); } } void RuleFactory::removeFunctionCall(String const& name) { addRule({callByNameOnly(name), deleteInstruction()}); } void RuleFactory::resolveConstantArraySizes() { auto size_replacer = [](Builder&, Value* val, Captures& cap, Replacements& replacements) { // Get the index and testing that it is a constant int auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"size\"]); if (cst == nullptr) { // ... if not, we cannot perform the mapping. return false; } val->replaceAllUsesWith(cst); replacements.push_back({llvm::dyn_cast<Instruction>(val), nullptr}); return true; }; llvm::errs() << \"Creating pattern\\n\"; auto create_array = call(\"__quantum__rt__array_create_1d\", \"elementSize\"_cap = _, \"size\"_cap = _); auto get_size = call(\"__quantum__rt__array_get_size_1d\", create_array); addRule({std::move(get_size), size_replacer}); } void RuleFactory::inlineCallables() { auto callable_replacer = [](Builder&, Value* val, Captures& captures, Replacements&) { llvm::errs() << \"FOUND CALLABLE\\n\"; llvm::errs() << *val << \"\\n\"; llvm::errs() << \"Calling \" << *captures[\"function\"] << \"\\n\"; return false; }; auto create_callable = call(\"__quantum__rt__callable_create\", \"function\"_cap = _, \"size\"_cap = _, _); auto invoke = call(\"__quantum__rt__callable_invoke\", create_callable, \"args\"_cap = _, \"ret\"_cap = _); addRule({std::move(invoke), callable_replacer}); } void RuleFactory::useStaticQubitArrayAllocation() { // TODO(issue-14): Use weak pointers to capture allocation managers auto qubit_alloc_manager = qubit_alloc_manager_; auto default_iw = default_integer_width_; auto allocation_replacer = [default_iw, qubit_alloc_manager](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"size\"]); if (cst == nullptr) { return false; } auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } if (cst == nullptr) { return false; } auto llvm_size = cst->getValue(); auto name = val->getName().str(); auto size = llvm_size.getZExtValue(); auto offset = qubit_alloc_manager->allocate(name, size); // Creating a new index APInt that is shifted by the offset of the allocation auto idx = llvm::APInt(default_iw, offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto instr = new llvm::IntToPtrInst(new_index, ptr_type); instr->takeName(val); // Replacing the instruction with new instruction auto old_instr = llvm::dyn_cast<Instruction>(val); // Safety precaution to ensure that we are dealing with a Instruction if (old_instr == nullptr) { return false; } // Ensuring that we have replaced the instruction before // identifying release old_instr->replaceAllUsesWith(instr); replacements.push_back({old_instr, instr}); return true; }; addRule({call(\"__quantum__rt__qubit_allocate_array\", \"size\"_cap = _), allocation_replacer}); auto access_replacer = [qubit_alloc_manager](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { // Getting the type pointer auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } // Get the index and testing that it is a constant int auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"index\"]); if (cst == nullptr) { // ... if not, we cannot perform the mapping. return false; } // Computing the index by getting the current index value and offsetting by // the offset at which the qubit array is allocated. auto offset_cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"arrayName\"]); if (offset_cst == nullptr) { return false; } auto llvm_offset = offset_cst->getValue(); auto offset = llvm_offset.getZExtValue(); // Creating a new index APInt that is shifted by the offset of the allocation auto llvm_size = cst->getValue(); auto idx = llvm::APInt(llvm_size.getBitWidth(), llvm_size.getZExtValue() + offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); // Converting pointer auto instr = new llvm::IntToPtrInst(new_index, ptr_type); instr->takeName(val); // Replacing the instruction with new instruction replacements.push_back({llvm::dyn_cast<Instruction>(val), instr}); // Deleting the getelement and cast operations replacements.push_back({llvm::dyn_cast<Instruction>(cap[\"getElement\"]), nullptr}); replacements.push_back({llvm::dyn_cast<Instruction>(cap[\"cast\"]), nullptr}); return true; }; auto get_element = call( \"__quantum__rt__array_get_element_ptr_1d\", intToPtr(\"arrayName\"_cap = constInt()), \"index\"_cap = constInt()); auto cast_pattern = bitCast(\"getElement\"_cap = get_element); auto load_pattern = load(\"cast\"_cap = cast_pattern); addRule({std::move(load_pattern), access_replacer}); auto deleter = deleteInstruction(); addRule( {call(\"__quantum__rt__qubit_release_array\", intToPtr(\"const\"_cap = constInt())), [qubit_alloc_manager, deleter](Builder& builder, Value* val, Captures& cap, Replacements& rep) { // Recovering the qubit id auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"const\"]); if (cst == nullptr) { return false; } auto address = cst->getValue().getZExtValue(); // Releasing qubit_alloc_manager->release(address); // Deleting instruction return deleter(builder, val, cap, rep); }}); } void RuleFactory::useStaticQubitAllocation() { auto qubit_alloc_manager = qubit_alloc_manager_; auto default_iw = default_integer_width_; auto allocation_replacer = [default_iw, qubit_alloc_manager](Builder& builder, Value* val, Captures&, Replacements& replacements) { // Getting the type pointer auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } auto qubit_name = val->getName().str(); // Computing the index by getting the current index value and offseting by // the offset at which the qubit array is allocated. auto offset = qubit_alloc_manager->allocate(qubit_name); // Creating a new index APInt that is shifted by the offset of the allocation auto idx = llvm::APInt(default_iw, offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto instr = new llvm::IntToPtrInst(new_index, ptr_type); instr->takeName(val); // Replacing the instruction with new instruction auto old_instr = llvm::dyn_cast<Instruction>(val); // Safety precaution to ensure that we are dealing with a Instruction if (old_instr == nullptr) { return false; } // Ensuring that we have replaced the instruction before // identifying release old_instr->replaceAllUsesWith(instr); replacements.push_back({old_instr, instr}); return true; }; // Dealing with qubit allocation addRule({call(\"__quantum__rt__qubit_allocate\"), allocation_replacer}); auto deleter = deleteInstruction(); // Handling the case where a constant integer is cast to a pointer and the pointer // is used in a call to qubit_release: // // %0 = inttoptr i64 0 to %Qubit* // call void @__quantum__rt__qubit_release(%Qubit* %0 // // The case of named addresses are also covered, by this pattern: // %leftMessage = inttoptr i64 0 to %Qubit* // call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) addRule( {call(\"__quantum__rt__qubit_release\", intToPtr(\"const\"_cap = constInt())), [qubit_alloc_manager, deleter](Builder& builder, Value* val, Captures& cap, Replacements& rep) { // Recovering the qubit id auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"const\"]); if (cst == nullptr) { return false; } auto address = cst->getValue().getZExtValue(); // Releasing qubit_alloc_manager->release(address); // Deleting instruction return deleter(builder, val, cap, rep); }}); // Handling where allocation is done by non-standard functions. In // this rule reports an error as we cannot reliably do a mapping. // // %leftMessage = call %Qubit* @__non_standard_allocator() // call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) addRule( {call(\"__quantum__rt__qubit_release\", \"name\"_cap = _), [qubit_alloc_manager, deleter](Builder& builder, Value* val, Captures& cap, Replacements& rep) { // Getting the name auto name = cap[\"name\"]->getName().str(); // Returning in case the name comes out empty if (name.empty()) { // TODO(issue-15): report error llvm::outs() << \"FAILED due to unnamed non standard allocation:\\n\"; llvm::outs() << *val << \"\\n\\n\"; // Deleting the instruction in order to proceed // and trying to discover as many other errors as possible return deleter(builder, val, cap, rep); } // TODO(issue-15): report error llvm::outs() << \"FAILED due to non standard allocation:\\n\"; llvm::outs() << *cap[\"name\"] << \"\\n\"; llvm::outs() << *val << \"\\n\\n\"; return deleter(builder, val, cap, rep); } }); } void RuleFactory::useStaticResultAllocation() { auto result_alloc_manager = result_alloc_manager_; auto default_iw = default_integer_width_; auto replace_measurement = [default_iw, result_alloc_manager]( Builder& builder, Value* val, Captures& cap, Replacements& replacements) { // Getting the type pointer auto ptr_type = llvm::dyn_cast<llvm::PointerType>(val->getType()); if (ptr_type == nullptr) { return false; } // Computing the index by getting the current index value and offseting by // the offset at which the qubit array is allocated. auto offset = result_alloc_manager->allocate(); // Creating a new index APInt that is shifted by the offset of the allocation auto idx = llvm::APInt(default_iw, offset); // Computing offset auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto instr = new llvm::IntToPtrInst(new_index, ptr_type); if (instr == nullptr) { return false; } instr->takeName(val); auto orig_instr = llvm::dyn_cast<llvm::Instruction>(val); if (orig_instr == nullptr) { return false; } auto module = orig_instr->getModule(); auto fnc = module->getFunction(\"__quantum__qis__mz__body\"); std::vector<llvm::Value*> arguments; arguments.push_back(cap[\"qubit\"]); arguments.push_back(instr); if (!fnc) { std::vector<llvm::Type*> types; types.resize(arguments.size()); for (uint64_t i = 0; i < types.size(); ++i) { types[i] = arguments[i]->getType(); } auto return_type = llvm::Type::getVoidTy(val->getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create( fnc_type, llvm::Function::ExternalLinkage, \"__quantum__qis__mz__body\", module); } // Ensuring we are inserting after the instruction being deleted builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(val)->getNextNode()); builder.CreateCall(fnc, arguments); // Replacing the instruction with new instruction replacements.push_back({llvm::dyn_cast<Instruction>(val), instr}); return true; }; // This rules identifies result allocations through the function \"__quantum__qis__m__body\". // As an example, the following // // %result1 = call %Result* @__quantum__qis__m__body(%Qubit* %0) // // translates into // // %result1 = inttoptr i64 0 to %Result* // call void @__quantum__qis__mz__body(%Qubit* %0, %Result* %result1) addRule({call(\"__quantum__qis__m__body\", \"qubit\"_cap = _), std::move(replace_measurement)}); } void RuleFactory::optimiseResultZero() { auto replace_branch_negative = [](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto cond = llvm::dyn_cast<llvm::Instruction>(val); if (cond == nullptr) { return false; } auto result = cap[\"result\"]; // Replacing result auto orig_instr = llvm::dyn_cast<llvm::Instruction>(val); if (orig_instr == nullptr) { return false; } auto module = orig_instr->getModule(); auto fnc = module->getFunction(\"__quantum__qis__read_result__body\"); std::vector<llvm::Value*> arguments; arguments.push_back(result); if (!fnc) { std::vector<llvm::Type*> types; types.resize(arguments.size()); for (uint64_t i = 0; i < types.size(); ++i) { types[i] = arguments[i]->getType(); } auto return_type = llvm::Type::getInt1Ty(val->getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create( fnc_type, llvm::Function::ExternalLinkage, \"__quantum__qis__read_result__body\", module); } builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(val)); auto new_call = builder.CreateCall(fnc, arguments); auto new_cond = builder.CreateNot(new_call); new_cond->takeName(cond); for (auto& use : cond->uses()) { llvm::User* user = use.getUser(); user->setOperand(use.getOperandNo(), new_cond); } cond->replaceAllUsesWith(new_cond); // Deleting the previous condition and function to fetch one replacements.push_back({cond, nullptr}); replacements.push_back({cap[\"zero\"], nullptr}); return true; }; /* Here is an example IR for which we want to make a match: %1 = call %Result* @__quantum__rt__result_get_zero() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 */ // Variations of get_one auto get_zero = call(\"__quantum__rt__result_get_zero\"); addRule( {call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"zero\"_cap = get_zero), replace_branch_negative}); addRule( {call(\"__quantum__rt__result_equal\", \"zero\"_cap = get_zero, \"result\"_cap = _), replace_branch_negative}); } void RuleFactory::optimiseResultOne() { auto replace_branch_positive = [](Builder& builder, Value* val, Captures& cap, Replacements& replacements) { auto cond = llvm::dyn_cast<llvm::Instruction>(val); if (cond == nullptr) { return false; } auto result = cap[\"result\"]; // Replacing result auto orig_instr = llvm::dyn_cast<llvm::Instruction>(val); if (orig_instr == nullptr) { return false; } auto module = orig_instr->getModule(); auto fnc = module->getFunction(\"__quantum__qis__read_result__body\"); std::vector<llvm::Value*> arguments; arguments.push_back(result); if (!fnc) { std::vector<llvm::Type*> types; types.resize(arguments.size()); for (uint64_t i = 0; i < types.size(); ++i) { types[i] = arguments[i]->getType(); } auto return_type = llvm::Type::getInt1Ty(val->getContext()); llvm::FunctionType* fnc_type = llvm::FunctionType::get(return_type, types, false); fnc = llvm::Function::Create( fnc_type, llvm::Function::ExternalLinkage, \"__quantum__qis__read_result__body\", module); } builder.SetInsertPoint(llvm::dyn_cast<llvm::Instruction>(val)); auto new_call = builder.CreateCall(fnc, arguments); new_call->takeName(cond); for (auto& use : cond->uses()) { llvm::User* user = use.getUser(); user->setOperand(use.getOperandNo(), new_call); } cond->replaceAllUsesWith(new_call); // Deleting the previous condition and function to fetch one replacements.push_back({cond, nullptr}); replacements.push_back({cap[\"one\"], nullptr}); return true; }; /* Here is an example IR for which we want to make a match: %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 */ // Variations of get_one auto get_one = call(\"__quantum__rt__result_get_one\"); addRule({call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), replace_branch_positive}); addRule({call(\"__quantum__rt__result_equal\", \"one\"_cap = get_one, \"result\"_cap = _), replace_branch_positive}); } void RuleFactory::disableReferenceCounting() { // removeFunctionCall(\"__quantum__rt__array_update_reference_count\"); removeFunctionCall(\"__quantum__rt__string_update_reference_count\"); removeFunctionCall(\"__quantum__rt__result_update_reference_count\"); } void RuleFactory::disableAliasCounting() { // removeFunctionCall(\"__quantum__rt__array_update_alias_count\"); removeFunctionCall(\"__quantum__rt__string_update_alias_count\"); removeFunctionCall(\"__quantum__rt__result_update_alias_count\"); } void RuleFactory::disableStringSupport() { removeFunctionCall(\"__quantum__rt__fail\"); removeFunctionCall(\"__quantum__rt__message\"); removeFunctionCall(\"__quantum__rt__string_update_alias_count\"); removeFunctionCall(\"__quantum__rt__string_create\"); removeFunctionCall(\"__quantum__rt__string_get_data\"); removeFunctionCall(\"__quantum__rt__string_get_length\"); removeFunctionCall(\"__quantum__rt__string_update_reference_count\"); removeFunctionCall(\"__quantum__rt__string_concatenate\"); removeFunctionCall(\"__quantum__rt__string_equal\"); removeFunctionCall(\"__quantum__rt__int_to_string\"); removeFunctionCall(\"__quantum__rt__double_to_string\"); removeFunctionCall(\"__quantum__rt__bool_to_string\"); removeFunctionCall(\"__quantum__rt__result_to_string\"); removeFunctionCall(\"__quantum__rt__pauli_to_string\"); removeFunctionCall(\"__quantum__rt__qubit_to_string\"); removeFunctionCall(\"__quantum__rt__range_to_string\"); removeFunctionCall(\"__quantum__rt__bigint_to_string\"); } ReplacementRulePtr RuleFactory::addRule(ReplacementRule&& rule) { auto ret = std::make_shared<ReplacementRule>(std::move(rule)); rule_set_.addRule(ret); return ret; } void RuleFactory::setDefaultIntegerWidth(uint32_t v) { default_integer_width_ = v; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_factory_8hpp/","text":"Rules/Factory.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::RuleFactory Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/AllocationManager.hpp\" #include \"Commandline/ConfigurationManager.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Rules/FactoryConfig.hpp\" #include \"Rules/ReplacementRule.hpp\" #include \"Rules/RuleSet.hpp\" #include \"Llvm/Llvm.hpp\" #include <memory> namespace microsoft { namespace quantum { class RuleFactory { public: using ReplacementRulePtr = std::shared_ptr<ReplacementRule>; using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; // Constructor configuration. Explicit construction with // rule set to be configured, which can be moved using move // semantics. No copy allowed. // RuleFactory( RuleSet& rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager); RuleFactory() = delete; RuleFactory(RuleFactory const&) = delete; RuleFactory(RuleFactory&&) = default; ~RuleFactory() = default; // // void usingConfiguration(FactoryConfiguration const& config); // Generic rules // void removeFunctionCall(String const& name); // Conventions // void useStaticQubitArrayAllocation(); void useStaticQubitAllocation(); void useStaticResultAllocation(); void resolveConstantArraySizes(); void inlineCallables(); // Optimisations // void optimiseResultOne(); void optimiseResultZero(); // Disabling by feature // void disableReferenceCounting(); void disableAliasCounting(); void disableStringSupport(); // Configuration // void setDefaultIntegerWidth(uint32_t v); private: ReplacementRulePtr addRule(ReplacementRule&& rule); // Affected artefacts // RuleSet& rule_set_; // Allocation managers. // AllocationManagerPtr qubit_alloc_manager_{nullptr}; AllocationManagerPtr result_alloc_manager_{nullptr}; // uint32_t default_integer_width_{64}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Factory.hpp"},{"location":"Api/Files/_factory_8hpp/#rulesfactoryhpp","text":"","title":"Rules/Factory.hpp"},{"location":"Api/Files/_factory_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_factory_8hpp/#classes","text":"Name class microsoft::quantum::RuleFactory","title":"Classes"},{"location":"Api/Files/_factory_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/AllocationManager.hpp\" #include \"Commandline/ConfigurationManager.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Rules/FactoryConfig.hpp\" #include \"Rules/ReplacementRule.hpp\" #include \"Rules/RuleSet.hpp\" #include \"Llvm/Llvm.hpp\" #include <memory> namespace microsoft { namespace quantum { class RuleFactory { public: using ReplacementRulePtr = std::shared_ptr<ReplacementRule>; using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; // Constructor configuration. Explicit construction with // rule set to be configured, which can be moved using move // semantics. No copy allowed. // RuleFactory( RuleSet& rule_set, AllocationManagerPtr qubit_alloc_manager, AllocationManagerPtr result_alloc_manager); RuleFactory() = delete; RuleFactory(RuleFactory const&) = delete; RuleFactory(RuleFactory&&) = default; ~RuleFactory() = default; // // void usingConfiguration(FactoryConfiguration const& config); // Generic rules // void removeFunctionCall(String const& name); // Conventions // void useStaticQubitArrayAllocation(); void useStaticQubitAllocation(); void useStaticResultAllocation(); void resolveConstantArraySizes(); void inlineCallables(); // Optimisations // void optimiseResultOne(); void optimiseResultZero(); // Disabling by feature // void disableReferenceCounting(); void disableAliasCounting(); void disableStringSupport(); // Configuration // void setDefaultIntegerWidth(uint32_t v); private: ReplacementRulePtr addRule(ReplacementRule&& rule); // Affected artefacts // RuleSet& rule_set_; // Allocation managers. // AllocationManagerPtr qubit_alloc_manager_{nullptr}; AllocationManagerPtr result_alloc_manager_{nullptr}; // uint32_t default_integer_width_{64}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_factory_config_8hpp/","text":"Rules/FactoryConfig.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::FactoryConfiguration Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" namespace microsoft { namespace quantum { class FactoryConfiguration { public: void setup(ConfigurationManager& config) { config.setSectionName(\"Transformation rules\", \"Rules used to transform instruction sequences in the QIR.\"); config.addParameter( disable_reference_counting_, \"disable-reference-counting\", \"Disables reference counting by instruction removal.\"); config.addParameter( disable_reference_counting_, \"disable-reference-counting\", \"Disables reference counting by instruction removal.\"); config.addParameter( disable_alias_counting_, \"disable-alias-counting\", \"Disables alias counting by instruction removal.\"); config.addParameter( disable_string_support_, \"disable-string-support\", \"Disables string support by instruction removal.\"); config.addParameter( optimise_result_one_, \"optimise-result-one\", \"Maps branching based on quantum measurements compared to one to base profile \" \"type measurement.\"); config.addParameter( optimise_result_zero_, \"optimise-result-zero\", \"Maps branching based on quantum measurements compared to zero to base profile \" \"type measurement.\"); config.addParameter( use_static_qubit_array_allocation_, \"use-static-qubit-array-allocation\", \"Maps allocation of qubit arrays to static array allocation.\"); config.addParameter( use_static_qubit_allocation_, \"use-static-qubit-allocation\", \"Maps qubit allocation to static allocation.\"); config.addParameter( use_static_result_allocation_, \"use-static-result-allocation\", \"Maps result allocation to static allocation.\"); } static FactoryConfiguration createDisabled() { FactoryConfiguration ret; ret.disable_reference_counting_ = false; ret.disable_alias_counting_ = false; ret.disable_string_support_ = false; ret.optimise_result_one_ = false; ret.optimise_result_zero_ = false; ret.use_static_qubit_array_allocation_ = false; ret.use_static_qubit_allocation_ = false; ret.use_static_result_allocation_ = false; return ret; } bool disableReferenceCounting() const { return disable_reference_counting_; } bool disableAliasCounting() const { return disable_alias_counting_; } bool disableStringSupport() const { return disable_string_support_; } bool optimiseResultOne() const { return optimise_result_one_; } bool optimiseResultZero() const { return optimise_result_zero_; } bool useStaticQubitArrayAllocation() const { return use_static_qubit_array_allocation_; } bool useStaticQubitAllocation() const { return use_static_qubit_allocation_; } bool useStaticResultAllocation() const { return use_static_result_allocation_; } uint32_t defaultIntegerWidth() const { return default_integer_width_; } bool isDisabled() const { return ( disable_reference_counting_ == false && disable_alias_counting_ == false && disable_string_support_ == false && optimise_result_one_ == false && optimise_result_zero_ == false && use_static_qubit_array_allocation_ == false && use_static_qubit_allocation_ == false && use_static_result_allocation_ == false); } bool isDefault() const { FactoryConfiguration ref{}; return ( disable_reference_counting_ == ref.disable_reference_counting_ && disable_alias_counting_ == ref.disable_alias_counting_ && disable_string_support_ == ref.disable_string_support_ && optimise_result_one_ == ref.optimise_result_one_ && optimise_result_zero_ == ref.optimise_result_zero_ && use_static_qubit_array_allocation_ == ref.use_static_qubit_array_allocation_ && use_static_qubit_allocation_ == ref.use_static_qubit_allocation_ && use_static_result_allocation_ == ref.use_static_result_allocation_); } private: bool disable_reference_counting_{true}; bool disable_alias_counting_{true}; bool disable_string_support_{true}; bool optimise_result_one_{true}; bool optimise_result_zero_{true}; bool use_static_qubit_array_allocation_{true}; bool use_static_qubit_allocation_{true}; bool use_static_result_allocation_{true}; uint32_t default_integer_width_{64}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/FactoryConfig.hpp"},{"location":"Api/Files/_factory_config_8hpp/#rulesfactoryconfighpp","text":"","title":"Rules/FactoryConfig.hpp"},{"location":"Api/Files/_factory_config_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_factory_config_8hpp/#classes","text":"Name class microsoft::quantum::FactoryConfiguration","title":"Classes"},{"location":"Api/Files/_factory_config_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" namespace microsoft { namespace quantum { class FactoryConfiguration { public: void setup(ConfigurationManager& config) { config.setSectionName(\"Transformation rules\", \"Rules used to transform instruction sequences in the QIR.\"); config.addParameter( disable_reference_counting_, \"disable-reference-counting\", \"Disables reference counting by instruction removal.\"); config.addParameter( disable_reference_counting_, \"disable-reference-counting\", \"Disables reference counting by instruction removal.\"); config.addParameter( disable_alias_counting_, \"disable-alias-counting\", \"Disables alias counting by instruction removal.\"); config.addParameter( disable_string_support_, \"disable-string-support\", \"Disables string support by instruction removal.\"); config.addParameter( optimise_result_one_, \"optimise-result-one\", \"Maps branching based on quantum measurements compared to one to base profile \" \"type measurement.\"); config.addParameter( optimise_result_zero_, \"optimise-result-zero\", \"Maps branching based on quantum measurements compared to zero to base profile \" \"type measurement.\"); config.addParameter( use_static_qubit_array_allocation_, \"use-static-qubit-array-allocation\", \"Maps allocation of qubit arrays to static array allocation.\"); config.addParameter( use_static_qubit_allocation_, \"use-static-qubit-allocation\", \"Maps qubit allocation to static allocation.\"); config.addParameter( use_static_result_allocation_, \"use-static-result-allocation\", \"Maps result allocation to static allocation.\"); } static FactoryConfiguration createDisabled() { FactoryConfiguration ret; ret.disable_reference_counting_ = false; ret.disable_alias_counting_ = false; ret.disable_string_support_ = false; ret.optimise_result_one_ = false; ret.optimise_result_zero_ = false; ret.use_static_qubit_array_allocation_ = false; ret.use_static_qubit_allocation_ = false; ret.use_static_result_allocation_ = false; return ret; } bool disableReferenceCounting() const { return disable_reference_counting_; } bool disableAliasCounting() const { return disable_alias_counting_; } bool disableStringSupport() const { return disable_string_support_; } bool optimiseResultOne() const { return optimise_result_one_; } bool optimiseResultZero() const { return optimise_result_zero_; } bool useStaticQubitArrayAllocation() const { return use_static_qubit_array_allocation_; } bool useStaticQubitAllocation() const { return use_static_qubit_allocation_; } bool useStaticResultAllocation() const { return use_static_result_allocation_; } uint32_t defaultIntegerWidth() const { return default_integer_width_; } bool isDisabled() const { return ( disable_reference_counting_ == false && disable_alias_counting_ == false && disable_string_support_ == false && optimise_result_one_ == false && optimise_result_zero_ == false && use_static_qubit_array_allocation_ == false && use_static_qubit_allocation_ == false && use_static_result_allocation_ == false); } bool isDefault() const { FactoryConfiguration ref{}; return ( disable_reference_counting_ == ref.disable_reference_counting_ && disable_alias_counting_ == ref.disable_alias_counting_ && disable_string_support_ == ref.disable_string_support_ && optimise_result_one_ == ref.optimise_result_one_ && optimise_result_zero_ == ref.optimise_result_zero_ && use_static_qubit_array_allocation_ == ref.use_static_qubit_array_allocation_ && use_static_qubit_allocation_ == ref.use_static_qubit_allocation_ && use_static_result_allocation_ == ref.use_static_result_allocation_); } private: bool disable_reference_counting_{true}; bool disable_alias_counting_{true}; bool disable_string_support_{true}; bool optimise_result_one_{true}; bool optimise_result_zero_{true}; bool use_static_qubit_array_allocation_{true}; bool use_static_qubit_allocation_{true}; bool use_static_result_allocation_{true}; uint32_t default_integer_width_{64}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_factory_configuration_8cpp/","text":"Rules/Tests/Unit/FactoryConfiguration.cpp Functions Name TEST (RuleSetTestSuite , FactoryConfiguration ) Functions Documentation function TEST TEST( RuleSetTestSuite , FactoryConfiguration ) Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/FactoryConfig.hpp\" #include \"gtest/gtest.h\" #include <functional> using namespace microsoft::quantum; // Single allocation with action and then release TEST(RuleSetTestSuite, FactoryConfiguration) { FactoryConfiguration c1 = FactoryConfiguration::createDisabled(); EXPECT_TRUE(c1.isDisabled()); FactoryConfiguration c2{}; EXPECT_TRUE(c2.isDefault()); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Tests/Unit/FactoryConfiguration.cpp"},{"location":"Api/Files/_factory_configuration_8cpp/#rulestestsunitfactoryconfigurationcpp","text":"","title":"Rules/Tests/Unit/FactoryConfiguration.cpp"},{"location":"Api/Files/_factory_configuration_8cpp/#functions","text":"Name TEST (RuleSetTestSuite , FactoryConfiguration )","title":"Functions"},{"location":"Api/Files/_factory_configuration_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Files/_factory_configuration_8cpp/#function-test","text":"TEST( RuleSetTestSuite , FactoryConfiguration )","title":"function TEST"},{"location":"Api/Files/_factory_configuration_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/FactoryConfig.hpp\" #include \"gtest/gtest.h\" #include <functional> using namespace microsoft::quantum; // Single allocation with action and then release TEST(RuleSetTestSuite, FactoryConfiguration) { FactoryConfiguration c1 = FactoryConfiguration::createDisabled(); EXPECT_TRUE(c1.isDisabled()); FactoryConfiguration c2{}; EXPECT_TRUE(c2.isDefault()); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_generators_2_tests_2_unit_2main_8cpp/","text":"Generators/Tests/Unit/main.cpp Types Name using std::shared_ptr< DefaultProfileGenerator > GeneratorPtr Functions Name TEST (GeneratorsTestSuite , ConfigureFunction ) TEST (GeneratorsTestSuite , ConfigurationManager ) Types Documentation using GeneratorPtr using GeneratorPtr = std::shared_ptr<DefaultProfileGenerator>; Functions Documentation function TEST TEST( GeneratorsTestSuite , ConfigureFunction ) function TEST TEST( GeneratorsTestSuite , ConfigurationManager ) Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Generators/LlvmPassesConfiguration.hpp\" #include \"Rules/FactoryConfig.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"TransformationRulesPass/TransformationRulesPassConfiguration.hpp\" #include \"gtest/gtest.h\" using namespace microsoft::quantum; using GeneratorPtr = std::shared_ptr<DefaultProfileGenerator>; namespace { class ExposedDefaultProfileGenerator : public DefaultProfileGenerator { public: using DefaultProfileGenerator::createGenerationModulePassManager; using DefaultProfileGenerator::createValidationModulePass; using DefaultProfileGenerator::DefaultProfileGenerator; }; class TestAnalysis { public: TestAnalysis(TestAnalysis const&) = delete; TestAnalysis(TestAnalysis&&) = default; ~TestAnalysis() = default; explicit TestAnalysis(bool debug = false) : loop_analysis_manager_{debug} , function_analysis_manager_{debug} , gscc_analysis_manager_{debug} , module_analysis_manager_{debug} { // Creating a full pass builder and registering each of the // components to make them accessible to the developer. pass_builder_.registerModuleAnalyses(module_analysis_manager_); pass_builder_.registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_.registerFunctionAnalyses(function_analysis_manager_); pass_builder_.registerLoopAnalyses(loop_analysis_manager_); pass_builder_.crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); } llvm::PassBuilder& passBuilder() { return pass_builder_; } llvm::LoopAnalysisManager& loopAnalysisManager() { return loop_analysis_manager_; } llvm::FunctionAnalysisManager& functionAnalysisManager() { return function_analysis_manager_; } llvm::CGSCCAnalysisManager& gsccAnalysisManager() { return gscc_analysis_manager_; } llvm::ModuleAnalysisManager& moduleAnalysisManager() { return module_analysis_manager_; } private: // Objects used to run a set of passes // llvm::PassBuilder pass_builder_; llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; }; } // namespace TEST(GeneratorsTestSuite, ConfigureFunction) { Profile profile{\"test\", false}; uint64_t call_count{0}; auto configure = [&call_count](RuleSet&) { ++call_count; }; auto generator = std::make_shared<ExposedDefaultProfileGenerator>(configure); TestAnalysis test; auto module_pass_manager = generator->createGenerationModulePassManager(profile, llvm::PassBuilder::OptimizationLevel::O0, false); EXPECT_EQ(call_count, 1); EXPECT_TRUE(generator->ruleTransformationConfig().isDisabled()); EXPECT_TRUE(generator->llvmPassesConfig().isDisabled()); } TEST(GeneratorsTestSuite, ConfigurationManager) { Profile profile{\"test\", false}; auto generator = std::make_shared<ExposedDefaultProfileGenerator>(); ConfigurationManager& configuration_manager = generator->configurationManager(); configuration_manager.addConfig<FactoryConfiguration>(); TestAnalysis test; auto module_pass_manager = generator->createGenerationModulePassManager(profile, llvm::PassBuilder::OptimizationLevel::O0, false); EXPECT_EQ(generator->ruleTransformationConfig(), TransformationRulesPassConfiguration()); EXPECT_EQ(generator->llvmPassesConfig(), LlvmPassesConfiguration()); EXPECT_FALSE(generator->ruleTransformationConfig().isDisabled()); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Generators/Tests/Unit/main.cpp"},{"location":"Api/Files/_generators_2_tests_2_unit_2main_8cpp/#generatorstestsunitmaincpp","text":"","title":"Generators/Tests/Unit/main.cpp"},{"location":"Api/Files/_generators_2_tests_2_unit_2main_8cpp/#types","text":"Name using std::shared_ptr< DefaultProfileGenerator > GeneratorPtr","title":"Types"},{"location":"Api/Files/_generators_2_tests_2_unit_2main_8cpp/#functions","text":"Name TEST (GeneratorsTestSuite , ConfigureFunction ) TEST (GeneratorsTestSuite , ConfigurationManager )","title":"Functions"},{"location":"Api/Files/_generators_2_tests_2_unit_2main_8cpp/#types-documentation","text":"","title":"Types Documentation"},{"location":"Api/Files/_generators_2_tests_2_unit_2main_8cpp/#using-generatorptr","text":"using GeneratorPtr = std::shared_ptr<DefaultProfileGenerator>;","title":"using GeneratorPtr"},{"location":"Api/Files/_generators_2_tests_2_unit_2main_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Files/_generators_2_tests_2_unit_2main_8cpp/#function-test","text":"TEST( GeneratorsTestSuite , ConfigureFunction )","title":"function TEST"},{"location":"Api/Files/_generators_2_tests_2_unit_2main_8cpp/#function-test_1","text":"TEST( GeneratorsTestSuite , ConfigurationManager )","title":"function TEST"},{"location":"Api/Files/_generators_2_tests_2_unit_2main_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Generators/LlvmPassesConfiguration.hpp\" #include \"Rules/FactoryConfig.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"TransformationRulesPass/TransformationRulesPassConfiguration.hpp\" #include \"gtest/gtest.h\" using namespace microsoft::quantum; using GeneratorPtr = std::shared_ptr<DefaultProfileGenerator>; namespace { class ExposedDefaultProfileGenerator : public DefaultProfileGenerator { public: using DefaultProfileGenerator::createGenerationModulePassManager; using DefaultProfileGenerator::createValidationModulePass; using DefaultProfileGenerator::DefaultProfileGenerator; }; class TestAnalysis { public: TestAnalysis(TestAnalysis const&) = delete; TestAnalysis(TestAnalysis&&) = default; ~TestAnalysis() = default; explicit TestAnalysis(bool debug = false) : loop_analysis_manager_{debug} , function_analysis_manager_{debug} , gscc_analysis_manager_{debug} , module_analysis_manager_{debug} { // Creating a full pass builder and registering each of the // components to make them accessible to the developer. pass_builder_.registerModuleAnalyses(module_analysis_manager_); pass_builder_.registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_.registerFunctionAnalyses(function_analysis_manager_); pass_builder_.registerLoopAnalyses(loop_analysis_manager_); pass_builder_.crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); } llvm::PassBuilder& passBuilder() { return pass_builder_; } llvm::LoopAnalysisManager& loopAnalysisManager() { return loop_analysis_manager_; } llvm::FunctionAnalysisManager& functionAnalysisManager() { return function_analysis_manager_; } llvm::CGSCCAnalysisManager& gsccAnalysisManager() { return gscc_analysis_manager_; } llvm::ModuleAnalysisManager& moduleAnalysisManager() { return module_analysis_manager_; } private: // Objects used to run a set of passes // llvm::PassBuilder pass_builder_; llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; }; } // namespace TEST(GeneratorsTestSuite, ConfigureFunction) { Profile profile{\"test\", false}; uint64_t call_count{0}; auto configure = [&call_count](RuleSet&) { ++call_count; }; auto generator = std::make_shared<ExposedDefaultProfileGenerator>(configure); TestAnalysis test; auto module_pass_manager = generator->createGenerationModulePassManager(profile, llvm::PassBuilder::OptimizationLevel::O0, false); EXPECT_EQ(call_count, 1); EXPECT_TRUE(generator->ruleTransformationConfig().isDisabled()); EXPECT_TRUE(generator->llvmPassesConfig().isDisabled()); } TEST(GeneratorsTestSuite, ConfigurationManager) { Profile profile{\"test\", false}; auto generator = std::make_shared<ExposedDefaultProfileGenerator>(); ConfigurationManager& configuration_manager = generator->configurationManager(); configuration_manager.addConfig<FactoryConfiguration>(); TestAnalysis test; auto module_pass_manager = generator->createGenerationModulePassManager(profile, llvm::PassBuilder::OptimizationLevel::O0, false); EXPECT_EQ(generator->ruleTransformationConfig(), TransformationRulesPassConfiguration()); EXPECT_EQ(generator->llvmPassesConfig(), LlvmPassesConfiguration()); EXPECT_FALSE(generator->ruleTransformationConfig().isDisabled()); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_i_allocation_manager_8cpp/","text":"AllocationManager/IAllocationManager.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/IAllocationManager.hpp\" namespace microsoft { namespace quantum { IAllocationManager::~IAllocationManager() = default; uint64_t IAllocationManager::allocationsInUse() const { return registers_in_use_; } uint64_t IAllocationManager::maxAllocationsUsed() const { return max_registers_used_; } void IAllocationManager::updateRegistersInUse(uint64_t n) { registers_in_use_ = n; if (n > max_registers_used_) { max_registers_used_ = n; } } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:35 UTC","title":"AllocationManager/IAllocationManager.cpp"},{"location":"Api/Files/_i_allocation_manager_8cpp/#allocationmanageriallocationmanagercpp","text":"","title":"AllocationManager/IAllocationManager.cpp"},{"location":"Api/Files/_i_allocation_manager_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_allocation_manager_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/IAllocationManager.hpp\" namespace microsoft { namespace quantum { IAllocationManager::~IAllocationManager() = default; uint64_t IAllocationManager::allocationsInUse() const { return registers_in_use_; } uint64_t IAllocationManager::maxAllocationsUsed() const { return max_registers_used_; } void IAllocationManager::updateRegistersInUse(uint64_t n) { registers_in_use_ = n; if (n > max_registers_used_) { max_registers_used_ = n; } } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:35 UTC","title":"Source code"},{"location":"Api/Files/_i_allocation_manager_8hpp/","text":"AllocationManager/IAllocationManager.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::IAllocationManager Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include <memory> #include <string> namespace microsoft { namespace quantum { class IAllocationManager { public: using Address = uint64_t; using Index = uint64_t; using AllocationManagerPtr = std::shared_ptr<IAllocationManager>; // Construction, moves and copies // IAllocationManager(IAllocationManager const&) = delete; IAllocationManager(IAllocationManager&&) = delete; IAllocationManager& operator=(IAllocationManager const&) = delete; IAllocationManager& operator=(IAllocationManager&&) = delete; virtual ~IAllocationManager(); // Interface // virtual Address allocate(String const& name = \"\", Index const& count = 1) = 0; virtual void release(Address const& address) = 0; virtual void reset() = 0; // Statistics // uint64_t allocationsInUse() const; uint64_t maxAllocationsUsed() const; protected: IAllocationManager() = default; void updateRegistersInUse(uint64_t n); private: uint64_t registers_in_use_{0}; uint64_t max_registers_used_{0}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:35 UTC","title":"AllocationManager/IAllocationManager.hpp"},{"location":"Api/Files/_i_allocation_manager_8hpp/#allocationmanageriallocationmanagerhpp","text":"","title":"AllocationManager/IAllocationManager.hpp"},{"location":"Api/Files/_i_allocation_manager_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_allocation_manager_8hpp/#classes","text":"Name class microsoft::quantum::IAllocationManager","title":"Classes"},{"location":"Api/Files/_i_allocation_manager_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include <memory> #include <string> namespace microsoft { namespace quantum { class IAllocationManager { public: using Address = uint64_t; using Index = uint64_t; using AllocationManagerPtr = std::shared_ptr<IAllocationManager>; // Construction, moves and copies // IAllocationManager(IAllocationManager const&) = delete; IAllocationManager(IAllocationManager&&) = delete; IAllocationManager& operator=(IAllocationManager const&) = delete; IAllocationManager& operator=(IAllocationManager&&) = delete; virtual ~IAllocationManager(); // Interface // virtual Address allocate(String const& name = \"\", Index const& count = 1) = 0; virtual void release(Address const& address) = 0; virtual void reset() = 0; // Statistics // uint64_t allocationsInUse() const; uint64_t maxAllocationsUsed() const; protected: IAllocationManager() = default; void updateRegistersInUse(uint64_t n); private: uint64_t registers_in_use_{0}; uint64_t max_registers_used_{0}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:35 UTC","title":"Source code"},{"location":"Api/Files/_i_config_bind_8cpp/","text":"Commandline/IConfigBind.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"Commandline/IConfigBind.hpp\" using namespace microsoft::quantum; namespace microsoft { namespace quantum { IConfigBind::IConfigBind(String const& name, String const& description) : name_{name} , description_{description} { } IConfigBind::~IConfigBind() = default; String IConfigBind::name() const { return name_; } String IConfigBind::description() const { return description_; } void IConfigBind::setName(String const& name) { name_ = name; } bool IConfigBind::isFlag() const { return is_flag_; } String IConfigBind::defaultValue() const { return str_default_value_; } void IConfigBind::markAsFlag() { is_flag_ = true; } void IConfigBind::setDefault(String const& v) { str_default_value_ = v; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Commandline/IConfigBind.cpp"},{"location":"Api/Files/_i_config_bind_8cpp/#commandlineiconfigbindcpp","text":"","title":"Commandline/IConfigBind.cpp"},{"location":"Api/Files/_i_config_bind_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_config_bind_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"Commandline/IConfigBind.hpp\" using namespace microsoft::quantum; namespace microsoft { namespace quantum { IConfigBind::IConfigBind(String const& name, String const& description) : name_{name} , description_{description} { } IConfigBind::~IConfigBind() = default; String IConfigBind::name() const { return name_; } String IConfigBind::description() const { return description_; } void IConfigBind::setName(String const& name) { name_ = name; } bool IConfigBind::isFlag() const { return is_flag_; } String IConfigBind::defaultValue() const { return str_default_value_; } void IConfigBind::markAsFlag() { is_flag_ = true; } void IConfigBind::setDefault(String const& v) { str_default_value_ = v; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_i_config_bind_8hpp/","text":"Commandline/IConfigBind.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::IConfigBind Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ParameterParser.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Llvm/Llvm.hpp\" #include <iomanip> #include <iostream> #include <sstream> #include <type_traits> #include <typeindex> namespace microsoft { namespace quantum { class IConfigBind { public: // Deleted constructors and deleted operators // // Strictly speaking the code would remain correct if we allowed copy and/or move, but // we have chosen to ban them by choice as potential bugs arising from allowing copy and/or // move can be difficult to find. We consider this behaviour a part of the interface definition. IConfigBind(IConfigBind const&) = delete; IConfigBind(IConfigBind&&) = delete; IConfigBind& operator=(IConfigBind const&) = delete; IConfigBind& operator=(IConfigBind&&) = delete; // Virtual destructor // virtual ~IConfigBind(); // Interface // virtual bool setupArguments(ParameterParser& parser) = 0; virtual bool configure(ParameterParser const& parser) = 0; virtual String value() = 0; // Properties // String name() const; String description() const; bool isFlag() const; String defaultValue() const; protected: // Constructor // IConfigBind(String const& name, String const& description); // Configuration // void setName(String const& name); void markAsFlag(); void setDefault(String const& v); private: String name_; String description_; bool is_flag_{false}; String str_default_value_; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Commandline/IConfigBind.hpp"},{"location":"Api/Files/_i_config_bind_8hpp/#commandlineiconfigbindhpp","text":"","title":"Commandline/IConfigBind.hpp"},{"location":"Api/Files/_i_config_bind_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_config_bind_8hpp/#classes","text":"Name class microsoft::quantum::IConfigBind","title":"Classes"},{"location":"Api/Files/_i_config_bind_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ParameterParser.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Llvm/Llvm.hpp\" #include <iomanip> #include <iostream> #include <sstream> #include <type_traits> #include <typeindex> namespace microsoft { namespace quantum { class IConfigBind { public: // Deleted constructors and deleted operators // // Strictly speaking the code would remain correct if we allowed copy and/or move, but // we have chosen to ban them by choice as potential bugs arising from allowing copy and/or // move can be difficult to find. We consider this behaviour a part of the interface definition. IConfigBind(IConfigBind const&) = delete; IConfigBind(IConfigBind&&) = delete; IConfigBind& operator=(IConfigBind const&) = delete; IConfigBind& operator=(IConfigBind&&) = delete; // Virtual destructor // virtual ~IConfigBind(); // Interface // virtual bool setupArguments(ParameterParser& parser) = 0; virtual bool configure(ParameterParser const& parser) = 0; virtual String value() = 0; // Properties // String name() const; String description() const; bool isFlag() const; String defaultValue() const; protected: // Constructor // IConfigBind(String const& name, String const& description); // Configuration // void setName(String const& name); void markAsFlag(); void setDefault(String const& v); private: String name_; String description_; bool is_flag_{false}; String str_default_value_; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_i_logger_8cpp/","text":"Logging/ILogger.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/ILogger.hpp\" #include <cstdint> #include <string> namespace microsoft { namespace quantum { ILogger::~ILogger() = default; } } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Logging/ILogger.cpp"},{"location":"Api/Files/_i_logger_8cpp/#loggingiloggercpp","text":"","title":"Logging/ILogger.cpp"},{"location":"Api/Files/_i_logger_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_logger_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/ILogger.hpp\" #include <cstdint> #include <string> namespace microsoft { namespace quantum { ILogger::~ILogger() = default; } } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_i_logger_8hpp/","text":"Logging/ILogger.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ILogger Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include <cstdint> #include <string> namespace microsoft { namespace quantum { class ILogger { public: // Constructors, copy and move operators and destructors // ILogger() = default; ILogger(ILogger const&) = default; ILogger(ILogger&&) = default; ILogger& operator=(ILogger const&) = default; ILogger& operator=(ILogger&&) = default; virtual ~ILogger(); // Abstract interface methods // virtual void debug(String const& message) = 0; virtual void info(String const& message) = 0; virtual void warning(String const& message) = 0; virtual void error(String const& message) = 0; virtual void internalError(String const& message) = 0; virtual void setLocation(String const& name, uint64_t row, uint64_t col) = 0; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Logging/ILogger.hpp"},{"location":"Api/Files/_i_logger_8hpp/#loggingiloggerhpp","text":"","title":"Logging/ILogger.hpp"},{"location":"Api/Files/_i_logger_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_logger_8hpp/#classes","text":"Name class microsoft::quantum::ILogger","title":"Classes"},{"location":"Api/Files/_i_logger_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include <cstdint> #include <string> namespace microsoft { namespace quantum { class ILogger { public: // Constructors, copy and move operators and destructors // ILogger() = default; ILogger(ILogger const&) = default; ILogger(ILogger&&) = default; ILogger& operator=(ILogger const&) = default; ILogger& operator=(ILogger&&) = default; virtual ~ILogger(); // Abstract interface methods // virtual void debug(String const& message) = 0; virtual void info(String const& message) = 0; virtual void warning(String const& message) = 0; virtual void error(String const& message) = 0; virtual void internalError(String const& message) = 0; virtual void setLocation(String const& name, uint64_t row, uint64_t col) = 0; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_i_operand_prototype_8cpp/","text":"Rules/IOperandPrototype.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" namespace microsoft { namespace quantum { IOperandPrototype::~IOperandPrototype() = default; bool IOperandPrototype::matchChildren(Value* value, Captures& captures) const { if (!children_.empty()) { auto user = llvm::dyn_cast<llvm::User>(value); if (user == nullptr) { return false; } if (user->getNumOperands() != children_.size()) { return false; } uint64_t i = 0; while (i < children_.size()) { auto v = user->getOperand(static_cast<uint32_t>(i)); if (!children_[i]->match(v, captures)) { return false; } ++i; } return true; } // TODO(issue-16): value may be other type than llvm::User. Check other relevant types // and deal with it. return true; } void IOperandPrototype::addChild(Child const& child) { children_.push_back(child); } void IOperandPrototype::captureAs(std::string capture_name) { capture_name_ = std::move(capture_name); } bool IOperandPrototype::fail(Value* /*value*/, Captures& /*captures*/) const { return false; } bool IOperandPrototype::success(Value* value, Captures& captures) const { capture(value, captures); auto ret = matchChildren(value, captures); if (!ret) { uncapture(value, captures); } return ret; } void IOperandPrototype::capture(Value* value, Captures& captures) const { if (!capture_name_.empty()) { captures[capture_name_] = value; } } void IOperandPrototype::uncapture(Value* /*value*/, Captures& captures) const { if (!capture_name_.empty()) { auto it = captures.find(capture_name_); if (it == captures.end()) { throw std::runtime_error(\"Previously captured name \" + capture_name_ + \" not found in capture list.\"); } captures.erase(it); } } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/IOperandPrototype.cpp"},{"location":"Api/Files/_i_operand_prototype_8cpp/#rulesioperandprototypecpp","text":"","title":"Rules/IOperandPrototype.cpp"},{"location":"Api/Files/_i_operand_prototype_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_operand_prototype_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" namespace microsoft { namespace quantum { IOperandPrototype::~IOperandPrototype() = default; bool IOperandPrototype::matchChildren(Value* value, Captures& captures) const { if (!children_.empty()) { auto user = llvm::dyn_cast<llvm::User>(value); if (user == nullptr) { return false; } if (user->getNumOperands() != children_.size()) { return false; } uint64_t i = 0; while (i < children_.size()) { auto v = user->getOperand(static_cast<uint32_t>(i)); if (!children_[i]->match(v, captures)) { return false; } ++i; } return true; } // TODO(issue-16): value may be other type than llvm::User. Check other relevant types // and deal with it. return true; } void IOperandPrototype::addChild(Child const& child) { children_.push_back(child); } void IOperandPrototype::captureAs(std::string capture_name) { capture_name_ = std::move(capture_name); } bool IOperandPrototype::fail(Value* /*value*/, Captures& /*captures*/) const { return false; } bool IOperandPrototype::success(Value* value, Captures& captures) const { capture(value, captures); auto ret = matchChildren(value, captures); if (!ret) { uncapture(value, captures); } return ret; } void IOperandPrototype::capture(Value* value, Captures& captures) const { if (!capture_name_.empty()) { captures[capture_name_] = value; } } void IOperandPrototype::uncapture(Value* /*value*/, Captures& captures) const { if (!capture_name_.empty()) { auto it = captures.find(capture_name_); if (it == captures.end()) { throw std::runtime_error(\"Previously captured name \" + capture_name_ + \" not found in capture list.\"); } captures.erase(it); } } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_i_operand_prototype_8hpp/","text":"Rules/IOperandPrototype.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::IOperandPrototype Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class IOperandPrototype { public: using Instruction = llvm::Instruction; using String = std::string; using Value = llvm::Value; using Child = std::shared_ptr<IOperandPrototype>; using Children = std::vector<Child>; using Captures = std::unordered_map<std::string, Value*>; // Constructors and destructors // IOperandPrototype() = default; virtual ~IOperandPrototype(); // Interface functions // virtual bool match(Value* value, Captures& captures) const = 0; virtual Child copy() const = 0; // Shared functionality // void addChild(Child const& child); void captureAs(std::string capture_name); protected: // Function to indicate match success or failure. Either of these // must be called prior to return from an implementation of // IOperandPrototype::match. // bool fail(Value* value, Captures& captures) const; bool success(Value* value, Captures& captures) const; // Helper functions for the capture logic. // bool matchChildren(Value* value, Captures& captures) const; // Helper functions for operation // void copyPropertiesFrom(IOperandPrototype const& other) { capture_name_ = other.capture_name_; children_ = other.children_; } private: void capture(Value* value, Captures& captures) const; void uncapture(Value* value, Captures& captures) const; // Data variables for common matching functionality // std::string capture_name_{\"\"}; Children children_{}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/IOperandPrototype.hpp"},{"location":"Api/Files/_i_operand_prototype_8hpp/#rulesioperandprototypehpp","text":"","title":"Rules/IOperandPrototype.hpp"},{"location":"Api/Files/_i_operand_prototype_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_i_operand_prototype_8hpp/#classes","text":"Name class microsoft::quantum::IOperandPrototype","title":"Classes"},{"location":"Api/Files/_i_operand_prototype_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class IOperandPrototype { public: using Instruction = llvm::Instruction; using String = std::string; using Value = llvm::Value; using Child = std::shared_ptr<IOperandPrototype>; using Children = std::vector<Child>; using Captures = std::unordered_map<std::string, Value*>; // Constructors and destructors // IOperandPrototype() = default; virtual ~IOperandPrototype(); // Interface functions // virtual bool match(Value* value, Captures& captures) const = 0; virtual Child copy() const = 0; // Shared functionality // void addChild(Child const& child); void captureAs(std::string capture_name); protected: // Function to indicate match success or failure. Either of these // must be called prior to return from an implementation of // IOperandPrototype::match. // bool fail(Value* value, Captures& captures) const; bool success(Value* value, Captures& captures) const; // Helper functions for the capture logic. // bool matchChildren(Value* value, Captures& captures) const; // Helper functions for operation // void copyPropertiesFrom(IOperandPrototype const& other) { capture_name_ = other.capture_name_; children_ = other.children_; } private: void capture(Value* value, Captures& captures) const; void uncapture(Value* value, Captures& captures) const; // Data variables for common matching functionality // std::string capture_name_{\"\"}; Children children_{}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_instruction_8cpp/","text":"Rules/Patterns/Instruction.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/Patterns/Instruction.hpp\" namespace microsoft { namespace quantum { bool StorePattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::StoreInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } StorePattern::Child StorePattern::copy() const { auto ret = std::make_shared<StorePattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool LoadPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::LoadInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } LoadPattern::Child LoadPattern::copy() const { auto ret = std::make_shared<LoadPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool BitCastPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::BitCastInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } BitCastPattern::Child BitCastPattern::copy() const { auto ret = std::make_shared<BitCastPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool IntToPtrPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::IntToPtrInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } IntToPtrPattern::Child IntToPtrPattern::copy() const { auto ret = std::make_shared<IntToPtrPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool ConstIntPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::ConstantInt>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } ConstIntPattern::Child ConstIntPattern::copy() const { auto ret = std::make_shared<ConstIntPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool BranchPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::BranchInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } BranchPattern::Child BranchPattern::copy() const { auto ret = std::make_shared<BranchPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool SelectPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::SelectInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } SelectPattern::Child SelectPattern::copy() const { auto ret = std::make_shared<SelectPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool BasicBlockPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::BasicBlock>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } BasicBlockPattern::Child BasicBlockPattern::copy() const { auto ret = std::make_shared<BasicBlockPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool SwitchPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::SwitchInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } SwitchPattern::Child SwitchPattern::copy() const { auto ret = std::make_shared<SwitchPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Patterns/Instruction.cpp"},{"location":"Api/Files/_instruction_8cpp/#rulespatternsinstructioncpp","text":"","title":"Rules/Patterns/Instruction.cpp"},{"location":"Api/Files/_instruction_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_instruction_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/Patterns/Instruction.hpp\" namespace microsoft { namespace quantum { bool StorePattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::StoreInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } StorePattern::Child StorePattern::copy() const { auto ret = std::make_shared<StorePattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool LoadPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::LoadInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } LoadPattern::Child LoadPattern::copy() const { auto ret = std::make_shared<LoadPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool BitCastPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::BitCastInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } BitCastPattern::Child BitCastPattern::copy() const { auto ret = std::make_shared<BitCastPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool IntToPtrPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::IntToPtrInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } IntToPtrPattern::Child IntToPtrPattern::copy() const { auto ret = std::make_shared<IntToPtrPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool ConstIntPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::ConstantInt>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } ConstIntPattern::Child ConstIntPattern::copy() const { auto ret = std::make_shared<ConstIntPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool BranchPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::BranchInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } BranchPattern::Child BranchPattern::copy() const { auto ret = std::make_shared<BranchPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool SelectPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::SelectInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } SelectPattern::Child SelectPattern::copy() const { auto ret = std::make_shared<SelectPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool BasicBlockPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::BasicBlock>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } BasicBlockPattern::Child BasicBlockPattern::copy() const { auto ret = std::make_shared<BasicBlockPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } bool SwitchPattern::match(Value* instr, Captures& captures) const { auto* load_instr = llvm::dyn_cast<llvm::SwitchInst>(instr); if (load_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } SwitchPattern::Child SwitchPattern::copy() const { auto ret = std::make_shared<SwitchPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_instruction_8hpp/","text":"Rules/Patterns/Instruction.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::StorePattern class microsoft::quantum::LoadPattern class microsoft::quantum::BitCastPattern class microsoft::quantum::IntToPtrPattern class microsoft::quantum::ConstIntPattern class microsoft::quantum::BranchPattern class microsoft::quantum::SelectPattern class microsoft::quantum::BasicBlockPattern class microsoft::quantum::SwitchPattern Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class StorePattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class LoadPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class BitCastPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class IntToPtrPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class ConstIntPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class BranchPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class SelectPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class BasicBlockPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class SwitchPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Patterns/Instruction.hpp"},{"location":"Api/Files/_instruction_8hpp/#rulespatternsinstructionhpp","text":"","title":"Rules/Patterns/Instruction.hpp"},{"location":"Api/Files/_instruction_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_instruction_8hpp/#classes","text":"Name class microsoft::quantum::StorePattern class microsoft::quantum::LoadPattern class microsoft::quantum::BitCastPattern class microsoft::quantum::IntToPtrPattern class microsoft::quantum::ConstIntPattern class microsoft::quantum::BranchPattern class microsoft::quantum::SelectPattern class microsoft::quantum::BasicBlockPattern class microsoft::quantum::SwitchPattern","title":"Classes"},{"location":"Api/Files/_instruction_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class StorePattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class LoadPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class BitCastPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class IntToPtrPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class ConstIntPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class BranchPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class SelectPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class BasicBlockPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; class SwitchPattern : public IOperandPrototype { public: bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_int_to_ptr_8cpp/","text":"Rules/Notation/IntToPtr.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr intToPtr(IOperandPrototypePtr const& arg) { auto cast_pattern = std::make_shared<IntToPtrPattern>(); cast_pattern->addChild(arg); return static_cast<IOperandPrototypePtr>(cast_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Notation/IntToPtr.cpp"},{"location":"Api/Files/_int_to_ptr_8cpp/#rulesnotationinttoptrcpp","text":"","title":"Rules/Notation/IntToPtr.cpp"},{"location":"Api/Files/_int_to_ptr_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_int_to_ptr_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr intToPtr(IOperandPrototypePtr const& arg) { auto cast_pattern = std::make_shared<IntToPtrPattern>(); cast_pattern->addChild(arg); return static_cast<IOperandPrototypePtr>(cast_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_ir_manipulation_test_helper_8cpp/","text":"TestTools/IrManipulationTestHelper.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { namespace { inline void ltrim(std::string& str) { str.erase(str.begin(), std::find_if(str.begin(), str.end(), [](uint8_t ch) { return !std::isspace(ch); })); } inline void rtrim(std::string& str) { str.erase( std::find_if(str.rbegin(), str.rend(), [](uint8_t ch) { return !std::isspace(ch); }).base(), str.end()); } inline void trim(std::string& s) { ltrim(s); rtrim(s); } } // namespace IrManipulationTestHelper::IrManipulationTestHelper() { pass_builder_.registerModuleAnalyses(module_analysis_manager_); pass_builder_.registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_.registerFunctionAnalyses(function_analysis_manager_); pass_builder_.registerLoopAnalyses(loop_analysis_manager_); pass_builder_.crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); } bool IrManipulationTestHelper::fromString(String const& data) { module_ = llvm::parseIR(llvm::MemoryBufferRef(data, \"IrManipulationTestHelper\"), error_, context_); compilation_failed_ = (module_ == nullptr); return !compilation_failed_; } String IrManipulationTestHelper::toString() const { String str; llvm::raw_string_ostream ostream(str); ostream << *module_; ostream.flush(); return str; } IrManipulationTestHelper::Strings IrManipulationTestHelper::toBodyInstructions() { if (isModuleBroken()) { return {}; } String data = toString(); Strings ret; auto pos = data.find(\"define i8 @Main() local_unnamed_addr\"); if (pos == String::npos) { return {}; } // Skipping entry pos = data.find(\"entry:\", pos); if (pos == String::npos) { return {}; } auto last_pos = data.find('\\n', pos); assert(last_pos != String::npos); auto next_pos = data.find('\\n', last_pos + 1); auto terminator = data.find('}', pos); while ((next_pos != String::npos) && (next_pos < terminator)) { auto val = data.substr(last_pos, next_pos - last_pos); trim(val); if (val != \"\") { ret.emplace_back(std::move(val)); } last_pos = next_pos; next_pos = data.find('\\n', last_pos + 1); } return ret; } bool IrManipulationTestHelper::hasInstructionSequence(Strings const& instructions) { auto body_instructions = toBodyInstructions(); uint64_t i = 0; uint64_t j = 0; while (i < instructions.size() && j < body_instructions.size()) { auto& a = instructions[i]; auto& b = body_instructions[j]; if (a == b) { ++i; } ++j; } if (i < instructions.size()) { return false; } return true; } void IrManipulationTestHelper::applyProfile( GeneratorPtr const& generator, OptimizationLevel const& optimisation_level, bool debug) { auto profile = generator->newProfile(\"generic\", optimisation_level, debug); profile.apply(*module_); // Verifying that the module is valid if (isModuleBroken()) { throw std::runtime_error(\"Module was broken after applying result\"); } } void IrManipulationTestHelper::declareOpaque(String const& name) { opaque_declarations_.insert(name); } void IrManipulationTestHelper::declareFunction(String const& declaration) { function_declarations_.insert(declaration); } String IrManipulationTestHelper::generateScript(String const& body, String const& args) const { String script = R\"script( ; ModuleID = 'IrManipulationTestHelper' source_filename = \"IrManipulationTestHelper.ll\" )script\"; // Adding opaque types for (auto const& op : opaque_declarations_) { script += \"%\" + op + \" = type opaque\\n\"; } script += \"define i8 @Main(\" + args + \") local_unnamed_addr #0 {\\nentry:\\n\"; script += body; script += \"\\n ret i8 0\\n\"; script += \"\\n}\\n\\n\"; for (auto const& op : function_declarations_) { script += \"declare \" + op + \"\\n\"; } script += \"\\nattributes #0 = { \\\"InteropFriendly\\\" }\\n\"; return script; } String IrManipulationTestHelper::getErrorMessage() const { String str; llvm::raw_string_ostream ostream(str); switch (error_.getKind()) { case llvm::SourceMgr::DiagKind::DK_Error: ostream << \"Error at \"; break; case llvm::SourceMgr::DiagKind::DK_Warning: ostream << \"Warning at \"; break; case llvm::SourceMgr::DiagKind::DK_Remark: ostream << \"Remark at \"; break; case llvm::SourceMgr::DiagKind::DK_Note: ostream << \"Note at \"; break; } ostream << error_.getLineNo() << \":\" << error_.getColumnNo() << \": \"; ostream << error_.getMessage() << \"\\n\\n\"; ostream << error_.getLineContents(); ostream.flush(); return str; } bool IrManipulationTestHelper::fromBodyString(String const& body, String const& args) { auto script = generateScript(body, args); return fromString(script); } IrManipulationTestHelper::ModulePtr& IrManipulationTestHelper::module() { return module_; } bool IrManipulationTestHelper::isModuleBroken() { if (compilation_failed_) { return compilation_failed_; } llvm::VerifierAnalysis verifier; auto result = verifier.run(*module_, module_analysis_manager_); return result.IRBroken; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"TestTools/IrManipulationTestHelper.cpp"},{"location":"Api/Files/_ir_manipulation_test_helper_8cpp/#testtoolsirmanipulationtesthelpercpp","text":"","title":"TestTools/IrManipulationTestHelper.cpp"},{"location":"Api/Files/_ir_manipulation_test_helper_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_ir_manipulation_test_helper_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { namespace { inline void ltrim(std::string& str) { str.erase(str.begin(), std::find_if(str.begin(), str.end(), [](uint8_t ch) { return !std::isspace(ch); })); } inline void rtrim(std::string& str) { str.erase( std::find_if(str.rbegin(), str.rend(), [](uint8_t ch) { return !std::isspace(ch); }).base(), str.end()); } inline void trim(std::string& s) { ltrim(s); rtrim(s); } } // namespace IrManipulationTestHelper::IrManipulationTestHelper() { pass_builder_.registerModuleAnalyses(module_analysis_manager_); pass_builder_.registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_.registerFunctionAnalyses(function_analysis_manager_); pass_builder_.registerLoopAnalyses(loop_analysis_manager_); pass_builder_.crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); } bool IrManipulationTestHelper::fromString(String const& data) { module_ = llvm::parseIR(llvm::MemoryBufferRef(data, \"IrManipulationTestHelper\"), error_, context_); compilation_failed_ = (module_ == nullptr); return !compilation_failed_; } String IrManipulationTestHelper::toString() const { String str; llvm::raw_string_ostream ostream(str); ostream << *module_; ostream.flush(); return str; } IrManipulationTestHelper::Strings IrManipulationTestHelper::toBodyInstructions() { if (isModuleBroken()) { return {}; } String data = toString(); Strings ret; auto pos = data.find(\"define i8 @Main() local_unnamed_addr\"); if (pos == String::npos) { return {}; } // Skipping entry pos = data.find(\"entry:\", pos); if (pos == String::npos) { return {}; } auto last_pos = data.find('\\n', pos); assert(last_pos != String::npos); auto next_pos = data.find('\\n', last_pos + 1); auto terminator = data.find('}', pos); while ((next_pos != String::npos) && (next_pos < terminator)) { auto val = data.substr(last_pos, next_pos - last_pos); trim(val); if (val != \"\") { ret.emplace_back(std::move(val)); } last_pos = next_pos; next_pos = data.find('\\n', last_pos + 1); } return ret; } bool IrManipulationTestHelper::hasInstructionSequence(Strings const& instructions) { auto body_instructions = toBodyInstructions(); uint64_t i = 0; uint64_t j = 0; while (i < instructions.size() && j < body_instructions.size()) { auto& a = instructions[i]; auto& b = body_instructions[j]; if (a == b) { ++i; } ++j; } if (i < instructions.size()) { return false; } return true; } void IrManipulationTestHelper::applyProfile( GeneratorPtr const& generator, OptimizationLevel const& optimisation_level, bool debug) { auto profile = generator->newProfile(\"generic\", optimisation_level, debug); profile.apply(*module_); // Verifying that the module is valid if (isModuleBroken()) { throw std::runtime_error(\"Module was broken after applying result\"); } } void IrManipulationTestHelper::declareOpaque(String const& name) { opaque_declarations_.insert(name); } void IrManipulationTestHelper::declareFunction(String const& declaration) { function_declarations_.insert(declaration); } String IrManipulationTestHelper::generateScript(String const& body, String const& args) const { String script = R\"script( ; ModuleID = 'IrManipulationTestHelper' source_filename = \"IrManipulationTestHelper.ll\" )script\"; // Adding opaque types for (auto const& op : opaque_declarations_) { script += \"%\" + op + \" = type opaque\\n\"; } script += \"define i8 @Main(\" + args + \") local_unnamed_addr #0 {\\nentry:\\n\"; script += body; script += \"\\n ret i8 0\\n\"; script += \"\\n}\\n\\n\"; for (auto const& op : function_declarations_) { script += \"declare \" + op + \"\\n\"; } script += \"\\nattributes #0 = { \\\"InteropFriendly\\\" }\\n\"; return script; } String IrManipulationTestHelper::getErrorMessage() const { String str; llvm::raw_string_ostream ostream(str); switch (error_.getKind()) { case llvm::SourceMgr::DiagKind::DK_Error: ostream << \"Error at \"; break; case llvm::SourceMgr::DiagKind::DK_Warning: ostream << \"Warning at \"; break; case llvm::SourceMgr::DiagKind::DK_Remark: ostream << \"Remark at \"; break; case llvm::SourceMgr::DiagKind::DK_Note: ostream << \"Note at \"; break; } ostream << error_.getLineNo() << \":\" << error_.getColumnNo() << \": \"; ostream << error_.getMessage() << \"\\n\\n\"; ostream << error_.getLineContents(); ostream.flush(); return str; } bool IrManipulationTestHelper::fromBodyString(String const& body, String const& args) { auto script = generateScript(body, args); return fromString(script); } IrManipulationTestHelper::ModulePtr& IrManipulationTestHelper::module() { return module_; } bool IrManipulationTestHelper::isModuleBroken() { if (compilation_failed_) { return compilation_failed_; } llvm::VerifierAnalysis verifier; auto result = verifier.run(*module_, module_analysis_manager_); return result.IRBroken; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_ir_manipulation_test_helper_8hpp/","text":"TestTools/IrManipulationTestHelper.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::IrManipulationTestHelper Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/ProfileGenerator.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_set> #include <vector> namespace microsoft { namespace quantum { class IrManipulationTestHelper { public: using String = std::string; using LLVMContext = llvm::LLVMContext; using SMDiagnostic = llvm::SMDiagnostic; using Module = llvm::Module; using ModulePtr = std::unique_ptr<Module>; using Strings = std::vector<String>; using OptimizationLevel = llvm::PassBuilder::OptimizationLevel; using GeneratorPtr = std::shared_ptr<ProfileGenerator>; // IrManipulationTestHelper is default constructible with no ability to move // or copy. // IrManipulationTestHelper(); IrManipulationTestHelper(IrManipulationTestHelper const&) = delete; IrManipulationTestHelper& operator=(IrManipulationTestHelper const&) = delete; IrManipulationTestHelper(IrManipulationTestHelper&&) = delete; IrManipulationTestHelper& operator=(IrManipulationTestHelper&&) = delete; // Output functions // String toString() const; Strings toBodyInstructions(); // Test functions // bool hasInstructionSequence(Strings const& instructions); void applyProfile( GeneratorPtr const& profile, OptimizationLevel const& optimisation_level = OptimizationLevel::O0, bool debug = false); // Declaration of partial or full IR // void declareOpaque(String const& name); void declareFunction(String const& declaration); bool fromBodyString(String const& body, String const& args = \"\"); String generateScript(String const& body, String const& args = \"\") const; bool fromString(String const& data); String getErrorMessage() const; bool isModuleBroken(); // Acccess member functions // ModulePtr& module(); private: // Declarations // std::unordered_set<std::string> opaque_declarations_{}; std::unordered_set<std::string> function_declarations_{}; // Compilation state // bool compilation_failed_{false}; SMDiagnostic error_; LLVMContext context_; ModulePtr module_; // Objects used to run a set of passes // llvm::PassBuilder pass_builder_; llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"TestTools/IrManipulationTestHelper.hpp"},{"location":"Api/Files/_ir_manipulation_test_helper_8hpp/#testtoolsirmanipulationtesthelperhpp","text":"","title":"TestTools/IrManipulationTestHelper.hpp"},{"location":"Api/Files/_ir_manipulation_test_helper_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_ir_manipulation_test_helper_8hpp/#classes","text":"Name class microsoft::quantum::IrManipulationTestHelper","title":"Classes"},{"location":"Api/Files/_ir_manipulation_test_helper_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/ProfileGenerator.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_set> #include <vector> namespace microsoft { namespace quantum { class IrManipulationTestHelper { public: using String = std::string; using LLVMContext = llvm::LLVMContext; using SMDiagnostic = llvm::SMDiagnostic; using Module = llvm::Module; using ModulePtr = std::unique_ptr<Module>; using Strings = std::vector<String>; using OptimizationLevel = llvm::PassBuilder::OptimizationLevel; using GeneratorPtr = std::shared_ptr<ProfileGenerator>; // IrManipulationTestHelper is default constructible with no ability to move // or copy. // IrManipulationTestHelper(); IrManipulationTestHelper(IrManipulationTestHelper const&) = delete; IrManipulationTestHelper& operator=(IrManipulationTestHelper const&) = delete; IrManipulationTestHelper(IrManipulationTestHelper&&) = delete; IrManipulationTestHelper& operator=(IrManipulationTestHelper&&) = delete; // Output functions // String toString() const; Strings toBodyInstructions(); // Test functions // bool hasInstructionSequence(Strings const& instructions); void applyProfile( GeneratorPtr const& profile, OptimizationLevel const& optimisation_level = OptimizationLevel::O0, bool debug = false); // Declaration of partial or full IR // void declareOpaque(String const& name); void declareFunction(String const& declaration); bool fromBodyString(String const& body, String const& args = \"\"); String generateScript(String const& body, String const& args = \"\") const; bool fromString(String const& data); String getErrorMessage() const; bool isModuleBroken(); // Acccess member functions // ModulePtr& module(); private: // Declarations // std::unordered_set<std::string> opaque_declarations_{}; std::unordered_set<std::string> function_declarations_{}; // Compilation state // bool compilation_failed_{false}; SMDiagnostic error_; LLVMContext context_; ModulePtr module_; // Objects used to run a set of passes // llvm::PassBuilder pass_builder_; llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_llvm_8hpp/","text":"Llvm/Llvm.hpp Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #if defined(__GNUC__) #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wconversion\" #pragma GCC diagnostic ignored \"-Wpedantic\" #pragma GCC diagnostic ignored \"-Wunused-value\" #pragma GCC diagnostic ignored \"-Wsign-compare\" #pragma GCC diagnostic ignored \"-Wunknown-warning-option\" #pragma GCC diagnostic ignored \"-Wunused-parameter\" #pragma GCC diagnostic ignored \"-Wall\" #pragma GCC diagnostic ignored \"-Weverything\" #endif #if defined(__clang__) #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wconversion\" #pragma clang diagnostic ignored \"-Wpedantic\" #pragma clang diagnostic ignored \"-Werror\" #pragma clang diagnostic ignored \"-Wshadow\" #pragma clang diagnostic ignored \"-Wreturn-std-move\" #pragma clang diagnostic ignored \"-Wunknown-warning-option\" #pragma clang diagnostic ignored \"-Wunused-parameter\" #pragma clang diagnostic ignored \"-Wall\" #pragma clang diagnostic ignored \"-Weverything\" #endif // Passes #include \"llvm/Analysis/InlineCost.h\" #include \"llvm/Passes/PassBuilder.h\" #include \"llvm/Passes/PassPlugin.h\" #include \"llvm/Support/raw_ostream.h\" #include \"llvm/Transforms/IPO/Inliner.h\" #include \"llvm/Transforms/Utils/BasicBlockUtils.h\" #include \"llvm/Transforms/Utils/Cloning.h\" // Building #include \"llvm/IR/BasicBlock.h\" #include \"llvm/IR/Constants.h\" #include \"llvm/IR/DerivedTypes.h\" #include \"llvm/IR/Function.h\" #include \"llvm/IR/IRBuilder.h\" #include \"llvm/IR/LLVMContext.h\" #include \"llvm/IR/Module.h\" #include \"llvm/IR/Type.h\" #include \"llvm/IR/Verifier.h\" // Reader tool #include \"llvm/IRReader/IRReader.h\" #include \"llvm/Support/SourceMgr.h\" #include \"llvm/Transforms/IPO/Inliner.h\" #include \"llvm/Transforms/Scalar/LoopUnrollPass.h\" // Profiles #include \"llvm/LinkAllPasses.h\" #include \"llvm/Transforms/Scalar/ADCE.h\" #include \"llvm/Transforms/Scalar/DCE.h\" // Const folding #include \"llvm/Analysis/ConstantFolding.h\" // Linking #include \"llvm/Linker/Linker.h\" // Bitcode output #include \"llvm/Bitcode/BitcodeWriter.h\" #include \"llvm/InitializePasses.h\" #include \"llvm/LinkAllIR.h\" #include \"llvm/LinkAllPasses.h\" #include \"llvm/MC/SubtargetFeature.h\" #include \"llvm/Passes/StandardInstrumentations.h\" #include \"llvm/Support/InitLLVM.h\" #include \"llvm/Support/TargetSelect.h\" #include \"llvm/Target/TargetMachine.h\" #if defined(__clang__) #pragma clang diagnostic pop #endif #if defined(__GNUC__) #pragma GCC diagnostic pop #endif Updated on 22 November 2021 at 10:28:34 UTC","title":"Llvm/Llvm.hpp"},{"location":"Api/Files/_llvm_8hpp/#llvmllvmhpp","text":"","title":"Llvm/Llvm.hpp"},{"location":"Api/Files/_llvm_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #if defined(__GNUC__) #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wconversion\" #pragma GCC diagnostic ignored \"-Wpedantic\" #pragma GCC diagnostic ignored \"-Wunused-value\" #pragma GCC diagnostic ignored \"-Wsign-compare\" #pragma GCC diagnostic ignored \"-Wunknown-warning-option\" #pragma GCC diagnostic ignored \"-Wunused-parameter\" #pragma GCC diagnostic ignored \"-Wall\" #pragma GCC diagnostic ignored \"-Weverything\" #endif #if defined(__clang__) #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wconversion\" #pragma clang diagnostic ignored \"-Wpedantic\" #pragma clang diagnostic ignored \"-Werror\" #pragma clang diagnostic ignored \"-Wshadow\" #pragma clang diagnostic ignored \"-Wreturn-std-move\" #pragma clang diagnostic ignored \"-Wunknown-warning-option\" #pragma clang diagnostic ignored \"-Wunused-parameter\" #pragma clang diagnostic ignored \"-Wall\" #pragma clang diagnostic ignored \"-Weverything\" #endif // Passes #include \"llvm/Analysis/InlineCost.h\" #include \"llvm/Passes/PassBuilder.h\" #include \"llvm/Passes/PassPlugin.h\" #include \"llvm/Support/raw_ostream.h\" #include \"llvm/Transforms/IPO/Inliner.h\" #include \"llvm/Transforms/Utils/BasicBlockUtils.h\" #include \"llvm/Transforms/Utils/Cloning.h\" // Building #include \"llvm/IR/BasicBlock.h\" #include \"llvm/IR/Constants.h\" #include \"llvm/IR/DerivedTypes.h\" #include \"llvm/IR/Function.h\" #include \"llvm/IR/IRBuilder.h\" #include \"llvm/IR/LLVMContext.h\" #include \"llvm/IR/Module.h\" #include \"llvm/IR/Type.h\" #include \"llvm/IR/Verifier.h\" // Reader tool #include \"llvm/IRReader/IRReader.h\" #include \"llvm/Support/SourceMgr.h\" #include \"llvm/Transforms/IPO/Inliner.h\" #include \"llvm/Transforms/Scalar/LoopUnrollPass.h\" // Profiles #include \"llvm/LinkAllPasses.h\" #include \"llvm/Transforms/Scalar/ADCE.h\" #include \"llvm/Transforms/Scalar/DCE.h\" // Const folding #include \"llvm/Analysis/ConstantFolding.h\" // Linking #include \"llvm/Linker/Linker.h\" // Bitcode output #include \"llvm/Bitcode/BitcodeWriter.h\" #include \"llvm/InitializePasses.h\" #include \"llvm/LinkAllIR.h\" #include \"llvm/LinkAllPasses.h\" #include \"llvm/MC/SubtargetFeature.h\" #include \"llvm/Passes/StandardInstrumentations.h\" #include \"llvm/Support/InitLLVM.h\" #include \"llvm/Support/TargetSelect.h\" #include \"llvm/Target/TargetMachine.h\" #if defined(__clang__) #pragma clang diagnostic pop #endif #if defined(__GNUC__) #pragma GCC diagnostic pop #endif Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_llvm_passes_configuration_8cpp/","text":"Generators/LlvmPassesConfiguration.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"Generators/LlvmPassesConfiguration.hpp\" namespace microsoft { namespace quantum { LlvmPassesConfiguration::LlvmPassesConfiguration() = default; void LlvmPassesConfiguration::setup(ConfigurationManager& config) { config.setSectionName(\"LLVM Passes\", \"Configuration of LLVM passes.\"); config.addParameter(always_inline_, \"always-inline\", \"Aggressively inline function calls.\"); config.addParameter( default_pipeline_is_disabled_, \"disable-default-pipeline\", \"Disables the the default pipeline.\"); config.addParameter(pass_pipeline_, \"passes\", \"LLVM passes pipeline to use upon applying this component.\"); config.addParameter(inline_parameter_, \"inlining-parameter\", \"Number of code lines acceptable when inlining.\"); } LlvmPassesConfiguration LlvmPassesConfiguration::createDisabled() { LlvmPassesConfiguration ret; ret.always_inline_ = false; ret.pass_pipeline_ = \"\"; ret.default_pipeline_is_disabled_ = true; return ret; } bool LlvmPassesConfiguration::alwaysInline() const { return always_inline_; } bool LlvmPassesConfiguration::disableDefaultPipeline() const { return default_pipeline_is_disabled_; } std::string LlvmPassesConfiguration::passPipeline() const { return pass_pipeline_; } bool LlvmPassesConfiguration::isDisabled() const { return always_inline_ == false && pass_pipeline_ == \"\"; } bool LlvmPassesConfiguration::operator==(LlvmPassesConfiguration const& ref) const { return always_inline_ == ref.always_inline_; } int32_t LlvmPassesConfiguration::inlineParameter() const { return inline_parameter_; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Generators/LlvmPassesConfiguration.cpp"},{"location":"Api/Files/_llvm_passes_configuration_8cpp/#generatorsllvmpassesconfigurationcpp","text":"","title":"Generators/LlvmPassesConfiguration.cpp"},{"location":"Api/Files/_llvm_passes_configuration_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_llvm_passes_configuration_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"Generators/LlvmPassesConfiguration.hpp\" namespace microsoft { namespace quantum { LlvmPassesConfiguration::LlvmPassesConfiguration() = default; void LlvmPassesConfiguration::setup(ConfigurationManager& config) { config.setSectionName(\"LLVM Passes\", \"Configuration of LLVM passes.\"); config.addParameter(always_inline_, \"always-inline\", \"Aggressively inline function calls.\"); config.addParameter( default_pipeline_is_disabled_, \"disable-default-pipeline\", \"Disables the the default pipeline.\"); config.addParameter(pass_pipeline_, \"passes\", \"LLVM passes pipeline to use upon applying this component.\"); config.addParameter(inline_parameter_, \"inlining-parameter\", \"Number of code lines acceptable when inlining.\"); } LlvmPassesConfiguration LlvmPassesConfiguration::createDisabled() { LlvmPassesConfiguration ret; ret.always_inline_ = false; ret.pass_pipeline_ = \"\"; ret.default_pipeline_is_disabled_ = true; return ret; } bool LlvmPassesConfiguration::alwaysInline() const { return always_inline_; } bool LlvmPassesConfiguration::disableDefaultPipeline() const { return default_pipeline_is_disabled_; } std::string LlvmPassesConfiguration::passPipeline() const { return pass_pipeline_; } bool LlvmPassesConfiguration::isDisabled() const { return always_inline_ == false && pass_pipeline_ == \"\"; } bool LlvmPassesConfiguration::operator==(LlvmPassesConfiguration const& ref) const { return always_inline_ == ref.always_inline_; } int32_t LlvmPassesConfiguration::inlineParameter() const { return inline_parameter_; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_llvm_passes_configuration_8hpp/","text":"Generators/LlvmPassesConfiguration.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::LlvmPassesConfiguration Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include <limits> namespace microsoft { namespace quantum { class LlvmPassesConfiguration { public: // Default constructor which sets the standard pipeline. LlvmPassesConfiguration(); // Setup and pre-fabricated configurations void setup(ConfigurationManager& config); static LlvmPassesConfiguration createDisabled(); // Configuration interpretation // bool isDisabled() const; bool operator==(LlvmPassesConfiguration const& ref) const; // Flags and options // bool alwaysInline() const; bool disableDefaultPipeline() const; std::string passPipeline() const; int32_t inlineParameter() const; private: // Variables that enables or disables the adding of specific passes // bool always_inline_{false}; bool default_pipeline_is_disabled_{false}; std::string pass_pipeline_{\"\"}; int32_t inline_parameter_{std::numeric_limits<int32_t>::max()}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Generators/LlvmPassesConfiguration.hpp"},{"location":"Api/Files/_llvm_passes_configuration_8hpp/#generatorsllvmpassesconfigurationhpp","text":"","title":"Generators/LlvmPassesConfiguration.hpp"},{"location":"Api/Files/_llvm_passes_configuration_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_llvm_passes_configuration_8hpp/#classes","text":"Name class microsoft::quantum::LlvmPassesConfiguration","title":"Classes"},{"location":"Api/Files/_llvm_passes_configuration_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include <limits> namespace microsoft { namespace quantum { class LlvmPassesConfiguration { public: // Default constructor which sets the standard pipeline. LlvmPassesConfiguration(); // Setup and pre-fabricated configurations void setup(ConfigurationManager& config); static LlvmPassesConfiguration createDisabled(); // Configuration interpretation // bool isDisabled() const; bool operator==(LlvmPassesConfiguration const& ref) const; // Flags and options // bool alwaysInline() const; bool disableDefaultPipeline() const; std::string passPipeline() const; int32_t inlineParameter() const; private: // Variables that enables or disables the adding of specific passes // bool always_inline_{false}; bool default_pipeline_is_disabled_{false}; std::string pass_pipeline_{\"\"}; int32_t inline_parameter_{std::numeric_limits<int32_t>::max()}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_load_8cpp/","text":"Rules/Notation/Load.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr load(IOperandPrototypePtr const& arg) { auto ret = std::make_shared<LoadPattern>(); ret->addChild(arg); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Notation/Load.cpp"},{"location":"Api/Files/_load_8cpp/#rulesnotationloadcpp","text":"","title":"Rules/Notation/Load.cpp"},{"location":"Api/Files/_load_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_load_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr load(IOperandPrototypePtr const& arg) { auto ret = std::make_shared<LoadPattern>(); ret->addChild(arg); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_log_collection_8cpp/","text":"Logging/LogCollection.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/LogCollection.hpp\" #include <vector> namespace microsoft { namespace quantum { void LogCollection::debug(String const& message) { messages_.push_back({Type::Debug, current_location_, message}); } void LogCollection::info(String const& message) { messages_.push_back({Type::Info, current_location_, message}); } void LogCollection::warning(String const& message) { messages_.push_back({Type::Warning, current_location_, message}); } void LogCollection::error(String const& message) { messages_.push_back({Type::Error, current_location_, message}); } void LogCollection::internalError(String const& message) { messages_.push_back({Type::InternalError, current_location_, message}); } void LogCollection::setLocation(String const& name, uint64_t row, uint64_t col) { current_location_.name = name; current_location_.row = row; current_location_.col = col; } LogCollection::Messages const& LogCollection::messages() const { return messages_; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Logging/LogCollection.cpp"},{"location":"Api/Files/_log_collection_8cpp/#logginglogcollectioncpp","text":"","title":"Logging/LogCollection.cpp"},{"location":"Api/Files/_log_collection_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_log_collection_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/LogCollection.hpp\" #include <vector> namespace microsoft { namespace quantum { void LogCollection::debug(String const& message) { messages_.push_back({Type::Debug, current_location_, message}); } void LogCollection::info(String const& message) { messages_.push_back({Type::Info, current_location_, message}); } void LogCollection::warning(String const& message) { messages_.push_back({Type::Warning, current_location_, message}); } void LogCollection::error(String const& message) { messages_.push_back({Type::Error, current_location_, message}); } void LogCollection::internalError(String const& message) { messages_.push_back({Type::InternalError, current_location_, message}); } void LogCollection::setLocation(String const& name, uint64_t row, uint64_t col) { current_location_.name = name; current_location_.row = row; current_location_.col = col; } LogCollection::Messages const& LogCollection::messages() const { return messages_; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_log_collection_8hpp/","text":"Logging/LogCollection.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::LogCollection struct microsoft::quantum::LogCollection::Location Class that holds the location of where the incident happened. struct microsoft::quantum::LogCollection::Message Struct to hold a message together with its type and location. Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/ILogger.hpp\" #include <vector> namespace microsoft { namespace quantum { class LogCollection : public ILogger { public: struct Location { String name{}; uint64_t row{0}; uint64_t col{0}; }; enum class Type { Debug, Info, Warning, Error, InternalError, }; struct Message { Type type; Location location; String message; }; using Messages = std::vector<Message>; // Interface implementation // void debug(String const& message) override; void info(String const& message) override; void warning(String const& message) override; void error(String const& message) override; void internalError(String const& message) override; void setLocation(String const& name, uint64_t row, uint64_t col) override; Messages const& messages() const; private: Location current_location_{}; Messages messages_; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Logging/LogCollection.hpp"},{"location":"Api/Files/_log_collection_8hpp/#logginglogcollectionhpp","text":"","title":"Logging/LogCollection.hpp"},{"location":"Api/Files/_log_collection_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_log_collection_8hpp/#classes","text":"Name class microsoft::quantum::LogCollection struct microsoft::quantum::LogCollection::Location Class that holds the location of where the incident happened. struct microsoft::quantum::LogCollection::Message Struct to hold a message together with its type and location.","title":"Classes"},{"location":"Api/Files/_log_collection_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/ILogger.hpp\" #include <vector> namespace microsoft { namespace quantum { class LogCollection : public ILogger { public: struct Location { String name{}; uint64_t row{0}; uint64_t col{0}; }; enum class Type { Debug, Info, Warning, Error, InternalError, }; struct Message { Type type; Location location; String message; }; using Messages = std::vector<Message>; // Interface implementation // void debug(String const& message) override; void info(String const& message) override; void warning(String const& message) override; void error(String const& message) override; void internalError(String const& message) override; void setLocation(String const& name, uint64_t row, uint64_t col) override; Messages const& messages() const; private: Location current_location_{}; Messages messages_; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_loop_unrolling_8cpp/","text":"TransformationRulesPass/Tests/Unit/LoopUnrolling.cpp Functions Name TEST ( TransformationRulesPass , LoopUnroll ) Functions Documentation function TEST TEST( TransformationRulesPass , LoopUnroll ) Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareOpaque(\"Array\"); ir_manip->declareOpaque(\"Tuple\"); ir_manip->declareOpaque(\"Range\"); ir_manip->declareOpaque(\"Callable\"); ir_manip->declareOpaque(\"String\"); ir_manip->declareFunction(\"%Qubit* @__quantum__rt__qubit_allocate()\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); ir_manip->declareFunction(\"i64 @TeleportChain__Calculate__body(i64, %Qubit*)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->generateScript(script) << \"\\n\\n\"; llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(TransformationRulesPass, LoopUnroll) { auto ir_manip = newIrManip(R\"script( %q = call %Qubit* @__quantum__rt__qubit_allocate() %ret = alloca i64, align 8 store i64 1, i64* %ret, align 4 br label %header__1 header__1: ; preds = %exiting__1, %entry %i = phi i64 [ 0, %entry ], [ %4, %exiting__1 ] %0 = icmp sle i64 %i, 5 br i1 %0, label %body__1, label %exit__1 body__1: ; preds = %header__1 %1 = load i64, i64* %ret, align 4 %2 = call i64 @TeleportChain__Calculate__body(i64 4, %Qubit* %q) %3 = add i64 %1, %2 store i64 %3, i64* %ret, align 4 br label %exiting__1 exiting__1: ; preds = %body__1 %4 = add i64 %i, 1 br label %header__1 exit__1: ; preds = %header__1 %5 = load i64, i64* %ret, align 4 call void @__quantum__rt__qubit_release(%Qubit* %q) )script\"); auto profile = std::make_shared<DefaultProfileGenerator>(); ConfigurationManager& configuration_manager = profile->configurationManager(); configuration_manager.addConfig<FactoryConfiguration>(); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence( {\"%0 = tail call i64 @TeleportChain__Calculate__body(i64 4, %Qubit* null)\", \"%1 = tail call i64 @TeleportChain__Calculate__body(i64 4, %Qubit* null)\", \"%2 = tail call i64 @TeleportChain__Calculate__body(i64 4, %Qubit* null)\", \"%3 = tail call i64 @TeleportChain__Calculate__body(i64 4, %Qubit* null)\", \"%4 = tail call i64 @TeleportChain__Calculate__body(i64 4, %Qubit* null)\", \"%5 = tail call i64 @TeleportChain__Calculate__body(i64 4, %Qubit* null)\"})); } Updated on 22 November 2021 at 10:28:34 UTC","title":"TransformationRulesPass/Tests/Unit/LoopUnrolling.cpp"},{"location":"Api/Files/_loop_unrolling_8cpp/#transformationrulespasstestsunitloopunrollingcpp","text":"","title":"TransformationRulesPass/Tests/Unit/LoopUnrolling.cpp"},{"location":"Api/Files/_loop_unrolling_8cpp/#functions","text":"Name TEST ( TransformationRulesPass , LoopUnroll )","title":"Functions"},{"location":"Api/Files/_loop_unrolling_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Files/_loop_unrolling_8cpp/#function-test","text":"TEST( TransformationRulesPass , LoopUnroll )","title":"function TEST"},{"location":"Api/Files/_loop_unrolling_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareOpaque(\"Array\"); ir_manip->declareOpaque(\"Tuple\"); ir_manip->declareOpaque(\"Range\"); ir_manip->declareOpaque(\"Callable\"); ir_manip->declareOpaque(\"String\"); ir_manip->declareFunction(\"%Qubit* @__quantum__rt__qubit_allocate()\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); ir_manip->declareFunction(\"i64 @TeleportChain__Calculate__body(i64, %Qubit*)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->generateScript(script) << \"\\n\\n\"; llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(TransformationRulesPass, LoopUnroll) { auto ir_manip = newIrManip(R\"script( %q = call %Qubit* @__quantum__rt__qubit_allocate() %ret = alloca i64, align 8 store i64 1, i64* %ret, align 4 br label %header__1 header__1: ; preds = %exiting__1, %entry %i = phi i64 [ 0, %entry ], [ %4, %exiting__1 ] %0 = icmp sle i64 %i, 5 br i1 %0, label %body__1, label %exit__1 body__1: ; preds = %header__1 %1 = load i64, i64* %ret, align 4 %2 = call i64 @TeleportChain__Calculate__body(i64 4, %Qubit* %q) %3 = add i64 %1, %2 store i64 %3, i64* %ret, align 4 br label %exiting__1 exiting__1: ; preds = %body__1 %4 = add i64 %i, 1 br label %header__1 exit__1: ; preds = %header__1 %5 = load i64, i64* %ret, align 4 call void @__quantum__rt__qubit_release(%Qubit* %q) )script\"); auto profile = std::make_shared<DefaultProfileGenerator>(); ConfigurationManager& configuration_manager = profile->configurationManager(); configuration_manager.addConfig<FactoryConfiguration>(); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence( {\"%0 = tail call i64 @TeleportChain__Calculate__body(i64 4, %Qubit* null)\", \"%1 = tail call i64 @TeleportChain__Calculate__body(i64 4, %Qubit* null)\", \"%2 = tail call i64 @TeleportChain__Calculate__body(i64 4, %Qubit* null)\", \"%3 = tail call i64 @TeleportChain__Calculate__body(i64 4, %Qubit* null)\", \"%4 = tail call i64 @TeleportChain__Calculate__body(i64 4, %Qubit* null)\", \"%5 = tail call i64 @TeleportChain__Calculate__body(i64 4, %Qubit* null)\"})); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_mini_tele_chain_8cpp/","text":"TransformationRulesPass/Tests/Unit/MiniTeleChain.cpp Functions Name TEST ( TransformationRulesPass , TeleportChain ) Functions Documentation function TEST TEST( TransformationRulesPass , TeleportChain ) Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareOpaque(\"Array\"); ir_manip->declareOpaque(\"Tuple\"); ir_manip->declareOpaque(\"Range\"); ir_manip->declareOpaque(\"Callable\"); ir_manip->declareOpaque(\"String\"); ir_manip->declareFunction(\"%Qubit* @__quantum__rt__qubit_allocate()\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); ir_manip->declareFunction(\"%Array* @__quantum__rt__qubit_allocate_array(i64)\"); ir_manip->declareFunction(\"void @__quantum__rt__array_update_alias_count(%Array*, i32)\"); ir_manip->declareFunction(\"void @__quantum__qis__cnot__body(%Qubit*, %Qubit*)\"); ir_manip->declareFunction(\"i8* @__quantum__rt__array_get_element_ptr_1d(%Array*, i64)\"); ir_manip->declareFunction(\"%Result* @__quantum__qis__m__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__reset__body(%Qubit*)\"); ir_manip->declareFunction(\"%Result* @__quantum__rt__result_get_one()\"); ir_manip->declareFunction(\"i1 @__quantum__rt__result_equal(%Result*, %Result*)\"); ir_manip->declareFunction(\"void @__quantum__rt__result_update_reference_count(%Result*, i32)\"); ir_manip->declareFunction(\"void @__quantum__qis__z__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__x__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__rt__message(%String*)\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release_array(%Array*)\"); ir_manip->declareFunction(\"%String* @__quantum__rt__result_to_string(%Result*)\"); ir_manip->declareFunction(\"void @__quantum__rt__string_update_reference_count(%String*, i32)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->generateScript(script) << \"\\n\\n\"; llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(TransformationRulesPass, TeleportChain) { auto ir_manip = newIrManip(R\"script( %leftMessage.i = tail call %Qubit* @__quantum__rt__qubit_allocate() %rightMessage.i = tail call %Qubit* @__quantum__rt__qubit_allocate() %leftPreshared.i = tail call %Array* @__quantum__rt__qubit_allocate_array(i64 2) tail call void @__quantum__rt__array_update_alias_count(%Array* %leftPreshared.i, i32 1) %rightPreshared.i = tail call %Array* @__quantum__rt__qubit_allocate_array(i64 2) tail call void @__quantum__rt__array_update_alias_count(%Array* %rightPreshared.i, i32 1) tail call void @__quantum__qis__h__body(%Qubit* %leftMessage.i) tail call void @__quantum__qis__cnot__body(%Qubit* %leftMessage.i, %Qubit* %rightMessage.i) %0 = tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %leftPreshared.i, i64 0) %1 = bitcast i8* %0 to %Qubit** %2 = load %Qubit*, %Qubit** %1, align 8 %3 = tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %rightPreshared.i, i64 0) %4 = bitcast i8* %3 to %Qubit** %5 = load %Qubit*, %Qubit** %4, align 8 tail call void @__quantum__qis__h__body(%Qubit* %2) tail call void @__quantum__qis__cnot__body(%Qubit* %2, %Qubit* %5) %6 = tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %leftPreshared.i, i64 1) %7 = bitcast i8* %6 to %Qubit** %8 = load %Qubit*, %Qubit** %7, align 8 %9 = tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %rightPreshared.i, i64 1) %10 = bitcast i8* %9 to %Qubit** %11 = load %Qubit*, %Qubit** %10, align 8 tail call void @__quantum__qis__h__body(%Qubit* %8) tail call void @__quantum__qis__cnot__body(%Qubit* %8, %Qubit* %11) %12 = tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %leftPreshared.i, i64 0) %13 = bitcast i8* %12 to %Qubit** %14 = load %Qubit*, %Qubit** %13, align 8 %15 = tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %rightPreshared.i, i64 0) %16 = bitcast i8* %15 to %Qubit** %17 = load %Qubit*, %Qubit** %16, align 8 tail call void @__quantum__qis__cnot__body(%Qubit* %rightMessage.i, %Qubit* %14) tail call void @__quantum__qis__h__body(%Qubit* %rightMessage.i) %result.i.i.i.i = tail call %Result* @__quantum__qis__m__body(%Qubit* %rightMessage.i) tail call void @__quantum__qis__reset__body(%Qubit* %rightMessage.i) %18 = tail call %Result* @__quantum__rt__result_get_one() %19 = tail call i1 @__quantum__rt__result_equal(%Result* %result.i.i.i.i, %Result* %18) tail call void @__quantum__rt__result_update_reference_count(%Result* %result.i.i.i.i, i32 -1) br i1 %19, label %then0__1.i.i.i, label %continue__1.i.i.i then0__1.i.i.i: ; preds = %entry tail call void @__quantum__qis__z__body(%Qubit* %17) br label %continue__1.i.i.i continue__1.i.i.i: ; preds = %then0__1.i.i.i, %entry %result.i1.i.i.i = tail call %Result* @__quantum__qis__m__body(%Qubit* %14) tail call void @__quantum__qis__reset__body(%Qubit* %14) %20 = tail call %Result* @__quantum__rt__result_get_one() %21 = tail call i1 @__quantum__rt__result_equal(%Result* %result.i1.i.i.i, %Result* %20) tail call void @__quantum__rt__result_update_reference_count(%Result* %result.i1.i.i.i, i32 -1) br i1 %21, label %then0__2.i.i.i, label %TeleportChain__TeleportQubitUsingPresharedEntanglement__body.2.exit.i then0__2.i.i.i: ; preds = %continue__1.i.i.i tail call void @__quantum__qis__x__body(%Qubit* %17) br label %TeleportChain__TeleportQubitUsingPresharedEntanglement__body.2.exit.i TeleportChain__TeleportQubitUsingPresharedEntanglement__body.2.exit.i: ; preds = %then0__2.i.i.i, %continue__1.i.i.i %22 = tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %rightPreshared.i, i64 0) %23 = bitcast i8* %22 to %Qubit** %24 = load %Qubit*, %Qubit** %23, align 8 %25 = tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %leftPreshared.i, i64 1) %26 = bitcast i8* %25 to %Qubit** %27 = load %Qubit*, %Qubit** %26, align 8 %28 = tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %rightPreshared.i, i64 1) %29 = bitcast i8* %28 to %Qubit** %30 = load %Qubit*, %Qubit** %29, align 8 tail call void @__quantum__qis__cnot__body(%Qubit* %24, %Qubit* %27) tail call void @__quantum__qis__h__body(%Qubit* %24) %result.i.i.i1.i = tail call %Result* @__quantum__qis__m__body(%Qubit* %24) tail call void @__quantum__qis__reset__body(%Qubit* %24) %31 = tail call %Result* @__quantum__rt__result_get_one() %32 = tail call i1 @__quantum__rt__result_equal(%Result* %result.i.i.i1.i, %Result* %31) tail call void @__quantum__rt__result_update_reference_count(%Result* %result.i.i.i1.i, i32 -1) br i1 %32, label %then0__1.i.i2.i, label %continue__1.i.i4.i then0__1.i.i2.i: ; preds = %TeleportChain__TeleportQubitUsingPresharedEntanglement__body.2.exit.i tail call void @__quantum__qis__z__body(%Qubit* %30) br label %continue__1.i.i4.i continue__1.i.i4.i: ; preds = %then0__1.i.i2.i, %TeleportChain__TeleportQubitUsingPresharedEntanglement__body.2.exit.i %result.i1.i.i3.i = tail call %Result* @__quantum__qis__m__body(%Qubit* %27) tail call void @__quantum__qis__reset__body(%Qubit* %27) %33 = tail call %Result* @__quantum__rt__result_get_one() %34 = tail call i1 @__quantum__rt__result_equal(%Result* %result.i1.i.i3.i, %Result* %33) tail call void @__quantum__rt__result_update_reference_count(%Result* %result.i1.i.i3.i, i32 -1) br i1 %34, label %then0__2.i.i5.i, label %TeleportChain__DemonstrateTeleportationUsingPresharedEntanglement__body.1.exit then0__2.i.i5.i: ; preds = %continue__1.i.i4.i tail call void @__quantum__qis__x__body(%Qubit* %30) br label %TeleportChain__DemonstrateTeleportationUsingPresharedEntanglement__body.1.exit TeleportChain__DemonstrateTeleportationUsingPresharedEntanglement__body.1.exit: ; preds = %continue__1.i.i4.i, %then0__2.i.i5.i %result.i.i = tail call %Result* @__quantum__qis__m__body(%Qubit* %leftMessage.i) tail call void @__quantum__qis__reset__body(%Qubit* %leftMessage.i) %35 = tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %rightPreshared.i, i64 1) %36 = bitcast i8* %35 to %Qubit** %37 = load %Qubit*, %Qubit** %36, align 8 %result.i1.i = tail call %Result* @__quantum__qis__m__body(%Qubit* %37) tail call void @__quantum__qis__reset__body(%Qubit* %37) tail call void @__quantum__rt__array_update_alias_count(%Array* %leftPreshared.i, i32 -1) tail call void @__quantum__rt__array_update_alias_count(%Array* %rightPreshared.i, i32 -1) tail call void @__quantum__rt__result_update_reference_count(%Result* %result.i.i, i32 -1) tail call void @__quantum__rt__qubit_release(%Qubit* %leftMessage.i) tail call void @__quantum__rt__qubit_release(%Qubit* %rightMessage.i) tail call void @__quantum__rt__qubit_release_array(%Array* %leftPreshared.i) tail call void @__quantum__rt__qubit_release_array(%Array* %rightPreshared.i) %38 = tail call %String* @__quantum__rt__result_to_string(%Result* %result.i1.i) tail call void @__quantum__rt__message(%String* %38) tail call void @__quantum__rt__result_update_reference_count(%Result* %result.i1.i, i32 -1) tail call void @__quantum__rt__string_update_reference_count(%String* %38, i32 -1) )script\"); auto profile = std::make_shared<DefaultProfileGenerator>(); ConfigurationManager& configuration_manager = profile->configurationManager(); configuration_manager.addConfig<FactoryConfiguration>(); ir_manip->applyProfile(profile); llvm::outs() << *ir_manip->module() << \"\\n\"; EXPECT_TRUE(ir_manip->hasInstructionSequence({ // clang-format off \"tail call void @__quantum__qis__h__body(%Qubit* null)\", \"tail call void @__quantum__qis__cnot__body(%Qubit* null, %Qubit* nonnull inttoptr (i64 1 to %Qubit*))\", \"tail call void @__quantum__qis__h__body(%Qubit* nonnull inttoptr (i64 2 to %Qubit*))\", \"tail call void @__quantum__qis__cnot__body(%Qubit* nonnull inttoptr (i64 2 to %Qubit*), %Qubit* nonnull inttoptr (i64 4 to %Qubit*))\", \"tail call void @__quantum__qis__h__body(%Qubit* nonnull inttoptr (i64 3 to %Qubit*))\", \"tail call void @__quantum__qis__cnot__body(%Qubit* nonnull inttoptr (i64 3 to %Qubit*), %Qubit* nonnull inttoptr (i64 5 to %Qubit*))\", \"tail call void @__quantum__qis__cnot__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*), %Qubit* nonnull inttoptr (i64 2 to %Qubit*))\", \"tail call void @__quantum__qis__h__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*))\", \"tail call void @__quantum__qis__mz__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*), %Result* null)\", \"tail call void @__quantum__qis__reset__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*))\", \"%0 = tail call i1 @__quantum__qis__read_result__body(%Result* null)\", \"br i1 %0, label %then0__1.i.i.i, label %continue__1.i.i.i\", // clang-format on })); EXPECT_TRUE(ir_manip->hasInstructionSequence({ // clang-format off \"tail call void @__quantum__qis__mz__body(%Qubit* nonnull inttoptr (i64 2 to %Qubit*), %Result* nonnull inttoptr (i64 1 to %Result*))\", \"tail call void @__quantum__qis__reset__body(%Qubit* nonnull inttoptr (i64 2 to %Qubit*))\", \"%1 = tail call i1 @__quantum__qis__read_result__body(%Result* nonnull inttoptr (i64 1 to %Result*))\", \"br i1 %1, label %then0__2.i.i.i, label %TeleportChain__TeleportQubitUsingPresharedEntanglement__body.2.exit.i\", // clang-format on })); EXPECT_TRUE(ir_manip->hasInstructionSequence({ // clang-format off \"tail call void @__quantum__qis__cnot__body(%Qubit* nonnull inttoptr (i64 4 to %Qubit*), %Qubit* nonnull inttoptr (i64 3 to %Qubit*))\", \"tail call void @__quantum__qis__h__body(%Qubit* nonnull inttoptr (i64 4 to %Qubit*))\", \"tail call void @__quantum__qis__mz__body(%Qubit* nonnull inttoptr (i64 4 to %Qubit*), %Result* nonnull inttoptr (i64 2 to %Result*))\", \"tail call void @__quantum__qis__reset__body(%Qubit* nonnull inttoptr (i64 4 to %Qubit*))\", \"%2 = tail call i1 @__quantum__qis__read_result__body(%Result* nonnull inttoptr (i64 2 to %Result*))\", \"br i1 %2, label %then0__1.i.i2.i, label %continue__1.i.i4.i\", // clang-format on })); EXPECT_TRUE(ir_manip->hasInstructionSequence({ // clang-format off \"tail call void @__quantum__qis__mz__body(%Qubit* nonnull inttoptr (i64 3 to %Qubit*), %Result* nonnull inttoptr (i64 3 to %Result*))\", \"tail call void @__quantum__qis__reset__body(%Qubit* nonnull inttoptr (i64 3 to %Qubit*))\", \"%3 = tail call i1 @__quantum__qis__read_result__body(%Result* nonnull inttoptr (i64 3 to %Result*))\", \"br i1 %3, label %then0__2.i.i5.i, label %TeleportChain__DemonstrateTeleportationUsingPresharedEntanglement__body.1.exit\", // clang-format on })); } Updated on 22 November 2021 at 10:28:34 UTC","title":"TransformationRulesPass/Tests/Unit/MiniTeleChain.cpp"},{"location":"Api/Files/_mini_tele_chain_8cpp/#transformationrulespasstestsunitminitelechaincpp","text":"","title":"TransformationRulesPass/Tests/Unit/MiniTeleChain.cpp"},{"location":"Api/Files/_mini_tele_chain_8cpp/#functions","text":"Name TEST ( TransformationRulesPass , TeleportChain )","title":"Functions"},{"location":"Api/Files/_mini_tele_chain_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Files/_mini_tele_chain_8cpp/#function-test","text":"TEST( TransformationRulesPass , TeleportChain )","title":"function TEST"},{"location":"Api/Files/_mini_tele_chain_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareOpaque(\"Array\"); ir_manip->declareOpaque(\"Tuple\"); ir_manip->declareOpaque(\"Range\"); ir_manip->declareOpaque(\"Callable\"); ir_manip->declareOpaque(\"String\"); ir_manip->declareFunction(\"%Qubit* @__quantum__rt__qubit_allocate()\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); ir_manip->declareFunction(\"%Array* @__quantum__rt__qubit_allocate_array(i64)\"); ir_manip->declareFunction(\"void @__quantum__rt__array_update_alias_count(%Array*, i32)\"); ir_manip->declareFunction(\"void @__quantum__qis__cnot__body(%Qubit*, %Qubit*)\"); ir_manip->declareFunction(\"i8* @__quantum__rt__array_get_element_ptr_1d(%Array*, i64)\"); ir_manip->declareFunction(\"%Result* @__quantum__qis__m__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__reset__body(%Qubit*)\"); ir_manip->declareFunction(\"%Result* @__quantum__rt__result_get_one()\"); ir_manip->declareFunction(\"i1 @__quantum__rt__result_equal(%Result*, %Result*)\"); ir_manip->declareFunction(\"void @__quantum__rt__result_update_reference_count(%Result*, i32)\"); ir_manip->declareFunction(\"void @__quantum__qis__z__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__x__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__rt__message(%String*)\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release_array(%Array*)\"); ir_manip->declareFunction(\"%String* @__quantum__rt__result_to_string(%Result*)\"); ir_manip->declareFunction(\"void @__quantum__rt__string_update_reference_count(%String*, i32)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->generateScript(script) << \"\\n\\n\"; llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(TransformationRulesPass, TeleportChain) { auto ir_manip = newIrManip(R\"script( %leftMessage.i = tail call %Qubit* @__quantum__rt__qubit_allocate() %rightMessage.i = tail call %Qubit* @__quantum__rt__qubit_allocate() %leftPreshared.i = tail call %Array* @__quantum__rt__qubit_allocate_array(i64 2) tail call void @__quantum__rt__array_update_alias_count(%Array* %leftPreshared.i, i32 1) %rightPreshared.i = tail call %Array* @__quantum__rt__qubit_allocate_array(i64 2) tail call void @__quantum__rt__array_update_alias_count(%Array* %rightPreshared.i, i32 1) tail call void @__quantum__qis__h__body(%Qubit* %leftMessage.i) tail call void @__quantum__qis__cnot__body(%Qubit* %leftMessage.i, %Qubit* %rightMessage.i) %0 = tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %leftPreshared.i, i64 0) %1 = bitcast i8* %0 to %Qubit** %2 = load %Qubit*, %Qubit** %1, align 8 %3 = tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %rightPreshared.i, i64 0) %4 = bitcast i8* %3 to %Qubit** %5 = load %Qubit*, %Qubit** %4, align 8 tail call void @__quantum__qis__h__body(%Qubit* %2) tail call void @__quantum__qis__cnot__body(%Qubit* %2, %Qubit* %5) %6 = tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %leftPreshared.i, i64 1) %7 = bitcast i8* %6 to %Qubit** %8 = load %Qubit*, %Qubit** %7, align 8 %9 = tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %rightPreshared.i, i64 1) %10 = bitcast i8* %9 to %Qubit** %11 = load %Qubit*, %Qubit** %10, align 8 tail call void @__quantum__qis__h__body(%Qubit* %8) tail call void @__quantum__qis__cnot__body(%Qubit* %8, %Qubit* %11) %12 = tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %leftPreshared.i, i64 0) %13 = bitcast i8* %12 to %Qubit** %14 = load %Qubit*, %Qubit** %13, align 8 %15 = tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %rightPreshared.i, i64 0) %16 = bitcast i8* %15 to %Qubit** %17 = load %Qubit*, %Qubit** %16, align 8 tail call void @__quantum__qis__cnot__body(%Qubit* %rightMessage.i, %Qubit* %14) tail call void @__quantum__qis__h__body(%Qubit* %rightMessage.i) %result.i.i.i.i = tail call %Result* @__quantum__qis__m__body(%Qubit* %rightMessage.i) tail call void @__quantum__qis__reset__body(%Qubit* %rightMessage.i) %18 = tail call %Result* @__quantum__rt__result_get_one() %19 = tail call i1 @__quantum__rt__result_equal(%Result* %result.i.i.i.i, %Result* %18) tail call void @__quantum__rt__result_update_reference_count(%Result* %result.i.i.i.i, i32 -1) br i1 %19, label %then0__1.i.i.i, label %continue__1.i.i.i then0__1.i.i.i: ; preds = %entry tail call void @__quantum__qis__z__body(%Qubit* %17) br label %continue__1.i.i.i continue__1.i.i.i: ; preds = %then0__1.i.i.i, %entry %result.i1.i.i.i = tail call %Result* @__quantum__qis__m__body(%Qubit* %14) tail call void @__quantum__qis__reset__body(%Qubit* %14) %20 = tail call %Result* @__quantum__rt__result_get_one() %21 = tail call i1 @__quantum__rt__result_equal(%Result* %result.i1.i.i.i, %Result* %20) tail call void @__quantum__rt__result_update_reference_count(%Result* %result.i1.i.i.i, i32 -1) br i1 %21, label %then0__2.i.i.i, label %TeleportChain__TeleportQubitUsingPresharedEntanglement__body.2.exit.i then0__2.i.i.i: ; preds = %continue__1.i.i.i tail call void @__quantum__qis__x__body(%Qubit* %17) br label %TeleportChain__TeleportQubitUsingPresharedEntanglement__body.2.exit.i TeleportChain__TeleportQubitUsingPresharedEntanglement__body.2.exit.i: ; preds = %then0__2.i.i.i, %continue__1.i.i.i %22 = tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %rightPreshared.i, i64 0) %23 = bitcast i8* %22 to %Qubit** %24 = load %Qubit*, %Qubit** %23, align 8 %25 = tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %leftPreshared.i, i64 1) %26 = bitcast i8* %25 to %Qubit** %27 = load %Qubit*, %Qubit** %26, align 8 %28 = tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %rightPreshared.i, i64 1) %29 = bitcast i8* %28 to %Qubit** %30 = load %Qubit*, %Qubit** %29, align 8 tail call void @__quantum__qis__cnot__body(%Qubit* %24, %Qubit* %27) tail call void @__quantum__qis__h__body(%Qubit* %24) %result.i.i.i1.i = tail call %Result* @__quantum__qis__m__body(%Qubit* %24) tail call void @__quantum__qis__reset__body(%Qubit* %24) %31 = tail call %Result* @__quantum__rt__result_get_one() %32 = tail call i1 @__quantum__rt__result_equal(%Result* %result.i.i.i1.i, %Result* %31) tail call void @__quantum__rt__result_update_reference_count(%Result* %result.i.i.i1.i, i32 -1) br i1 %32, label %then0__1.i.i2.i, label %continue__1.i.i4.i then0__1.i.i2.i: ; preds = %TeleportChain__TeleportQubitUsingPresharedEntanglement__body.2.exit.i tail call void @__quantum__qis__z__body(%Qubit* %30) br label %continue__1.i.i4.i continue__1.i.i4.i: ; preds = %then0__1.i.i2.i, %TeleportChain__TeleportQubitUsingPresharedEntanglement__body.2.exit.i %result.i1.i.i3.i = tail call %Result* @__quantum__qis__m__body(%Qubit* %27) tail call void @__quantum__qis__reset__body(%Qubit* %27) %33 = tail call %Result* @__quantum__rt__result_get_one() %34 = tail call i1 @__quantum__rt__result_equal(%Result* %result.i1.i.i3.i, %Result* %33) tail call void @__quantum__rt__result_update_reference_count(%Result* %result.i1.i.i3.i, i32 -1) br i1 %34, label %then0__2.i.i5.i, label %TeleportChain__DemonstrateTeleportationUsingPresharedEntanglement__body.1.exit then0__2.i.i5.i: ; preds = %continue__1.i.i4.i tail call void @__quantum__qis__x__body(%Qubit* %30) br label %TeleportChain__DemonstrateTeleportationUsingPresharedEntanglement__body.1.exit TeleportChain__DemonstrateTeleportationUsingPresharedEntanglement__body.1.exit: ; preds = %continue__1.i.i4.i, %then0__2.i.i5.i %result.i.i = tail call %Result* @__quantum__qis__m__body(%Qubit* %leftMessage.i) tail call void @__quantum__qis__reset__body(%Qubit* %leftMessage.i) %35 = tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %rightPreshared.i, i64 1) %36 = bitcast i8* %35 to %Qubit** %37 = load %Qubit*, %Qubit** %36, align 8 %result.i1.i = tail call %Result* @__quantum__qis__m__body(%Qubit* %37) tail call void @__quantum__qis__reset__body(%Qubit* %37) tail call void @__quantum__rt__array_update_alias_count(%Array* %leftPreshared.i, i32 -1) tail call void @__quantum__rt__array_update_alias_count(%Array* %rightPreshared.i, i32 -1) tail call void @__quantum__rt__result_update_reference_count(%Result* %result.i.i, i32 -1) tail call void @__quantum__rt__qubit_release(%Qubit* %leftMessage.i) tail call void @__quantum__rt__qubit_release(%Qubit* %rightMessage.i) tail call void @__quantum__rt__qubit_release_array(%Array* %leftPreshared.i) tail call void @__quantum__rt__qubit_release_array(%Array* %rightPreshared.i) %38 = tail call %String* @__quantum__rt__result_to_string(%Result* %result.i1.i) tail call void @__quantum__rt__message(%String* %38) tail call void @__quantum__rt__result_update_reference_count(%Result* %result.i1.i, i32 -1) tail call void @__quantum__rt__string_update_reference_count(%String* %38, i32 -1) )script\"); auto profile = std::make_shared<DefaultProfileGenerator>(); ConfigurationManager& configuration_manager = profile->configurationManager(); configuration_manager.addConfig<FactoryConfiguration>(); ir_manip->applyProfile(profile); llvm::outs() << *ir_manip->module() << \"\\n\"; EXPECT_TRUE(ir_manip->hasInstructionSequence({ // clang-format off \"tail call void @__quantum__qis__h__body(%Qubit* null)\", \"tail call void @__quantum__qis__cnot__body(%Qubit* null, %Qubit* nonnull inttoptr (i64 1 to %Qubit*))\", \"tail call void @__quantum__qis__h__body(%Qubit* nonnull inttoptr (i64 2 to %Qubit*))\", \"tail call void @__quantum__qis__cnot__body(%Qubit* nonnull inttoptr (i64 2 to %Qubit*), %Qubit* nonnull inttoptr (i64 4 to %Qubit*))\", \"tail call void @__quantum__qis__h__body(%Qubit* nonnull inttoptr (i64 3 to %Qubit*))\", \"tail call void @__quantum__qis__cnot__body(%Qubit* nonnull inttoptr (i64 3 to %Qubit*), %Qubit* nonnull inttoptr (i64 5 to %Qubit*))\", \"tail call void @__quantum__qis__cnot__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*), %Qubit* nonnull inttoptr (i64 2 to %Qubit*))\", \"tail call void @__quantum__qis__h__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*))\", \"tail call void @__quantum__qis__mz__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*), %Result* null)\", \"tail call void @__quantum__qis__reset__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*))\", \"%0 = tail call i1 @__quantum__qis__read_result__body(%Result* null)\", \"br i1 %0, label %then0__1.i.i.i, label %continue__1.i.i.i\", // clang-format on })); EXPECT_TRUE(ir_manip->hasInstructionSequence({ // clang-format off \"tail call void @__quantum__qis__mz__body(%Qubit* nonnull inttoptr (i64 2 to %Qubit*), %Result* nonnull inttoptr (i64 1 to %Result*))\", \"tail call void @__quantum__qis__reset__body(%Qubit* nonnull inttoptr (i64 2 to %Qubit*))\", \"%1 = tail call i1 @__quantum__qis__read_result__body(%Result* nonnull inttoptr (i64 1 to %Result*))\", \"br i1 %1, label %then0__2.i.i.i, label %TeleportChain__TeleportQubitUsingPresharedEntanglement__body.2.exit.i\", // clang-format on })); EXPECT_TRUE(ir_manip->hasInstructionSequence({ // clang-format off \"tail call void @__quantum__qis__cnot__body(%Qubit* nonnull inttoptr (i64 4 to %Qubit*), %Qubit* nonnull inttoptr (i64 3 to %Qubit*))\", \"tail call void @__quantum__qis__h__body(%Qubit* nonnull inttoptr (i64 4 to %Qubit*))\", \"tail call void @__quantum__qis__mz__body(%Qubit* nonnull inttoptr (i64 4 to %Qubit*), %Result* nonnull inttoptr (i64 2 to %Result*))\", \"tail call void @__quantum__qis__reset__body(%Qubit* nonnull inttoptr (i64 4 to %Qubit*))\", \"%2 = tail call i1 @__quantum__qis__read_result__body(%Result* nonnull inttoptr (i64 2 to %Result*))\", \"br i1 %2, label %then0__1.i.i2.i, label %continue__1.i.i4.i\", // clang-format on })); EXPECT_TRUE(ir_manip->hasInstructionSequence({ // clang-format off \"tail call void @__quantum__qis__mz__body(%Qubit* nonnull inttoptr (i64 3 to %Qubit*), %Result* nonnull inttoptr (i64 3 to %Result*))\", \"tail call void @__quantum__qis__reset__body(%Qubit* nonnull inttoptr (i64 3 to %Qubit*))\", \"%3 = tail call i1 @__quantum__qis__read_result__body(%Result* nonnull inttoptr (i64 3 to %Result*))\", \"br i1 %3, label %then0__2.i.i5.i, label %TeleportChain__DemonstrateTeleportationUsingPresharedEntanglement__body.1.exit\", // clang-format on })); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_module_loader_8hpp/","text":"ModuleLoader/ModuleLoader.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ModuleLoader Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include \"RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { class ModuleLoader { public: using Module = llvm::Module; using Linker = llvm::Linker; using SMDiagnostic = llvm::SMDiagnostic; explicit ModuleLoader(Module* final_module) : final_module_{final_module} , linker_{*final_module} { } bool addModule(std::unique_ptr<Module>&& module, String const& filename = \"unknown\") { if (llvm::verifyModule(*module, &llvm::errs())) { llvm::errs() << filename << \": \" << \"input module is broken!\\n\"; return false; } return !linker_.linkInModule(std::move(module), Linker::Flags::None); } bool addIrFile(String const& filename) { // Loading module SMDiagnostic err; std::unique_ptr<Module> module = llvm::parseIRFile(filename, err, final_module_->getContext()); if (!module) { llvm::errs() << \"Failed to load \" << filename << \"\\n\"; return false; } // Transforming module SingleModuleTransformation transformation; if (!transformation.apply(module.get())) { llvm::errs() << \"Failed to transform \" << filename << \"\\n\"; return false; } // Linking return addModule(std::move(module), filename); } private: Module* final_module_; Linker linker_; // Single Module Transformation // class SingleModuleTransformation { public: using PassBuilder = llvm::PassBuilder; using OptimizationLevel = PassBuilder::OptimizationLevel; using FunctionAnalysisManager = llvm::FunctionAnalysisManager; explicit SingleModuleTransformation( OptimizationLevel const& optimisation_level = OptimizationLevel::O0, bool debug = false) : loop_analysis_manager_{debug} , function_analysis_manager_{debug} , gscc_analysis_manager_{debug} , module_analysis_manager_{debug} , optimisation_level_{optimisation_level} , debug_{debug} { pass_builder_.registerModuleAnalyses(module_analysis_manager_); pass_builder_.registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_.registerFunctionAnalyses(function_analysis_manager_); pass_builder_.registerLoopAnalyses(loop_analysis_manager_); pass_builder_.crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); module_pass_manager_.addPass(RemoveDisallowedAttributesPass()); } bool apply(llvm::Module* module) { module_pass_manager_.run(*module, module_analysis_manager_); if (llvm::verifyModule(*module, &llvm::errs())) { return false; } return true; } bool isDebugMode() const { return debug_; } private: llvm::PassBuilder pass_builder_; llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; llvm::ModulePassManager module_pass_manager_{}; OptimizationLevel optimisation_level_{}; bool debug_{false}; }; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"ModuleLoader/ModuleLoader.hpp"},{"location":"Api/Files/_module_loader_8hpp/#moduleloadermoduleloaderhpp","text":"","title":"ModuleLoader/ModuleLoader.hpp"},{"location":"Api/Files/_module_loader_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_module_loader_8hpp/#classes","text":"Name class microsoft::quantum::ModuleLoader","title":"Classes"},{"location":"Api/Files/_module_loader_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include \"RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { class ModuleLoader { public: using Module = llvm::Module; using Linker = llvm::Linker; using SMDiagnostic = llvm::SMDiagnostic; explicit ModuleLoader(Module* final_module) : final_module_{final_module} , linker_{*final_module} { } bool addModule(std::unique_ptr<Module>&& module, String const& filename = \"unknown\") { if (llvm::verifyModule(*module, &llvm::errs())) { llvm::errs() << filename << \": \" << \"input module is broken!\\n\"; return false; } return !linker_.linkInModule(std::move(module), Linker::Flags::None); } bool addIrFile(String const& filename) { // Loading module SMDiagnostic err; std::unique_ptr<Module> module = llvm::parseIRFile(filename, err, final_module_->getContext()); if (!module) { llvm::errs() << \"Failed to load \" << filename << \"\\n\"; return false; } // Transforming module SingleModuleTransformation transformation; if (!transformation.apply(module.get())) { llvm::errs() << \"Failed to transform \" << filename << \"\\n\"; return false; } // Linking return addModule(std::move(module), filename); } private: Module* final_module_; Linker linker_; // Single Module Transformation // class SingleModuleTransformation { public: using PassBuilder = llvm::PassBuilder; using OptimizationLevel = PassBuilder::OptimizationLevel; using FunctionAnalysisManager = llvm::FunctionAnalysisManager; explicit SingleModuleTransformation( OptimizationLevel const& optimisation_level = OptimizationLevel::O0, bool debug = false) : loop_analysis_manager_{debug} , function_analysis_manager_{debug} , gscc_analysis_manager_{debug} , module_analysis_manager_{debug} , optimisation_level_{optimisation_level} , debug_{debug} { pass_builder_.registerModuleAnalyses(module_analysis_manager_); pass_builder_.registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_.registerFunctionAnalyses(function_analysis_manager_); pass_builder_.registerLoopAnalyses(loop_analysis_manager_); pass_builder_.crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); module_pass_manager_.addPass(RemoveDisallowedAttributesPass()); } bool apply(llvm::Module* module) { module_pass_manager_.run(*module, module_analysis_manager_); if (llvm::verifyModule(*module, &llvm::errs())) { return false; } return true; } bool isDebugMode() const { return debug_; } private: llvm::PassBuilder pass_builder_; llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; llvm::ModulePassManager module_pass_manager_{}; OptimizationLevel optimisation_level_{}; bool debug_{false}; }; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_notation_8cpp/","text":"Rules/Notation/Notation.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { ReplacerFunction deleteInstruction() { return [](ReplacementRule::Builder&, ReplacementRule::Value* val, ReplacementRule::Captures&, ReplacementRule::Replacements& replacements) { auto type = val->getType(); val->replaceAllUsesWith(llvm::UndefValue::get(type)); replacements.push_back({llvm::dyn_cast<llvm::Instruction>(val), nullptr}); return true; }; } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Notation/Notation.cpp"},{"location":"Api/Files/_notation_8cpp/#rulesnotationnotationcpp","text":"","title":"Rules/Notation/Notation.cpp"},{"location":"Api/Files/_notation_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_notation_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { ReplacerFunction deleteInstruction() { return [](ReplacementRule::Builder&, ReplacementRule::Value* val, ReplacementRule::Captures&, ReplacementRule::Replacements& replacements) { auto type = val->getType(); val->replaceAllUsesWith(llvm::UndefValue::get(type)); replacements.push_back({llvm::dyn_cast<llvm::Instruction>(val), nullptr}); return true; }; } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_notation_8hpp/","text":"Rules/Notation/Notation.hpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Classes Name class microsoft::quantum::notation::Capture Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Call.hpp\" #include \"Rules/Notation/Call.ipp\" #include \"Rules/Notation/Phi.ipp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Rules/Patterns/PhiPattern.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; using ReplacerFunction = std::function<bool( ReplacementRule::Builder&, ReplacementRule::Value*, ReplacementRule::Captures&, ReplacementRule::Replacements&)>; class Capture { public: explicit Capture(std::string const& name); // Note that this operator is delibrately unconventional IOperandPrototypePtr operator=(IOperandPrototypePtr const& other); // NOLINT private: std::string name_{}; }; template <typename... Args> IOperandPrototypePtr call(std::string const& name, Args... args); IOperandPrototypePtr unnamedInvoke(); template <typename... Args> IOperandPrototypePtr phi(Args... args); IOperandPrototypePtr callByNameOnly(std::string const& name); IOperandPrototypePtr bitCast(IOperandPrototypePtr const& arg); IOperandPrototypePtr intToPtr(IOperandPrototypePtr const& arg); IOperandPrototypePtr constInt(); IOperandPrototypePtr branch( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2); IOperandPrototypePtr switchOp( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2); IOperandPrototypePtr select( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2); IOperandPrototypePtr load(IOperandPrototypePtr const& arg); IOperandPrototypePtr store(IOperandPrototypePtr const& target, IOperandPrototypePtr const& value); IOperandPrototypePtr basicBlock(); static std::shared_ptr<AnyPattern> const _ = std::make_shared<AnyPattern>(); // NOLINT ReplacerFunction deleteInstruction(); Capture operator\"\"_cap(char const* name, std::size_t); } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Notation/Notation.hpp"},{"location":"Api/Files/_notation_8hpp/#rulesnotationnotationhpp","text":"","title":"Rules/Notation/Notation.hpp"},{"location":"Api/Files/_notation_8hpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_notation_8hpp/#classes","text":"Name class microsoft::quantum::notation::Capture","title":"Classes"},{"location":"Api/Files/_notation_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Call.hpp\" #include \"Rules/Notation/Call.ipp\" #include \"Rules/Notation/Phi.ipp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Rules/Patterns/PhiPattern.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; using ReplacerFunction = std::function<bool( ReplacementRule::Builder&, ReplacementRule::Value*, ReplacementRule::Captures&, ReplacementRule::Replacements&)>; class Capture { public: explicit Capture(std::string const& name); // Note that this operator is delibrately unconventional IOperandPrototypePtr operator=(IOperandPrototypePtr const& other); // NOLINT private: std::string name_{}; }; template <typename... Args> IOperandPrototypePtr call(std::string const& name, Args... args); IOperandPrototypePtr unnamedInvoke(); template <typename... Args> IOperandPrototypePtr phi(Args... args); IOperandPrototypePtr callByNameOnly(std::string const& name); IOperandPrototypePtr bitCast(IOperandPrototypePtr const& arg); IOperandPrototypePtr intToPtr(IOperandPrototypePtr const& arg); IOperandPrototypePtr constInt(); IOperandPrototypePtr branch( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2); IOperandPrototypePtr switchOp( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2); IOperandPrototypePtr select( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2); IOperandPrototypePtr load(IOperandPrototypePtr const& arg); IOperandPrototypePtr store(IOperandPrototypePtr const& target, IOperandPrototypePtr const& value); IOperandPrototypePtr basicBlock(); static std::shared_ptr<AnyPattern> const _ = std::make_shared<AnyPattern>(); // NOLINT ReplacerFunction deleteInstruction(); Capture operator\"\"_cap(char const* name, std::size_t); } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_parameter_parser_8cpp/","text":"Commandline/ParameterParser.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ParameterParser.hpp\" #include <iostream> #include <stdexcept> #include <string> #include <unordered_map> namespace microsoft { namespace quantum { void ParameterParser::parseArgs(int argc, char** argv) { uint64_t i = 1; std::vector<ParsedValue> values; while (i < static_cast<uint64_t>(argc)) { values.push_back(parseSingleArg(argv[i])); ++i; } i = 0; while (i < values.size()) { auto& v = values[i]; ++i; if (!v.is_key) { arguments_.push_back(v.value); continue; } if (i >= values.size()) { settings_[v.value] = \"true\"; continue; } auto& v2 = values[i]; if (!v2.is_key && isOption(v.value)) { settings_[v.value] = v2.value; ++i; continue; } settings_[v.value] = \"true\"; } } void ParameterParser::addFlag(String const& v) { flags_.insert(v); } String const& ParameterParser::get(String const& name, String const& default_value) const noexcept { auto it = settings_.find(name); if (it == settings_.end()) { return default_value; } return it->second; } String const& ParameterParser::get(String const& name) const { auto it = settings_.find(name); if (it == settings_.end()) { throw std::runtime_error(\"Could not find setting '\" + name + \"'.\"); } return it->second; } bool ParameterParser::has(String const& name) const noexcept { auto it = settings_.find(name); return (it != settings_.end()); } ParameterParser::Arguments const& ParameterParser::arguments() const { return arguments_; } String const& ParameterParser::getArg(Arguments::size_type const& n) const { return arguments_[n]; } ParameterParser::ParsedValue ParameterParser::parseSingleArg(String key) { bool is_key = false; if (key.size() > 2 && key.substr(0, 2) == \"--\") { is_key = true; key = key.substr(2); } else if (key.size() > 1 && key.substr(0, 1) == \"-\") { is_key = true; key = key.substr(1); } return {is_key, key}; } bool ParameterParser::isOption(String const& key) { if (flags_.find(key) != flags_.end()) { return false; } return true; } void ParameterParser::reset() { arguments_.clear(); settings_.clear(); flags_.clear(); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Commandline/ParameterParser.cpp"},{"location":"Api/Files/_parameter_parser_8cpp/#commandlineparameterparsercpp","text":"","title":"Commandline/ParameterParser.cpp"},{"location":"Api/Files/_parameter_parser_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_parameter_parser_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ParameterParser.hpp\" #include <iostream> #include <stdexcept> #include <string> #include <unordered_map> namespace microsoft { namespace quantum { void ParameterParser::parseArgs(int argc, char** argv) { uint64_t i = 1; std::vector<ParsedValue> values; while (i < static_cast<uint64_t>(argc)) { values.push_back(parseSingleArg(argv[i])); ++i; } i = 0; while (i < values.size()) { auto& v = values[i]; ++i; if (!v.is_key) { arguments_.push_back(v.value); continue; } if (i >= values.size()) { settings_[v.value] = \"true\"; continue; } auto& v2 = values[i]; if (!v2.is_key && isOption(v.value)) { settings_[v.value] = v2.value; ++i; continue; } settings_[v.value] = \"true\"; } } void ParameterParser::addFlag(String const& v) { flags_.insert(v); } String const& ParameterParser::get(String const& name, String const& default_value) const noexcept { auto it = settings_.find(name); if (it == settings_.end()) { return default_value; } return it->second; } String const& ParameterParser::get(String const& name) const { auto it = settings_.find(name); if (it == settings_.end()) { throw std::runtime_error(\"Could not find setting '\" + name + \"'.\"); } return it->second; } bool ParameterParser::has(String const& name) const noexcept { auto it = settings_.find(name); return (it != settings_.end()); } ParameterParser::Arguments const& ParameterParser::arguments() const { return arguments_; } String const& ParameterParser::getArg(Arguments::size_type const& n) const { return arguments_[n]; } ParameterParser::ParsedValue ParameterParser::parseSingleArg(String key) { bool is_key = false; if (key.size() > 2 && key.substr(0, 2) == \"--\") { is_key = true; key = key.substr(2); } else if (key.size() > 1 && key.substr(0, 1) == \"-\") { is_key = true; key = key.substr(1); } return {is_key, key}; } bool ParameterParser::isOption(String const& key) { if (flags_.find(key) != flags_.end()) { return false; } return true; } void ParameterParser::reset() { arguments_.clear(); settings_.clear(); flags_.clear(); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_parameter_parser_8hpp/","text":"Commandline/ParameterParser.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ParameterParser Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include <string> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft { namespace quantum { class ParameterParser { public: using Arguments = std::vector<String>; using Flags = std::unordered_set<String>; using SettingsMap = std::unordered_map<String, String>; // Construction and deconstrution configuration // ParameterParser() = default; // No copy construction. ParameterParser(ParameterParser const& other) = delete; // Allow move semantics. ParameterParser(ParameterParser&& other) = default; // Default destruction. ~ParameterParser() = default; // Configuration // void addFlag(String const& v); // Operation // void parseArgs(int argc, char** argv); Arguments const& arguments() const; String const& getArg(Arguments::size_type const& n) const; String const& get(String const& name, String const& default_value) const noexcept; String const& get(String const& name) const; bool has(String const& name) const noexcept; void reset(); private: struct ParsedValue { bool is_key{false}; String value; }; // Helper functions // // Parses a single argument and returns the parsed value. This function // determines if the string was specified to be a key or a value. ParsedValue parseSingleArg(String key); bool isOption(String const& key); // Storage of parsed data // Flags flags_{}; Arguments arguments_{}; SettingsMap settings_; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Commandline/ParameterParser.hpp"},{"location":"Api/Files/_parameter_parser_8hpp/#commandlineparameterparserhpp","text":"","title":"Commandline/ParameterParser.hpp"},{"location":"Api/Files/_parameter_parser_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_parameter_parser_8hpp/#classes","text":"Name class microsoft::quantum::ParameterParser","title":"Classes"},{"location":"Api/Files/_parameter_parser_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include <string> #include <unordered_map> #include <unordered_set> #include <vector> namespace microsoft { namespace quantum { class ParameterParser { public: using Arguments = std::vector<String>; using Flags = std::unordered_set<String>; using SettingsMap = std::unordered_map<String, String>; // Construction and deconstrution configuration // ParameterParser() = default; // No copy construction. ParameterParser(ParameterParser const& other) = delete; // Allow move semantics. ParameterParser(ParameterParser&& other) = default; // Default destruction. ~ParameterParser() = default; // Configuration // void addFlag(String const& v); // Operation // void parseArgs(int argc, char** argv); Arguments const& arguments() const; String const& getArg(Arguments::size_type const& n) const; String const& get(String const& name, String const& default_value) const noexcept; String const& get(String const& name) const; bool has(String const& name) const noexcept; void reset(); private: struct ParsedValue { bool is_key{false}; String value; }; // Helper functions // // Parses a single argument and returns the parsed value. This function // determines if the string was specified to be a key or a value. ParsedValue parseSingleArg(String key); bool isOption(String const& key); // Storage of parsed data // Flags flags_{}; Arguments arguments_{}; SettingsMap settings_; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_phi_8ipp/","text":"Rules/Notation/Phi.ipp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Llvm/Llvm.hpp\" #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Rules/Patterns/PhiPattern.hpp\" #include \"Rules/ReplacementRule.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; template <typename... Args> IOperandPrototypePtr phi(Args... args) { IOperandPrototypePtr ret = std::make_shared<PhiPattern>(); std::vector<IOperandPrototypePtr> arguments{args...}; // Adding arguments to matching for (auto &a : arguments) { ret->addChild(a); } return ret; } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Notation/Phi.ipp"},{"location":"Api/Files/_phi_8ipp/#rulesnotationphiipp","text":"","title":"Rules/Notation/Phi.ipp"},{"location":"Api/Files/_phi_8ipp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_phi_8ipp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Llvm/Llvm.hpp\" #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Rules/Patterns/PhiPattern.hpp\" #include \"Rules/ReplacementRule.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; template <typename... Args> IOperandPrototypePtr phi(Args... args) { IOperandPrototypePtr ret = std::make_shared<PhiPattern>(); std::vector<IOperandPrototypePtr> arguments{args...}; // Adding arguments to matching for (auto &a : arguments) { ret->addChild(a); } return ret; } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_phi_elimination_8cpp/","text":"TransformationRulesPass/Tests/Unit/PhiElimination.cpp Functions Name TEST ( TransformationRulesPass , PhiEliminationBranch1 ) TEST ( TransformationRulesPass , PhiEliminationBranch0 ) Functions Documentation function TEST TEST( TransformationRulesPass , PhiEliminationBranch1 ) function TEST TEST( TransformationRulesPass , PhiEliminationBranch0 ) Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareOpaque(\"Array\"); ir_manip->declareOpaque(\"Tuple\"); ir_manip->declareOpaque(\"Range\"); ir_manip->declareOpaque(\"Callable\"); ir_manip->declareOpaque(\"String\"); ir_manip->declareFunction(\"%Qubit* @__quantum__rt__qubit_allocate()\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); ir_manip->declareFunction(\"%Array* @__quantum__rt__qubit_allocate_array(i64)\"); ir_manip->declareFunction(\"void @__quantum__rt__array_update_alias_count(%Array*, i32)\"); ir_manip->declareFunction(\"void @__quantum__qis__cnot__body(%Qubit*, %Qubit*)\"); ir_manip->declareFunction(\"i8* @__quantum__rt__array_get_element_ptr_1d(%Array*, i64)\"); ir_manip->declareFunction(\"%Result* @__quantum__qis__m__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__reset__body(%Qubit*)\"); ir_manip->declareFunction(\"%Result* @__quantum__rt__result_get_one()\"); ir_manip->declareFunction(\"i1 @__quantum__rt__result_equal(%Result*, %Result*)\"); ir_manip->declareFunction(\"void @__quantum__rt__result_update_reference_count(%Result*, i32)\"); ir_manip->declareFunction(\"void @__quantum__qis__z__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__x__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__rt__message(%String*)\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release_array(%Array*)\"); ir_manip->declareFunction(\"%String* @__quantum__rt__result_to_string(%Result*)\"); ir_manip->declareFunction(\"void @__quantum__rt__string_update_reference_count(%String*, i32)\"); ir_manip->declareFunction(\"double @Microsoft__Quantum__Math__PI__body()\"); ir_manip->declareFunction(\"%Result* @Microsoft__Quantum__Qir__Emission__Iterate__body(double, double, %Qubit*)\"); ir_manip->declareFunction(\"void @Microsoft__Quantum__Qir__Emission__Prepare__body(%Qubit*)\"); ir_manip->declareFunction(\"void @Microsoft__Quantum__Intrinsic__CNOT__body(%Qubit*, %Qubit*)\"); ir_manip->declareFunction(\"i64 @TeleportChain__Calculate__body(i64, %Qubit*)\"); ir_manip->declareFunction(\"void @Microsoft__Quantum__Intrinsic__H__body(%Qubit*)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->generateScript(script) << \"\\n\\n\"; llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(TransformationRulesPass, PhiEliminationBranch1) { auto ir_manip = newIrManip(R\"script( %c = inttoptr i64 0 to %Qubit* %n = add i64 0, 1 %q = call %Qubit* @__quantum__rt__qubit_allocate() %ret = alloca i64, align 8 store i64 2, i64* %ret, align 4 call void @Microsoft__Quantum__Intrinsic__H__body(%Qubit* %q) call void @Microsoft__Quantum__Intrinsic__CNOT__body(%Qubit* %c, %Qubit* %q) %0 = icmp ne i64 %n, 0 br i1 %0, label %then0__1, label %continue__1 then0__1: ; preds = %entry %1 = sub i64 %n, 1 %2 = call i64 @TeleportChain__Calculate__body(i64 %1, %Qubit* %q) %3 = add i64 %2, 2 store i64 %3, i64* %ret, align 4 br label %continue__1 continue__1: ; preds = %then0__1, %entry %4 = load i64, i64* %ret, align 4 call void @__quantum__rt__qubit_release(%Qubit* %q) )script\"); auto profile = std::make_shared<DefaultProfileGenerator>(); ConfigurationManager& configuration_manager = profile->configurationManager(); configuration_manager.addConfig<FactoryConfiguration>(); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence({ \"tail call void @Microsoft__Quantum__Intrinsic__H__body(%Qubit* null)\", \"tail call void @Microsoft__Quantum__Intrinsic__CNOT__body(%Qubit* null, %Qubit* null)\", \"%0 = tail call i64 @TeleportChain__Calculate__body(i64 0, %Qubit* null)\", })); } TEST(TransformationRulesPass, PhiEliminationBranch0) { auto ir_manip = newIrManip(R\"script( %c = inttoptr i64 0 to %Qubit* %n = add i64 0, 0 %q = call %Qubit* @__quantum__rt__qubit_allocate() %ret = alloca i64, align 8 store i64 2, i64* %ret, align 4 call void @Microsoft__Quantum__Intrinsic__H__body(%Qubit* %q) call void @Microsoft__Quantum__Intrinsic__CNOT__body(%Qubit* %c, %Qubit* %q) %0 = icmp ne i64 %n, 0 br i1 %0, label %then0__1, label %continue__1 then0__1: ; preds = %entry %1 = sub i64 %n, 1 %2 = call i64 @TeleportChain__Calculate__body(i64 %1, %Qubit* %q) %3 = add i64 %2, 2 store i64 %3, i64* %ret, align 4 br label %continue__1 continue__1: ; preds = %then0__1, %entry %4 = load i64, i64* %ret, align 4 call void @__quantum__rt__qubit_release(%Qubit* %q) )script\"); auto profile = std::make_shared<DefaultProfileGenerator>(); ConfigurationManager& configuration_manager = profile->configurationManager(); configuration_manager.addConfig<FactoryConfiguration>(); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence({ \"tail call void @Microsoft__Quantum__Intrinsic__H__body(%Qubit* null)\", \"tail call void @Microsoft__Quantum__Intrinsic__CNOT__body(%Qubit* null, %Qubit* null)\", })); EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%0 = tail call i64 @TeleportChain__Calculate__body(i64 0, %Qubit* %q)\", })); } Updated on 22 November 2021 at 10:28:34 UTC","title":"TransformationRulesPass/Tests/Unit/PhiElimination.cpp"},{"location":"Api/Files/_phi_elimination_8cpp/#transformationrulespasstestsunitphieliminationcpp","text":"","title":"TransformationRulesPass/Tests/Unit/PhiElimination.cpp"},{"location":"Api/Files/_phi_elimination_8cpp/#functions","text":"Name TEST ( TransformationRulesPass , PhiEliminationBranch1 ) TEST ( TransformationRulesPass , PhiEliminationBranch0 )","title":"Functions"},{"location":"Api/Files/_phi_elimination_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Files/_phi_elimination_8cpp/#function-test","text":"TEST( TransformationRulesPass , PhiEliminationBranch1 )","title":"function TEST"},{"location":"Api/Files/_phi_elimination_8cpp/#function-test_1","text":"TEST( TransformationRulesPass , PhiEliminationBranch0 )","title":"function TEST"},{"location":"Api/Files/_phi_elimination_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareOpaque(\"Array\"); ir_manip->declareOpaque(\"Tuple\"); ir_manip->declareOpaque(\"Range\"); ir_manip->declareOpaque(\"Callable\"); ir_manip->declareOpaque(\"String\"); ir_manip->declareFunction(\"%Qubit* @__quantum__rt__qubit_allocate()\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); ir_manip->declareFunction(\"%Array* @__quantum__rt__qubit_allocate_array(i64)\"); ir_manip->declareFunction(\"void @__quantum__rt__array_update_alias_count(%Array*, i32)\"); ir_manip->declareFunction(\"void @__quantum__qis__cnot__body(%Qubit*, %Qubit*)\"); ir_manip->declareFunction(\"i8* @__quantum__rt__array_get_element_ptr_1d(%Array*, i64)\"); ir_manip->declareFunction(\"%Result* @__quantum__qis__m__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__reset__body(%Qubit*)\"); ir_manip->declareFunction(\"%Result* @__quantum__rt__result_get_one()\"); ir_manip->declareFunction(\"i1 @__quantum__rt__result_equal(%Result*, %Result*)\"); ir_manip->declareFunction(\"void @__quantum__rt__result_update_reference_count(%Result*, i32)\"); ir_manip->declareFunction(\"void @__quantum__qis__z__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__x__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__rt__message(%String*)\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release_array(%Array*)\"); ir_manip->declareFunction(\"%String* @__quantum__rt__result_to_string(%Result*)\"); ir_manip->declareFunction(\"void @__quantum__rt__string_update_reference_count(%String*, i32)\"); ir_manip->declareFunction(\"double @Microsoft__Quantum__Math__PI__body()\"); ir_manip->declareFunction(\"%Result* @Microsoft__Quantum__Qir__Emission__Iterate__body(double, double, %Qubit*)\"); ir_manip->declareFunction(\"void @Microsoft__Quantum__Qir__Emission__Prepare__body(%Qubit*)\"); ir_manip->declareFunction(\"void @Microsoft__Quantum__Intrinsic__CNOT__body(%Qubit*, %Qubit*)\"); ir_manip->declareFunction(\"i64 @TeleportChain__Calculate__body(i64, %Qubit*)\"); ir_manip->declareFunction(\"void @Microsoft__Quantum__Intrinsic__H__body(%Qubit*)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->generateScript(script) << \"\\n\\n\"; llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(TransformationRulesPass, PhiEliminationBranch1) { auto ir_manip = newIrManip(R\"script( %c = inttoptr i64 0 to %Qubit* %n = add i64 0, 1 %q = call %Qubit* @__quantum__rt__qubit_allocate() %ret = alloca i64, align 8 store i64 2, i64* %ret, align 4 call void @Microsoft__Quantum__Intrinsic__H__body(%Qubit* %q) call void @Microsoft__Quantum__Intrinsic__CNOT__body(%Qubit* %c, %Qubit* %q) %0 = icmp ne i64 %n, 0 br i1 %0, label %then0__1, label %continue__1 then0__1: ; preds = %entry %1 = sub i64 %n, 1 %2 = call i64 @TeleportChain__Calculate__body(i64 %1, %Qubit* %q) %3 = add i64 %2, 2 store i64 %3, i64* %ret, align 4 br label %continue__1 continue__1: ; preds = %then0__1, %entry %4 = load i64, i64* %ret, align 4 call void @__quantum__rt__qubit_release(%Qubit* %q) )script\"); auto profile = std::make_shared<DefaultProfileGenerator>(); ConfigurationManager& configuration_manager = profile->configurationManager(); configuration_manager.addConfig<FactoryConfiguration>(); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence({ \"tail call void @Microsoft__Quantum__Intrinsic__H__body(%Qubit* null)\", \"tail call void @Microsoft__Quantum__Intrinsic__CNOT__body(%Qubit* null, %Qubit* null)\", \"%0 = tail call i64 @TeleportChain__Calculate__body(i64 0, %Qubit* null)\", })); } TEST(TransformationRulesPass, PhiEliminationBranch0) { auto ir_manip = newIrManip(R\"script( %c = inttoptr i64 0 to %Qubit* %n = add i64 0, 0 %q = call %Qubit* @__quantum__rt__qubit_allocate() %ret = alloca i64, align 8 store i64 2, i64* %ret, align 4 call void @Microsoft__Quantum__Intrinsic__H__body(%Qubit* %q) call void @Microsoft__Quantum__Intrinsic__CNOT__body(%Qubit* %c, %Qubit* %q) %0 = icmp ne i64 %n, 0 br i1 %0, label %then0__1, label %continue__1 then0__1: ; preds = %entry %1 = sub i64 %n, 1 %2 = call i64 @TeleportChain__Calculate__body(i64 %1, %Qubit* %q) %3 = add i64 %2, 2 store i64 %3, i64* %ret, align 4 br label %continue__1 continue__1: ; preds = %then0__1, %entry %4 = load i64, i64* %ret, align 4 call void @__quantum__rt__qubit_release(%Qubit* %q) )script\"); auto profile = std::make_shared<DefaultProfileGenerator>(); ConfigurationManager& configuration_manager = profile->configurationManager(); configuration_manager.addConfig<FactoryConfiguration>(); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence({ \"tail call void @Microsoft__Quantum__Intrinsic__H__body(%Qubit* null)\", \"tail call void @Microsoft__Quantum__Intrinsic__CNOT__body(%Qubit* null, %Qubit* null)\", })); EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%0 = tail call i64 @TeleportChain__Calculate__body(i64 0, %Qubit* %q)\", })); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_phi_pattern_8cpp/","text":"Rules/Patterns/PhiPattern.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/Patterns/PhiPattern.hpp\" namespace microsoft { namespace quantum { PhiPattern::~PhiPattern() = default; bool PhiPattern::match(Value* instr, Captures& captures) const { auto* phi_node = llvm::dyn_cast<llvm::PHINode>(instr); if (phi_node == nullptr) { return fail(instr, captures); } return success(instr, captures); } PhiPattern::Child PhiPattern::copy() const { auto ret = std::make_shared<PhiPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Patterns/PhiPattern.cpp"},{"location":"Api/Files/_phi_pattern_8cpp/#rulespatternsphipatterncpp","text":"","title":"Rules/Patterns/PhiPattern.cpp"},{"location":"Api/Files/_phi_pattern_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_phi_pattern_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/Patterns/PhiPattern.hpp\" namespace microsoft { namespace quantum { PhiPattern::~PhiPattern() = default; bool PhiPattern::match(Value* instr, Captures& captures) const { auto* phi_node = llvm::dyn_cast<llvm::PHINode>(instr); if (phi_node == nullptr) { return fail(instr, captures); } return success(instr, captures); } PhiPattern::Child PhiPattern::copy() const { auto ret = std::make_shared<PhiPattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_phi_pattern_8hpp/","text":"Rules/Patterns/PhiPattern.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::PhiPattern Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class PhiPattern : public IOperandPrototype { public: using String = std::string; // Construction of the call pattern by name or move only. // PhiPattern() = default; PhiPattern(PhiPattern const& other) = delete; PhiPattern(PhiPattern&& other) = default; ~PhiPattern() override; // Phi implmenetation of the member functions in IOperandPrototype. // bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Patterns/PhiPattern.hpp"},{"location":"Api/Files/_phi_pattern_8hpp/#rulespatternsphipatternhpp","text":"","title":"Rules/Patterns/PhiPattern.hpp"},{"location":"Api/Files/_phi_pattern_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_phi_pattern_8hpp/#classes","text":"Name class microsoft::quantum::PhiPattern","title":"Classes"},{"location":"Api/Files/_phi_pattern_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class PhiPattern : public IOperandPrototype { public: using String = std::string; // Construction of the call pattern by name or move only. // PhiPattern() = default; PhiPattern(PhiPattern const& other) = delete; PhiPattern(PhiPattern&& other) = default; ~PhiPattern() override; // Phi implmenetation of the member functions in IOperandPrototype. // bool match(Value* instr, Captures& captures) const override; Child copy() const override; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_profile_8cpp/","text":"Profile/Profile.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Profile/Profile.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { Profile::Profile( String const& name, bool debug, llvm::TargetMachine* target_machine, AllocationManagerPtr qubit_allocation_manager, AllocationManagerPtr result_allocation_manager) : name_{name} , loop_analysis_manager_{debug} , function_analysis_manager_{debug} , gscc_analysis_manager_{debug} , module_analysis_manager_{debug} , pass_instrumentation_callbacks_{std::make_unique<llvm::PassInstrumentationCallbacks>()} , standard_instrumentations_{std::make_unique<llvm::StandardInstrumentations>()} , qubit_allocation_manager_{std::move(qubit_allocation_manager)} , result_allocation_manager_{std::move(result_allocation_manager)} , validator_{std::make_unique<Validator>(ValidationPassConfiguration(), debug)} { bool verify_each_pass = false; standard_instrumentations_->registerCallbacks(*pass_instrumentation_callbacks_); // TODO(issue-13): Parameterize // pipeline_tuning_options_.LoopUnrolling = !DisableLoopUnrolling; // pipeline_tuning_options_.Coroutines = Coroutines; pass_builder_ = std::make_unique<llvm::PassBuilder>( target_machine, pipeline_tuning_options_, pgo_options_, pass_instrumentation_callbacks_.get()); registerEPCallbacks(verify_each_pass, debug); // Creating a full pass builder and registering each of the // components to make them accessible to the developer. pass_builder_->registerModuleAnalyses(module_analysis_manager_); pass_builder_->registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_->registerFunctionAnalyses(function_analysis_manager_); pass_builder_->registerLoopAnalyses(loop_analysis_manager_); pass_builder_->crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); } void Profile::registerEPCallbacks(bool verify_each_pass, bool debug) { if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, peephole_ep_pipeline_)) { pass_builder_->registerPeepholeEPCallback( [this, verify_each_pass, debug](llvm::FunctionPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse PeepholeEP pipeline: \"); error_safeguard( pass_builder_->parsePassPipeline(pass_manager, peephole_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::LoopPassManager>(*pass_builder_, late_loop_optimizations_ep_pipeline_)) { pass_builder_->registerLateLoopOptimizationsEPCallback( [this, verify_each_pass, debug](llvm::LoopPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse LateLoopOptimizationsEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, late_loop_optimizations_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::LoopPassManager>(*pass_builder_, loop_optimizer_end_ep_pipeline_)) { pass_builder_->registerLoopOptimizerEndEPCallback( [this, verify_each_pass, debug](llvm::LoopPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse LoopOptimizerEndEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, loop_optimizer_end_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, scalar_optimizer_late_ep_pipeline_)) { pass_builder_->registerScalarOptimizerLateEPCallback( [this, verify_each_pass, debug](llvm::FunctionPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse ScalarOptimizerLateEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, scalar_optimizer_late_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::CGSCCPassManager>(*pass_builder_, cgscc_optimizer_late_ep_pipeline_)) { pass_builder_->registerCGSCCOptimizerLateEPCallback( [this, verify_each_pass, debug](llvm::CGSCCPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse CGSCCOptimizerLateEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, cgscc_optimizer_late_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, vectorizer_start_ep_pipeline_)) { pass_builder_->registerVectorizerStartEPCallback( [this, verify_each_pass, debug](llvm::FunctionPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse VectorizerStartEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, vectorizer_start_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::ModulePassManager>(*pass_builder_, pipeline_start_ep_pipeline_)) { pass_builder_->registerPipelineStartEPCallback( [this, verify_each_pass, debug](llvm::ModulePassManager& pass_manager) { llvm::ExitOnError error_safeguard(\"Unable to parse PipelineStartEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, pipeline_start_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, optimizer_last_ep_pipeline_)) { pass_builder_->registerOptimizerLastEPCallback( [this, verify_each_pass, debug](llvm::ModulePassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse OptimizerLastEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, optimizer_last_ep_pipeline_, verify_each_pass, debug)); }); } } void Profile::apply(llvm::Module& module) { module_pass_manager_.run(module, module_analysis_manager_); } bool Profile::verify(llvm::Module& module) { llvm::VerifierAnalysis verifier; auto result = verifier.run(module, module_analysis_manager_); return !result.IRBroken; } bool Profile::validate(llvm::Module& module) { return validator_->validate(module); } String const& Profile::name() const { return name_; } Profile::AllocationManagerPtr Profile::getQubitAllocationManager() { return qubit_allocation_manager_; } Profile::AllocationManagerPtr Profile::getResultAllocationManager() { return result_allocation_manager_; } void Profile::setModulePassManager(llvm::ModulePassManager&& manager) { module_pass_manager_ = std::move(manager); } void Profile::setValidator(ValidatorPtr&& validator) { validator_ = std::move(validator); } llvm::PassBuilder& Profile::passBuilder() { return *pass_builder_; } llvm::LoopAnalysisManager& Profile::loopAnalysisManager() { return loop_analysis_manager_; } llvm::FunctionAnalysisManager& Profile::functionAnalysisManager() { return function_analysis_manager_; } llvm::CGSCCAnalysisManager& Profile::gsccAnalysisManager() { return gscc_analysis_manager_; } llvm::ModuleAnalysisManager& Profile::moduleAnalysisManager() { return module_analysis_manager_; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Profile/Profile.cpp"},{"location":"Api/Files/_profile_8cpp/#profileprofilecpp","text":"","title":"Profile/Profile.cpp"},{"location":"Api/Files/_profile_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_profile_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Profile/Profile.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { Profile::Profile( String const& name, bool debug, llvm::TargetMachine* target_machine, AllocationManagerPtr qubit_allocation_manager, AllocationManagerPtr result_allocation_manager) : name_{name} , loop_analysis_manager_{debug} , function_analysis_manager_{debug} , gscc_analysis_manager_{debug} , module_analysis_manager_{debug} , pass_instrumentation_callbacks_{std::make_unique<llvm::PassInstrumentationCallbacks>()} , standard_instrumentations_{std::make_unique<llvm::StandardInstrumentations>()} , qubit_allocation_manager_{std::move(qubit_allocation_manager)} , result_allocation_manager_{std::move(result_allocation_manager)} , validator_{std::make_unique<Validator>(ValidationPassConfiguration(), debug)} { bool verify_each_pass = false; standard_instrumentations_->registerCallbacks(*pass_instrumentation_callbacks_); // TODO(issue-13): Parameterize // pipeline_tuning_options_.LoopUnrolling = !DisableLoopUnrolling; // pipeline_tuning_options_.Coroutines = Coroutines; pass_builder_ = std::make_unique<llvm::PassBuilder>( target_machine, pipeline_tuning_options_, pgo_options_, pass_instrumentation_callbacks_.get()); registerEPCallbacks(verify_each_pass, debug); // Creating a full pass builder and registering each of the // components to make them accessible to the developer. pass_builder_->registerModuleAnalyses(module_analysis_manager_); pass_builder_->registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_->registerFunctionAnalyses(function_analysis_manager_); pass_builder_->registerLoopAnalyses(loop_analysis_manager_); pass_builder_->crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); } void Profile::registerEPCallbacks(bool verify_each_pass, bool debug) { if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, peephole_ep_pipeline_)) { pass_builder_->registerPeepholeEPCallback( [this, verify_each_pass, debug](llvm::FunctionPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse PeepholeEP pipeline: \"); error_safeguard( pass_builder_->parsePassPipeline(pass_manager, peephole_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::LoopPassManager>(*pass_builder_, late_loop_optimizations_ep_pipeline_)) { pass_builder_->registerLateLoopOptimizationsEPCallback( [this, verify_each_pass, debug](llvm::LoopPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse LateLoopOptimizationsEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, late_loop_optimizations_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::LoopPassManager>(*pass_builder_, loop_optimizer_end_ep_pipeline_)) { pass_builder_->registerLoopOptimizerEndEPCallback( [this, verify_each_pass, debug](llvm::LoopPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse LoopOptimizerEndEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, loop_optimizer_end_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, scalar_optimizer_late_ep_pipeline_)) { pass_builder_->registerScalarOptimizerLateEPCallback( [this, verify_each_pass, debug](llvm::FunctionPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse ScalarOptimizerLateEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, scalar_optimizer_late_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::CGSCCPassManager>(*pass_builder_, cgscc_optimizer_late_ep_pipeline_)) { pass_builder_->registerCGSCCOptimizerLateEPCallback( [this, verify_each_pass, debug](llvm::CGSCCPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse CGSCCOptimizerLateEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, cgscc_optimizer_late_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, vectorizer_start_ep_pipeline_)) { pass_builder_->registerVectorizerStartEPCallback( [this, verify_each_pass, debug](llvm::FunctionPassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse VectorizerStartEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, vectorizer_start_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::ModulePassManager>(*pass_builder_, pipeline_start_ep_pipeline_)) { pass_builder_->registerPipelineStartEPCallback( [this, verify_each_pass, debug](llvm::ModulePassManager& pass_manager) { llvm::ExitOnError error_safeguard(\"Unable to parse PipelineStartEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, pipeline_start_ep_pipeline_, verify_each_pass, debug)); }); } if (tryParsePipelineText<llvm::FunctionPassManager>(*pass_builder_, optimizer_last_ep_pipeline_)) { pass_builder_->registerOptimizerLastEPCallback( [this, verify_each_pass, debug](llvm::ModulePassManager& pass_manager, llvm::PassBuilder::OptimizationLevel) { llvm::ExitOnError error_safeguard(\"Unable to parse OptimizerLastEP pipeline: \"); error_safeguard(pass_builder_->parsePassPipeline( pass_manager, optimizer_last_ep_pipeline_, verify_each_pass, debug)); }); } } void Profile::apply(llvm::Module& module) { module_pass_manager_.run(module, module_analysis_manager_); } bool Profile::verify(llvm::Module& module) { llvm::VerifierAnalysis verifier; auto result = verifier.run(module, module_analysis_manager_); return !result.IRBroken; } bool Profile::validate(llvm::Module& module) { return validator_->validate(module); } String const& Profile::name() const { return name_; } Profile::AllocationManagerPtr Profile::getQubitAllocationManager() { return qubit_allocation_manager_; } Profile::AllocationManagerPtr Profile::getResultAllocationManager() { return result_allocation_manager_; } void Profile::setModulePassManager(llvm::ModulePassManager&& manager) { module_pass_manager_ = std::move(manager); } void Profile::setValidator(ValidatorPtr&& validator) { validator_ = std::move(validator); } llvm::PassBuilder& Profile::passBuilder() { return *pass_builder_; } llvm::LoopAnalysisManager& Profile::loopAnalysisManager() { return loop_analysis_manager_; } llvm::FunctionAnalysisManager& Profile::functionAnalysisManager() { return function_analysis_manager_; } llvm::CGSCCAnalysisManager& Profile::gsccAnalysisManager() { return gscc_analysis_manager_; } llvm::ModuleAnalysisManager& Profile::moduleAnalysisManager() { return module_analysis_manager_; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_profile_8hpp/","text":"Profile/Profile.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::Profile Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/AllocationManager.hpp\" #include \"AllocationManager/IAllocationManager.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Validator/Validator.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { class ProfileGenerator; class Profile { public: using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; using ValidatorPtr = Validator::ValidatorPtr; // Constructors // explicit Profile( String const& name, bool debug, llvm::TargetMachine* target_machine = nullptr, AllocationManagerPtr qubit_allocation_manager = BasicAllocationManager::createNew(), AllocationManagerPtr result_allocation_manager = BasicAllocationManager::createNew()); // Default construction not allowed as this leads to invalid configuration of the allocation // managers. Profile() = delete; Profile(Profile const&) = delete; Profile(Profile&&) = default; Profile& operator=(Profile const&) = delete; Profile& operator=(Profile&&) = default; ~Profile() = default; // Profile methods // void apply(llvm::Module& module); bool verify(llvm::Module& module); bool validate(llvm::Module& module); AllocationManagerPtr getQubitAllocationManager(); AllocationManagerPtr getResultAllocationManager(); String const& name() const; protected: // Ensuring that ProfileGenerator has access to following protected functions. friend class ProfileGenerator; void setModulePassManager(llvm::ModulePassManager&& manager); void setValidator(ValidatorPtr&& validator); llvm::PassBuilder& passBuilder(); llvm::LoopAnalysisManager& loopAnalysisManager(); llvm::FunctionAnalysisManager& functionAnalysisManager(); llvm::CGSCCAnalysisManager& gsccAnalysisManager(); llvm::ModuleAnalysisManager& moduleAnalysisManager(); private: using PassInstrumentationCallbacksPtr = std::unique_ptr<llvm::PassInstrumentationCallbacks>; using StandardInstrumentationsPtr = std::unique_ptr<llvm::StandardInstrumentations>; using PassBuilderPtr = std::unique_ptr<llvm::PassBuilder>; void registerEPCallbacks(bool verify_each_pass, bool debug); template <typename PassManager> bool tryParsePipelineText(llvm::PassBuilder& pass_builder, std::string const& pipeline_options) { if (pipeline_options.empty()) { return false; } PassManager pass_manager; if (auto err = pass_builder.parsePassPipeline(pass_manager, pipeline_options)) { llvm::errs() << \"Could not parse -\" << pipeline_options << \" pipeline: \" << toString(std::move(err)) << \"\\n\"; return false; } return true; } String name_{}; // LLVM logic to run the passes // llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; llvm::Optional<llvm::PGOOptions> pgo_options_; PassInstrumentationCallbacksPtr pass_instrumentation_callbacks_; StandardInstrumentationsPtr standard_instrumentations_; llvm::PipelineTuningOptions pipeline_tuning_options_; PassBuilderPtr pass_builder_; llvm::ModulePassManager module_pass_manager_{}; // Allocation management // AllocationManagerPtr qubit_allocation_manager_{}; AllocationManagerPtr result_allocation_manager_{}; ValidatorPtr validator_{}; std::string peephole_ep_pipeline_{\"\"}; std::string late_loop_optimizations_ep_pipeline_{\"\"}; std::string loop_optimizer_end_ep_pipeline_{\"\"}; std::string scalar_optimizer_late_ep_pipeline_{\"\"}; std::string cgscc_optimizer_late_ep_pipeline_{\"\"}; std::string vectorizer_start_ep_pipeline_{\"\"}; std::string pipeline_start_ep_pipeline_{\"\"}; std::string optimizer_last_ep_pipeline_{\"\"}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Profile/Profile.hpp"},{"location":"Api/Files/_profile_8hpp/#profileprofilehpp","text":"","title":"Profile/Profile.hpp"},{"location":"Api/Files/_profile_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_profile_8hpp/#classes","text":"Name class microsoft::quantum::Profile","title":"Classes"},{"location":"Api/Files/_profile_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/AllocationManager.hpp\" #include \"AllocationManager/IAllocationManager.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Validator/Validator.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { class ProfileGenerator; class Profile { public: using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; using ValidatorPtr = Validator::ValidatorPtr; // Constructors // explicit Profile( String const& name, bool debug, llvm::TargetMachine* target_machine = nullptr, AllocationManagerPtr qubit_allocation_manager = BasicAllocationManager::createNew(), AllocationManagerPtr result_allocation_manager = BasicAllocationManager::createNew()); // Default construction not allowed as this leads to invalid configuration of the allocation // managers. Profile() = delete; Profile(Profile const&) = delete; Profile(Profile&&) = default; Profile& operator=(Profile const&) = delete; Profile& operator=(Profile&&) = default; ~Profile() = default; // Profile methods // void apply(llvm::Module& module); bool verify(llvm::Module& module); bool validate(llvm::Module& module); AllocationManagerPtr getQubitAllocationManager(); AllocationManagerPtr getResultAllocationManager(); String const& name() const; protected: // Ensuring that ProfileGenerator has access to following protected functions. friend class ProfileGenerator; void setModulePassManager(llvm::ModulePassManager&& manager); void setValidator(ValidatorPtr&& validator); llvm::PassBuilder& passBuilder(); llvm::LoopAnalysisManager& loopAnalysisManager(); llvm::FunctionAnalysisManager& functionAnalysisManager(); llvm::CGSCCAnalysisManager& gsccAnalysisManager(); llvm::ModuleAnalysisManager& moduleAnalysisManager(); private: using PassInstrumentationCallbacksPtr = std::unique_ptr<llvm::PassInstrumentationCallbacks>; using StandardInstrumentationsPtr = std::unique_ptr<llvm::StandardInstrumentations>; using PassBuilderPtr = std::unique_ptr<llvm::PassBuilder>; void registerEPCallbacks(bool verify_each_pass, bool debug); template <typename PassManager> bool tryParsePipelineText(llvm::PassBuilder& pass_builder, std::string const& pipeline_options) { if (pipeline_options.empty()) { return false; } PassManager pass_manager; if (auto err = pass_builder.parsePassPipeline(pass_manager, pipeline_options)) { llvm::errs() << \"Could not parse -\" << pipeline_options << \" pipeline: \" << toString(std::move(err)) << \"\\n\"; return false; } return true; } String name_{}; // LLVM logic to run the passes // llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; llvm::Optional<llvm::PGOOptions> pgo_options_; PassInstrumentationCallbacksPtr pass_instrumentation_callbacks_; StandardInstrumentationsPtr standard_instrumentations_; llvm::PipelineTuningOptions pipeline_tuning_options_; PassBuilderPtr pass_builder_; llvm::ModulePassManager module_pass_manager_{}; // Allocation management // AllocationManagerPtr qubit_allocation_manager_{}; AllocationManagerPtr result_allocation_manager_{}; ValidatorPtr validator_{}; std::string peephole_ep_pipeline_{\"\"}; std::string late_loop_optimizations_ep_pipeline_{\"\"}; std::string loop_optimizer_end_ep_pipeline_{\"\"}; std::string scalar_optimizer_late_ep_pipeline_{\"\"}; std::string cgscc_optimizer_late_ep_pipeline_{\"\"}; std::string vectorizer_start_ep_pipeline_{\"\"}; std::string pipeline_start_ep_pipeline_{\"\"}; std::string optimizer_last_ep_pipeline_{\"\"}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_profile_generator_8cpp/","text":"Generators/ProfileGenerator.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/ProfileGenerator.hpp\" #include \"TransformationRulesPass/TransformationRulesPassConfiguration.hpp\" #include \"ValidationPass/ValidationPassConfiguration.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { Profile ProfileGenerator::newProfile(String const& name, OptimizationLevel const& optimisation_level, bool debug) { auto qubit_allocation_manager = BasicAllocationManager::createNew(); auto result_allocation_manager = BasicAllocationManager::createNew(); auto cfg = configuration_manager_.get<TransformationRulesPassConfiguration>(); qubit_allocation_manager->setReuseRegisters(cfg.shouldReuseQubits()); result_allocation_manager->setReuseRegisters(cfg.shouldReuseResults()); // Creating profile // TODO(issue-12): Set target machine Profile ret{name, debug, nullptr, qubit_allocation_manager, result_allocation_manager}; auto module_pass_manager = createGenerationModulePassManager(ret, optimisation_level, debug); ret.setModulePassManager(std::move(module_pass_manager)); // Creating validator auto validator = std::make_unique<Validator>(configuration_manager_.get<ValidationPassConfiguration>(), debug); ret.setValidator(std::move(validator)); return ret; } llvm::ModulePassManager ProfileGenerator::createGenerationModulePassManager( Profile& profile, OptimizationLevel const& optimisation_level, bool debug) { auto& pass_builder = profile.passBuilder(); llvm::ModulePassManager ret{}; module_pass_manager_ = &ret; pass_builder_ = &pass_builder; optimisation_level_ = optimisation_level; debug_ = debug; for (auto& c : components_) { if (debug) { llvm::outs() << \"Setting \" << c.first << \" up\\n\"; } c.second(this, profile); } return ret; } llvm::ModulePassManager ProfileGenerator::createValidationModulePass(PassBuilder&, OptimizationLevel const&, bool) { throw std::runtime_error(\"Validation is not supported yet.\"); } llvm::ModulePassManager& ProfileGenerator::modulePassManager() { return *module_pass_manager_; } llvm::PassBuilder& ProfileGenerator::passBuilder() { return *pass_builder_; } ConfigurationManager& ProfileGenerator::configurationManager() { return configuration_manager_; } ConfigurationManager const& ProfileGenerator::configurationManager() const { return configuration_manager_; } ProfileGenerator::OptimizationLevel ProfileGenerator::optimisationLevel() const { return optimisation_level_; } bool ProfileGenerator::isDebugMode() const { return debug_; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Generators/ProfileGenerator.cpp"},{"location":"Api/Files/_profile_generator_8cpp/#generatorsprofilegeneratorcpp","text":"","title":"Generators/ProfileGenerator.cpp"},{"location":"Api/Files/_profile_generator_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_profile_generator_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/ProfileGenerator.hpp\" #include \"TransformationRulesPass/TransformationRulesPassConfiguration.hpp\" #include \"ValidationPass/ValidationPassConfiguration.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { Profile ProfileGenerator::newProfile(String const& name, OptimizationLevel const& optimisation_level, bool debug) { auto qubit_allocation_manager = BasicAllocationManager::createNew(); auto result_allocation_manager = BasicAllocationManager::createNew(); auto cfg = configuration_manager_.get<TransformationRulesPassConfiguration>(); qubit_allocation_manager->setReuseRegisters(cfg.shouldReuseQubits()); result_allocation_manager->setReuseRegisters(cfg.shouldReuseResults()); // Creating profile // TODO(issue-12): Set target machine Profile ret{name, debug, nullptr, qubit_allocation_manager, result_allocation_manager}; auto module_pass_manager = createGenerationModulePassManager(ret, optimisation_level, debug); ret.setModulePassManager(std::move(module_pass_manager)); // Creating validator auto validator = std::make_unique<Validator>(configuration_manager_.get<ValidationPassConfiguration>(), debug); ret.setValidator(std::move(validator)); return ret; } llvm::ModulePassManager ProfileGenerator::createGenerationModulePassManager( Profile& profile, OptimizationLevel const& optimisation_level, bool debug) { auto& pass_builder = profile.passBuilder(); llvm::ModulePassManager ret{}; module_pass_manager_ = &ret; pass_builder_ = &pass_builder; optimisation_level_ = optimisation_level; debug_ = debug; for (auto& c : components_) { if (debug) { llvm::outs() << \"Setting \" << c.first << \" up\\n\"; } c.second(this, profile); } return ret; } llvm::ModulePassManager ProfileGenerator::createValidationModulePass(PassBuilder&, OptimizationLevel const&, bool) { throw std::runtime_error(\"Validation is not supported yet.\"); } llvm::ModulePassManager& ProfileGenerator::modulePassManager() { return *module_pass_manager_; } llvm::PassBuilder& ProfileGenerator::passBuilder() { return *pass_builder_; } ConfigurationManager& ProfileGenerator::configurationManager() { return configuration_manager_; } ConfigurationManager const& ProfileGenerator::configurationManager() const { return configuration_manager_; } ProfileGenerator::OptimizationLevel ProfileGenerator::optimisationLevel() const { return optimisation_level_; } bool ProfileGenerator::isDebugMode() const { return debug_; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_profile_generator_8hpp/","text":"Generators/ProfileGenerator.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ProfileGenerator Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"Profile/Profile.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { class ProfileGenerator { public: // LLVM types // using PassBuilder = llvm::PassBuilder; using OptimizationLevel = PassBuilder::OptimizationLevel; using FunctionAnalysisManager = llvm::FunctionAnalysisManager; template <typename R> using SetupFunction = std::function<void(R const&, ProfileGenerator*, Profile&)>; using SetupFunctionWrapper = std::function<void(ProfileGenerator*, Profile&)>; using Components = std::vector<std::pair<String, SetupFunctionWrapper>>; // Construction, moves and copies // ProfileGenerator() = default; ~ProfileGenerator() = default; ProfileGenerator(ProfileGenerator const&) = delete; ProfileGenerator(ProfileGenerator&&) = delete; ProfileGenerator& operator=(ProfileGenerator const&) = delete; ProfileGenerator& operator=(ProfileGenerator&&) = delete; // Profile generation interface // ConfigurationManager& configurationManager(); ConfigurationManager const& configurationManager() const; Profile newProfile(String const& name, OptimizationLevel const& optimisation_level, bool debug); // Defining the generator // template <typename R> void registerProfileComponent(String const& id, SetupFunction<R> setup); // Support properties for generators // llvm::ModulePassManager& modulePassManager(); llvm::PassBuilder& passBuilder(); OptimizationLevel optimisationLevel() const; bool isDebugMode() const; protected: llvm::ModulePassManager createGenerationModulePassManager( Profile& profile, OptimizationLevel const& optimisation_level, bool debug); llvm::ModulePassManager createValidationModulePass( PassBuilder& pass_builder, OptimizationLevel const& optimisation_level, bool debug); private: ConfigurationManager configuration_manager_; Components components_; llvm::ModulePassManager* module_pass_manager_{nullptr}; llvm::PassBuilder* pass_builder_{nullptr}; OptimizationLevel optimisation_level_{OptimizationLevel::O0}; bool debug_{false}; }; template <typename R> void ProfileGenerator::registerProfileComponent(String const& id, SetupFunction<R> setup) { configuration_manager_.addConfig<R>(id); auto setup_wrapper = [setup](ProfileGenerator* ptr, Profile& profile) { if (ptr->configuration_manager_.isActive<R>()) { auto& config = ptr->configuration_manager_.get<R>(); setup(config, ptr, profile); } }; components_.push_back({id, std::move(setup_wrapper)}); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Generators/ProfileGenerator.hpp"},{"location":"Api/Files/_profile_generator_8hpp/#generatorsprofilegeneratorhpp","text":"","title":"Generators/ProfileGenerator.hpp"},{"location":"Api/Files/_profile_generator_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_profile_generator_8hpp/#classes","text":"Name class microsoft::quantum::ProfileGenerator","title":"Classes"},{"location":"Api/Files/_profile_generator_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"Profile/Profile.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Llvm/Llvm.hpp\" namespace microsoft { namespace quantum { class ProfileGenerator { public: // LLVM types // using PassBuilder = llvm::PassBuilder; using OptimizationLevel = PassBuilder::OptimizationLevel; using FunctionAnalysisManager = llvm::FunctionAnalysisManager; template <typename R> using SetupFunction = std::function<void(R const&, ProfileGenerator*, Profile&)>; using SetupFunctionWrapper = std::function<void(ProfileGenerator*, Profile&)>; using Components = std::vector<std::pair<String, SetupFunctionWrapper>>; // Construction, moves and copies // ProfileGenerator() = default; ~ProfileGenerator() = default; ProfileGenerator(ProfileGenerator const&) = delete; ProfileGenerator(ProfileGenerator&&) = delete; ProfileGenerator& operator=(ProfileGenerator const&) = delete; ProfileGenerator& operator=(ProfileGenerator&&) = delete; // Profile generation interface // ConfigurationManager& configurationManager(); ConfigurationManager const& configurationManager() const; Profile newProfile(String const& name, OptimizationLevel const& optimisation_level, bool debug); // Defining the generator // template <typename R> void registerProfileComponent(String const& id, SetupFunction<R> setup); // Support properties for generators // llvm::ModulePassManager& modulePassManager(); llvm::PassBuilder& passBuilder(); OptimizationLevel optimisationLevel() const; bool isDebugMode() const; protected: llvm::ModulePassManager createGenerationModulePassManager( Profile& profile, OptimizationLevel const& optimisation_level, bool debug); llvm::ModulePassManager createValidationModulePass( PassBuilder& pass_builder, OptimizationLevel const& optimisation_level, bool debug); private: ConfigurationManager configuration_manager_; Components components_; llvm::ModulePassManager* module_pass_manager_{nullptr}; llvm::PassBuilder* pass_builder_{nullptr}; OptimizationLevel optimisation_level_{OptimizationLevel::O0}; bool debug_{false}; }; template <typename R> void ProfileGenerator::registerProfileComponent(String const& id, SetupFunction<R> setup) { configuration_manager_.addConfig<R>(id); auto setup_wrapper = [setup](ProfileGenerator* ptr, Profile& profile) { if (ptr->configuration_manager_.isActive<R>()) { auto& config = ptr->configuration_manager_.get<R>(); setup(config, ptr, profile); } }; components_.push_back({id, std::move(setup_wrapper)}); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_qat_8cpp/","text":"Apps/Qat/Qat.cpp Namespaces Name llvm Functions Name void init () int main (int argc, char ** argv) Functions Documentation function init void init() function main int main( int argc, char ** argv ) Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Apps/Qat/QatConfig.hpp\" #include \"Commandline/ConfigurationManager.hpp\" #include \"Commandline/ParameterParser.hpp\" #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Generators/LlvmPassesConfiguration.hpp\" #include \"ModuleLoader/ModuleLoader.hpp\" #include \"Profile/Profile.hpp\" #include \"Rules/Factory.hpp\" #include \"Rules/FactoryConfig.hpp\" #include \"TransformationRulesPass/TransformationRulesPass.hpp\" #include \"TransformationRulesPass/TransformationRulesPassConfiguration.hpp\" #include \"ValidationPass/ValidationPassConfiguration.hpp\" #include \"Validator/Validator.hpp\" #include \"Llvm/Llvm.hpp\" #include <dlfcn.h> #include <iomanip> #include <iostream> #include <unordered_map> using namespace llvm; using namespace microsoft::quantum; void init(); void init() { // Initialize LLVM passes PassRegistry& registry = *PassRegistry::getPassRegistry(); initializeCore(registry); initializeCoroutines(registry); initializeScalarOpts(registry); initializeObjCARCOpts(registry); initializeVectorization(registry); initializeIPO(registry); initializeAnalysis(registry); initializeTransformUtils(registry); initializeInstCombine(registry); initializeAggressiveInstCombine(registry); initializeInstrumentation(registry); initializeTarget(registry); initializeExpandMemCmpPassPass(registry); initializeScalarizeMaskedMemIntrinPass(registry); initializeCodeGenPreparePass(registry); initializeAtomicExpandPass(registry); initializeRewriteSymbolsLegacyPassPass(registry); initializeWinEHPreparePass(registry); initializeDwarfEHPreparePass(registry); initializeSafeStackLegacyPassPass(registry); initializeSjLjEHPreparePass(registry); initializePreISelIntrinsicLoweringLegacyPassPass(registry); initializeGlobalMergePass(registry); initializeIndirectBrExpandPassPass(registry); initializeInterleavedLoadCombinePass(registry); initializeInterleavedAccessPass(registry); initializeEntryExitInstrumenterPass(registry); initializePostInlineEntryExitInstrumenterPass(registry); initializeUnreachableBlockElimLegacyPassPass(registry); initializeExpandReductionsPass(registry); initializeWasmEHPreparePass(registry); initializeWriteBitcodePassPass(registry); initializeHardwareLoopsPass(registry); initializeTypePromotionPass(registry); } int main(int argc, char** argv) { try { // Default generator. A future version of QAT may allow the generator to be selected // through the command line, but it is hard coded for now. auto generator = std::make_shared<ProfileGenerator>(); // Configuration and command line parsing // ConfigurationManager& configuration_manager = generator->configurationManager(); configuration_manager.addConfig<QatConfig>(); configuration_manager.addConfig<FactoryConfiguration>(); ParameterParser parser; configuration_manager.setupArguments(parser); parser.parseArgs(argc, argv); configuration_manager.configure(parser); // Getting the main configuration auto config = configuration_manager.get<QatConfig>(); // Setting profile validation configuration configuration_manager.addConfig<ValidationPassConfiguration>( \"validation-configuration\", ValidationPassConfiguration::fromProfileName(config.profile())); // Loading components // generator->registerProfileComponent<TransformationRulesPassConfiguration>( \"transformation-rules\", [](TransformationRulesPassConfiguration const& cfg, ProfileGenerator* ptr, Profile& profile) { auto& ret = ptr->modulePassManager(); // Default optimisation pipeline if (cfg.shouldSimplifyPriorTransform()) { auto& pass_builder = ptr->passBuilder(); llvm::ModulePassManager pipeline = pass_builder.buildPerModuleDefaultPipeline(ptr->optimisationLevel()); ret.addPass(std::move(pipeline)); } // Defining the mapping RuleSet rule_set; auto factory = RuleFactory(rule_set, profile.getQubitAllocationManager(), profile.getResultAllocationManager()); factory.usingConfiguration(ptr->configurationManager().get<FactoryConfiguration>()); // Creating profile pass ret.addPass(TransformationRulesPass(std::move(rule_set), cfg, &profile)); }); if (!config.load().empty()) { // TODO (tfr): Add support for multiple loads void* handle = dlopen(config.load().c_str(), RTLD_LAZY); if (handle == nullptr) { std::cerr << \"Invalid component \" << config.load() << std::endl; } else { using LoadFunctionPtr = void (*)(ProfileGenerator*); LoadFunctionPtr load_component; load_component = reinterpret_cast<LoadFunctionPtr>(dlsym(handle, \"loadComponent\")); load_component(generator.get()); } } generator->registerProfileComponent<LlvmPassesConfiguration>( \"llvm-passes\", [](LlvmPassesConfiguration const& cfg, ProfileGenerator* ptr, Profile&) { auto pass_pipeline = cfg.passPipeline(); if (!pass_pipeline.empty()) { auto& pass_builder = ptr->passBuilder(); auto& npm = ptr->modulePassManager(); if (auto err = pass_builder.parsePassPipeline(npm, pass_pipeline, false, false)) { throw std::runtime_error( \"Failed to set pass pipeline up. Value: '\" + pass_pipeline + \"', error: \" + toString(std::move(err))); } } else if (cfg.alwaysInline()) { auto& ret = ptr->modulePassManager(); auto& pass_builder = ptr->passBuilder(); ret.addPass(llvm::AlwaysInlinerPass()); auto inliner_pass = pass_builder.buildInlinerPipeline( ptr->optimisationLevel(), llvm::PassBuilder::ThinLTOPhase::None, ptr->isDebugMode()); ret.addPass(std::move(inliner_pass)); } else if (!cfg.disableDefaultPipeline()) { auto& mpm = ptr->modulePassManager(); llvm::PassBuilder::OptimizationLevel opt = llvm::PassBuilder::OptimizationLevel::O3; // If not explicitly disabled, we fall back to the default LLVM pipeline auto& pass_builder = ptr->passBuilder(); llvm::ModulePassManager pipeline1 = pass_builder.buildPerModuleDefaultPipeline(opt); mpm.addPass(std::move(pipeline1)); llvm::ModulePassManager pipeline2 = pass_builder.buildModuleSimplificationPipeline(opt, llvm::PassBuilder::ThinLTOPhase::None); mpm.addPass(std::move(pipeline2)); llvm::ModulePassManager pipeline3 = pass_builder.buildModuleOptimizationPipeline(opt, ptr->isDebugMode()); mpm.addPass(std::move(pipeline3)); auto inline_param = getInlineParams(cfg.inlineParameter()); llvm::ModuleInlinerWrapperPass pipeline4 = ModuleInlinerWrapperPass(inline_param); mpm.addPass(std::move(pipeline4)); } }); // Reconfiguring to get all the arguments of the passes registered parser.reset(); configuration_manager.setupArguments(parser); parser.parseArgs(argc, argv); configuration_manager.configure(parser); // In case we debug, we also print the settings to allow provide a full // picture of what is going. This step deliberately comes before validating // the input to allow dumping the configuration if something goes wrong. if (config.shouldDumpConfig()) { configuration_manager.printConfiguration(); } // Checking that we have sufficient information to proceed. If not we print // usage instructions and the corresponding description of how to use the tool. if (parser.arguments().empty()) { std::cerr << \"Usage: \" << argv[0] << \" [options] filename\" << std::endl; configuration_manager.printHelp(); std::cerr << \"\\n\"; exit(-1); } // Loading IR from file(s). // LLVMContext context; init(); auto module = std::make_unique<Module>(\"qat-link\", context); ModuleLoader loader(module.get()); for (auto const& arg : parser.arguments()) { if (!loader.addIrFile(arg)) { llvm::errs() << \"Could not load \" << arg << \"\\n\"; return -1; } } if (!module) { std::cerr << \"Invalid IR.\" << std::endl; exit(-1); } // Getting the optimisation level // auto optimisation_level = llvm::PassBuilder::OptimizationLevel::O0; // Setting the optimisation level if (config.isOpt1Enabled()) { optimisation_level = llvm::PassBuilder::OptimizationLevel::O1; } if (config.isOpt2Enabled()) { optimisation_level = llvm::PassBuilder::OptimizationLevel::O2; } if (config.isOpt3Enabled()) { optimisation_level = llvm::PassBuilder::OptimizationLevel::O3; } // Profile manipulation // // Creating the profile that will be used for generation and validation auto profile = generator->newProfile(config.profile(), optimisation_level, config.isDebugMode()); if (config.shouldGenerate()) { profile.apply(*module); } // We deliberately emit LLVM prior to verification and validation // to allow output the IR for debugging purposes. if (config.shouldEmitLlvm()) { llvm::outs() << *module << \"\\n\"; } else { llvm::WriteBitcodeToFile(*module, llvm::outs()); } if (config.verifyModule()) { if (!profile.verify(*module)) { std::cerr << \"IR is broken.\" << std::endl; exit(-1); } } if (config.shouldValidate()) { if (!profile.validate(*module)) { std::cerr << \"IR did not validate to the profile constraints.\" << std::endl; exit(-1); } } } catch (std::exception const& e) { std::cerr << \"An error occurred: \" << e.what() << std::endl; exit(-1); } return 0; } Updated on 22 November 2021 at 10:28:35 UTC","title":"Apps/Qat/Qat.cpp"},{"location":"Api/Files/_qat_8cpp/#appsqatqatcpp","text":"","title":"Apps/Qat/Qat.cpp"},{"location":"Api/Files/_qat_8cpp/#namespaces","text":"Name llvm","title":"Namespaces"},{"location":"Api/Files/_qat_8cpp/#functions","text":"Name void init () int main (int argc, char ** argv)","title":"Functions"},{"location":"Api/Files/_qat_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Files/_qat_8cpp/#function-init","text":"void init()","title":"function init"},{"location":"Api/Files/_qat_8cpp/#function-main","text":"int main( int argc, char ** argv )","title":"function main"},{"location":"Api/Files/_qat_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Apps/Qat/QatConfig.hpp\" #include \"Commandline/ConfigurationManager.hpp\" #include \"Commandline/ParameterParser.hpp\" #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Generators/LlvmPassesConfiguration.hpp\" #include \"ModuleLoader/ModuleLoader.hpp\" #include \"Profile/Profile.hpp\" #include \"Rules/Factory.hpp\" #include \"Rules/FactoryConfig.hpp\" #include \"TransformationRulesPass/TransformationRulesPass.hpp\" #include \"TransformationRulesPass/TransformationRulesPassConfiguration.hpp\" #include \"ValidationPass/ValidationPassConfiguration.hpp\" #include \"Validator/Validator.hpp\" #include \"Llvm/Llvm.hpp\" #include <dlfcn.h> #include <iomanip> #include <iostream> #include <unordered_map> using namespace llvm; using namespace microsoft::quantum; void init(); void init() { // Initialize LLVM passes PassRegistry& registry = *PassRegistry::getPassRegistry(); initializeCore(registry); initializeCoroutines(registry); initializeScalarOpts(registry); initializeObjCARCOpts(registry); initializeVectorization(registry); initializeIPO(registry); initializeAnalysis(registry); initializeTransformUtils(registry); initializeInstCombine(registry); initializeAggressiveInstCombine(registry); initializeInstrumentation(registry); initializeTarget(registry); initializeExpandMemCmpPassPass(registry); initializeScalarizeMaskedMemIntrinPass(registry); initializeCodeGenPreparePass(registry); initializeAtomicExpandPass(registry); initializeRewriteSymbolsLegacyPassPass(registry); initializeWinEHPreparePass(registry); initializeDwarfEHPreparePass(registry); initializeSafeStackLegacyPassPass(registry); initializeSjLjEHPreparePass(registry); initializePreISelIntrinsicLoweringLegacyPassPass(registry); initializeGlobalMergePass(registry); initializeIndirectBrExpandPassPass(registry); initializeInterleavedLoadCombinePass(registry); initializeInterleavedAccessPass(registry); initializeEntryExitInstrumenterPass(registry); initializePostInlineEntryExitInstrumenterPass(registry); initializeUnreachableBlockElimLegacyPassPass(registry); initializeExpandReductionsPass(registry); initializeWasmEHPreparePass(registry); initializeWriteBitcodePassPass(registry); initializeHardwareLoopsPass(registry); initializeTypePromotionPass(registry); } int main(int argc, char** argv) { try { // Default generator. A future version of QAT may allow the generator to be selected // through the command line, but it is hard coded for now. auto generator = std::make_shared<ProfileGenerator>(); // Configuration and command line parsing // ConfigurationManager& configuration_manager = generator->configurationManager(); configuration_manager.addConfig<QatConfig>(); configuration_manager.addConfig<FactoryConfiguration>(); ParameterParser parser; configuration_manager.setupArguments(parser); parser.parseArgs(argc, argv); configuration_manager.configure(parser); // Getting the main configuration auto config = configuration_manager.get<QatConfig>(); // Setting profile validation configuration configuration_manager.addConfig<ValidationPassConfiguration>( \"validation-configuration\", ValidationPassConfiguration::fromProfileName(config.profile())); // Loading components // generator->registerProfileComponent<TransformationRulesPassConfiguration>( \"transformation-rules\", [](TransformationRulesPassConfiguration const& cfg, ProfileGenerator* ptr, Profile& profile) { auto& ret = ptr->modulePassManager(); // Default optimisation pipeline if (cfg.shouldSimplifyPriorTransform()) { auto& pass_builder = ptr->passBuilder(); llvm::ModulePassManager pipeline = pass_builder.buildPerModuleDefaultPipeline(ptr->optimisationLevel()); ret.addPass(std::move(pipeline)); } // Defining the mapping RuleSet rule_set; auto factory = RuleFactory(rule_set, profile.getQubitAllocationManager(), profile.getResultAllocationManager()); factory.usingConfiguration(ptr->configurationManager().get<FactoryConfiguration>()); // Creating profile pass ret.addPass(TransformationRulesPass(std::move(rule_set), cfg, &profile)); }); if (!config.load().empty()) { // TODO (tfr): Add support for multiple loads void* handle = dlopen(config.load().c_str(), RTLD_LAZY); if (handle == nullptr) { std::cerr << \"Invalid component \" << config.load() << std::endl; } else { using LoadFunctionPtr = void (*)(ProfileGenerator*); LoadFunctionPtr load_component; load_component = reinterpret_cast<LoadFunctionPtr>(dlsym(handle, \"loadComponent\")); load_component(generator.get()); } } generator->registerProfileComponent<LlvmPassesConfiguration>( \"llvm-passes\", [](LlvmPassesConfiguration const& cfg, ProfileGenerator* ptr, Profile&) { auto pass_pipeline = cfg.passPipeline(); if (!pass_pipeline.empty()) { auto& pass_builder = ptr->passBuilder(); auto& npm = ptr->modulePassManager(); if (auto err = pass_builder.parsePassPipeline(npm, pass_pipeline, false, false)) { throw std::runtime_error( \"Failed to set pass pipeline up. Value: '\" + pass_pipeline + \"', error: \" + toString(std::move(err))); } } else if (cfg.alwaysInline()) { auto& ret = ptr->modulePassManager(); auto& pass_builder = ptr->passBuilder(); ret.addPass(llvm::AlwaysInlinerPass()); auto inliner_pass = pass_builder.buildInlinerPipeline( ptr->optimisationLevel(), llvm::PassBuilder::ThinLTOPhase::None, ptr->isDebugMode()); ret.addPass(std::move(inliner_pass)); } else if (!cfg.disableDefaultPipeline()) { auto& mpm = ptr->modulePassManager(); llvm::PassBuilder::OptimizationLevel opt = llvm::PassBuilder::OptimizationLevel::O3; // If not explicitly disabled, we fall back to the default LLVM pipeline auto& pass_builder = ptr->passBuilder(); llvm::ModulePassManager pipeline1 = pass_builder.buildPerModuleDefaultPipeline(opt); mpm.addPass(std::move(pipeline1)); llvm::ModulePassManager pipeline2 = pass_builder.buildModuleSimplificationPipeline(opt, llvm::PassBuilder::ThinLTOPhase::None); mpm.addPass(std::move(pipeline2)); llvm::ModulePassManager pipeline3 = pass_builder.buildModuleOptimizationPipeline(opt, ptr->isDebugMode()); mpm.addPass(std::move(pipeline3)); auto inline_param = getInlineParams(cfg.inlineParameter()); llvm::ModuleInlinerWrapperPass pipeline4 = ModuleInlinerWrapperPass(inline_param); mpm.addPass(std::move(pipeline4)); } }); // Reconfiguring to get all the arguments of the passes registered parser.reset(); configuration_manager.setupArguments(parser); parser.parseArgs(argc, argv); configuration_manager.configure(parser); // In case we debug, we also print the settings to allow provide a full // picture of what is going. This step deliberately comes before validating // the input to allow dumping the configuration if something goes wrong. if (config.shouldDumpConfig()) { configuration_manager.printConfiguration(); } // Checking that we have sufficient information to proceed. If not we print // usage instructions and the corresponding description of how to use the tool. if (parser.arguments().empty()) { std::cerr << \"Usage: \" << argv[0] << \" [options] filename\" << std::endl; configuration_manager.printHelp(); std::cerr << \"\\n\"; exit(-1); } // Loading IR from file(s). // LLVMContext context; init(); auto module = std::make_unique<Module>(\"qat-link\", context); ModuleLoader loader(module.get()); for (auto const& arg : parser.arguments()) { if (!loader.addIrFile(arg)) { llvm::errs() << \"Could not load \" << arg << \"\\n\"; return -1; } } if (!module) { std::cerr << \"Invalid IR.\" << std::endl; exit(-1); } // Getting the optimisation level // auto optimisation_level = llvm::PassBuilder::OptimizationLevel::O0; // Setting the optimisation level if (config.isOpt1Enabled()) { optimisation_level = llvm::PassBuilder::OptimizationLevel::O1; } if (config.isOpt2Enabled()) { optimisation_level = llvm::PassBuilder::OptimizationLevel::O2; } if (config.isOpt3Enabled()) { optimisation_level = llvm::PassBuilder::OptimizationLevel::O3; } // Profile manipulation // // Creating the profile that will be used for generation and validation auto profile = generator->newProfile(config.profile(), optimisation_level, config.isDebugMode()); if (config.shouldGenerate()) { profile.apply(*module); } // We deliberately emit LLVM prior to verification and validation // to allow output the IR for debugging purposes. if (config.shouldEmitLlvm()) { llvm::outs() << *module << \"\\n\"; } else { llvm::WriteBitcodeToFile(*module, llvm::outs()); } if (config.verifyModule()) { if (!profile.verify(*module)) { std::cerr << \"IR is broken.\" << std::endl; exit(-1); } } if (config.shouldValidate()) { if (!profile.validate(*module)) { std::cerr << \"IR did not validate to the profile constraints.\" << std::endl; exit(-1); } } } catch (std::exception const& e) { std::cerr << \"An error occurred: \" << e.what() << std::endl; exit(-1); } return 0; } Updated on 22 November 2021 at 10:28:35 UTC","title":"Source code"},{"location":"Api/Files/_qat_config_8cpp/","text":"Apps/Qat/QatConfig.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Apps/Qat/QatConfig.hpp\" #include \"Commandline/ConfigurationManager.hpp\" namespace microsoft { namespace quantum { void QatConfig::setup(ConfigurationManager& config) { config.setSectionName( \"Base configuration\", \"Configuration of the quantum adoption tool to execute a specific behaviour.\"); config.addParameter(load_, \"load\", \"Load component.\"); config.addParameter( generate_, \"apply\", \"Applies a profile to transform the IR in correspondence with the profile.\"); config.addParameter(validate_, \"validate\", \"Executes the validation procedure.\"); config.addParameter(profile_, \"profile\", \"Sets the profile.\"); config.addParameter(emit_llvm_, \"S\", \"Emits LLVM IR to the standard output.\"); config.addParameter(opt0_, \"O0\", \"Optimisation level 0.\"); config.addParameter(opt1_, \"O1\", \"Optimisation level 1.\"); config.addParameter(opt2_, \"O2\", \"Optimisation level 2.\"); config.addParameter(opt3_, \"O3\", \"Optimisation level 3.\"); config.addParameter(verify_module_, \"verify-module\", \"Verifies the module after transformation.\"); config.addParameter(dump_config_, \"dump-config\", \"Prints the configuration to the standard output.\"); } bool QatConfig::shouldGenerate() const { return generate_; } bool QatConfig::shouldValidate() const { return validate_; } String QatConfig::profile() const { return profile_; } bool QatConfig::shouldEmitLlvm() const { return emit_llvm_; } bool QatConfig::isOpt0Enabled() const { return opt0_; } bool QatConfig::isOpt1Enabled() const { return opt1_; } bool QatConfig::isOpt2Enabled() const { return opt2_; } bool QatConfig::isOpt3Enabled() const { return opt3_; } bool QatConfig::verifyModule() const { return verify_module_; } bool QatConfig::isDebugMode() const { return debug_; } bool QatConfig::shouldDumpConfig() const { return dump_config_; } String QatConfig::load() const { return load_; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:35 UTC","title":"Apps/Qat/QatConfig.cpp"},{"location":"Api/Files/_qat_config_8cpp/#appsqatqatconfigcpp","text":"","title":"Apps/Qat/QatConfig.cpp"},{"location":"Api/Files/_qat_config_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_qat_config_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Apps/Qat/QatConfig.hpp\" #include \"Commandline/ConfigurationManager.hpp\" namespace microsoft { namespace quantum { void QatConfig::setup(ConfigurationManager& config) { config.setSectionName( \"Base configuration\", \"Configuration of the quantum adoption tool to execute a specific behaviour.\"); config.addParameter(load_, \"load\", \"Load component.\"); config.addParameter( generate_, \"apply\", \"Applies a profile to transform the IR in correspondence with the profile.\"); config.addParameter(validate_, \"validate\", \"Executes the validation procedure.\"); config.addParameter(profile_, \"profile\", \"Sets the profile.\"); config.addParameter(emit_llvm_, \"S\", \"Emits LLVM IR to the standard output.\"); config.addParameter(opt0_, \"O0\", \"Optimisation level 0.\"); config.addParameter(opt1_, \"O1\", \"Optimisation level 1.\"); config.addParameter(opt2_, \"O2\", \"Optimisation level 2.\"); config.addParameter(opt3_, \"O3\", \"Optimisation level 3.\"); config.addParameter(verify_module_, \"verify-module\", \"Verifies the module after transformation.\"); config.addParameter(dump_config_, \"dump-config\", \"Prints the configuration to the standard output.\"); } bool QatConfig::shouldGenerate() const { return generate_; } bool QatConfig::shouldValidate() const { return validate_; } String QatConfig::profile() const { return profile_; } bool QatConfig::shouldEmitLlvm() const { return emit_llvm_; } bool QatConfig::isOpt0Enabled() const { return opt0_; } bool QatConfig::isOpt1Enabled() const { return opt1_; } bool QatConfig::isOpt2Enabled() const { return opt2_; } bool QatConfig::isOpt3Enabled() const { return opt3_; } bool QatConfig::verifyModule() const { return verify_module_; } bool QatConfig::isDebugMode() const { return debug_; } bool QatConfig::shouldDumpConfig() const { return dump_config_; } String QatConfig::load() const { return load_; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:35 UTC","title":"Source code"},{"location":"Api/Files/_qat_config_8hpp/","text":"Apps/Qat/QatConfig.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::QatConfig Main configuration class for the qat command-line program. Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"QatTypes/QatTypes.hpp\" namespace microsoft { namespace quantum { class QatConfig { public: // Functions required by configuration manager // void setup(ConfigurationManager& config); // Flags and options // String load() const; bool shouldGenerate() const; bool verifyModule() const; bool shouldValidate() const; String profile() const; bool shouldEmitLlvm() const; bool isOpt0Enabled() const; bool isOpt1Enabled() const; bool isOpt2Enabled() const; bool isOpt3Enabled() const; bool isDebugMode() const; bool shouldDumpConfig() const; private: // Variables to be bound to the configuration manager // String load_{\"\"}; bool generate_{false}; bool validate_{false}; String profile_{\"generic\"}; bool emit_llvm_{false}; bool opt0_{false}; bool opt1_{false}; bool opt2_{false}; bool opt3_{false}; bool verify_module_{false}; bool debug_{false}; bool dump_config_{false}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:35 UTC","title":"Apps/Qat/QatConfig.hpp"},{"location":"Api/Files/_qat_config_8hpp/#appsqatqatconfighpp","text":"","title":"Apps/Qat/QatConfig.hpp"},{"location":"Api/Files/_qat_config_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_qat_config_8hpp/#classes","text":"Name class microsoft::quantum::QatConfig Main configuration class for the qat command-line program.","title":"Classes"},{"location":"Api/Files/_qat_config_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"QatTypes/QatTypes.hpp\" namespace microsoft { namespace quantum { class QatConfig { public: // Functions required by configuration manager // void setup(ConfigurationManager& config); // Flags and options // String load() const; bool shouldGenerate() const; bool verifyModule() const; bool shouldValidate() const; String profile() const; bool shouldEmitLlvm() const; bool isOpt0Enabled() const; bool isOpt1Enabled() const; bool isOpt2Enabled() const; bool isOpt3Enabled() const; bool isDebugMode() const; bool shouldDumpConfig() const; private: // Variables to be bound to the configuration manager // String load_{\"\"}; bool generate_{false}; bool validate_{false}; String profile_{\"generic\"}; bool emit_llvm_{false}; bool opt0_{false}; bool opt1_{false}; bool opt2_{false}; bool opt3_{false}; bool verify_module_{false}; bool debug_{false}; bool dump_config_{false}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:35 UTC","title":"Source code"},{"location":"Api/Files/_qat_types_8hpp/","text":"QatTypes/QatTypes.hpp Namespaces Name microsoft microsoft::quantum Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include <string> namespace microsoft { namespace quantum { using String = std::string; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"QatTypes/QatTypes.hpp"},{"location":"Api/Files/_qat_types_8hpp/#qattypesqattypeshpp","text":"","title":"QatTypes/QatTypes.hpp"},{"location":"Api/Files/_qat_types_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_qat_types_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include <string> namespace microsoft { namespace quantum { using String = std::string; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_remove_disallowed_attributes_pass_8hpp/","text":"RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::RemoveDisallowedAttributesPass Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include \"Llvm/Llvm.hpp\" #include <functional> #include <unordered_set> #include <vector> namespace microsoft { namespace quantum { class RemoveDisallowedAttributesPass : public llvm::PassInfoMixin<RemoveDisallowedAttributesPass> { public: RemoveDisallowedAttributesPass() : allowed_attrs_{{static_cast<String>(\"EntryPoint\"), static_cast<String>(\"InteropFriendly\")}} { } llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { for (auto& fnc : module) { std::unordered_set<String> to_keep; // Finding all valid attributes for (auto& attrset : fnc.getAttributes()) { for (auto& attr : attrset) { auto r = static_cast<String>(attr.getAsString()); // Stripping quotes if (r.size() >= 2 && r[0] == '\"' && r[r.size() - 1] == '\"') { r = r.substr(1, r.size() - 2); } // Inserting if allowed if (allowed_attrs_.find(r) != allowed_attrs_.end()) { to_keep.insert(r); } } } // Deleting every fnc.setAttributes({}); for (auto& attr : to_keep) { fnc.addFnAttr(attr); } } return llvm::PreservedAnalyses::none(); } private: std::unordered_set<String> allowed_attrs_; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp"},{"location":"Api/Files/_remove_disallowed_attributes_pass_8hpp/#removedisallowedattributespassremovedisallowedattributespasshpp","text":"","title":"RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp"},{"location":"Api/Files/_remove_disallowed_attributes_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_remove_disallowed_attributes_pass_8hpp/#classes","text":"Name class microsoft::quantum::RemoveDisallowedAttributesPass","title":"Classes"},{"location":"Api/Files/_remove_disallowed_attributes_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"QatTypes/QatTypes.hpp\" #include \"Llvm/Llvm.hpp\" #include <functional> #include <unordered_set> #include <vector> namespace microsoft { namespace quantum { class RemoveDisallowedAttributesPass : public llvm::PassInfoMixin<RemoveDisallowedAttributesPass> { public: RemoveDisallowedAttributesPass() : allowed_attrs_{{static_cast<String>(\"EntryPoint\"), static_cast<String>(\"InteropFriendly\")}} { } llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { for (auto& fnc : module) { std::unordered_set<String> to_keep; // Finding all valid attributes for (auto& attrset : fnc.getAttributes()) { for (auto& attr : attrset) { auto r = static_cast<String>(attr.getAsString()); // Stripping quotes if (r.size() >= 2 && r[0] == '\"' && r[r.size() - 1] == '\"') { r = r.substr(1, r.size() - 2); } // Inserting if allowed if (allowed_attrs_.find(r) != allowed_attrs_.end()) { to_keep.insert(r); } } } // Deleting every fnc.setAttributes({}); for (auto& attr : to_keep) { fnc.addFnAttr(attr); } } return llvm::PreservedAnalyses::none(); } private: std::unordered_set<String> allowed_attrs_; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_remove_function_call_8cpp/","text":"Rules/Tests/Unit/RemoveFunctionCall.cpp Functions Name TEST (RuleSetTestSuite , RemovingFunctionCall ) Functions Documentation function TEST TEST( RuleSetTestSuite , RemovingFunctionCall ) Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareFunction(\"%Qubit* @__quantum__rt__qubit_allocate()\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(RuleSetTestSuite, RemovingFunctionCall) { auto ir_manip = newIrManip(R\"script( %qubit = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %qubit) call void @__quantum__rt__qubit_release(%Qubit* %qubit) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.removeFunctionCall(\"__quantum__qis__h__body\"); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence( {\"%qubit = tail call %Qubit* @__quantum__rt__qubit_allocate()\", \"tail call void @__quantum__rt__qubit_release(%Qubit* %qubit)\"})); // We expect that the call was removed EXPECT_FALSE(ir_manip->hasInstructionSequence({\"call void @__quantum__qis__h__body(%Qubit* %qubit)\"})); EXPECT_FALSE(ir_manip->hasInstructionSequence({\"tail call void @__quantum__qis__h__body(%Qubit* %qubit)\"})); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Tests/Unit/RemoveFunctionCall.cpp"},{"location":"Api/Files/_remove_function_call_8cpp/#rulestestsunitremovefunctioncallcpp","text":"","title":"Rules/Tests/Unit/RemoveFunctionCall.cpp"},{"location":"Api/Files/_remove_function_call_8cpp/#functions","text":"Name TEST (RuleSetTestSuite , RemovingFunctionCall )","title":"Functions"},{"location":"Api/Files/_remove_function_call_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Files/_remove_function_call_8cpp/#function-test","text":"TEST( RuleSetTestSuite , RemovingFunctionCall )","title":"function TEST"},{"location":"Api/Files/_remove_function_call_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareFunction(\"%Qubit* @__quantum__rt__qubit_allocate()\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(RuleSetTestSuite, RemovingFunctionCall) { auto ir_manip = newIrManip(R\"script( %qubit = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %qubit) call void @__quantum__rt__qubit_release(%Qubit* %qubit) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.removeFunctionCall(\"__quantum__qis__h__body\"); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence( {\"%qubit = tail call %Qubit* @__quantum__rt__qubit_allocate()\", \"tail call void @__quantum__rt__qubit_release(%Qubit* %qubit)\"})); // We expect that the call was removed EXPECT_FALSE(ir_manip->hasInstructionSequence({\"call void @__quantum__qis__h__body(%Qubit* %qubit)\"})); EXPECT_FALSE(ir_manip->hasInstructionSequence({\"tail call void @__quantum__qis__h__body(%Qubit* %qubit)\"})); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_replacement_rule_8cpp/","text":"Rules/ReplacementRule.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/ReplacementRule.hpp\" namespace microsoft { namespace quantum { ReplacementRule::ReplacementRule(IOperandPrototypePtr&& pattern, ReplaceFunction&& replacer) : pattern_{std::move(pattern)} , replacer_{std::move(replacer)} { } void ReplacementRule::setPattern(IOperandPrototypePtr&& pattern) { pattern_ = std::move(pattern); } void ReplacementRule::setReplacer(ReplaceFunction const& replacer) { replacer_ = replacer; } bool ReplacementRule::match(Value* value, Captures& captures) const { if (pattern_ == nullptr) { return false; } return pattern_->match(value, captures); } bool ReplacementRule::replace(Builder& builder, Value* value, Captures& captures, Replacements& replacements) const { if (replacer_) { auto ret = replacer_(builder, value, captures, replacements); // In case replacement failed, the captures are deleted. if (!ret) { captures.clear(); } return ret; } return false; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/ReplacementRule.cpp"},{"location":"Api/Files/_replacement_rule_8cpp/#rulesreplacementrulecpp","text":"","title":"Rules/ReplacementRule.cpp"},{"location":"Api/Files/_replacement_rule_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_replacement_rule_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/ReplacementRule.hpp\" namespace microsoft { namespace quantum { ReplacementRule::ReplacementRule(IOperandPrototypePtr&& pattern, ReplaceFunction&& replacer) : pattern_{std::move(pattern)} , replacer_{std::move(replacer)} { } void ReplacementRule::setPattern(IOperandPrototypePtr&& pattern) { pattern_ = std::move(pattern); } void ReplacementRule::setReplacer(ReplaceFunction const& replacer) { replacer_ = replacer; } bool ReplacementRule::match(Value* value, Captures& captures) const { if (pattern_ == nullptr) { return false; } return pattern_->match(value, captures); } bool ReplacementRule::replace(Builder& builder, Value* value, Captures& captures, Replacements& replacements) const { if (replacer_) { auto ret = replacer_(builder, value, captures, replacements); // In case replacement failed, the captures are deleted. if (!ret) { captures.clear(); } return ret; } return false; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_replacement_rule_8hpp/","text":"Rules/ReplacementRule.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ReplacementRule Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class ReplacementRule { public: using Captures = IOperandPrototype::Captures; using Value = llvm::Value; using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; using Builder = llvm::IRBuilder<>; using Replacements = std::vector<std::pair<Value*, Value*>>; using ReplaceFunction = std::function<bool(Builder&, Value*, Captures&, Replacements&)>; // Constructors and destructors // ReplacementRule() = default; ReplacementRule(IOperandPrototypePtr&& pattern, ReplaceFunction&& replacer); // Rule configuration // void setPattern(IOperandPrototypePtr&& pattern); void setReplacer(ReplaceFunction const& replacer); // Operation // bool match(Value* value, Captures& captures) const; bool replace(Builder& builder, Value* value, Captures& captures, Replacements& replacements) const; private: IOperandPrototypePtr pattern_{nullptr}; ReplaceFunction replacer_{nullptr}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/ReplacementRule.hpp"},{"location":"Api/Files/_replacement_rule_8hpp/#rulesreplacementrulehpp","text":"","title":"Rules/ReplacementRule.hpp"},{"location":"Api/Files/_replacement_rule_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_replacement_rule_8hpp/#classes","text":"Name class microsoft::quantum::ReplacementRule","title":"Classes"},{"location":"Api/Files/_replacement_rule_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class ReplacementRule { public: using Captures = IOperandPrototype::Captures; using Value = llvm::Value; using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; using Builder = llvm::IRBuilder<>; using Replacements = std::vector<std::pair<Value*, Value*>>; using ReplaceFunction = std::function<bool(Builder&, Value*, Captures&, Replacements&)>; // Constructors and destructors // ReplacementRule() = default; ReplacementRule(IOperandPrototypePtr&& pattern, ReplaceFunction&& replacer); // Rule configuration // void setPattern(IOperandPrototypePtr&& pattern); void setReplacer(ReplaceFunction const& replacer); // Operation // bool match(Value* value, Captures& captures) const; bool replace(Builder& builder, Value* value, Captures& captures, Replacements& replacements) const; private: IOperandPrototypePtr pattern_{nullptr}; ReplaceFunction replacer_{nullptr}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_rule_set_8cpp/","text":"Rules/RuleSet.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/ReplacementRule.hpp\" #include \"Rules/RuleSet.hpp\" #include \"Llvm/Llvm.hpp\" #include <iostream> #include <vector> namespace microsoft { namespace quantum { bool RuleSet::matchAndReplace(Instruction* value, Replacements& replacements) { Captures captures; for (auto const& rule : rules_) { // Checking if the rule is matched and keep track of captured nodes if (rule->match(value, captures)) { // If it is matched, we attempt to replace it llvm::IRBuilder<> builder{value}; if (rule->replace(builder, value, captures, replacements)) { return true; } else { captures.clear(); } } } return false; } void RuleSet::addRule(ReplacementRulePtr const& rule) { rules_.push_back(rule); } void RuleSet::addRule(ReplacementRule&& rule) { addRule(std::make_shared<ReplacementRule>(std::move(rule))); } void RuleSet::clear() { rules_.clear(); } uint64_t RuleSet::size() const { return rules_.size(); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/RuleSet.cpp"},{"location":"Api/Files/_rule_set_8cpp/#rulesrulesetcpp","text":"","title":"Rules/RuleSet.cpp"},{"location":"Api/Files/_rule_set_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_rule_set_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/ReplacementRule.hpp\" #include \"Rules/RuleSet.hpp\" #include \"Llvm/Llvm.hpp\" #include <iostream> #include <vector> namespace microsoft { namespace quantum { bool RuleSet::matchAndReplace(Instruction* value, Replacements& replacements) { Captures captures; for (auto const& rule : rules_) { // Checking if the rule is matched and keep track of captured nodes if (rule->match(value, captures)) { // If it is matched, we attempt to replace it llvm::IRBuilder<> builder{value}; if (rule->replace(builder, value, captures, replacements)) { return true; } else { captures.clear(); } } } return false; } void RuleSet::addRule(ReplacementRulePtr const& rule) { rules_.push_back(rule); } void RuleSet::addRule(ReplacementRule&& rule) { addRule(std::make_shared<ReplacementRule>(std::move(rule))); } void RuleSet::clear() { rules_.clear(); } uint64_t RuleSet::size() const { return rules_.size(); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_rule_set_8hpp/","text":"Rules/RuleSet.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::RuleSet Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/IAllocationManager.hpp\" #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/ReplacementRule.hpp\" #include \"Llvm/Llvm.hpp\" #include <memory> #include <vector> namespace microsoft { namespace quantum { class RuleSet { public: using ReplacementRulePtr = std::shared_ptr<ReplacementRule>; using Rules = std::vector<ReplacementRulePtr>; using Replacements = ReplacementRule::Replacements; using Captures = IOperandPrototype::Captures; using Instruction = llvm::Instruction; using Value = llvm::Value; using Builder = ReplacementRule::Builder; using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; // Constructors // RuleSet() = default; RuleSet(RuleSet const&) = default; RuleSet(RuleSet&&) = default; ~RuleSet() = default; // Operators // RuleSet& operator=(RuleSet const&) = default; RuleSet& operator=(RuleSet&&) = default; // Operating rule sets // bool matchAndReplace(Instruction* value, Replacements& replacements); // Set up and configuration // void addRule(ReplacementRulePtr const& rule); void addRule(ReplacementRule&& rule); void clear(); uint64_t size() const; private: Rules rules_; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/RuleSet.hpp"},{"location":"Api/Files/_rule_set_8hpp/#rulesrulesethpp","text":"","title":"Rules/RuleSet.hpp"},{"location":"Api/Files/_rule_set_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_rule_set_8hpp/#classes","text":"Name class microsoft::quantum::RuleSet","title":"Classes"},{"location":"Api/Files/_rule_set_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/IAllocationManager.hpp\" #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/ReplacementRule.hpp\" #include \"Llvm/Llvm.hpp\" #include <memory> #include <vector> namespace microsoft { namespace quantum { class RuleSet { public: using ReplacementRulePtr = std::shared_ptr<ReplacementRule>; using Rules = std::vector<ReplacementRulePtr>; using Replacements = ReplacementRule::Replacements; using Captures = IOperandPrototype::Captures; using Instruction = llvm::Instruction; using Value = llvm::Value; using Builder = ReplacementRule::Builder; using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; // Constructors // RuleSet() = default; RuleSet(RuleSet const&) = default; RuleSet(RuleSet&&) = default; ~RuleSet() = default; // Operators // RuleSet& operator=(RuleSet const&) = default; RuleSet& operator=(RuleSet&&) = default; // Operating rule sets // bool matchAndReplace(Instruction* value, Replacements& replacements); // Set up and configuration // void addRule(ReplacementRulePtr const& rule); void addRule(ReplacementRule&& rule); void clear(); uint64_t size() const; private: Rules rules_; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_select_8cpp/","text":"Rules/Notation/Select.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr select( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2) { auto select_pattern = std::make_shared<SelectPattern>(); select_pattern->addChild(cond); select_pattern->addChild(arg1); select_pattern->addChild(arg2); return static_cast<IOperandPrototypePtr>(select_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Notation/Select.cpp"},{"location":"Api/Files/_select_8cpp/#rulesnotationselectcpp","text":"","title":"Rules/Notation/Select.cpp"},{"location":"Api/Files/_select_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_select_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr select( IOperandPrototypePtr const& cond, IOperandPrototypePtr const& arg1, IOperandPrototypePtr const& arg2) { auto select_pattern = std::make_shared<SelectPattern>(); select_pattern->addChild(cond); select_pattern->addChild(arg1); select_pattern->addChild(arg2); return static_cast<IOperandPrototypePtr>(select_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_select_on_one_8cpp/","text":"Rules/Tests/Unit/SelectOnOne.cpp Functions Name TEST (RuleSetTestSuite , SelectOnOne ) Functions Documentation function TEST TEST( RuleSetTestSuite , SelectOnOne ) Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"Rules/ReplacementRule.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareFunction(\"void @__quantum__qis__reset__body(%Qubit*)\"); ir_manip->declareFunction(\"%Result* @__quantum__rt__result_get_one()\"); ir_manip->declareFunction(\"i1 @__quantum__rt__result_equal(%Result*, %Result*)\"); ir_manip->declareFunction(\"void @__quantum__qis__mz__body(%Qubit*, %Result*)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Select on measurement result TEST(RuleSetTestSuite, SelectOnOne) { auto ir_manip = newIrManip(R\"script( tail call void @__quantum__qis__mz__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*), %Result* nonnull inttoptr (i64 1 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*)) %0 = tail call %Result* @__quantum__rt__result_get_one() %1 = tail call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 1 to %Result*), %Result* %0) %2 = select i1 %1, i8 3, i8 4 %3 = add i8 2, %2 ret i8 %3 )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.optimiseResultOne(); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); ir_manip->applyProfile(profile); // This optimisation is specific to the the __quantum__qis__read_result__body which // returns 1 or 0 depending on the result. We expect that // // %1 = tail call %Result* @__quantum__rt__result_get_one() // %2 = tail call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) // ... // %5 = select i1 %2, <type> %3, <type> %4 // // will be mapped to using this instruction. EXPECT_TRUE(ir_manip->hasInstructionSequence( {\"%0 = tail call i1 @__quantum__qis__read_result__body(%Result* \" \"nonnull inttoptr (i64 1 to %Result*))\", \"%1 = select i1 %0, i8 5, i8 6\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"%1 = call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 1 \" \"to %Result*), %Result* %0)\"}) || ir_manip->hasInstructionSequence({\"%1 = tail call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr \" \"(i64 1 to %Result*), %Result* %0)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"%0 = call %Result* @__quantum__rt__result_get_one()\"}) || ir_manip->hasInstructionSequence({\"%0 = tail call %Result* @__quantum__rt__result_get_one()\"})); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Tests/Unit/SelectOnOne.cpp"},{"location":"Api/Files/_select_on_one_8cpp/#rulestestsunitselectononecpp","text":"","title":"Rules/Tests/Unit/SelectOnOne.cpp"},{"location":"Api/Files/_select_on_one_8cpp/#functions","text":"Name TEST (RuleSetTestSuite , SelectOnOne )","title":"Functions"},{"location":"Api/Files/_select_on_one_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Files/_select_on_one_8cpp/#function-test","text":"TEST( RuleSetTestSuite , SelectOnOne )","title":"function TEST"},{"location":"Api/Files/_select_on_one_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"Rules/ReplacementRule.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareFunction(\"void @__quantum__qis__reset__body(%Qubit*)\"); ir_manip->declareFunction(\"%Result* @__quantum__rt__result_get_one()\"); ir_manip->declareFunction(\"i1 @__quantum__rt__result_equal(%Result*, %Result*)\"); ir_manip->declareFunction(\"void @__quantum__qis__mz__body(%Qubit*, %Result*)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Select on measurement result TEST(RuleSetTestSuite, SelectOnOne) { auto ir_manip = newIrManip(R\"script( tail call void @__quantum__qis__mz__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*), %Result* nonnull inttoptr (i64 1 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* nonnull inttoptr (i64 1 to %Qubit*)) %0 = tail call %Result* @__quantum__rt__result_get_one() %1 = tail call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 1 to %Result*), %Result* %0) %2 = select i1 %1, i8 3, i8 4 %3 = add i8 2, %2 ret i8 %3 )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.optimiseResultOne(); }; auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); ir_manip->applyProfile(profile); // This optimisation is specific to the the __quantum__qis__read_result__body which // returns 1 or 0 depending on the result. We expect that // // %1 = tail call %Result* @__quantum__rt__result_get_one() // %2 = tail call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) // ... // %5 = select i1 %2, <type> %3, <type> %4 // // will be mapped to using this instruction. EXPECT_TRUE(ir_manip->hasInstructionSequence( {\"%0 = tail call i1 @__quantum__qis__read_result__body(%Result* \" \"nonnull inttoptr (i64 1 to %Result*))\", \"%1 = select i1 %0, i8 5, i8 6\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"%1 = call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 1 \" \"to %Result*), %Result* %0)\"}) || ir_manip->hasInstructionSequence({\"%1 = tail call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr \" \"(i64 1 to %Result*), %Result* %0)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"%0 = call %Result* @__quantum__rt__result_get_one()\"}) || ir_manip->hasInstructionSequence({\"%0 = tail call %Result* @__quantum__rt__result_get_one()\"})); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_single_qubit_allocation_8cpp/","text":"Rules/Tests/Unit/SingleQubitAllocation.cpp Functions Name TEST (RuleSetTestSuite , AllocationActionRelease ) TEST (RuleSetTestSuite , MultipleAllocationsNoRelease ) TEST (RuleSetTestSuite , AllocateReleaseMultipleTimes ) TEST (RuleSetTestSuite , ErrorAllocateReleaseByName ) TEST (RuleSetTestSuite , ErrorAllocateReleaseByNameWithNoName ) TEST (RuleSetTestSuite , ErrorReleaseWithTypeErasedAllocation ) Functions Documentation function TEST TEST( RuleSetTestSuite , AllocationActionRelease ) function TEST TEST( RuleSetTestSuite , MultipleAllocationsNoRelease ) function TEST TEST( RuleSetTestSuite , AllocateReleaseMultipleTimes ) function TEST TEST( RuleSetTestSuite , ErrorAllocateReleaseByName ) function TEST TEST( RuleSetTestSuite , ErrorAllocateReleaseByNameWithNoName ) function TEST TEST( RuleSetTestSuite , ErrorReleaseWithTypeErasedAllocation ) Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareFunction(\"%Qubit* @__non_standard_allocator()\"); ir_manip->declareFunction(\"i8* @__non_standard_int_allocator()\"); ir_manip->declareFunction(\"%Qubit* @__quantum__rt__qubit_allocate()\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(RuleSetTestSuite, AllocationActionRelease) { auto ir_manip = newIrManip(R\"script( %qubit = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %qubit) call void @__quantum__rt__qubit_release(%Qubit* %qubit) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.useStaticQubitAllocation(); }; auto profile = std::make_shared<DefaultProfileGenerator>( std::move(configure_profile), TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration::createDisabled()); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence( {\"%qubit = inttoptr i64 0 to %Qubit*\", \"call void @__quantum__qis__h__body(%Qubit* %qubit)\"})); } // Scenario 2 - Multiple sequential allocations TEST(RuleSetTestSuite, MultipleAllocationsNoRelease) { auto ir_manip = newIrManip(R\"script( %qubit1 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit2 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit3 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit4 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit5 = call %Qubit* @__quantum__rt__qubit_allocate() )script\"); auto profile = std::make_shared<DefaultProfileGenerator>( [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.useStaticQubitAllocation(); }, TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration::createDisabled()); ir_manip->applyProfile(profile); // Checking that static allocations happened EXPECT_TRUE(ir_manip->hasInstructionSequence({ \"%qubit1 = inttoptr i64 0 to %Qubit*\", \"%qubit2 = inttoptr i64 1 to %Qubit*\", \"%qubit3 = inttoptr i64 2 to %Qubit*\", \"%qubit4 = inttoptr i64 3 to %Qubit*\", \"%qubit5 = inttoptr i64 4 to %Qubit*\", })); // Checking that dynamic allocations were removed EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%qubit1 = call %Qubit* @__quantum__rt__qubit_allocate()\", })); EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%qubit2 = call %Qubit* @__quantum__rt__qubit_allocate()\", })); EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%qubit3 = call %Qubit* @__quantum__rt__qubit_allocate()\", })); EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%qubit4 = call %Qubit* @__quantum__rt__qubit_allocate()\", })); EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%qubit5 = call %Qubit* @__quantum__rt__qubit_allocate()\", })); } // Scenario 3 - Allocate, release - multiple times TEST(RuleSetTestSuite, AllocateReleaseMultipleTimes) { auto ir_manip = newIrManip(R\"script( %qubit1 = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__rt__qubit_release(%Qubit* %qubit1) %qubit2 = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__rt__qubit_release(%Qubit* %qubit2) %qubit3 = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__rt__qubit_release(%Qubit* %qubit3) %qubit4 = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__rt__qubit_release(%Qubit* %qubit4) %qubit5 = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__rt__qubit_release(%Qubit* %qubit4) )script\"); auto profile = std::make_shared<DefaultProfileGenerator>( [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.useStaticQubitAllocation(); }, TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration::createDisabled()); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence({ \"%qubit1 = inttoptr i64 0 to %Qubit*\", \"%qubit2 = inttoptr i64 0 to %Qubit*\", \"%qubit3 = inttoptr i64 0 to %Qubit*\", \"%qubit4 = inttoptr i64 0 to %Qubit*\", \"%qubit5 = inttoptr i64 0 to %Qubit*\", })); // Checking that dynamic allocations were removed EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%qubit1 = call %Qubit* @__quantum__rt__qubit_allocate()\", })); EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%qubit2 = call %Qubit* @__quantum__rt__qubit_allocate()\", })); EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%qubit3 = call %Qubit* @__quantum__rt__qubit_allocate()\", })); EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%qubit4 = call %Qubit* @__quantum__rt__qubit_allocate()\", })); EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%qubit5 = call %Qubit* @__quantum__rt__qubit_allocate()\", })); } // Scenario 4 - Allocate, release - multiple times TEST(RuleSetTestSuite, ErrorAllocateReleaseByName) { auto ir_manip = newIrManip(R\"script( %leftMessage = call %Qubit* @__non_standard_allocator() call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) )script\"); auto profile = std::make_shared<DefaultProfileGenerator>( [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.useStaticQubitAllocation(); }, TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration::createDisabled()); ir_manip->applyProfile(profile); EXPECT_FALSE(ir_manip->isModuleBroken()); EXPECT_TRUE(ir_manip->hasInstructionSequence({\"%leftMessage = call %Qubit* @__non_standard_allocator()\"})); } TEST(RuleSetTestSuite, ErrorAllocateReleaseByNameWithNoName) { auto ir_manip = newIrManip(R\"script( %0 = call %Qubit* @__non_standard_allocator() call void @__quantum__rt__qubit_release(%Qubit* %0) )script\"); auto profile = std::make_shared<DefaultProfileGenerator>( [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.useStaticQubitAllocation(); }, TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration::createDisabled()); ir_manip->applyProfile(profile); EXPECT_FALSE(ir_manip->isModuleBroken()); EXPECT_TRUE(ir_manip->hasInstructionSequence({\"%0 = call %Qubit* @__non_standard_allocator()\"})); } TEST(RuleSetTestSuite, ErrorReleaseWithTypeErasedAllocation) { auto ir_manip = newIrManip(R\"script( %0 = call i8* @__non_standard_int_allocator() %1 = bitcast i8* %0 to %Qubit* call void @__quantum__rt__qubit_release(%Qubit* %1) )script\"); auto profile = std::make_shared<DefaultProfileGenerator>( [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.useStaticQubitAllocation(); }, TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration::createDisabled()); ir_manip->applyProfile(profile); EXPECT_FALSE(ir_manip->isModuleBroken()); EXPECT_TRUE(ir_manip->hasInstructionSequence({\"%0 = call i8* @__non_standard_int_allocator()\"})); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Tests/Unit/SingleQubitAllocation.cpp"},{"location":"Api/Files/_single_qubit_allocation_8cpp/#rulestestsunitsinglequbitallocationcpp","text":"","title":"Rules/Tests/Unit/SingleQubitAllocation.cpp"},{"location":"Api/Files/_single_qubit_allocation_8cpp/#functions","text":"Name TEST (RuleSetTestSuite , AllocationActionRelease ) TEST (RuleSetTestSuite , MultipleAllocationsNoRelease ) TEST (RuleSetTestSuite , AllocateReleaseMultipleTimes ) TEST (RuleSetTestSuite , ErrorAllocateReleaseByName ) TEST (RuleSetTestSuite , ErrorAllocateReleaseByNameWithNoName ) TEST (RuleSetTestSuite , ErrorReleaseWithTypeErasedAllocation )","title":"Functions"},{"location":"Api/Files/_single_qubit_allocation_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Files/_single_qubit_allocation_8cpp/#function-test","text":"TEST( RuleSetTestSuite , AllocationActionRelease )","title":"function TEST"},{"location":"Api/Files/_single_qubit_allocation_8cpp/#function-test_1","text":"TEST( RuleSetTestSuite , MultipleAllocationsNoRelease )","title":"function TEST"},{"location":"Api/Files/_single_qubit_allocation_8cpp/#function-test_2","text":"TEST( RuleSetTestSuite , AllocateReleaseMultipleTimes )","title":"function TEST"},{"location":"Api/Files/_single_qubit_allocation_8cpp/#function-test_3","text":"TEST( RuleSetTestSuite , ErrorAllocateReleaseByName )","title":"function TEST"},{"location":"Api/Files/_single_qubit_allocation_8cpp/#function-test_4","text":"TEST( RuleSetTestSuite , ErrorAllocateReleaseByNameWithNoName )","title":"function TEST"},{"location":"Api/Files/_single_qubit_allocation_8cpp/#function-test_5","text":"TEST( RuleSetTestSuite , ErrorReleaseWithTypeErasedAllocation )","title":"function TEST"},{"location":"Api/Files/_single_qubit_allocation_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareFunction(\"%Qubit* @__non_standard_allocator()\"); ir_manip->declareFunction(\"i8* @__non_standard_int_allocator()\"); ir_manip->declareFunction(\"%Qubit* @__quantum__rt__qubit_allocate()\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(RuleSetTestSuite, AllocationActionRelease) { auto ir_manip = newIrManip(R\"script( %qubit = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %qubit) call void @__quantum__rt__qubit_release(%Qubit* %qubit) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.useStaticQubitAllocation(); }; auto profile = std::make_shared<DefaultProfileGenerator>( std::move(configure_profile), TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration::createDisabled()); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence( {\"%qubit = inttoptr i64 0 to %Qubit*\", \"call void @__quantum__qis__h__body(%Qubit* %qubit)\"})); } // Scenario 2 - Multiple sequential allocations TEST(RuleSetTestSuite, MultipleAllocationsNoRelease) { auto ir_manip = newIrManip(R\"script( %qubit1 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit2 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit3 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit4 = call %Qubit* @__quantum__rt__qubit_allocate() %qubit5 = call %Qubit* @__quantum__rt__qubit_allocate() )script\"); auto profile = std::make_shared<DefaultProfileGenerator>( [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.useStaticQubitAllocation(); }, TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration::createDisabled()); ir_manip->applyProfile(profile); // Checking that static allocations happened EXPECT_TRUE(ir_manip->hasInstructionSequence({ \"%qubit1 = inttoptr i64 0 to %Qubit*\", \"%qubit2 = inttoptr i64 1 to %Qubit*\", \"%qubit3 = inttoptr i64 2 to %Qubit*\", \"%qubit4 = inttoptr i64 3 to %Qubit*\", \"%qubit5 = inttoptr i64 4 to %Qubit*\", })); // Checking that dynamic allocations were removed EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%qubit1 = call %Qubit* @__quantum__rt__qubit_allocate()\", })); EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%qubit2 = call %Qubit* @__quantum__rt__qubit_allocate()\", })); EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%qubit3 = call %Qubit* @__quantum__rt__qubit_allocate()\", })); EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%qubit4 = call %Qubit* @__quantum__rt__qubit_allocate()\", })); EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%qubit5 = call %Qubit* @__quantum__rt__qubit_allocate()\", })); } // Scenario 3 - Allocate, release - multiple times TEST(RuleSetTestSuite, AllocateReleaseMultipleTimes) { auto ir_manip = newIrManip(R\"script( %qubit1 = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__rt__qubit_release(%Qubit* %qubit1) %qubit2 = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__rt__qubit_release(%Qubit* %qubit2) %qubit3 = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__rt__qubit_release(%Qubit* %qubit3) %qubit4 = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__rt__qubit_release(%Qubit* %qubit4) %qubit5 = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__rt__qubit_release(%Qubit* %qubit4) )script\"); auto profile = std::make_shared<DefaultProfileGenerator>( [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.useStaticQubitAllocation(); }, TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration::createDisabled()); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence({ \"%qubit1 = inttoptr i64 0 to %Qubit*\", \"%qubit2 = inttoptr i64 0 to %Qubit*\", \"%qubit3 = inttoptr i64 0 to %Qubit*\", \"%qubit4 = inttoptr i64 0 to %Qubit*\", \"%qubit5 = inttoptr i64 0 to %Qubit*\", })); // Checking that dynamic allocations were removed EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%qubit1 = call %Qubit* @__quantum__rt__qubit_allocate()\", })); EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%qubit2 = call %Qubit* @__quantum__rt__qubit_allocate()\", })); EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%qubit3 = call %Qubit* @__quantum__rt__qubit_allocate()\", })); EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%qubit4 = call %Qubit* @__quantum__rt__qubit_allocate()\", })); EXPECT_FALSE(ir_manip->hasInstructionSequence({ \"%qubit5 = call %Qubit* @__quantum__rt__qubit_allocate()\", })); } // Scenario 4 - Allocate, release - multiple times TEST(RuleSetTestSuite, ErrorAllocateReleaseByName) { auto ir_manip = newIrManip(R\"script( %leftMessage = call %Qubit* @__non_standard_allocator() call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) )script\"); auto profile = std::make_shared<DefaultProfileGenerator>( [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.useStaticQubitAllocation(); }, TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration::createDisabled()); ir_manip->applyProfile(profile); EXPECT_FALSE(ir_manip->isModuleBroken()); EXPECT_TRUE(ir_manip->hasInstructionSequence({\"%leftMessage = call %Qubit* @__non_standard_allocator()\"})); } TEST(RuleSetTestSuite, ErrorAllocateReleaseByNameWithNoName) { auto ir_manip = newIrManip(R\"script( %0 = call %Qubit* @__non_standard_allocator() call void @__quantum__rt__qubit_release(%Qubit* %0) )script\"); auto profile = std::make_shared<DefaultProfileGenerator>( [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.useStaticQubitAllocation(); }, TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration::createDisabled()); ir_manip->applyProfile(profile); EXPECT_FALSE(ir_manip->isModuleBroken()); EXPECT_TRUE(ir_manip->hasInstructionSequence({\"%0 = call %Qubit* @__non_standard_allocator()\"})); } TEST(RuleSetTestSuite, ErrorReleaseWithTypeErasedAllocation) { auto ir_manip = newIrManip(R\"script( %0 = call i8* @__non_standard_int_allocator() %1 = bitcast i8* %0 to %Qubit* call void @__quantum__rt__qubit_release(%Qubit* %1) )script\"); auto profile = std::make_shared<DefaultProfileGenerator>( [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.useStaticQubitAllocation(); }, TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration::createDisabled()); ir_manip->applyProfile(profile); EXPECT_FALSE(ir_manip->isModuleBroken()); EXPECT_TRUE(ir_manip->hasInstructionSequence({\"%0 = call i8* @__non_standard_int_allocator()\"})); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_static_qubit_array_allocation_8cpp/","text":"Rules/Tests/Unit/StaticQubitArrayAllocation.cpp Functions Name TEST (RuleSetTestSuite , StaticQubitArrayAllocationOffsets ) TEST (RuleSetTestSuite , StaticQubitArrayAllocationGetPtr ) TEST (RuleSetTestSuite , StaticQubitArrayAllocationAdvanced ) Functions Documentation function TEST TEST( RuleSetTestSuite , StaticQubitArrayAllocationOffsets ) function TEST TEST( RuleSetTestSuite , StaticQubitArrayAllocationGetPtr ) function TEST TEST( RuleSetTestSuite , StaticQubitArrayAllocationAdvanced ) Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Array\"); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareFunction(\"%Array* @__quantum__rt__qubit_allocate_array(i64)\"); ir_manip->declareFunction(\"i8* @__quantum__rt__array_get_element_ptr_1d(%Array*, i64)\"); ir_manip->declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release_array(%Array*)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace /* %0 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %leftPreshared, i64 0) %1 = bitcast i8* %0 to i64* store i64 1, i64* %1, align 4 */ // Single allocation with action and then release TEST(RuleSetTestSuite, StaticQubitArrayAllocationOffsets) { auto ir_manip = newIrManip(R\"script( %array1 = call %Array* @__quantum__rt__qubit_allocate_array(i64 2) ; offset 0 %array2 = call %Array* @__quantum__rt__qubit_allocate_array(i64 3) ; offset 2 %array3 = call %Array* @__quantum__rt__qubit_allocate_array(i64 5) ; offset 5 %array4 = call %Array* @__quantum__rt__qubit_allocate_array(i64 9) ; offset 10 %array5 = call %Array* @__quantum__rt__qubit_allocate_array(i64 14) ; offset 19 )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.useStaticQubitArrayAllocation(); }; auto profile = std::make_shared<DefaultProfileGenerator>( std::move(configure_profile), TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration::createDisabled()); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence( {\"%array1 = inttoptr i64 0 to %Array*\", \"%array2 = inttoptr i64 2 to %Array*\", \"%array3 = inttoptr i64 5 to %Array*\", \"%array4 = inttoptr i64 10 to %Array*\", \"%array5 = inttoptr i64 19 to %Array*\"})); } TEST(RuleSetTestSuite, StaticQubitArrayAllocationGetPtr) { auto ir_manip = newIrManip(R\"script( %array1 = call %Array* @__quantum__rt__qubit_allocate_array(i64 10) %0 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %array1, i64 7) %1 = bitcast i8* %0 to %Qubit** %qubit = load %Qubit*, %Qubit** %1, align 8 call void @__quantum__qis__h__body(%Qubit* %qubit) call void @__quantum__rt__qubit_release_array(%Array* %array1) )script\"); // TODO(issue-18): Possibly the \"correct\" way to deal with this is to // do a more granular approach, translating __quantum__rt__array_get_element_ptr_1d // int to a constant i8*. For discussion with team. A good example is // // %array1 = call %Array* @__quantum__rt__qubit_allocate_array(i64 10) // %0 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %array1, i64 7) // %1 = bitcast i8* %0 to %Qubit** // %qubit = load %Qubit*, %Qubit** %1, align 8 // ;;; call @__quantum__qis__h__body(%Qubit* %qubit) < Note this instruction is missing // // LLVM will optimise the two last instructions away even at O0 as they are not used. // Consequently the pattern fails. auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.useStaticQubitArrayAllocation(); }; auto profile = std::make_shared<DefaultProfileGenerator>( std::move(configure_profile), TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration::createDisabled()); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence( {\"%array1 = inttoptr i64 0 to %Array*\", \"%qubit = inttoptr i64 7 to %Qubit*\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__qubit_release_array(%Array* %array1)\"}) || ir_manip->hasInstructionSequence({\"tail call void @__quantum__rt__qubit_release_array(%Array* %array1)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"call %Array* @__quantum__rt__qubit_allocate_array(i64 10)\"}) || ir_manip->hasInstructionSequence({\"tail call %Array* @__quantum__rt__qubit_allocate_array(i64 10)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence( {\"call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %array1, i64 7)\"}) || ir_manip->hasInstructionSequence( {\"tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %array1, i64 7)\"})); } TEST(RuleSetTestSuite, StaticQubitArrayAllocationAdvanced) { auto ir_manip = newIrManip(R\"script( %array1 = call %Array* @__quantum__rt__qubit_allocate_array(i64 10) %array2 = call %Array* @__quantum__rt__qubit_allocate_array(i64 7) %0 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %array1, i64 7) %1 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %array2, i64 3) %2 = bitcast i8* %0 to %Qubit** %3 = bitcast i8* %1 to %Qubit** %qubit1 = load %Qubit*, %Qubit** %2, align 8 %qubit2 = load %Qubit*, %Qubit** %3, align 8 call void @__quantum__qis__h__body(%Qubit* %qubit1) call void @__quantum__qis__h__body(%Qubit* %qubit2) call void @__quantum__rt__qubit_release_array(%Array* %array1) call void @__quantum__rt__qubit_release_array(%Array* %array2) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.useStaticQubitArrayAllocation(); }; auto profile = std::make_shared<DefaultProfileGenerator>( std::move(configure_profile), TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration::createDisabled()); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence( {\"%array1 = inttoptr i64 0 to %Array*\", \"%qubit1 = inttoptr i64 7 to %Qubit*\"})); EXPECT_TRUE(ir_manip->hasInstructionSequence( {\"%array2 = inttoptr i64 10 to %Array*\", \"%qubit2 = inttoptr i64 13 to %Qubit*\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__qubit_release_array(%Array* %array1)\"}) || ir_manip->hasInstructionSequence({\"tail call void @__quantum__rt__qubit_release_array(%Array* %array1)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__qubit_release_array(%Array* %array2)\"}) || ir_manip->hasInstructionSequence({\"tail call void @__quantum__rt__qubit_release_array(%Array* %array2)\"})); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Tests/Unit/StaticQubitArrayAllocation.cpp"},{"location":"Api/Files/_static_qubit_array_allocation_8cpp/#rulestestsunitstaticqubitarrayallocationcpp","text":"","title":"Rules/Tests/Unit/StaticQubitArrayAllocation.cpp"},{"location":"Api/Files/_static_qubit_array_allocation_8cpp/#functions","text":"Name TEST (RuleSetTestSuite , StaticQubitArrayAllocationOffsets ) TEST (RuleSetTestSuite , StaticQubitArrayAllocationGetPtr ) TEST (RuleSetTestSuite , StaticQubitArrayAllocationAdvanced )","title":"Functions"},{"location":"Api/Files/_static_qubit_array_allocation_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Files/_static_qubit_array_allocation_8cpp/#function-test","text":"TEST( RuleSetTestSuite , StaticQubitArrayAllocationOffsets )","title":"function TEST"},{"location":"Api/Files/_static_qubit_array_allocation_8cpp/#function-test_1","text":"TEST( RuleSetTestSuite , StaticQubitArrayAllocationGetPtr )","title":"function TEST"},{"location":"Api/Files/_static_qubit_array_allocation_8cpp/#function-test_2","text":"TEST( RuleSetTestSuite , StaticQubitArrayAllocationAdvanced )","title":"function TEST"},{"location":"Api/Files/_static_qubit_array_allocation_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Array\"); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareFunction(\"%Array* @__quantum__rt__qubit_allocate_array(i64)\"); ir_manip->declareFunction(\"i8* @__quantum__rt__array_get_element_ptr_1d(%Array*, i64)\"); ir_manip->declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release_array(%Array*)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace /* %0 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %leftPreshared, i64 0) %1 = bitcast i8* %0 to i64* store i64 1, i64* %1, align 4 */ // Single allocation with action and then release TEST(RuleSetTestSuite, StaticQubitArrayAllocationOffsets) { auto ir_manip = newIrManip(R\"script( %array1 = call %Array* @__quantum__rt__qubit_allocate_array(i64 2) ; offset 0 %array2 = call %Array* @__quantum__rt__qubit_allocate_array(i64 3) ; offset 2 %array3 = call %Array* @__quantum__rt__qubit_allocate_array(i64 5) ; offset 5 %array4 = call %Array* @__quantum__rt__qubit_allocate_array(i64 9) ; offset 10 %array5 = call %Array* @__quantum__rt__qubit_allocate_array(i64 14) ; offset 19 )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.useStaticQubitArrayAllocation(); }; auto profile = std::make_shared<DefaultProfileGenerator>( std::move(configure_profile), TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration::createDisabled()); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence( {\"%array1 = inttoptr i64 0 to %Array*\", \"%array2 = inttoptr i64 2 to %Array*\", \"%array3 = inttoptr i64 5 to %Array*\", \"%array4 = inttoptr i64 10 to %Array*\", \"%array5 = inttoptr i64 19 to %Array*\"})); } TEST(RuleSetTestSuite, StaticQubitArrayAllocationGetPtr) { auto ir_manip = newIrManip(R\"script( %array1 = call %Array* @__quantum__rt__qubit_allocate_array(i64 10) %0 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %array1, i64 7) %1 = bitcast i8* %0 to %Qubit** %qubit = load %Qubit*, %Qubit** %1, align 8 call void @__quantum__qis__h__body(%Qubit* %qubit) call void @__quantum__rt__qubit_release_array(%Array* %array1) )script\"); // TODO(issue-18): Possibly the \"correct\" way to deal with this is to // do a more granular approach, translating __quantum__rt__array_get_element_ptr_1d // int to a constant i8*. For discussion with team. A good example is // // %array1 = call %Array* @__quantum__rt__qubit_allocate_array(i64 10) // %0 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %array1, i64 7) // %1 = bitcast i8* %0 to %Qubit** // %qubit = load %Qubit*, %Qubit** %1, align 8 // ;;; call @__quantum__qis__h__body(%Qubit* %qubit) < Note this instruction is missing // // LLVM will optimise the two last instructions away even at O0 as they are not used. // Consequently the pattern fails. auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.useStaticQubitArrayAllocation(); }; auto profile = std::make_shared<DefaultProfileGenerator>( std::move(configure_profile), TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration::createDisabled()); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence( {\"%array1 = inttoptr i64 0 to %Array*\", \"%qubit = inttoptr i64 7 to %Qubit*\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__qubit_release_array(%Array* %array1)\"}) || ir_manip->hasInstructionSequence({\"tail call void @__quantum__rt__qubit_release_array(%Array* %array1)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"call %Array* @__quantum__rt__qubit_allocate_array(i64 10)\"}) || ir_manip->hasInstructionSequence({\"tail call %Array* @__quantum__rt__qubit_allocate_array(i64 10)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence( {\"call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %array1, i64 7)\"}) || ir_manip->hasInstructionSequence( {\"tail call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %array1, i64 7)\"})); } TEST(RuleSetTestSuite, StaticQubitArrayAllocationAdvanced) { auto ir_manip = newIrManip(R\"script( %array1 = call %Array* @__quantum__rt__qubit_allocate_array(i64 10) %array2 = call %Array* @__quantum__rt__qubit_allocate_array(i64 7) %0 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %array1, i64 7) %1 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %array2, i64 3) %2 = bitcast i8* %0 to %Qubit** %3 = bitcast i8* %1 to %Qubit** %qubit1 = load %Qubit*, %Qubit** %2, align 8 %qubit2 = load %Qubit*, %Qubit** %3, align 8 call void @__quantum__qis__h__body(%Qubit* %qubit1) call void @__quantum__qis__h__body(%Qubit* %qubit2) call void @__quantum__rt__qubit_release_array(%Array* %array1) call void @__quantum__rt__qubit_release_array(%Array* %array2) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.useStaticQubitArrayAllocation(); }; auto profile = std::make_shared<DefaultProfileGenerator>( std::move(configure_profile), TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration::createDisabled()); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence( {\"%array1 = inttoptr i64 0 to %Array*\", \"%qubit1 = inttoptr i64 7 to %Qubit*\"})); EXPECT_TRUE(ir_manip->hasInstructionSequence( {\"%array2 = inttoptr i64 10 to %Array*\", \"%qubit2 = inttoptr i64 13 to %Qubit*\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__qubit_release_array(%Array* %array1)\"}) || ir_manip->hasInstructionSequence({\"tail call void @__quantum__rt__qubit_release_array(%Array* %array1)\"})); EXPECT_FALSE( ir_manip->hasInstructionSequence({\"call void @__quantum__rt__qubit_release_array(%Array* %array2)\"}) || ir_manip->hasInstructionSequence({\"tail call void @__quantum__rt__qubit_release_array(%Array* %array2)\"})); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_static_result_allocation_8cpp/","text":"Rules/Tests/Unit/StaticResultAllocation.cpp Functions Name TEST (RuleSetTestSuite , ResultTranslatedTo ) Functions Documentation function TEST TEST( RuleSetTestSuite , ResultTranslatedTo ) Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareFunction(\"%Qubit* @__non_standard_allocator()\"); ir_manip->declareFunction(\"i8* @__non_standard_int_allocator()\"); ir_manip->declareFunction(\"%Result* @__quantum__qis__m__body(%Qubit*)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(RuleSetTestSuite, ResultTranslatedTo) { auto ir_manip = newIrManip(R\"script( %result1 = call %Result* @__quantum__qis__m__body(%Qubit* null) %result2 = call %Result* @__quantum__qis__m__body(%Qubit* null) %result3 = call %Result* @__quantum__qis__m__body(%Qubit* null) %result4 = call %Result* @__quantum__qis__m__body(%Qubit* null) %result5 = call %Result* @__quantum__qis__m__body(%Qubit* null) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.useStaticResultAllocation(); }; auto profile = std::make_shared<DefaultProfileGenerator>( std::move(configure_profile), TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration::createDisabled()); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence({ \"%result1 = inttoptr i64 0 to %Result*\", \"call void @__quantum__qis__mz__body(%Qubit* null, %Result* %result1)\", \"%result2 = inttoptr i64 1 to %Result*\", \"call void @__quantum__qis__mz__body(%Qubit* null, %Result* %result2)\", \"%result3 = inttoptr i64 2 to %Result*\", \"call void @__quantum__qis__mz__body(%Qubit* null, %Result* %result3)\", \"%result4 = inttoptr i64 3 to %Result*\", \"call void @__quantum__qis__mz__body(%Qubit* null, %Result* %result4)\", \"%result5 = inttoptr i64 4 to %Result*\", \"call void @__quantum__qis__mz__body(%Qubit* null, %Result* %result5)\", })); EXPECT_FALSE( ir_manip->hasInstructionSequence({ \"%result1 = call %Result* @__quantum__qis__m__body(%Qubit* null)\", }) || ir_manip->hasInstructionSequence({ \"%result1 = tail call %Result* @__quantum__qis__m__body(%Qubit* null)\", })); EXPECT_FALSE( ir_manip->hasInstructionSequence({ \"%result2 = call %Result* @__quantum__qis__m__body(%Qubit* null)\", }) || ir_manip->hasInstructionSequence({ \"%result2 = tail call %Result* @__quantum__qis__m__body(%Qubit* null)\", })); EXPECT_FALSE( ir_manip->hasInstructionSequence({ \"%result3 = call %Result* @__quantum__qis__m__body(%Qubit* null)\", }) || ir_manip->hasInstructionSequence({ \"%result3 = tail call %Result* @__quantum__qis__m__body(%Qubit* null)\", })); EXPECT_FALSE( ir_manip->hasInstructionSequence({ \"%result4 = call %Result* @__quantum__qis__m__body(%Qubit* null)\", }) || ir_manip->hasInstructionSequence({ \"%result4 = tail call %Result* @__quantum__qis__m__body(%Qubit* null)\", })); EXPECT_FALSE( ir_manip->hasInstructionSequence({ \"%result5 = call %Result* @__quantum__qis__m__body(%Qubit* null)\", }) || ir_manip->hasInstructionSequence({ \"%result5 = tail call %Result* @__quantum__qis__m__body(%Qubit* null)\", })); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Tests/Unit/StaticResultAllocation.cpp"},{"location":"Api/Files/_static_result_allocation_8cpp/#rulestestsunitstaticresultallocationcpp","text":"","title":"Rules/Tests/Unit/StaticResultAllocation.cpp"},{"location":"Api/Files/_static_result_allocation_8cpp/#functions","text":"Name TEST (RuleSetTestSuite , ResultTranslatedTo )","title":"Functions"},{"location":"Api/Files/_static_result_allocation_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Files/_static_result_allocation_8cpp/#function-test","text":"TEST( RuleSetTestSuite , ResultTranslatedTo )","title":"function TEST"},{"location":"Api/Files/_static_result_allocation_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Generators/DefaultProfileGenerator.hpp\" #include \"Rules/Factory.hpp\" #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" #include \"Llvm/Llvm.hpp\" #include <functional> using namespace microsoft::quantum; namespace { using IrManipulationTestHelperPtr = std::shared_ptr<IrManipulationTestHelper>; IrManipulationTestHelperPtr newIrManip(std::string const& script) { IrManipulationTestHelperPtr ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareOpaque(\"Result\"); ir_manip->declareFunction(\"%Qubit* @__non_standard_allocator()\"); ir_manip->declareFunction(\"i8* @__non_standard_int_allocator()\"); ir_manip->declareFunction(\"%Result* @__quantum__qis__m__body(%Qubit*)\"); if (!ir_manip->fromBodyString(script)) { llvm::outs() << ir_manip->getErrorMessage() << \"\\n\"; exit(-1); } return ir_manip; } } // namespace // Single allocation with action and then release TEST(RuleSetTestSuite, ResultTranslatedTo) { auto ir_manip = newIrManip(R\"script( %result1 = call %Result* @__quantum__qis__m__body(%Qubit* null) %result2 = call %Result* @__quantum__qis__m__body(%Qubit* null) %result3 = call %Result* @__quantum__qis__m__body(%Qubit* null) %result4 = call %Result* @__quantum__qis__m__body(%Qubit* null) %result5 = call %Result* @__quantum__qis__m__body(%Qubit* null) )script\"); auto configure_profile = [](RuleSet& rule_set) { auto factory = RuleFactory(rule_set, BasicAllocationManager::createNew(), BasicAllocationManager::createNew()); factory.useStaticResultAllocation(); }; auto profile = std::make_shared<DefaultProfileGenerator>( std::move(configure_profile), TransformationRulesPassConfiguration::createDisabled(), LlvmPassesConfiguration::createDisabled()); ir_manip->applyProfile(profile); EXPECT_TRUE(ir_manip->hasInstructionSequence({ \"%result1 = inttoptr i64 0 to %Result*\", \"call void @__quantum__qis__mz__body(%Qubit* null, %Result* %result1)\", \"%result2 = inttoptr i64 1 to %Result*\", \"call void @__quantum__qis__mz__body(%Qubit* null, %Result* %result2)\", \"%result3 = inttoptr i64 2 to %Result*\", \"call void @__quantum__qis__mz__body(%Qubit* null, %Result* %result3)\", \"%result4 = inttoptr i64 3 to %Result*\", \"call void @__quantum__qis__mz__body(%Qubit* null, %Result* %result4)\", \"%result5 = inttoptr i64 4 to %Result*\", \"call void @__quantum__qis__mz__body(%Qubit* null, %Result* %result5)\", })); EXPECT_FALSE( ir_manip->hasInstructionSequence({ \"%result1 = call %Result* @__quantum__qis__m__body(%Qubit* null)\", }) || ir_manip->hasInstructionSequence({ \"%result1 = tail call %Result* @__quantum__qis__m__body(%Qubit* null)\", })); EXPECT_FALSE( ir_manip->hasInstructionSequence({ \"%result2 = call %Result* @__quantum__qis__m__body(%Qubit* null)\", }) || ir_manip->hasInstructionSequence({ \"%result2 = tail call %Result* @__quantum__qis__m__body(%Qubit* null)\", })); EXPECT_FALSE( ir_manip->hasInstructionSequence({ \"%result3 = call %Result* @__quantum__qis__m__body(%Qubit* null)\", }) || ir_manip->hasInstructionSequence({ \"%result3 = tail call %Result* @__quantum__qis__m__body(%Qubit* null)\", })); EXPECT_FALSE( ir_manip->hasInstructionSequence({ \"%result4 = call %Result* @__quantum__qis__m__body(%Qubit* null)\", }) || ir_manip->hasInstructionSequence({ \"%result4 = tail call %Result* @__quantum__qis__m__body(%Qubit* null)\", })); EXPECT_FALSE( ir_manip->hasInstructionSequence({ \"%result5 = call %Result* @__quantum__qis__m__body(%Qubit* null)\", }) || ir_manip->hasInstructionSequence({ \"%result5 = tail call %Result* @__quantum__qis__m__body(%Qubit* null)\", })); } Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_store_8cpp/","text":"Rules/Notation/Store.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr store(IOperandPrototypePtr const& target, IOperandPrototypePtr const& value) { auto ret = std::make_shared<StorePattern>(); ret->addChild(target); ret->addChild(value); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Notation/Store.cpp"},{"location":"Api/Files/_store_8cpp/#rulesnotationstorecpp","text":"","title":"Rules/Notation/Store.cpp"},{"location":"Api/Files/_store_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_store_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr store(IOperandPrototypePtr const& target, IOperandPrototypePtr const& value) { auto ret = std::make_shared<StorePattern>(); ret->addChild(target); ret->addChild(value); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_switch_8cpp/","text":"Rules/Notation/Switch.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr switchOp( IOperandPrototypePtr const& /*cond*/, IOperandPrototypePtr const& /*arg1*/, IOperandPrototypePtr const& /*arg2*/) { auto switch_pattern = std::make_shared<SwitchPattern>(); // TODO(issue-17): finish switch pattern // switch_pattern->addChild(cond); // switch_pattern->addChild(arg1); // switch_pattern->addChild(arg2); return static_cast<IOperandPrototypePtr>(switch_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Notation/Switch.cpp"},{"location":"Api/Files/_switch_8cpp/#rulesnotationswitchcpp","text":"","title":"Rules/Notation/Switch.cpp"},{"location":"Api/Files/_switch_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_switch_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/AnyPattern.hpp\" #include \"Rules/Patterns/CallPattern.hpp\" #include \"Rules/Patterns/Instruction.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr switchOp( IOperandPrototypePtr const& /*cond*/, IOperandPrototypePtr const& /*arg1*/, IOperandPrototypePtr const& /*arg2*/) { auto switch_pattern = std::make_shared<SwitchPattern>(); // TODO(issue-17): finish switch pattern // switch_pattern->addChild(cond); // switch_pattern->addChild(arg1); // switch_pattern->addChild(arg2); return static_cast<IOperandPrototypePtr>(switch_pattern); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_test_tools_2_tests_2_unit_2main_8cpp/","text":"TestTools/Tests/Unit/main.cpp Functions Name TEST (TestToolsTestSuite , IrParitalConstruction ) TEST (TestToolsTestSuite , IrFullConstruction ) TEST (TestToolsTestSuite , ErrorOutput ) TEST (TestToolsTestSuite , BrokenIRFunctions ) Functions Documentation function TEST TEST( TestToolsTestSuite , IrParitalConstruction ) function TEST TEST( TestToolsTestSuite , IrFullConstruction ) function TEST TEST( TestToolsTestSuite , ErrorOutput ) function TEST TEST( TestToolsTestSuite , BrokenIRFunctions ) Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" using namespace microsoft::quantum; TEST(TestToolsTestSuite, IrParitalConstruction) { IrManipulationTestHelper input; input.declareOpaque(\"Qubit\"); input.declareOpaque(\"Result\"); input.declareFunction(\"i1 @__quantum__rt__result_equal(%Result*, %Result*)\"); input.declareFunction(\"%Qubit* @__quantum__rt__qubit_allocate()\"); input.declareFunction(\"void @__quantum__rt__qubit_release(%Qubit*)\"); input.declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); input.declareFunction(\"%Result* @__quantum__rt__result_get_zero()\"); input.declareFunction(\"void @__quantum__qis__mz__body(%Qubit*, %Result*)\"); input.fromBodyString(R\"script( %leftMessage = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %leftMessage) call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) %0 = call %Result* @__quantum__rt__result_get_zero() %1 = call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 3 to %Result*), %Result* %0) ret i8 0 )script\"); if (input.isModuleBroken()) { llvm::outs() << input.getErrorMessage() << \"\\n\"; exit(-1); } EXPECT_TRUE(input.hasInstructionSequence({})); EXPECT_TRUE(input.hasInstructionSequence( {\"call void @__quantum__qis__h__body(%Qubit* %leftMessage)\", \"%0 = call %Result* @__quantum__rt__result_get_zero()\"})); EXPECT_TRUE(input.hasInstructionSequence( {\"%0 = call %Result* @__quantum__rt__result_get_zero()\", \"%1 = call i1 @__quantum__rt__result_equal(%Result* nonnull \" \"inttoptr (i64 3 to %Result*), %Result* %0)\"})); EXPECT_FALSE(input.hasInstructionSequence( {\"%0 = call %Result* @__quantum__rt__result_get_zero()\", \"call void @__quantum__qis__h__body(%Qubit* %leftMessage)\"})); EXPECT_FALSE(input.hasInstructionSequence({\"%0 = call %Result* @non_existant_function()\"})); EXPECT_FALSE(input.hasInstructionSequence({\"\"})); } TEST(TestToolsTestSuite, IrFullConstruction) { IrManipulationTestHelper input; input.fromString(R\"script( ; ModuleID = 'IrManipulationTestHelper' source_filename = \"IrManipulationTestHelper.ll\" %Qubit = type opaque %Result = type opaque define i8 @Main() local_unnamed_addr { entry: %leftMessage = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %leftMessage) call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) %0 = call %Result* @__quantum__rt__result_get_zero() %1 = call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 3 to %Result*), %Result* %0) ret i8 0 } declare void @__quantum__qis__mz__body(%Qubit*, %Result*) local_unnamed_addr declare %Result* @__quantum__rt__result_get_zero() local_unnamed_addr declare void @__quantum__qis__h__body(%Qubit*) local_unnamed_addr declare void @__quantum__rt__qubit_release(%Qubit*) local_unnamed_addr declare %Qubit* @__quantum__rt__qubit_allocate() local_unnamed_addr declare i1 @__quantum__rt__result_equal(%Result*, %Result*) local_unnamed_addr )script\"); EXPECT_TRUE(input.hasInstructionSequence({})); EXPECT_TRUE(input.hasInstructionSequence( {\"call void @__quantum__qis__h__body(%Qubit* %leftMessage)\", \"%0 = call %Result* @__quantum__rt__result_get_zero()\"})); EXPECT_TRUE(input.hasInstructionSequence( {\"%0 = call %Result* @__quantum__rt__result_get_zero()\", \"%1 = call i1 @__quantum__rt__result_equal(%Result* nonnull \" \"inttoptr (i64 3 to %Result*), %Result* %0)\"})); EXPECT_FALSE(input.hasInstructionSequence( {\"%0 = call %Result* @__quantum__rt__result_get_zero()\", \"call void @__quantum__qis__h__body(%Qubit* %leftMessage)\"})); EXPECT_FALSE(input.hasInstructionSequence({\"%0 = call %Result* @non_existant_function()\"})); EXPECT_FALSE(input.hasInstructionSequence({\"\"})); } TEST(TestToolsTestSuite, ErrorOutput) { IrManipulationTestHelper input; input.fromString(R\"script( ; ModuleID = 'IrManipulationTestHelper' source_filename = \"IrManipulationTestHelper.ll\" define i8 @Main() local_unnamed_addr { entry: %0 = call i1 @__call_to_unkown() ret i8 0 } )script\"); EXPECT_TRUE(input.isModuleBroken()); EXPECT_TRUE( input.getErrorMessage().find(\"Error at 7:15: use of undefined value '@__call_to_unkown'\") != std::string::npos); } TEST(TestToolsTestSuite, BrokenIRFunctions) { using Strings = IrManipulationTestHelper::Strings; { IrManipulationTestHelper input; input.fromString(R\"script( ; ModuleID = 'IrManipulationTestHelper' source_filename = \"IrManipulationTestHelper.ll\" %Qubit = type opaque %Result = type opaque define i8 @Main2() local_unnamed_addr { entry: %leftMessage = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %leftMessage) call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) %0 = call %Result* @__quantum__rt__result_get_zero() %1 = call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 3 to %Result*), %Result* %0) ret i8 0 } declare void @__quantum__qis__mz__body(%Qubit*, %Result*) local_unnamed_addr declare %Result* @__quantum__rt__result_get_zero() local_unnamed_addr declare void @__quantum__qis__h__body(%Qubit*) local_unnamed_addr declare void @__quantum__rt__qubit_release(%Qubit*) local_unnamed_addr declare %Qubit* @__quantum__rt__qubit_allocate() local_unnamed_addr declare i1 @__quantum__rt__result_equal(%Result*, %Result*) local_unnamed_addr )script\"); EXPECT_EQ(input.toBodyInstructions(), Strings({})); } { IrManipulationTestHelper input; input.fromString(R\"script( ; ModuleID = 'IrManipulationTestHelper' source_filename = \"IrManipulationTestHelper.ll\" %Qubit = type opaque %Result = type opaque define i8 @Main() local_unnamed_addr { entry2: %leftMessage = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %leftMessage) call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) %0 = call %Result* @__quantum__rt__result_get_zero() %1 = call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 3 to %Result*), %Result* %0) ret i8 0 } declare void @__quantum__qis__mz__body(%Qubit*, %Result*) local_unnamed_addr declare %Result* @__quantum__rt__result_get_zero() local_unnamed_addr declare void @__quantum__qis__h__body(%Qubit*) local_unnamed_addr declare void @__quantum__rt__qubit_release(%Qubit*) local_unnamed_addr declare %Qubit* @__quantum__rt__qubit_allocate() local_unnamed_addr declare i1 @__quantum__rt__result_equal(%Result*, %Result*) local_unnamed_addr )script\"); EXPECT_EQ(input.toBodyInstructions(), Strings({})); } { IrManipulationTestHelper input; input.fromString(R\"script( ; ModuleID = 'IrManipulationTestHelper' source_filename = \"IrManipulationTestHelper.ll\" %Qubit = type opaque %Result = type opaque define i8 @Main() local_unnamed_addr { entry2: %leftMessage = call %Qubit* @__quantum__rt__qubit_allocate() call void @__unknown_function(%Qubit* %leftMessage) call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) %0 = call %Result* @__quantum__rt__result_get_zero() %1 = call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 3 to %Result*), %Result* %0) ret i8 0 } declare void @__quantum__qis__mz__body(%Qubit*, %Result*) local_unnamed_addr declare %Result* @__quantum__rt__result_get_zero() local_unnamed_addr declare void @__quantum__qis__h__body(%Qubit*) local_unnamed_addr declare void @__quantum__rt__qubit_release(%Qubit*) local_unnamed_addr declare %Qubit* @__quantum__rt__qubit_allocate() local_unnamed_addr declare i1 @__quantum__rt__result_equal(%Result*, %Result*) local_unnamed_addr )script\"); EXPECT_EQ(input.toBodyInstructions(), Strings({})); } } Updated on 22 November 2021 at 10:28:34 UTC","title":"TestTools/Tests/Unit/main.cpp"},{"location":"Api/Files/_test_tools_2_tests_2_unit_2main_8cpp/#testtoolstestsunitmaincpp","text":"","title":"TestTools/Tests/Unit/main.cpp"},{"location":"Api/Files/_test_tools_2_tests_2_unit_2main_8cpp/#functions","text":"Name TEST (TestToolsTestSuite , IrParitalConstruction ) TEST (TestToolsTestSuite , IrFullConstruction ) TEST (TestToolsTestSuite , ErrorOutput ) TEST (TestToolsTestSuite , BrokenIRFunctions )","title":"Functions"},{"location":"Api/Files/_test_tools_2_tests_2_unit_2main_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Files/_test_tools_2_tests_2_unit_2main_8cpp/#function-test","text":"TEST( TestToolsTestSuite , IrParitalConstruction )","title":"function TEST"},{"location":"Api/Files/_test_tools_2_tests_2_unit_2main_8cpp/#function-test_1","text":"TEST( TestToolsTestSuite , IrFullConstruction )","title":"function TEST"},{"location":"Api/Files/_test_tools_2_tests_2_unit_2main_8cpp/#function-test_2","text":"TEST( TestToolsTestSuite , ErrorOutput )","title":"function TEST"},{"location":"Api/Files/_test_tools_2_tests_2_unit_2main_8cpp/#function-test_3","text":"TEST( TestToolsTestSuite , BrokenIRFunctions )","title":"function TEST"},{"location":"Api/Files/_test_tools_2_tests_2_unit_2main_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"TestTools/IrManipulationTestHelper.hpp\" #include \"gtest/gtest.h\" using namespace microsoft::quantum; TEST(TestToolsTestSuite, IrParitalConstruction) { IrManipulationTestHelper input; input.declareOpaque(\"Qubit\"); input.declareOpaque(\"Result\"); input.declareFunction(\"i1 @__quantum__rt__result_equal(%Result*, %Result*)\"); input.declareFunction(\"%Qubit* @__quantum__rt__qubit_allocate()\"); input.declareFunction(\"void @__quantum__rt__qubit_release(%Qubit*)\"); input.declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); input.declareFunction(\"%Result* @__quantum__rt__result_get_zero()\"); input.declareFunction(\"void @__quantum__qis__mz__body(%Qubit*, %Result*)\"); input.fromBodyString(R\"script( %leftMessage = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %leftMessage) call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) %0 = call %Result* @__quantum__rt__result_get_zero() %1 = call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 3 to %Result*), %Result* %0) ret i8 0 )script\"); if (input.isModuleBroken()) { llvm::outs() << input.getErrorMessage() << \"\\n\"; exit(-1); } EXPECT_TRUE(input.hasInstructionSequence({})); EXPECT_TRUE(input.hasInstructionSequence( {\"call void @__quantum__qis__h__body(%Qubit* %leftMessage)\", \"%0 = call %Result* @__quantum__rt__result_get_zero()\"})); EXPECT_TRUE(input.hasInstructionSequence( {\"%0 = call %Result* @__quantum__rt__result_get_zero()\", \"%1 = call i1 @__quantum__rt__result_equal(%Result* nonnull \" \"inttoptr (i64 3 to %Result*), %Result* %0)\"})); EXPECT_FALSE(input.hasInstructionSequence( {\"%0 = call %Result* @__quantum__rt__result_get_zero()\", \"call void @__quantum__qis__h__body(%Qubit* %leftMessage)\"})); EXPECT_FALSE(input.hasInstructionSequence({\"%0 = call %Result* @non_existant_function()\"})); EXPECT_FALSE(input.hasInstructionSequence({\"\"})); } TEST(TestToolsTestSuite, IrFullConstruction) { IrManipulationTestHelper input; input.fromString(R\"script( ; ModuleID = 'IrManipulationTestHelper' source_filename = \"IrManipulationTestHelper.ll\" %Qubit = type opaque %Result = type opaque define i8 @Main() local_unnamed_addr { entry: %leftMessage = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %leftMessage) call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) %0 = call %Result* @__quantum__rt__result_get_zero() %1 = call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 3 to %Result*), %Result* %0) ret i8 0 } declare void @__quantum__qis__mz__body(%Qubit*, %Result*) local_unnamed_addr declare %Result* @__quantum__rt__result_get_zero() local_unnamed_addr declare void @__quantum__qis__h__body(%Qubit*) local_unnamed_addr declare void @__quantum__rt__qubit_release(%Qubit*) local_unnamed_addr declare %Qubit* @__quantum__rt__qubit_allocate() local_unnamed_addr declare i1 @__quantum__rt__result_equal(%Result*, %Result*) local_unnamed_addr )script\"); EXPECT_TRUE(input.hasInstructionSequence({})); EXPECT_TRUE(input.hasInstructionSequence( {\"call void @__quantum__qis__h__body(%Qubit* %leftMessage)\", \"%0 = call %Result* @__quantum__rt__result_get_zero()\"})); EXPECT_TRUE(input.hasInstructionSequence( {\"%0 = call %Result* @__quantum__rt__result_get_zero()\", \"%1 = call i1 @__quantum__rt__result_equal(%Result* nonnull \" \"inttoptr (i64 3 to %Result*), %Result* %0)\"})); EXPECT_FALSE(input.hasInstructionSequence( {\"%0 = call %Result* @__quantum__rt__result_get_zero()\", \"call void @__quantum__qis__h__body(%Qubit* %leftMessage)\"})); EXPECT_FALSE(input.hasInstructionSequence({\"%0 = call %Result* @non_existant_function()\"})); EXPECT_FALSE(input.hasInstructionSequence({\"\"})); } TEST(TestToolsTestSuite, ErrorOutput) { IrManipulationTestHelper input; input.fromString(R\"script( ; ModuleID = 'IrManipulationTestHelper' source_filename = \"IrManipulationTestHelper.ll\" define i8 @Main() local_unnamed_addr { entry: %0 = call i1 @__call_to_unkown() ret i8 0 } )script\"); EXPECT_TRUE(input.isModuleBroken()); EXPECT_TRUE( input.getErrorMessage().find(\"Error at 7:15: use of undefined value '@__call_to_unkown'\") != std::string::npos); } TEST(TestToolsTestSuite, BrokenIRFunctions) { using Strings = IrManipulationTestHelper::Strings; { IrManipulationTestHelper input; input.fromString(R\"script( ; ModuleID = 'IrManipulationTestHelper' source_filename = \"IrManipulationTestHelper.ll\" %Qubit = type opaque %Result = type opaque define i8 @Main2() local_unnamed_addr { entry: %leftMessage = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %leftMessage) call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) %0 = call %Result* @__quantum__rt__result_get_zero() %1 = call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 3 to %Result*), %Result* %0) ret i8 0 } declare void @__quantum__qis__mz__body(%Qubit*, %Result*) local_unnamed_addr declare %Result* @__quantum__rt__result_get_zero() local_unnamed_addr declare void @__quantum__qis__h__body(%Qubit*) local_unnamed_addr declare void @__quantum__rt__qubit_release(%Qubit*) local_unnamed_addr declare %Qubit* @__quantum__rt__qubit_allocate() local_unnamed_addr declare i1 @__quantum__rt__result_equal(%Result*, %Result*) local_unnamed_addr )script\"); EXPECT_EQ(input.toBodyInstructions(), Strings({})); } { IrManipulationTestHelper input; input.fromString(R\"script( ; ModuleID = 'IrManipulationTestHelper' source_filename = \"IrManipulationTestHelper.ll\" %Qubit = type opaque %Result = type opaque define i8 @Main() local_unnamed_addr { entry2: %leftMessage = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %leftMessage) call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) %0 = call %Result* @__quantum__rt__result_get_zero() %1 = call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 3 to %Result*), %Result* %0) ret i8 0 } declare void @__quantum__qis__mz__body(%Qubit*, %Result*) local_unnamed_addr declare %Result* @__quantum__rt__result_get_zero() local_unnamed_addr declare void @__quantum__qis__h__body(%Qubit*) local_unnamed_addr declare void @__quantum__rt__qubit_release(%Qubit*) local_unnamed_addr declare %Qubit* @__quantum__rt__qubit_allocate() local_unnamed_addr declare i1 @__quantum__rt__result_equal(%Result*, %Result*) local_unnamed_addr )script\"); EXPECT_EQ(input.toBodyInstructions(), Strings({})); } { IrManipulationTestHelper input; input.fromString(R\"script( ; ModuleID = 'IrManipulationTestHelper' source_filename = \"IrManipulationTestHelper.ll\" %Qubit = type opaque %Result = type opaque define i8 @Main() local_unnamed_addr { entry2: %leftMessage = call %Qubit* @__quantum__rt__qubit_allocate() call void @__unknown_function(%Qubit* %leftMessage) call void @__quantum__rt__qubit_release(%Qubit* %leftMessage) %0 = call %Result* @__quantum__rt__result_get_zero() %1 = call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 3 to %Result*), %Result* %0) ret i8 0 } declare void @__quantum__qis__mz__body(%Qubit*, %Result*) local_unnamed_addr declare %Result* @__quantum__rt__result_get_zero() local_unnamed_addr declare void @__quantum__qis__h__body(%Qubit*) local_unnamed_addr declare void @__quantum__rt__qubit_release(%Qubit*) local_unnamed_addr declare %Qubit* @__quantum__rt__qubit_allocate() local_unnamed_addr declare i1 @__quantum__rt__result_equal(%Result*, %Result*) local_unnamed_addr )script\"); EXPECT_EQ(input.toBodyInstructions(), Strings({})); } } Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_transformation_rules_pass_8cpp/","text":"TransformationRulesPass/TransformationRulesPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Factory.hpp\" #include \"Rules/Notation/Notation.hpp\" #include \"Rules/ReplacementRule.hpp\" #include \"TransformationRulesPass/TransformationRulesPass.hpp\" #include \"Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft { namespace quantum { TransformationRulesPass::TransformationRulesPass( RuleSet&& rule_set, TransformationRulesPassConfiguration const& config, Profile* profile) : rule_set_{std::move(rule_set)} , config_{config} , profile_{profile} { } void TransformationRulesPass::setupCopyAndExpand() { using namespace microsoft::quantum::notation; addConstExprRule( {branch(\"cond\"_cap = constInt(), \"if_false\"_cap = _, \"if_true\"_cap = _), [](Builder& builder, Value* val, Captures& captures, Replacements& replacements) { auto cst = llvm::dyn_cast<llvm::ConstantInt>(captures[\"cond\"]); auto instr = llvm::dyn_cast<llvm::Instruction>(val); if (cst == nullptr || instr == nullptr) { return false; } auto type = instr->getType(); if (type == nullptr) { return false; } auto branch_cond = cst->getValue().getZExtValue(); if (branch_cond) { auto if_true = llvm::dyn_cast<llvm::BasicBlock>(captures[\"if_true\"]); builder.CreateBr(if_true); instr->replaceAllUsesWith(llvm::UndefValue::get(type)); } else { auto if_false = llvm::dyn_cast<llvm::BasicBlock>(captures[\"if_false\"]); builder.CreateBr(if_false); instr->replaceAllUsesWith(llvm::UndefValue::get(type)); } replacements.push_back({val, nullptr}); return true; }}); if (config_.assumeNoExceptions()) { // Replacing all invokes with calls addConstExprRule({unnamedInvoke(), [](Builder& builder, Value* val, Captures&, Replacements& replacements) { auto invoke = llvm::dyn_cast<llvm::InvokeInst>(val); if (invoke == nullptr) { return false; } auto callee_function = invoke->getCalledFunction(); // List with new call arguments std::vector<llvm::Value*> new_arguments; for (unsigned i = 0; i < invoke->getNumArgOperands(); ++i) { // Getting the i'th argument llvm::Value* arg = invoke->getArgOperand(i); new_arguments.push_back(arg); } // Creating a new call auto* new_call = builder.CreateCall(callee_function, new_arguments); builder.CreateBr(invoke->getNormalDest()); new_call->takeName(invoke); // Replace all calls to old function with calls to new function invoke->replaceAllUsesWith(new_call); replacements.push_back({invoke, nullptr}); return true; }}); } } void TransformationRulesPass::addConstExprRule(ReplacementRule&& rule) { auto ret = std::make_shared<ReplacementRule>(std::move(rule)); const_expr_replacements_.addRule(ret); } void TransformationRulesPass::constantFoldFunction(llvm::Function& fnc) { std::vector<llvm::Instruction*> to_delete; // Folding all constants for (auto& basic_block : fnc) { for (auto& instr : basic_block) { auto module = instr.getModule(); auto const& dl = module->getDataLayout(); auto cst = llvm::ConstantFoldInstruction(&instr, dl, nullptr); if (cst != nullptr) { instr.replaceAllUsesWith(cst); to_delete.push_back(&instr); } } } // Deleting constants for (auto& x : to_delete) { x->eraseFromParent(); } // Folding constant expressions Replacements replacements; for (auto& basic_block : fnc) { for (auto& instr : basic_block) { const_expr_replacements_.matchAndReplace(&instr, replacements); } } for (auto& r : replacements) { if (r.second != nullptr) { throw std::runtime_error(\"Real replacements not implemented.\"); } auto instr = llvm::dyn_cast<llvm::Instruction>(r.first); if (instr != nullptr) { instr->eraseFromParent(); continue; } auto block = llvm::dyn_cast<llvm::BasicBlock>(r.first); if (block != nullptr) { llvm::DeleteDeadBlock(block); } } } llvm::Value* TransformationRulesPass::copyAndExpand( llvm::Value* input, DeletableInstructions& schedule_instruction_deletion) { llvm::Value* ret = input; auto* call_instr = llvm::dyn_cast<llvm::CallInst>(input); auto instr_ptr = llvm::dyn_cast<llvm::Instruction>(input); if (call_instr != nullptr && instr_ptr != nullptr) { auto& instr = *instr_ptr; auto callee_function = call_instr->getCalledFunction(); if (callee_function != nullptr && !callee_function->isDeclaration()) { ConstantArguments argument_constants{}; std::vector<uint32_t> remaining_arguments{}; uint32_t idx = 0; auto n = static_cast<uint32_t>(callee_function->arg_size()); // Finding argument constants while (idx < n) { auto arg = callee_function->getArg(idx); auto value = call_instr->getArgOperand(idx); auto cst = llvm::dyn_cast<llvm::ConstantInt>(value); if (cst != nullptr) { argument_constants[arg->getName().str()] = cst; } else { remaining_arguments.push_back(idx); } ++idx; } // Making a function copy auto new_callee = expandFunctionCall(*callee_function, argument_constants); // Replacing call if a new function was created if (new_callee != nullptr) { llvm::IRBuilder<> builder(call_instr); // List with new call arguments std::vector<llvm::Value*> new_arguments; for (auto const& i : remaining_arguments) { // Getting the i'th argument llvm::Value* arg = call_instr->getArgOperand(i); // Adding arguments that were not constant if (argument_constants.find(arg->getName().str()) == argument_constants.end()) { new_arguments.push_back(arg); } } // Creating a new call auto* new_call = builder.CreateCall(new_callee, new_arguments); new_call->takeName(call_instr); new_call->setTailCall(call_instr->isTailCall()); new_call->setTailCallKind(call_instr->getTailCallKind()); if (call_instr->canReturnTwice()) { new_call->setCanReturnTwice(); } new_call->setCallingConv(call_instr->getCallingConv()); new_call->setAttributes(call_instr->getAttributes()); // Replace all calls to old function with calls to new function instr.replaceAllUsesWith(new_call); // Deleting instruction schedule_instruction_deletion.push_back(&instr); // Folding constants in the new function as we may have replaced some of // the arguments with constants constantFoldFunction(*new_callee); // Recursion: Returning the new call as the instruction to be analysed ret = new_call; } // Deleting the function the original function if it is no longer in use if (callee_function->use_empty()) { callee_function->eraseFromParent(); } } } return ret; } llvm::Value* TransformationRulesPass::detectActiveCode(llvm::Value* input, DeletableInstructions&) { active_pieces_.insert(input); return input; } bool TransformationRulesPass::runOnFunction(llvm::Function& function, InstructionModifier const& modifier) { if (function.isDeclaration()) { return false; } if (depth_ >= config_.maxRecursion()) { llvm::outs() << \"Exceed max recursion of \" << config_.maxRecursion() << \"\\n\"; return false; } ++depth_; // Keep track of instructions scheduled for deletion DeletableInstructions schedule_instruction_deletion; // Block queue std::deque<llvm::BasicBlock*> queue; std::unordered_set<llvm::BasicBlock*> blocks_queued; queue.push_back(&function.getEntryBlock()); blocks_queued.insert(&function.getEntryBlock()); // Executing the modifier on the function itsel modifier(&function, schedule_instruction_deletion); while (!queue.empty()) { auto& basic_block = *(queue.front()); queue.pop_front(); // Executing the modifier on the block modifier(&basic_block, schedule_instruction_deletion); for (auto& instr : basic_block) { // Modifying instruction as needed auto instr_ptr = modifier(&instr, schedule_instruction_deletion); // In case the instruction was scheduled for deletion if (instr_ptr == nullptr) { continue; } // Checking if we are calling a function auto call_instr = llvm::dyn_cast<llvm::CallBase>(instr_ptr); if (call_instr != nullptr) { auto callee_function = call_instr->getCalledFunction(); if (callee_function != nullptr && !callee_function->isDeclaration()) { runOnFunction(*callee_function, modifier); } } // Following the branches to their basic blocks auto* br_instr = llvm::dyn_cast<llvm::BranchInst>(&instr); if (br_instr != nullptr) { for (uint32_t i = 0; i < br_instr->getNumOperands(); ++i) { // TODO(issue-19): This may not work on multi path branches (conditional) // as we may accidentally add the final path (contains qubit release) // and we cannot make assumptions since optimisation may have rearranged // everything. In this case, we should revert to the order they appear in the // function auto bb = llvm::dyn_cast<llvm::BasicBlock>(br_instr->getOperand(i)); if (bb != nullptr) { // Ensuring that we are not scheduling the same block twice if (blocks_queued.find(bb) == blocks_queued.end()) { queue.push_back(bb); blocks_queued.insert(bb); } } } continue; } // Follow the branches of auto* switch_instr = llvm::dyn_cast<llvm::SwitchInst>(&instr); if (switch_instr != nullptr) { for (uint64_t i = 0; i < switch_instr->getNumSuccessors(); ++i) { auto bb = switch_instr->getSuccessor(static_cast<uint32_t>(i)); // Ensuring that we are not scheduling the same block twice if (blocks_queued.find(bb) == blocks_queued.end()) { queue.push_back(bb); blocks_queued.insert(bb); } } continue; } // Checking if this is an invoke call auto* invoke_inst = llvm::dyn_cast<llvm::InvokeInst>(&instr); if (invoke_inst != nullptr) { // Checking that configuration is correct if (!config_.assumeNoExceptions()) { // TODO(issue-20): Unify error reporting throw std::runtime_error(\"Exceptions paths cannot be handled at compile time. Either disable \" \"transform-execution-path-only or add assumption assume-no-except\"); } // Adding the block which is the on the \"no except\" path auto bb = invoke_inst->getNormalDest(); if (blocks_queued.find(bb) == blocks_queued.end()) { queue.push_back(bb); blocks_queued.insert(bb); } } } } // Deleting constants for (auto& x : schedule_instruction_deletion) { x->eraseFromParent(); } --depth_; return true; } bool TransformationRulesPass::isActive(llvm::Value* value) const { return active_pieces_.find(value) != active_pieces_.end(); } void TransformationRulesPass::runCopyAndExpand(llvm::Module& module, llvm::ModuleAnalysisManager&) { replacements_.clear(); // For every instruction in every block, we attempt a match // and replace. for (auto& function : module) { if (function.hasFnAttribute(config_.entryPointAttr())) { runOnFunction(function, [this](llvm::Value* value, DeletableInstructions& modifier) { return copyAndExpand(value, modifier); }); } } // Active code detection for (auto& global : module.globals()) { active_pieces_.insert(&global); for (auto& op : global.operands()) { active_pieces_.insert(op); } } for (auto& function : module) { bool is_active = false; // Checking if the function is referenced by a global variable for (auto user : function.users()) { // If the user is active, then it should be expected that the function is also active if (isActive(user)) { is_active = true; break; } } if (is_active || function.hasFnAttribute(config_.entryPointAttr())) { // Marking function as active active_pieces_.insert(&function); // Detecting active code runOnFunction(function, [this](llvm::Value* value, DeletableInstructions& modifier) { return detectActiveCode(value, modifier); }); } } processReplacements(); } void TransformationRulesPass::processReplacements() { // Applying all replacements std::unordered_set<llvm::Value*> already_removed; for (auto it = replacements_.rbegin(); it != replacements_.rend(); ++it) { auto instr1 = llvm::dyn_cast<llvm::Instruction>(it->first); if (instr1 == nullptr) { llvm::outs() << \"; WARNING: cannot deal with non-instruction replacements\\n\"; continue; } // Checking if by accident the same instruction was added if (already_removed.find(instr1) != already_removed.end()) { throw std::runtime_error(\"Instruction was already removed.\"); } already_removed.insert(instr1); // Cheking if have a replacement for the instruction if (it->second != nullptr) { // ... if so, we just replace it, auto instr2 = llvm::dyn_cast<llvm::Instruction>(it->second); if (instr2 == nullptr) { llvm::outs() << \"; WARNING: cannot replace instruction with non-instruction\\n\"; continue; } llvm::ReplaceInstWithInst(instr1, instr2); } else { // ... otherwise we delete the the instruction // Removing all uses if (!instr1->use_empty()) { auto type = instr1->getType(); if (type != nullptr) { instr1->replaceAllUsesWith(llvm::UndefValue::get(type)); } } // And finally we delete the instruction. The if statement // is first and foremost a precaution which prevents the program // from seg-faulting in the unlikely case that instr1->getType() is null. if (instr1->use_empty()) { instr1->eraseFromParent(); } } } replacements_.clear(); } void TransformationRulesPass::runDetectActiveCode(llvm::Module& module, llvm::ModuleAnalysisManager&) { blocks_to_delete_.clear(); functions_to_delete_.clear(); for (auto& function : module) { if (isActive(&function)) { for (auto& block : function) { if (!isActive(&block)) { blocks_to_delete_.push_back(&block); } } } else if (!function.isDeclaration()) { functions_to_delete_.push_back(&function); } } } void TransformationRulesPass::runDeleteDeadCode(llvm::Module&, llvm::ModuleAnalysisManager&) { // Removing all function references and scheduling blocks for deletion for (auto& function : functions_to_delete_) { // Schedule for deletion function->replaceAllUsesWith(llvm::UndefValue::get(function->getType())); function->clearGC(); function->clearMetadata(); // Deleteing blocks in reverse order std::vector<llvm::BasicBlock*> blocks; for (auto& block : *function) { blocks.push_back(&block); } // Removing backwards to avoid segfault for (auto it = blocks.rbegin(); it != blocks.rend(); ++it) { auto& block = **it; // Deleting instructions in reverse order (needed because it is a DAG structure) std::vector<llvm::Instruction*> instructions; for (auto& instr : block) { instructions.push_back(&instr); } // Removing all instructions for (auto it2 = instructions.rbegin(); it2 != instructions.rend(); ++it2) { auto& instr = **it2; instr.replaceAllUsesWith(llvm::UndefValue::get(instr.getType())); instr.eraseFromParent(); } // Removing all block references block.replaceAllUsesWith(llvm::UndefValue::get(block.getType())); // Scheduling block deletion blocks_to_delete_.push_back(&block); } } // Deleting all blocks for (auto block : blocks_to_delete_) { if (block->use_empty()) { block->eraseFromParent(); } else { llvm::errs() << \"; INTERNAL ERROR: block was supposed to be unused.\\n\"; for (auto& x : block->uses()) { llvm::errs() << \" -x \" << *x << \"\\n\"; } for (auto x : block->users()) { llvm::errs() << \" -: \" << *x << \"\\n\"; } llvm::errs() << \" ----- \\n\"; llvm::errs() << *block << \"\\n\"; } } // Removing functions for (auto& function : functions_to_delete_) { if (function->isDeclaration() && function->use_empty()) { function->eraseFromParent(); } } } void TransformationRulesPass::runReplacePhi(llvm::Module& module, llvm::ModuleAnalysisManager&) { using namespace microsoft::quantum::notation; auto rule = phi(\"b1\"_cap = _, \"b2\"_cap = _); IOperandPrototype::Captures captures; std::vector<llvm::Instruction*> to_delete; std::unordered_map<llvm::Instruction*, llvm::Value*> replacements; for (auto& function : module) { for (auto& block : function) { std::vector<llvm::Instruction*> instrs; for (auto& instr : block) { if (rule->match(&instr, captures)) { auto phi = llvm::dyn_cast<llvm::PHINode>(&instr); if (phi == nullptr) { continue; } auto val1 = captures[\"b1\"]; auto val2 = captures[\"b2\"]; auto block1 = phi->getIncomingBlock(0); // TODO(issue-21): Make sure that block1 matches val1 auto block2 = phi->getIncomingBlock(1); if (!isActive(block1)) { val2->takeName(&instr); replacements[&instr] = val2; to_delete.push_back(&instr); } else if (!isActive(block2)) { val1->takeName(&instr); replacements[&instr] = val2; to_delete.push_back(&instr); } captures.clear(); } } } } for (auto& r : replacements) { r.first->replaceAllUsesWith(r.second); } for (auto& x : to_delete) { x->eraseFromParent(); } } void TransformationRulesPass::runApplyRules(llvm::Module& module, llvm::ModuleAnalysisManager&) { replacements_.clear(); std::unordered_set<llvm::Value*> already_visited; for (auto& function : module) { if (function.hasFnAttribute(config_.entryPointAttr())) { runOnFunction(function, [this, &already_visited](llvm::Value* value, DeletableInstructions&) { auto instr = llvm::dyn_cast<llvm::Instruction>(value); // Sanity check if (already_visited.find(value) != already_visited.end()) { throw std::runtime_error(\"Already visited\"); } already_visited.insert(value); // Checking if we should analyse if (instr != nullptr) { rule_set_.matchAndReplace(instr, replacements_); } return value; }); if (config_.shouldAnnotateQubitUse()) { std::stringstream ss{\"\"}; ss << profile_->getQubitAllocationManager()->maxAllocationsUsed(); function.addFnAttr(\"requiredQubits\", ss.str()); } if (config_.shouldAnnotateResultUse()) { std::stringstream ss{\"\"}; ss << profile_->getResultAllocationManager()->maxAllocationsUsed(); function.addFnAttr(\"requiredResults\", ss.str()); } } } processReplacements(); } llvm::PreservedAnalyses TransformationRulesPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& mam) { // In case the module is istructed to clone functions, if (config_.shouldCloneFunctions()) { setupCopyAndExpand(); runCopyAndExpand(module, mam); } // Deleting dead code if configured to do so. This process consists // of three steps: detecting dead code, removing phi nodes (and references) // and finally deleting the code. This implementation is aggressive in the sense // that any code that we cannot prove to be active is considered dead. if (config_.shouldDeleteDeadCode()) { runDetectActiveCode(module, mam); runReplacePhi(module, mam); runDeleteDeadCode(module, mam); } // Applying rule set if (config_.shouldTransformExecutionPathOnly()) { // We only apply transformation rules to code which is reachable // via the execution path. runApplyRules(module, mam); } else { // Otherwise we apply to all sections of the code. replacements_.clear(); for (auto& function : module) { for (auto& block : function) { for (auto& instr : block) { rule_set_.matchAndReplace(&instr, replacements_); } } } processReplacements(); } return llvm::PreservedAnalyses::none(); } llvm::Function* TransformationRulesPass::expandFunctionCall( llvm::Function& callee, ConstantArguments const& const_args) { auto module = callee.getParent(); auto& context = module->getContext(); llvm::IRBuilder<> builder(context); // Copying the original function llvm::ValueToValueMapTy remapper; std::vector<llvm::Type*> arg_types; // The user might be deleting arguments to the function by specifying them in // the VMap. If so, we need to not add the arguments to the arg ty vector // for (auto const& arg : callee.args()) { // Skipping constant arguments if (const_args.find(arg.getName().str()) != const_args.end()) { continue; } arg_types.push_back(arg.getType()); } // Creating a new function llvm::FunctionType* function_type = llvm::FunctionType::get( callee.getFunctionType()->getReturnType(), arg_types, callee.getFunctionType()->isVarArg()); auto function = llvm::Function::Create( function_type, callee.getLinkage(), callee.getAddressSpace(), callee.getName(), module); // Copying the non-const arguments auto dest_args_it = function->arg_begin(); for (auto const& arg : callee.args()) { auto const_it = const_args.find(arg.getName().str()); if (const_it == const_args.end()) { // Mapping remaining function arguments dest_args_it->setName(arg.getName()); remapper[&arg] = &*dest_args_it++; } else { remapper[&arg] = llvm::ConstantInt::get(context, const_it->second->getValue()); } } llvm::SmallVector<llvm::ReturnInst*, 8> returns; // Ignore returns cloned. // Note: In LLVM 13 upgrade 'true' to 'llvm::CloneFunctionChangeType::LocalChangesOnly' llvm::CloneFunctionInto(function, &callee, remapper, true, returns, \"\", nullptr); verifyFunction(*function); return function; } void TransformationRulesPass::setLogger(ILoggerPtr logger) { logger_ = std::move(logger); } bool TransformationRulesPass::isRequired() { return true; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"TransformationRulesPass/TransformationRulesPass.cpp"},{"location":"Api/Files/_transformation_rules_pass_8cpp/#transformationrulespasstransformationrulespasscpp","text":"","title":"TransformationRulesPass/TransformationRulesPass.cpp"},{"location":"Api/Files/_transformation_rules_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_transformation_rules_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Factory.hpp\" #include \"Rules/Notation/Notation.hpp\" #include \"Rules/ReplacementRule.hpp\" #include \"TransformationRulesPass/TransformationRulesPass.hpp\" #include \"Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft { namespace quantum { TransformationRulesPass::TransformationRulesPass( RuleSet&& rule_set, TransformationRulesPassConfiguration const& config, Profile* profile) : rule_set_{std::move(rule_set)} , config_{config} , profile_{profile} { } void TransformationRulesPass::setupCopyAndExpand() { using namespace microsoft::quantum::notation; addConstExprRule( {branch(\"cond\"_cap = constInt(), \"if_false\"_cap = _, \"if_true\"_cap = _), [](Builder& builder, Value* val, Captures& captures, Replacements& replacements) { auto cst = llvm::dyn_cast<llvm::ConstantInt>(captures[\"cond\"]); auto instr = llvm::dyn_cast<llvm::Instruction>(val); if (cst == nullptr || instr == nullptr) { return false; } auto type = instr->getType(); if (type == nullptr) { return false; } auto branch_cond = cst->getValue().getZExtValue(); if (branch_cond) { auto if_true = llvm::dyn_cast<llvm::BasicBlock>(captures[\"if_true\"]); builder.CreateBr(if_true); instr->replaceAllUsesWith(llvm::UndefValue::get(type)); } else { auto if_false = llvm::dyn_cast<llvm::BasicBlock>(captures[\"if_false\"]); builder.CreateBr(if_false); instr->replaceAllUsesWith(llvm::UndefValue::get(type)); } replacements.push_back({val, nullptr}); return true; }}); if (config_.assumeNoExceptions()) { // Replacing all invokes with calls addConstExprRule({unnamedInvoke(), [](Builder& builder, Value* val, Captures&, Replacements& replacements) { auto invoke = llvm::dyn_cast<llvm::InvokeInst>(val); if (invoke == nullptr) { return false; } auto callee_function = invoke->getCalledFunction(); // List with new call arguments std::vector<llvm::Value*> new_arguments; for (unsigned i = 0; i < invoke->getNumArgOperands(); ++i) { // Getting the i'th argument llvm::Value* arg = invoke->getArgOperand(i); new_arguments.push_back(arg); } // Creating a new call auto* new_call = builder.CreateCall(callee_function, new_arguments); builder.CreateBr(invoke->getNormalDest()); new_call->takeName(invoke); // Replace all calls to old function with calls to new function invoke->replaceAllUsesWith(new_call); replacements.push_back({invoke, nullptr}); return true; }}); } } void TransformationRulesPass::addConstExprRule(ReplacementRule&& rule) { auto ret = std::make_shared<ReplacementRule>(std::move(rule)); const_expr_replacements_.addRule(ret); } void TransformationRulesPass::constantFoldFunction(llvm::Function& fnc) { std::vector<llvm::Instruction*> to_delete; // Folding all constants for (auto& basic_block : fnc) { for (auto& instr : basic_block) { auto module = instr.getModule(); auto const& dl = module->getDataLayout(); auto cst = llvm::ConstantFoldInstruction(&instr, dl, nullptr); if (cst != nullptr) { instr.replaceAllUsesWith(cst); to_delete.push_back(&instr); } } } // Deleting constants for (auto& x : to_delete) { x->eraseFromParent(); } // Folding constant expressions Replacements replacements; for (auto& basic_block : fnc) { for (auto& instr : basic_block) { const_expr_replacements_.matchAndReplace(&instr, replacements); } } for (auto& r : replacements) { if (r.second != nullptr) { throw std::runtime_error(\"Real replacements not implemented.\"); } auto instr = llvm::dyn_cast<llvm::Instruction>(r.first); if (instr != nullptr) { instr->eraseFromParent(); continue; } auto block = llvm::dyn_cast<llvm::BasicBlock>(r.first); if (block != nullptr) { llvm::DeleteDeadBlock(block); } } } llvm::Value* TransformationRulesPass::copyAndExpand( llvm::Value* input, DeletableInstructions& schedule_instruction_deletion) { llvm::Value* ret = input; auto* call_instr = llvm::dyn_cast<llvm::CallInst>(input); auto instr_ptr = llvm::dyn_cast<llvm::Instruction>(input); if (call_instr != nullptr && instr_ptr != nullptr) { auto& instr = *instr_ptr; auto callee_function = call_instr->getCalledFunction(); if (callee_function != nullptr && !callee_function->isDeclaration()) { ConstantArguments argument_constants{}; std::vector<uint32_t> remaining_arguments{}; uint32_t idx = 0; auto n = static_cast<uint32_t>(callee_function->arg_size()); // Finding argument constants while (idx < n) { auto arg = callee_function->getArg(idx); auto value = call_instr->getArgOperand(idx); auto cst = llvm::dyn_cast<llvm::ConstantInt>(value); if (cst != nullptr) { argument_constants[arg->getName().str()] = cst; } else { remaining_arguments.push_back(idx); } ++idx; } // Making a function copy auto new_callee = expandFunctionCall(*callee_function, argument_constants); // Replacing call if a new function was created if (new_callee != nullptr) { llvm::IRBuilder<> builder(call_instr); // List with new call arguments std::vector<llvm::Value*> new_arguments; for (auto const& i : remaining_arguments) { // Getting the i'th argument llvm::Value* arg = call_instr->getArgOperand(i); // Adding arguments that were not constant if (argument_constants.find(arg->getName().str()) == argument_constants.end()) { new_arguments.push_back(arg); } } // Creating a new call auto* new_call = builder.CreateCall(new_callee, new_arguments); new_call->takeName(call_instr); new_call->setTailCall(call_instr->isTailCall()); new_call->setTailCallKind(call_instr->getTailCallKind()); if (call_instr->canReturnTwice()) { new_call->setCanReturnTwice(); } new_call->setCallingConv(call_instr->getCallingConv()); new_call->setAttributes(call_instr->getAttributes()); // Replace all calls to old function with calls to new function instr.replaceAllUsesWith(new_call); // Deleting instruction schedule_instruction_deletion.push_back(&instr); // Folding constants in the new function as we may have replaced some of // the arguments with constants constantFoldFunction(*new_callee); // Recursion: Returning the new call as the instruction to be analysed ret = new_call; } // Deleting the function the original function if it is no longer in use if (callee_function->use_empty()) { callee_function->eraseFromParent(); } } } return ret; } llvm::Value* TransformationRulesPass::detectActiveCode(llvm::Value* input, DeletableInstructions&) { active_pieces_.insert(input); return input; } bool TransformationRulesPass::runOnFunction(llvm::Function& function, InstructionModifier const& modifier) { if (function.isDeclaration()) { return false; } if (depth_ >= config_.maxRecursion()) { llvm::outs() << \"Exceed max recursion of \" << config_.maxRecursion() << \"\\n\"; return false; } ++depth_; // Keep track of instructions scheduled for deletion DeletableInstructions schedule_instruction_deletion; // Block queue std::deque<llvm::BasicBlock*> queue; std::unordered_set<llvm::BasicBlock*> blocks_queued; queue.push_back(&function.getEntryBlock()); blocks_queued.insert(&function.getEntryBlock()); // Executing the modifier on the function itsel modifier(&function, schedule_instruction_deletion); while (!queue.empty()) { auto& basic_block = *(queue.front()); queue.pop_front(); // Executing the modifier on the block modifier(&basic_block, schedule_instruction_deletion); for (auto& instr : basic_block) { // Modifying instruction as needed auto instr_ptr = modifier(&instr, schedule_instruction_deletion); // In case the instruction was scheduled for deletion if (instr_ptr == nullptr) { continue; } // Checking if we are calling a function auto call_instr = llvm::dyn_cast<llvm::CallBase>(instr_ptr); if (call_instr != nullptr) { auto callee_function = call_instr->getCalledFunction(); if (callee_function != nullptr && !callee_function->isDeclaration()) { runOnFunction(*callee_function, modifier); } } // Following the branches to their basic blocks auto* br_instr = llvm::dyn_cast<llvm::BranchInst>(&instr); if (br_instr != nullptr) { for (uint32_t i = 0; i < br_instr->getNumOperands(); ++i) { // TODO(issue-19): This may not work on multi path branches (conditional) // as we may accidentally add the final path (contains qubit release) // and we cannot make assumptions since optimisation may have rearranged // everything. In this case, we should revert to the order they appear in the // function auto bb = llvm::dyn_cast<llvm::BasicBlock>(br_instr->getOperand(i)); if (bb != nullptr) { // Ensuring that we are not scheduling the same block twice if (blocks_queued.find(bb) == blocks_queued.end()) { queue.push_back(bb); blocks_queued.insert(bb); } } } continue; } // Follow the branches of auto* switch_instr = llvm::dyn_cast<llvm::SwitchInst>(&instr); if (switch_instr != nullptr) { for (uint64_t i = 0; i < switch_instr->getNumSuccessors(); ++i) { auto bb = switch_instr->getSuccessor(static_cast<uint32_t>(i)); // Ensuring that we are not scheduling the same block twice if (blocks_queued.find(bb) == blocks_queued.end()) { queue.push_back(bb); blocks_queued.insert(bb); } } continue; } // Checking if this is an invoke call auto* invoke_inst = llvm::dyn_cast<llvm::InvokeInst>(&instr); if (invoke_inst != nullptr) { // Checking that configuration is correct if (!config_.assumeNoExceptions()) { // TODO(issue-20): Unify error reporting throw std::runtime_error(\"Exceptions paths cannot be handled at compile time. Either disable \" \"transform-execution-path-only or add assumption assume-no-except\"); } // Adding the block which is the on the \"no except\" path auto bb = invoke_inst->getNormalDest(); if (blocks_queued.find(bb) == blocks_queued.end()) { queue.push_back(bb); blocks_queued.insert(bb); } } } } // Deleting constants for (auto& x : schedule_instruction_deletion) { x->eraseFromParent(); } --depth_; return true; } bool TransformationRulesPass::isActive(llvm::Value* value) const { return active_pieces_.find(value) != active_pieces_.end(); } void TransformationRulesPass::runCopyAndExpand(llvm::Module& module, llvm::ModuleAnalysisManager&) { replacements_.clear(); // For every instruction in every block, we attempt a match // and replace. for (auto& function : module) { if (function.hasFnAttribute(config_.entryPointAttr())) { runOnFunction(function, [this](llvm::Value* value, DeletableInstructions& modifier) { return copyAndExpand(value, modifier); }); } } // Active code detection for (auto& global : module.globals()) { active_pieces_.insert(&global); for (auto& op : global.operands()) { active_pieces_.insert(op); } } for (auto& function : module) { bool is_active = false; // Checking if the function is referenced by a global variable for (auto user : function.users()) { // If the user is active, then it should be expected that the function is also active if (isActive(user)) { is_active = true; break; } } if (is_active || function.hasFnAttribute(config_.entryPointAttr())) { // Marking function as active active_pieces_.insert(&function); // Detecting active code runOnFunction(function, [this](llvm::Value* value, DeletableInstructions& modifier) { return detectActiveCode(value, modifier); }); } } processReplacements(); } void TransformationRulesPass::processReplacements() { // Applying all replacements std::unordered_set<llvm::Value*> already_removed; for (auto it = replacements_.rbegin(); it != replacements_.rend(); ++it) { auto instr1 = llvm::dyn_cast<llvm::Instruction>(it->first); if (instr1 == nullptr) { llvm::outs() << \"; WARNING: cannot deal with non-instruction replacements\\n\"; continue; } // Checking if by accident the same instruction was added if (already_removed.find(instr1) != already_removed.end()) { throw std::runtime_error(\"Instruction was already removed.\"); } already_removed.insert(instr1); // Cheking if have a replacement for the instruction if (it->second != nullptr) { // ... if so, we just replace it, auto instr2 = llvm::dyn_cast<llvm::Instruction>(it->second); if (instr2 == nullptr) { llvm::outs() << \"; WARNING: cannot replace instruction with non-instruction\\n\"; continue; } llvm::ReplaceInstWithInst(instr1, instr2); } else { // ... otherwise we delete the the instruction // Removing all uses if (!instr1->use_empty()) { auto type = instr1->getType(); if (type != nullptr) { instr1->replaceAllUsesWith(llvm::UndefValue::get(type)); } } // And finally we delete the instruction. The if statement // is first and foremost a precaution which prevents the program // from seg-faulting in the unlikely case that instr1->getType() is null. if (instr1->use_empty()) { instr1->eraseFromParent(); } } } replacements_.clear(); } void TransformationRulesPass::runDetectActiveCode(llvm::Module& module, llvm::ModuleAnalysisManager&) { blocks_to_delete_.clear(); functions_to_delete_.clear(); for (auto& function : module) { if (isActive(&function)) { for (auto& block : function) { if (!isActive(&block)) { blocks_to_delete_.push_back(&block); } } } else if (!function.isDeclaration()) { functions_to_delete_.push_back(&function); } } } void TransformationRulesPass::runDeleteDeadCode(llvm::Module&, llvm::ModuleAnalysisManager&) { // Removing all function references and scheduling blocks for deletion for (auto& function : functions_to_delete_) { // Schedule for deletion function->replaceAllUsesWith(llvm::UndefValue::get(function->getType())); function->clearGC(); function->clearMetadata(); // Deleteing blocks in reverse order std::vector<llvm::BasicBlock*> blocks; for (auto& block : *function) { blocks.push_back(&block); } // Removing backwards to avoid segfault for (auto it = blocks.rbegin(); it != blocks.rend(); ++it) { auto& block = **it; // Deleting instructions in reverse order (needed because it is a DAG structure) std::vector<llvm::Instruction*> instructions; for (auto& instr : block) { instructions.push_back(&instr); } // Removing all instructions for (auto it2 = instructions.rbegin(); it2 != instructions.rend(); ++it2) { auto& instr = **it2; instr.replaceAllUsesWith(llvm::UndefValue::get(instr.getType())); instr.eraseFromParent(); } // Removing all block references block.replaceAllUsesWith(llvm::UndefValue::get(block.getType())); // Scheduling block deletion blocks_to_delete_.push_back(&block); } } // Deleting all blocks for (auto block : blocks_to_delete_) { if (block->use_empty()) { block->eraseFromParent(); } else { llvm::errs() << \"; INTERNAL ERROR: block was supposed to be unused.\\n\"; for (auto& x : block->uses()) { llvm::errs() << \" -x \" << *x << \"\\n\"; } for (auto x : block->users()) { llvm::errs() << \" -: \" << *x << \"\\n\"; } llvm::errs() << \" ----- \\n\"; llvm::errs() << *block << \"\\n\"; } } // Removing functions for (auto& function : functions_to_delete_) { if (function->isDeclaration() && function->use_empty()) { function->eraseFromParent(); } } } void TransformationRulesPass::runReplacePhi(llvm::Module& module, llvm::ModuleAnalysisManager&) { using namespace microsoft::quantum::notation; auto rule = phi(\"b1\"_cap = _, \"b2\"_cap = _); IOperandPrototype::Captures captures; std::vector<llvm::Instruction*> to_delete; std::unordered_map<llvm::Instruction*, llvm::Value*> replacements; for (auto& function : module) { for (auto& block : function) { std::vector<llvm::Instruction*> instrs; for (auto& instr : block) { if (rule->match(&instr, captures)) { auto phi = llvm::dyn_cast<llvm::PHINode>(&instr); if (phi == nullptr) { continue; } auto val1 = captures[\"b1\"]; auto val2 = captures[\"b2\"]; auto block1 = phi->getIncomingBlock(0); // TODO(issue-21): Make sure that block1 matches val1 auto block2 = phi->getIncomingBlock(1); if (!isActive(block1)) { val2->takeName(&instr); replacements[&instr] = val2; to_delete.push_back(&instr); } else if (!isActive(block2)) { val1->takeName(&instr); replacements[&instr] = val2; to_delete.push_back(&instr); } captures.clear(); } } } } for (auto& r : replacements) { r.first->replaceAllUsesWith(r.second); } for (auto& x : to_delete) { x->eraseFromParent(); } } void TransformationRulesPass::runApplyRules(llvm::Module& module, llvm::ModuleAnalysisManager&) { replacements_.clear(); std::unordered_set<llvm::Value*> already_visited; for (auto& function : module) { if (function.hasFnAttribute(config_.entryPointAttr())) { runOnFunction(function, [this, &already_visited](llvm::Value* value, DeletableInstructions&) { auto instr = llvm::dyn_cast<llvm::Instruction>(value); // Sanity check if (already_visited.find(value) != already_visited.end()) { throw std::runtime_error(\"Already visited\"); } already_visited.insert(value); // Checking if we should analyse if (instr != nullptr) { rule_set_.matchAndReplace(instr, replacements_); } return value; }); if (config_.shouldAnnotateQubitUse()) { std::stringstream ss{\"\"}; ss << profile_->getQubitAllocationManager()->maxAllocationsUsed(); function.addFnAttr(\"requiredQubits\", ss.str()); } if (config_.shouldAnnotateResultUse()) { std::stringstream ss{\"\"}; ss << profile_->getResultAllocationManager()->maxAllocationsUsed(); function.addFnAttr(\"requiredResults\", ss.str()); } } } processReplacements(); } llvm::PreservedAnalyses TransformationRulesPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& mam) { // In case the module is istructed to clone functions, if (config_.shouldCloneFunctions()) { setupCopyAndExpand(); runCopyAndExpand(module, mam); } // Deleting dead code if configured to do so. This process consists // of three steps: detecting dead code, removing phi nodes (and references) // and finally deleting the code. This implementation is aggressive in the sense // that any code that we cannot prove to be active is considered dead. if (config_.shouldDeleteDeadCode()) { runDetectActiveCode(module, mam); runReplacePhi(module, mam); runDeleteDeadCode(module, mam); } // Applying rule set if (config_.shouldTransformExecutionPathOnly()) { // We only apply transformation rules to code which is reachable // via the execution path. runApplyRules(module, mam); } else { // Otherwise we apply to all sections of the code. replacements_.clear(); for (auto& function : module) { for (auto& block : function) { for (auto& instr : block) { rule_set_.matchAndReplace(&instr, replacements_); } } } processReplacements(); } return llvm::PreservedAnalyses::none(); } llvm::Function* TransformationRulesPass::expandFunctionCall( llvm::Function& callee, ConstantArguments const& const_args) { auto module = callee.getParent(); auto& context = module->getContext(); llvm::IRBuilder<> builder(context); // Copying the original function llvm::ValueToValueMapTy remapper; std::vector<llvm::Type*> arg_types; // The user might be deleting arguments to the function by specifying them in // the VMap. If so, we need to not add the arguments to the arg ty vector // for (auto const& arg : callee.args()) { // Skipping constant arguments if (const_args.find(arg.getName().str()) != const_args.end()) { continue; } arg_types.push_back(arg.getType()); } // Creating a new function llvm::FunctionType* function_type = llvm::FunctionType::get( callee.getFunctionType()->getReturnType(), arg_types, callee.getFunctionType()->isVarArg()); auto function = llvm::Function::Create( function_type, callee.getLinkage(), callee.getAddressSpace(), callee.getName(), module); // Copying the non-const arguments auto dest_args_it = function->arg_begin(); for (auto const& arg : callee.args()) { auto const_it = const_args.find(arg.getName().str()); if (const_it == const_args.end()) { // Mapping remaining function arguments dest_args_it->setName(arg.getName()); remapper[&arg] = &*dest_args_it++; } else { remapper[&arg] = llvm::ConstantInt::get(context, const_it->second->getValue()); } } llvm::SmallVector<llvm::ReturnInst*, 8> returns; // Ignore returns cloned. // Note: In LLVM 13 upgrade 'true' to 'llvm::CloneFunctionChangeType::LocalChangesOnly' llvm::CloneFunctionInto(function, &callee, remapper, true, returns, \"\", nullptr); verifyFunction(*function); return function; } void TransformationRulesPass::setLogger(ILoggerPtr logger) { logger_ = std::move(logger); } bool TransformationRulesPass::isRequired() { return true; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_transformation_rules_pass_8hpp/","text":"TransformationRulesPass/TransformationRulesPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::TransformationRulesPass Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/ILogger.hpp\" #include \"Profile/Profile.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Rules/RuleSet.hpp\" #include \"TransformationRulesPass/TransformationRulesPassConfiguration.hpp\" #include \"Llvm/Llvm.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class TransformationRulesPass : public llvm::PassInfoMixin<TransformationRulesPass> { public: using Replacements = ReplacementRule::Replacements; using Instruction = llvm::Instruction; using Rules = std::vector<ReplacementRule>; using Value = llvm::Value; using Builder = ReplacementRule::Builder; using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; using Captures = RuleSet::Captures; using ConstantArguments = std::unordered_map<std::string, llvm::ConstantInt*>; using ILoggerPtr = std::shared_ptr<ILogger>; // Construction and destruction configuration. // TransformationRulesPass( RuleSet&& rule_set, TransformationRulesPassConfiguration const& config, Profile* profile); TransformationRulesPass(TransformationRulesPass const&) = delete; TransformationRulesPass(TransformationRulesPass&&) = default; ~TransformationRulesPass() = default; // Operators // TransformationRulesPass& operator=(TransformationRulesPass const&) = delete; TransformationRulesPass& operator=(TransformationRulesPass&&) = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); using DeletableInstructions = std::vector<llvm::Instruction*>; using InstructionModifier = std::function<llvm::Value*(llvm::Value*, DeletableInstructions&)>; // Generic helper functions // bool runOnFunction(llvm::Function& function, InstructionModifier const& modifier); void processReplacements(); // Copy and expand // void setupCopyAndExpand(); void runCopyAndExpand(llvm::Module& module, llvm::ModuleAnalysisManager& mam); llvm::Value* copyAndExpand(llvm::Value* input, DeletableInstructions&); llvm::Function* expandFunctionCall(llvm::Function& callee, ConstantArguments const& const_args = {}); void constantFoldFunction(llvm::Function& callee); void addConstExprRule(ReplacementRule&& rule); // Dead code detection // void runDetectActiveCode(llvm::Module& module, llvm::ModuleAnalysisManager& mam); void runDeleteDeadCode(llvm::Module& module, llvm::ModuleAnalysisManager& mam); llvm::Value* detectActiveCode(llvm::Value* input, DeletableInstructions&); llvm::Value* deleteDeadCode(llvm::Value* input, DeletableInstructions&); bool isActive(llvm::Value* value) const; void followUsers(llvm::Value* value); // Phi replacement // void runReplacePhi(llvm::Module& module, llvm::ModuleAnalysisManager& mam); // Rules // void runApplyRules(llvm::Module& module, llvm::ModuleAnalysisManager& mam); bool onQubitRelease(llvm::Instruction* instruction, Captures& captures); bool onQubitAllocate(llvm::Instruction* instruction, Captures& captures); static bool isRequired(); // Logger // void setLogger(ILoggerPtr logger); private: // Pass configuration // RuleSet rule_set_{}; TransformationRulesPassConfiguration config_{}; // Logging and data collection // ILoggerPtr logger_{nullptr}; // Execution path unrolling // uint64_t depth_{0}; // Copy and expand // RuleSet const_expr_replacements_{}; // Dead code elimination // std::unordered_set<Value*> active_pieces_{}; std::vector<llvm::BasicBlock*> blocks_to_delete_{}; std::vector<llvm::Function*> functions_to_delete_{}; // Phi detection // Replacements replacements_; // Profile // Profile* profile_{nullptr}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"TransformationRulesPass/TransformationRulesPass.hpp"},{"location":"Api/Files/_transformation_rules_pass_8hpp/#transformationrulespasstransformationrulespasshpp","text":"","title":"TransformationRulesPass/TransformationRulesPass.hpp"},{"location":"Api/Files/_transformation_rules_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_transformation_rules_pass_8hpp/#classes","text":"Name class microsoft::quantum::TransformationRulesPass","title":"Classes"},{"location":"Api/Files/_transformation_rules_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/ILogger.hpp\" #include \"Profile/Profile.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"Rules/RuleSet.hpp\" #include \"TransformationRulesPass/TransformationRulesPassConfiguration.hpp\" #include \"Llvm/Llvm.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class TransformationRulesPass : public llvm::PassInfoMixin<TransformationRulesPass> { public: using Replacements = ReplacementRule::Replacements; using Instruction = llvm::Instruction; using Rules = std::vector<ReplacementRule>; using Value = llvm::Value; using Builder = ReplacementRule::Builder; using AllocationManagerPtr = IAllocationManager::AllocationManagerPtr; using Captures = RuleSet::Captures; using ConstantArguments = std::unordered_map<std::string, llvm::ConstantInt*>; using ILoggerPtr = std::shared_ptr<ILogger>; // Construction and destruction configuration. // TransformationRulesPass( RuleSet&& rule_set, TransformationRulesPassConfiguration const& config, Profile* profile); TransformationRulesPass(TransformationRulesPass const&) = delete; TransformationRulesPass(TransformationRulesPass&&) = default; ~TransformationRulesPass() = default; // Operators // TransformationRulesPass& operator=(TransformationRulesPass const&) = delete; TransformationRulesPass& operator=(TransformationRulesPass&&) = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); using DeletableInstructions = std::vector<llvm::Instruction*>; using InstructionModifier = std::function<llvm::Value*(llvm::Value*, DeletableInstructions&)>; // Generic helper functions // bool runOnFunction(llvm::Function& function, InstructionModifier const& modifier); void processReplacements(); // Copy and expand // void setupCopyAndExpand(); void runCopyAndExpand(llvm::Module& module, llvm::ModuleAnalysisManager& mam); llvm::Value* copyAndExpand(llvm::Value* input, DeletableInstructions&); llvm::Function* expandFunctionCall(llvm::Function& callee, ConstantArguments const& const_args = {}); void constantFoldFunction(llvm::Function& callee); void addConstExprRule(ReplacementRule&& rule); // Dead code detection // void runDetectActiveCode(llvm::Module& module, llvm::ModuleAnalysisManager& mam); void runDeleteDeadCode(llvm::Module& module, llvm::ModuleAnalysisManager& mam); llvm::Value* detectActiveCode(llvm::Value* input, DeletableInstructions&); llvm::Value* deleteDeadCode(llvm::Value* input, DeletableInstructions&); bool isActive(llvm::Value* value) const; void followUsers(llvm::Value* value); // Phi replacement // void runReplacePhi(llvm::Module& module, llvm::ModuleAnalysisManager& mam); // Rules // void runApplyRules(llvm::Module& module, llvm::ModuleAnalysisManager& mam); bool onQubitRelease(llvm::Instruction* instruction, Captures& captures); bool onQubitAllocate(llvm::Instruction* instruction, Captures& captures); static bool isRequired(); // Logger // void setLogger(ILoggerPtr logger); private: // Pass configuration // RuleSet rule_set_{}; TransformationRulesPassConfiguration config_{}; // Logging and data collection // ILoggerPtr logger_{nullptr}; // Execution path unrolling // uint64_t depth_{0}; // Copy and expand // RuleSet const_expr_replacements_{}; // Dead code elimination // std::unordered_set<Value*> active_pieces_{}; std::vector<llvm::BasicBlock*> blocks_to_delete_{}; std::vector<llvm::Function*> functions_to_delete_{}; // Phi detection // Replacements replacements_; // Profile // Profile* profile_{nullptr}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_transformation_rules_pass_configuration_8cpp/","text":"TransformationRulesPass/TransformationRulesPassConfiguration.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"TransformationRulesPass/TransformationRulesPassConfiguration.hpp\" namespace microsoft { namespace quantum { void TransformationRulesPassConfiguration::setup(ConfigurationManager& config) { config.setSectionName(\"Pass configuration\", \"Configuration of the pass and its corresponding optimisations.\"); config.addParameter(delete_dead_code_, \"delete-dead-code\", \"Deleted dead code.\"); config.addParameter(clone_functions_, \"clone-functions\", \"Clone functions to ensure correct qubit allocation.\"); config.addParameter( transform_execution_path_only_, \"transform-execution-path-only\", \"Transform execution paths only.\"); config.addParameter( max_recursion_, \"max-recursion\", \"Defines the maximum recursion when unrolling the execution path\"); config.addParameter( assume_no_exceptions_, \"assume-no-except\", \"Assumes that no exception will occur during runtime.\"); config.addParameter(reuse_qubits_, \"reuse-qubits\", \"Use to define whether or not to reuse qubits.\"); config.addParameter(annotate_qubit_use_, \"annotate-qubit-use\", \"Annotate the number of qubits used\"); config.addParameter(reuse_results_, \"reuse-results\", \"Use to define whether or not to reuse results.\"); config.addParameter(annotate_result_use_, \"annotate-result-use\", \"Annotate the number of results used\"); config.addParameter( entry_point_attr_, \"entry-point-attr\", \"Specifies the attribute indicating the entry point.\"); config.addParameter( simplify_prior_transformation_, \"simplify-prior-transform\", \"When active, the IR is simplified using LLVM passes before transformation.\"); // Not implemented yet config.addParameter(group_measurements_, \"group-measurements\", \"NOT IMPLEMENTED - group-measurements\"); config.addParameter(one_shot_measurement_, \"one-shot-measurement\", \"NOT IMPLEMENTED - one-shot-measurement\"); } TransformationRulesPassConfiguration TransformationRulesPassConfiguration::createDisabled() { TransformationRulesPassConfiguration ret; ret.delete_dead_code_ = false; ret.clone_functions_ = false; ret.transform_execution_path_only_ = false; ret.max_recursion_ = 512; ret.simplify_prior_transformation_ = false; ret.reuse_qubits_ = false; ret.annotate_qubit_use_ = false; ret.group_measurements_ = false; ret.one_shot_measurement_ = false; return ret; } bool TransformationRulesPassConfiguration::shouldSimplifyPriorTransform() const { return simplify_prior_transformation_; } bool TransformationRulesPassConfiguration::shouldDeleteDeadCode() const { return delete_dead_code_; } bool TransformationRulesPassConfiguration::shouldCloneFunctions() const { return clone_functions_; } bool TransformationRulesPassConfiguration::shouldTransformExecutionPathOnly() const { return transform_execution_path_only_; } uint64_t TransformationRulesPassConfiguration::maxRecursion() const { return max_recursion_; } bool TransformationRulesPassConfiguration::shouldReuseQubits() const { return reuse_qubits_; } bool TransformationRulesPassConfiguration::shouldAnnotateQubitUse() const { return annotate_qubit_use_; } bool TransformationRulesPassConfiguration::shouldReuseResults() const { return reuse_results_; } bool TransformationRulesPassConfiguration::shouldAnnotateResultUse() const { return annotate_result_use_; } bool TransformationRulesPassConfiguration::shouldGroupMeasurements() const { return group_measurements_; } bool TransformationRulesPassConfiguration::oneShotMeasurement() const { return one_shot_measurement_; } std::string TransformationRulesPassConfiguration::entryPointAttr() const { return entry_point_attr_; } bool TransformationRulesPassConfiguration::assumeNoExceptions() const { return assume_no_exceptions_; } bool TransformationRulesPassConfiguration::isDisabled() const { return ( delete_dead_code_ == false && clone_functions_ == false && simplify_prior_transformation_ == false && transform_execution_path_only_ == false && reuse_qubits_ == false && group_measurements_ == false && one_shot_measurement_ == false); } bool TransformationRulesPassConfiguration::operator==(TransformationRulesPassConfiguration const& ref) const { return ( delete_dead_code_ == ref.delete_dead_code_ && clone_functions_ == ref.clone_functions_ && transform_execution_path_only_ == ref.transform_execution_path_only_ && reuse_qubits_ == ref.reuse_qubits_ && group_measurements_ == ref.group_measurements_ && one_shot_measurement_ == ref.one_shot_measurement_); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"TransformationRulesPass/TransformationRulesPassConfiguration.cpp"},{"location":"Api/Files/_transformation_rules_pass_configuration_8cpp/#transformationrulespasstransformationrulespassconfigurationcpp","text":"","title":"TransformationRulesPass/TransformationRulesPassConfiguration.cpp"},{"location":"Api/Files/_transformation_rules_pass_configuration_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_transformation_rules_pass_configuration_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"TransformationRulesPass/TransformationRulesPassConfiguration.hpp\" namespace microsoft { namespace quantum { void TransformationRulesPassConfiguration::setup(ConfigurationManager& config) { config.setSectionName(\"Pass configuration\", \"Configuration of the pass and its corresponding optimisations.\"); config.addParameter(delete_dead_code_, \"delete-dead-code\", \"Deleted dead code.\"); config.addParameter(clone_functions_, \"clone-functions\", \"Clone functions to ensure correct qubit allocation.\"); config.addParameter( transform_execution_path_only_, \"transform-execution-path-only\", \"Transform execution paths only.\"); config.addParameter( max_recursion_, \"max-recursion\", \"Defines the maximum recursion when unrolling the execution path\"); config.addParameter( assume_no_exceptions_, \"assume-no-except\", \"Assumes that no exception will occur during runtime.\"); config.addParameter(reuse_qubits_, \"reuse-qubits\", \"Use to define whether or not to reuse qubits.\"); config.addParameter(annotate_qubit_use_, \"annotate-qubit-use\", \"Annotate the number of qubits used\"); config.addParameter(reuse_results_, \"reuse-results\", \"Use to define whether or not to reuse results.\"); config.addParameter(annotate_result_use_, \"annotate-result-use\", \"Annotate the number of results used\"); config.addParameter( entry_point_attr_, \"entry-point-attr\", \"Specifies the attribute indicating the entry point.\"); config.addParameter( simplify_prior_transformation_, \"simplify-prior-transform\", \"When active, the IR is simplified using LLVM passes before transformation.\"); // Not implemented yet config.addParameter(group_measurements_, \"group-measurements\", \"NOT IMPLEMENTED - group-measurements\"); config.addParameter(one_shot_measurement_, \"one-shot-measurement\", \"NOT IMPLEMENTED - one-shot-measurement\"); } TransformationRulesPassConfiguration TransformationRulesPassConfiguration::createDisabled() { TransformationRulesPassConfiguration ret; ret.delete_dead_code_ = false; ret.clone_functions_ = false; ret.transform_execution_path_only_ = false; ret.max_recursion_ = 512; ret.simplify_prior_transformation_ = false; ret.reuse_qubits_ = false; ret.annotate_qubit_use_ = false; ret.group_measurements_ = false; ret.one_shot_measurement_ = false; return ret; } bool TransformationRulesPassConfiguration::shouldSimplifyPriorTransform() const { return simplify_prior_transformation_; } bool TransformationRulesPassConfiguration::shouldDeleteDeadCode() const { return delete_dead_code_; } bool TransformationRulesPassConfiguration::shouldCloneFunctions() const { return clone_functions_; } bool TransformationRulesPassConfiguration::shouldTransformExecutionPathOnly() const { return transform_execution_path_only_; } uint64_t TransformationRulesPassConfiguration::maxRecursion() const { return max_recursion_; } bool TransformationRulesPassConfiguration::shouldReuseQubits() const { return reuse_qubits_; } bool TransformationRulesPassConfiguration::shouldAnnotateQubitUse() const { return annotate_qubit_use_; } bool TransformationRulesPassConfiguration::shouldReuseResults() const { return reuse_results_; } bool TransformationRulesPassConfiguration::shouldAnnotateResultUse() const { return annotate_result_use_; } bool TransformationRulesPassConfiguration::shouldGroupMeasurements() const { return group_measurements_; } bool TransformationRulesPassConfiguration::oneShotMeasurement() const { return one_shot_measurement_; } std::string TransformationRulesPassConfiguration::entryPointAttr() const { return entry_point_attr_; } bool TransformationRulesPassConfiguration::assumeNoExceptions() const { return assume_no_exceptions_; } bool TransformationRulesPassConfiguration::isDisabled() const { return ( delete_dead_code_ == false && clone_functions_ == false && simplify_prior_transformation_ == false && transform_execution_path_only_ == false && reuse_qubits_ == false && group_measurements_ == false && one_shot_measurement_ == false); } bool TransformationRulesPassConfiguration::operator==(TransformationRulesPassConfiguration const& ref) const { return ( delete_dead_code_ == ref.delete_dead_code_ && clone_functions_ == ref.clone_functions_ && transform_execution_path_only_ == ref.transform_execution_path_only_ && reuse_qubits_ == ref.reuse_qubits_ && group_measurements_ == ref.group_measurements_ && one_shot_measurement_ == ref.one_shot_measurement_); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_transformation_rules_pass_configuration_8hpp/","text":"TransformationRulesPass/TransformationRulesPassConfiguration.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::TransformationRulesPassConfiguration Configuration class for the RuleTransformation pass. Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" namespace microsoft { namespace quantum { class TransformationRulesPassConfiguration { public: // Setup and construction // void setup(ConfigurationManager& config); static TransformationRulesPassConfiguration createDisabled(); // Configuration classes // bool isDisabled() const; bool operator==(TransformationRulesPassConfiguration const& ref) const; // Properties // bool shouldDeleteDeadCode() const; bool shouldCloneFunctions() const; bool assumeNoExceptions() const; bool shouldTransformExecutionPathOnly() const; uint64_t maxRecursion() const; bool shouldReuseQubits() const; bool shouldAnnotateQubitUse() const; bool shouldReuseResults() const; bool shouldAnnotateResultUse() const; bool shouldGroupMeasurements() const; bool oneShotMeasurement() const; bool shouldSimplifyPriorTransform() const; std::string entryPointAttr() const; private: // Code expansion and trimming // bool delete_dead_code_{true}; bool clone_functions_{true}; bool transform_execution_path_only_{true}; uint64_t max_recursion_{512}; std::string entry_point_attr_{\"InteropFriendly\"}; bool simplify_prior_transformation_{true}; // Branching bool assume_no_exceptions_{false}; // Allocation options // bool reuse_qubits_{true}; bool annotate_qubit_use_{true}; bool reuse_results_{true}; bool annotate_result_use_{true}; // Measurement // bool group_measurements_{false}; bool one_shot_measurement_{true}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"TransformationRulesPass/TransformationRulesPassConfiguration.hpp"},{"location":"Api/Files/_transformation_rules_pass_configuration_8hpp/#transformationrulespasstransformationrulespassconfigurationhpp","text":"","title":"TransformationRulesPass/TransformationRulesPassConfiguration.hpp"},{"location":"Api/Files/_transformation_rules_pass_configuration_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_transformation_rules_pass_configuration_8hpp/#classes","text":"Name class microsoft::quantum::TransformationRulesPassConfiguration Configuration class for the RuleTransformation pass.","title":"Classes"},{"location":"Api/Files/_transformation_rules_pass_configuration_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" namespace microsoft { namespace quantum { class TransformationRulesPassConfiguration { public: // Setup and construction // void setup(ConfigurationManager& config); static TransformationRulesPassConfiguration createDisabled(); // Configuration classes // bool isDisabled() const; bool operator==(TransformationRulesPassConfiguration const& ref) const; // Properties // bool shouldDeleteDeadCode() const; bool shouldCloneFunctions() const; bool assumeNoExceptions() const; bool shouldTransformExecutionPathOnly() const; uint64_t maxRecursion() const; bool shouldReuseQubits() const; bool shouldAnnotateQubitUse() const; bool shouldReuseResults() const; bool shouldAnnotateResultUse() const; bool shouldGroupMeasurements() const; bool oneShotMeasurement() const; bool shouldSimplifyPriorTransform() const; std::string entryPointAttr() const; private: // Code expansion and trimming // bool delete_dead_code_{true}; bool clone_functions_{true}; bool transform_execution_path_only_{true}; uint64_t max_recursion_{512}; std::string entry_point_attr_{\"InteropFriendly\"}; bool simplify_prior_transformation_{true}; // Branching bool assume_no_exceptions_{false}; // Allocation options // bool reuse_qubits_{true}; bool annotate_qubit_use_{true}; bool reuse_results_{true}; bool annotate_result_use_{true}; // Measurement // bool group_measurements_{false}; bool one_shot_measurement_{true}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_unnamed_invoke_8cpp/","text":"Rules/Notation/UnnamedInvoke.cpp Namespaces Name microsoft microsoft::quantum microsoft::quantum::notation Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/UnnamedInvokePattern.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr unnamedInvoke() { auto ret = std::make_shared<UnnamedInvokePattern>(); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Notation/UnnamedInvoke.cpp"},{"location":"Api/Files/_unnamed_invoke_8cpp/#rulesnotationunnamedinvokecpp","text":"","title":"Rules/Notation/UnnamedInvoke.cpp"},{"location":"Api/Files/_unnamed_invoke_8cpp/#namespaces","text":"Name microsoft microsoft::quantum microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Files/_unnamed_invoke_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/Notation/Notation.hpp\" #include \"Rules/Patterns/UnnamedInvokePattern.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { namespace notation { using IOperandPrototypePtr = std::shared_ptr<IOperandPrototype>; IOperandPrototypePtr unnamedInvoke() { auto ret = std::make_shared<UnnamedInvokePattern>(); return static_cast<IOperandPrototypePtr>(ret); } } // namespace notation } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_unnamed_invoke_pattern_8cpp/","text":"Rules/Patterns/UnnamedInvokePattern.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/Patterns/UnnamedInvokePattern.hpp\" namespace microsoft { namespace quantum { UnnamedInvokePattern::~UnnamedInvokePattern() = default; bool UnnamedInvokePattern::match(Value* instr, Captures& captures) const { auto* call_instr = llvm::dyn_cast<llvm::InvokeInst>(instr); if (call_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } UnnamedInvokePattern::Child UnnamedInvokePattern::copy() const { auto ret = std::make_shared<UnnamedInvokePattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Patterns/UnnamedInvokePattern.cpp"},{"location":"Api/Files/_unnamed_invoke_pattern_8cpp/#rulespatternsunnamedinvokepatterncpp","text":"","title":"Rules/Patterns/UnnamedInvokePattern.cpp"},{"location":"Api/Files/_unnamed_invoke_pattern_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_unnamed_invoke_pattern_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Rules/Patterns/UnnamedInvokePattern.hpp\" namespace microsoft { namespace quantum { UnnamedInvokePattern::~UnnamedInvokePattern() = default; bool UnnamedInvokePattern::match(Value* instr, Captures& captures) const { auto* call_instr = llvm::dyn_cast<llvm::InvokeInst>(instr); if (call_instr == nullptr) { return fail(instr, captures); } return success(instr, captures); } UnnamedInvokePattern::Child UnnamedInvokePattern::copy() const { auto ret = std::make_shared<UnnamedInvokePattern>(); ret->copyPropertiesFrom(*this); return std::move(ret); } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_unnamed_invoke_pattern_8hpp/","text":"Rules/Patterns/UnnamedInvokePattern.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::UnnamedInvokePattern Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class UnnamedInvokePattern : public IOperandPrototype { public: using String = std::string; // Construction // UnnamedInvokePattern() = default; UnnamedInvokePattern(UnnamedInvokePattern const& other) = delete; UnnamedInvokePattern(UnnamedInvokePattern&& other) = default; ~UnnamedInvokePattern() override; // Call implementation of the member functions in IOperandPrototype. // bool match(Value* instr, Captures& captures) const override; Child copy() const override; private: }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Patterns/UnnamedInvokePattern.hpp"},{"location":"Api/Files/_unnamed_invoke_pattern_8hpp/#rulespatternsunnamedinvokepatternhpp","text":"","title":"Rules/Patterns/UnnamedInvokePattern.hpp"},{"location":"Api/Files/_unnamed_invoke_pattern_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_unnamed_invoke_pattern_8hpp/#classes","text":"Name class microsoft::quantum::UnnamedInvokePattern","title":"Classes"},{"location":"Api/Files/_unnamed_invoke_pattern_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Rules/IOperandPrototype.hpp\" #include \"Llvm/Llvm.hpp\" #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class UnnamedInvokePattern : public IOperandPrototype { public: using String = std::string; // Construction // UnnamedInvokePattern() = default; UnnamedInvokePattern(UnnamedInvokePattern const& other) = delete; UnnamedInvokePattern(UnnamedInvokePattern&& other) = default; ~UnnamedInvokePattern() override; // Call implementation of the member functions in IOperandPrototype. // bool match(Value* instr, Captures& captures) const override; Child copy() const override; private: }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_validation_pass_8cpp/","text":"ValidationPass/ValidationPass.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"ValidationPass/ValidationPass.hpp\" #include \"Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft { namespace quantum { llvm::PreservedAnalyses ValidationPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { for (auto& function : module) { for (auto& block : function) { for (auto& instr : block) { auto opname = instr.getOpcodeName(); if (opcodes_.find(opname) != opcodes_.end()) { ++opcodes_[opname]; } else { opcodes_[opname] = 1; } auto call_instr = llvm::dyn_cast<llvm::CallBase>(&instr); if (call_instr != nullptr) { auto f = call_instr->getCalledFunction(); if (f == nullptr) { continue; } auto name = static_cast<std::string>(f->getName()); if (f->isDeclaration()) { if (external_calls_.find(name) != external_calls_.end()) { ++external_calls_[name]; } else { external_calls_[name] = 1; } } else { if (internal_calls_.find(name) != internal_calls_.end()) { ++internal_calls_[name]; } else { internal_calls_[name] = 1; } } } } } } bool raise_exception = false; if (config_.allowlistOpcodes()) { auto const& allowed_ops = config_.allowedOpcodes(); for (auto const& k : opcodes_) { if (allowed_ops.find(k.first) == allowed_ops.end()) { logger_->error(\"'\" + k.first + \"' is not allowed for this profile.\"); } } } if (config_.allowlistOpcodes()) { auto const& allowed_functions = config_.allowedExternalCallNames(); for (auto const& k : external_calls_) { if (allowed_functions.find(k.first) == allowed_functions.end()) { logger_->error(\"'\" + k.first + \"' is not allowed for this profile.\"); } } } if (!config_.allowInternalCalls() && !internal_calls_.empty()) { logger_->error(\"Calls to custom defined functions not allowed.\"); raise_exception = true; } if (raise_exception) { throw std::runtime_error(\"QIR is not valid within the defined profile\"); } return llvm::PreservedAnalyses::all(); } bool ValidationPass::isRequired() { return true; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"ValidationPass/ValidationPass.cpp"},{"location":"Api/Files/_validation_pass_8cpp/#validationpassvalidationpasscpp","text":"","title":"ValidationPass/ValidationPass.cpp"},{"location":"Api/Files/_validation_pass_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_validation_pass_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"ValidationPass/ValidationPass.hpp\" #include \"Llvm/Llvm.hpp\" #include <fstream> #include <iostream> namespace microsoft { namespace quantum { llvm::PreservedAnalyses ValidationPass::run(llvm::Module& module, llvm::ModuleAnalysisManager& /*mam*/) { for (auto& function : module) { for (auto& block : function) { for (auto& instr : block) { auto opname = instr.getOpcodeName(); if (opcodes_.find(opname) != opcodes_.end()) { ++opcodes_[opname]; } else { opcodes_[opname] = 1; } auto call_instr = llvm::dyn_cast<llvm::CallBase>(&instr); if (call_instr != nullptr) { auto f = call_instr->getCalledFunction(); if (f == nullptr) { continue; } auto name = static_cast<std::string>(f->getName()); if (f->isDeclaration()) { if (external_calls_.find(name) != external_calls_.end()) { ++external_calls_[name]; } else { external_calls_[name] = 1; } } else { if (internal_calls_.find(name) != internal_calls_.end()) { ++internal_calls_[name]; } else { internal_calls_[name] = 1; } } } } } } bool raise_exception = false; if (config_.allowlistOpcodes()) { auto const& allowed_ops = config_.allowedOpcodes(); for (auto const& k : opcodes_) { if (allowed_ops.find(k.first) == allowed_ops.end()) { logger_->error(\"'\" + k.first + \"' is not allowed for this profile.\"); } } } if (config_.allowlistOpcodes()) { auto const& allowed_functions = config_.allowedExternalCallNames(); for (auto const& k : external_calls_) { if (allowed_functions.find(k.first) == allowed_functions.end()) { logger_->error(\"'\" + k.first + \"' is not allowed for this profile.\"); } } } if (!config_.allowInternalCalls() && !internal_calls_.empty()) { logger_->error(\"Calls to custom defined functions not allowed.\"); raise_exception = true; } if (raise_exception) { throw std::runtime_error(\"QIR is not valid within the defined profile\"); } return llvm::PreservedAnalyses::all(); } bool ValidationPass::isRequired() { return true; } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_validation_pass_8hpp/","text":"ValidationPass/ValidationPass.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ValidationPass Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/ILogger.hpp\" #include \"Profile/Profile.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"ValidationPass/ValidationPassConfiguration.hpp\" #include \"Llvm/Llvm.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class ValidationPass : public llvm::PassInfoMixin<ValidationPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = std::shared_ptr<ILogger>; // Construction and destruction configuration. // explicit ValidationPass(ValidationPassConfiguration const& cfg, ILoggerPtr const& logger = nullptr) : config_{cfg} , logger_{logger} { } ValidationPass(ValidationPass const&) = delete; ValidationPass(ValidationPass&&) = default; ~ValidationPass() = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired(); private: ValidationPassConfiguration config_{}; std::unordered_map<std::string, uint64_t> opcodes_; std::unordered_map<std::string, uint64_t> external_calls_; std::unordered_map<std::string, uint64_t> internal_calls_; ILoggerPtr logger_{nullptr}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"ValidationPass/ValidationPass.hpp"},{"location":"Api/Files/_validation_pass_8hpp/#validationpassvalidationpasshpp","text":"","title":"ValidationPass/ValidationPass.hpp"},{"location":"Api/Files/_validation_pass_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_validation_pass_8hpp/#classes","text":"Name class microsoft::quantum::ValidationPass","title":"Classes"},{"location":"Api/Files/_validation_pass_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/ILogger.hpp\" #include \"Profile/Profile.hpp\" #include \"QatTypes/QatTypes.hpp\" #include \"ValidationPass/ValidationPassConfiguration.hpp\" #include \"Llvm/Llvm.hpp\" #include <functional> #include <unordered_map> #include <vector> namespace microsoft { namespace quantum { class ValidationPass : public llvm::PassInfoMixin<ValidationPass> { public: using Instruction = llvm::Instruction; using Value = llvm::Value; using ILoggerPtr = std::shared_ptr<ILogger>; // Construction and destruction configuration. // explicit ValidationPass(ValidationPassConfiguration const& cfg, ILoggerPtr const& logger = nullptr) : config_{cfg} , logger_{logger} { } ValidationPass(ValidationPass const&) = delete; ValidationPass(ValidationPass&&) = default; ~ValidationPass() = default; llvm::PreservedAnalyses run(llvm::Module& module, llvm::ModuleAnalysisManager& mam); static bool isRequired(); private: ValidationPassConfiguration config_{}; std::unordered_map<std::string, uint64_t> opcodes_; std::unordered_map<std::string, uint64_t> external_calls_; std::unordered_map<std::string, uint64_t> internal_calls_; ILoggerPtr logger_{nullptr}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_validation_pass_configuration_8hpp/","text":"ValidationPass/ValidationPassConfiguration.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::ValidationPassConfiguration Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"QatTypes/QatTypes.hpp\" namespace microsoft { namespace quantum { class ValidationPassConfiguration { public: using Set = std::unordered_set<std::string>; // Setup and construction // void setup(ConfigurationManager& config) { config.setSectionName(\"Validation configuration\", \"\"); config.addParameter( allow_internal_calls_, \"allow-internal-calls\", \"Whether or not internal calls are allowed.\"); config.addParameter( save_report_to_, \"save-validation-report\", \"Saves the validation report to specified filename.\"); } static ValidationPassConfiguration fromProfileName(String const& name) { auto ret = ValidationPassConfiguration(); if (name == \"generic\") { ret.allow_internal_calls_ = true; ret.allowlist_external_calls_ = false; ret.allowlist_opcodes_ = false; } else if (name == \"base\") { ret.allow_internal_calls_ = false; ret.allowlist_external_calls_ = true; ret.allowlist_opcodes_ = true; ret.opcodes_ = Set{\"br\", \"call\", \"unreachable\", \"ret\", \"phi\", \"select\"}; ret.external_calls_ = Set{ \"__quantum__qis__mz__body\", \"__quantum__qis__read_result__body\", \"__quantum__qis__reset__body\", \"__quantum__qis__z__body\", \"__quantum__qis__s__adj\", \"__quantum__qis__dumpregister__body\", \"__quantum__qis__y__body\", \"__quantum__qis__x__body\", \"__quantum__qis__t__body\", \"__quantum__qis__cz__body\", \"__quantum__qis__s__body\", \"__quantum__qis__h__body\", \"__quantum__qis__cnot__body\", \"__quantum__qis__sqrt__body\", \"__quantum__qis__crz__body\", \"__quantum__qis__rz__body\", \"__quantum__qis__arcsin__body\", \"__quantum__qis__drawrandomint__body\", \"__quantum__qis__rx__body\", \"__quantum__qis__m__body\", \"__quantum__qis__t__adj\", }; } else { throw std::runtime_error(\"Invalid profile \" + name); } return ret; } Set const& allowedOpcodes() const { return opcodes_; } Set const& allowedExternalCallNames() const { return external_calls_; } bool allowInternalCalls() const { return allow_internal_calls_; } bool allowlistOpcodes() const { return allowlist_opcodes_; } bool allowlistExternalCalls() const { return allowlist_external_calls_; } String const& saveReportTo() const { return save_report_to_; } private: Set opcodes_{}; Set external_calls_{}; String save_report_to_{\"\"}; bool allowlist_opcodes_{true}; bool allowlist_external_calls_{true}; bool allow_internal_calls_{false}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"ValidationPass/ValidationPassConfiguration.hpp"},{"location":"Api/Files/_validation_pass_configuration_8hpp/#validationpassvalidationpassconfigurationhpp","text":"","title":"ValidationPass/ValidationPassConfiguration.hpp"},{"location":"Api/Files/_validation_pass_configuration_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_validation_pass_configuration_8hpp/#classes","text":"Name class microsoft::quantum::ValidationPassConfiguration","title":"Classes"},{"location":"Api/Files/_validation_pass_configuration_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Commandline/ConfigurationManager.hpp\" #include \"QatTypes/QatTypes.hpp\" namespace microsoft { namespace quantum { class ValidationPassConfiguration { public: using Set = std::unordered_set<std::string>; // Setup and construction // void setup(ConfigurationManager& config) { config.setSectionName(\"Validation configuration\", \"\"); config.addParameter( allow_internal_calls_, \"allow-internal-calls\", \"Whether or not internal calls are allowed.\"); config.addParameter( save_report_to_, \"save-validation-report\", \"Saves the validation report to specified filename.\"); } static ValidationPassConfiguration fromProfileName(String const& name) { auto ret = ValidationPassConfiguration(); if (name == \"generic\") { ret.allow_internal_calls_ = true; ret.allowlist_external_calls_ = false; ret.allowlist_opcodes_ = false; } else if (name == \"base\") { ret.allow_internal_calls_ = false; ret.allowlist_external_calls_ = true; ret.allowlist_opcodes_ = true; ret.opcodes_ = Set{\"br\", \"call\", \"unreachable\", \"ret\", \"phi\", \"select\"}; ret.external_calls_ = Set{ \"__quantum__qis__mz__body\", \"__quantum__qis__read_result__body\", \"__quantum__qis__reset__body\", \"__quantum__qis__z__body\", \"__quantum__qis__s__adj\", \"__quantum__qis__dumpregister__body\", \"__quantum__qis__y__body\", \"__quantum__qis__x__body\", \"__quantum__qis__t__body\", \"__quantum__qis__cz__body\", \"__quantum__qis__s__body\", \"__quantum__qis__h__body\", \"__quantum__qis__cnot__body\", \"__quantum__qis__sqrt__body\", \"__quantum__qis__crz__body\", \"__quantum__qis__rz__body\", \"__quantum__qis__arcsin__body\", \"__quantum__qis__drawrandomint__body\", \"__quantum__qis__rx__body\", \"__quantum__qis__m__body\", \"__quantum__qis__t__adj\", }; } else { throw std::runtime_error(\"Invalid profile \" + name); } return ret; } Set const& allowedOpcodes() const { return opcodes_; } Set const& allowedExternalCallNames() const { return external_calls_; } bool allowInternalCalls() const { return allow_internal_calls_; } bool allowlistOpcodes() const { return allowlist_opcodes_; } bool allowlistExternalCalls() const { return allowlist_external_calls_; } String const& saveReportTo() const { return save_report_to_; } private: Set opcodes_{}; Set external_calls_{}; String save_report_to_{\"\"}; bool allowlist_opcodes_{true}; bool allowlist_external_calls_{true}; bool allow_internal_calls_{false}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_validator_8cpp/","text":"Validator/Validator.cpp Namespaces Name microsoft microsoft::quantum Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/CommentLogger.hpp\" #include \"Logging/ILogger.hpp\" #include \"Logging/LogCollection.hpp\" #include \"ValidationPass/ValidationPass.hpp\" #include \"Validator/Validator.hpp\" #include \"Llvm/Llvm.hpp\" #include <fstream> namespace microsoft { namespace quantum { Validator::Validator(ValidationPassConfiguration const& cfg, bool debug, llvm::TargetMachine* target_machine) : loop_analysis_manager_{debug} , function_analysis_manager_{debug} , gscc_analysis_manager_{debug} , module_analysis_manager_{debug} , logger_{nullptr} { pass_builder_ = std::make_unique<llvm::PassBuilder>(target_machine); pass_builder_->registerModuleAnalyses(module_analysis_manager_); pass_builder_->registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_->registerFunctionAnalyses(function_analysis_manager_); pass_builder_->registerLoopAnalyses(loop_analysis_manager_); pass_builder_->crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); // Checking if we need to save the log to a file if (!cfg.saveReportTo().empty()) { logger_ = std::make_shared<LogCollection>(); save_to_filename_ = cfg.saveReportTo(); module_pass_manager_.addPass(ValidationPass(cfg, logger_)); } else { // Our default is a pass that logs errors via comments module_pass_manager_.addPass(ValidationPass(cfg, std::make_shared<CommentLogger>())); } } bool Validator::validate(llvm::Module& module) { llvm::VerifierAnalysis verifier; auto result = verifier.run(module, module_analysis_manager_); if (result.IRBroken) { if (logger_) { logger_->error(\"Fatal error: Invalid IR.\"); } saveReportToFileIfNeeded(); return false; } try { module_pass_manager_.run(module, module_analysis_manager_); } catch (std::exception const& e) { if (logger_) { logger_->error(\"Fatal error: \" + static_cast<std::string>(e.what())); } saveReportToFileIfNeeded(); return false; } saveReportToFileIfNeeded(); return true; } llvm::PassBuilder& Validator::passBuilder() { return *pass_builder_; } llvm::LoopAnalysisManager& Validator::loopAnalysisManager() { return loop_analysis_manager_; } llvm::FunctionAnalysisManager& Validator::functionAnalysisManager() { return function_analysis_manager_; } llvm::CGSCCAnalysisManager& Validator::gsccAnalysisManager() { return gscc_analysis_manager_; } llvm::ModuleAnalysisManager& Validator::moduleAnalysisManager() { return module_analysis_manager_; } void Validator::saveReportToFileIfNeeded() { if (!save_to_filename_.empty() && logger_) { std::fstream fout(save_to_filename_, std::ios::out); bool not_first = false; fout << \"[\"; for (auto& message : logger_->messages()) { if (not_first) { fout << \",\"; } fout << \"\\n\"; fout << \" {\\n\"; switch (message.type) { case LogCollection::Type::Debug: fout << \" \\\"type\\\": \\\"debug\\\",\\n\"; break; case LogCollection::Type::Info: fout << \" \\\"type\\\": \\\"info\\\",\\n\"; break; case LogCollection::Type::Warning: fout << \" \\\"type\\\": \\\"warning\\\",\\n\"; break; case LogCollection::Type::Error: fout << \" \\\"type\\\": \\\"error\\\",\\n\"; break; case LogCollection::Type::InternalError: fout << \" \\\"type\\\": \\\"internalError\\\",\\n\"; break; } fout << \" \\\"message\\\": \\\"\" << message.message << \"\\\",\\n\"; fout << \" \\\"location\\\": {\\n\"; fout << \" \\\"name\\\": \\\"\" << message.location.name << \"\\\",\\n\"; fout << \" \\\"row\\\": \" << message.location.row << \",\\n\"; fout << \" \\\"col\\\": \" << message.location.col << \"\\n\"; fout << \" }\\n\"; fout << \" }\"; not_first = true; } fout << \"\\n]\\n\"; fout.close(); } } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Validator/Validator.cpp"},{"location":"Api/Files/_validator_8cpp/#validatorvalidatorcpp","text":"","title":"Validator/Validator.cpp"},{"location":"Api/Files/_validator_8cpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_validator_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"Logging/CommentLogger.hpp\" #include \"Logging/ILogger.hpp\" #include \"Logging/LogCollection.hpp\" #include \"ValidationPass/ValidationPass.hpp\" #include \"Validator/Validator.hpp\" #include \"Llvm/Llvm.hpp\" #include <fstream> namespace microsoft { namespace quantum { Validator::Validator(ValidationPassConfiguration const& cfg, bool debug, llvm::TargetMachine* target_machine) : loop_analysis_manager_{debug} , function_analysis_manager_{debug} , gscc_analysis_manager_{debug} , module_analysis_manager_{debug} , logger_{nullptr} { pass_builder_ = std::make_unique<llvm::PassBuilder>(target_machine); pass_builder_->registerModuleAnalyses(module_analysis_manager_); pass_builder_->registerCGSCCAnalyses(gscc_analysis_manager_); pass_builder_->registerFunctionAnalyses(function_analysis_manager_); pass_builder_->registerLoopAnalyses(loop_analysis_manager_); pass_builder_->crossRegisterProxies( loop_analysis_manager_, function_analysis_manager_, gscc_analysis_manager_, module_analysis_manager_); // Checking if we need to save the log to a file if (!cfg.saveReportTo().empty()) { logger_ = std::make_shared<LogCollection>(); save_to_filename_ = cfg.saveReportTo(); module_pass_manager_.addPass(ValidationPass(cfg, logger_)); } else { // Our default is a pass that logs errors via comments module_pass_manager_.addPass(ValidationPass(cfg, std::make_shared<CommentLogger>())); } } bool Validator::validate(llvm::Module& module) { llvm::VerifierAnalysis verifier; auto result = verifier.run(module, module_analysis_manager_); if (result.IRBroken) { if (logger_) { logger_->error(\"Fatal error: Invalid IR.\"); } saveReportToFileIfNeeded(); return false; } try { module_pass_manager_.run(module, module_analysis_manager_); } catch (std::exception const& e) { if (logger_) { logger_->error(\"Fatal error: \" + static_cast<std::string>(e.what())); } saveReportToFileIfNeeded(); return false; } saveReportToFileIfNeeded(); return true; } llvm::PassBuilder& Validator::passBuilder() { return *pass_builder_; } llvm::LoopAnalysisManager& Validator::loopAnalysisManager() { return loop_analysis_manager_; } llvm::FunctionAnalysisManager& Validator::functionAnalysisManager() { return function_analysis_manager_; } llvm::CGSCCAnalysisManager& Validator::gsccAnalysisManager() { return gscc_analysis_manager_; } llvm::ModuleAnalysisManager& Validator::moduleAnalysisManager() { return module_analysis_manager_; } void Validator::saveReportToFileIfNeeded() { if (!save_to_filename_.empty() && logger_) { std::fstream fout(save_to_filename_, std::ios::out); bool not_first = false; fout << \"[\"; for (auto& message : logger_->messages()) { if (not_first) { fout << \",\"; } fout << \"\\n\"; fout << \" {\\n\"; switch (message.type) { case LogCollection::Type::Debug: fout << \" \\\"type\\\": \\\"debug\\\",\\n\"; break; case LogCollection::Type::Info: fout << \" \\\"type\\\": \\\"info\\\",\\n\"; break; case LogCollection::Type::Warning: fout << \" \\\"type\\\": \\\"warning\\\",\\n\"; break; case LogCollection::Type::Error: fout << \" \\\"type\\\": \\\"error\\\",\\n\"; break; case LogCollection::Type::InternalError: fout << \" \\\"type\\\": \\\"internalError\\\",\\n\"; break; } fout << \" \\\"message\\\": \\\"\" << message.message << \"\\\",\\n\"; fout << \" \\\"location\\\": {\\n\"; fout << \" \\\"name\\\": \\\"\" << message.location.name << \"\\\",\\n\"; fout << \" \\\"row\\\": \" << message.location.row << \",\\n\"; fout << \" \\\"col\\\": \" << message.location.col << \"\\n\"; fout << \" }\\n\"; fout << \" }\"; not_first = true; } fout << \"\\n]\\n\"; fout.close(); } } } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/_validator_8hpp/","text":"Validator/Validator.hpp Namespaces Name microsoft microsoft::quantum Classes Name class microsoft::quantum::Validator Source code #pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/AllocationManager.hpp\" #include \"AllocationManager/IAllocationManager.hpp\" #include \"Logging/ILogger.hpp\" #include \"Logging/LogCollection.hpp\" #include \"ValidationPass/ValidationPassConfiguration.hpp\" #include \"Llvm/Llvm.hpp\" #include <memory> namespace microsoft { namespace quantum { class Validator { public: using ValidatorPtr = std::unique_ptr<Validator>; using LogColloectionPtr = std::shared_ptr<LogCollection>; // Constructors // explicit Validator( ValidationPassConfiguration const& cfg, bool debug, llvm::TargetMachine* target_machine = nullptr); // Default construction not allowed to ensure that LLVM modules and passes are set up correctly. // Copy construction is prohibited due to restriction on classes held by Validator. Validator() = delete; Validator(Validator const&) = delete; Validator(Validator&&) = default; Validator& operator=(Validator const&) = delete; Validator& operator=(Validator&&) = default; ~Validator() = default; // Validator methods // bool validate(llvm::Module& module); protected: using PassBuilderPtr = std::unique_ptr<llvm::PassBuilder>; llvm::PassBuilder& passBuilder(); llvm::LoopAnalysisManager& loopAnalysisManager(); llvm::FunctionAnalysisManager& functionAnalysisManager(); llvm::CGSCCAnalysisManager& gsccAnalysisManager(); llvm::ModuleAnalysisManager& moduleAnalysisManager(); private: void saveReportToFileIfNeeded(); // LLVM logic to run the passes // llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; PassBuilderPtr pass_builder_; llvm::ModulePassManager module_pass_manager_{}; LogColloectionPtr logger_{nullptr}; String save_to_filename_{\"\"}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Validator/Validator.hpp"},{"location":"Api/Files/_validator_8hpp/#validatorvalidatorhpp","text":"","title":"Validator/Validator.hpp"},{"location":"Api/Files/_validator_8hpp/#namespaces","text":"Name microsoft microsoft::quantum","title":"Namespaces"},{"location":"Api/Files/_validator_8hpp/#classes","text":"Name class microsoft::quantum::Validator","title":"Classes"},{"location":"Api/Files/_validator_8hpp/#source-code","text":"#pragma once // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/AllocationManager.hpp\" #include \"AllocationManager/IAllocationManager.hpp\" #include \"Logging/ILogger.hpp\" #include \"Logging/LogCollection.hpp\" #include \"ValidationPass/ValidationPassConfiguration.hpp\" #include \"Llvm/Llvm.hpp\" #include <memory> namespace microsoft { namespace quantum { class Validator { public: using ValidatorPtr = std::unique_ptr<Validator>; using LogColloectionPtr = std::shared_ptr<LogCollection>; // Constructors // explicit Validator( ValidationPassConfiguration const& cfg, bool debug, llvm::TargetMachine* target_machine = nullptr); // Default construction not allowed to ensure that LLVM modules and passes are set up correctly. // Copy construction is prohibited due to restriction on classes held by Validator. Validator() = delete; Validator(Validator const&) = delete; Validator(Validator&&) = default; Validator& operator=(Validator const&) = delete; Validator& operator=(Validator&&) = default; ~Validator() = default; // Validator methods // bool validate(llvm::Module& module); protected: using PassBuilderPtr = std::unique_ptr<llvm::PassBuilder>; llvm::PassBuilder& passBuilder(); llvm::LoopAnalysisManager& loopAnalysisManager(); llvm::FunctionAnalysisManager& functionAnalysisManager(); llvm::CGSCCAnalysisManager& gsccAnalysisManager(); llvm::ModuleAnalysisManager& moduleAnalysisManager(); private: void saveReportToFileIfNeeded(); // LLVM logic to run the passes // llvm::LoopAnalysisManager loop_analysis_manager_; llvm::FunctionAnalysisManager function_analysis_manager_; llvm::CGSCCAnalysisManager gscc_analysis_manager_; llvm::ModuleAnalysisManager module_analysis_manager_; PassBuilderPtr pass_builder_; llvm::ModulePassManager module_pass_manager_{}; LogColloectionPtr logger_{nullptr}; String save_to_filename_{\"\"}; }; } // namespace quantum } // namespace microsoft Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/configuration_8cpp/","text":"Commandline/Tests/Unit/configuration.cpp Functions Name TEST (CommandlineTestSuite , Configuration ) Functions Documentation function TEST TEST( CommandlineTestSuite , Configuration ) Source code // Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/AllocationManager.hpp\" #include \"Commandline/ConfigurationManager.hpp\" #include \"gtest/gtest.h\" using namespace microsoft::quantum; namespace { class TestConfig1 { public: void setup(ConfigurationManager& config) { config.setSectionName(\"Base configuration\", \"\"); config.addParameter(param1_, \"param1\", \"\"); config.addParameter(param2_, \"param2\", \"\"); config.addParameter(param3_, \"param3\", \"\"); } bool param1() const { return param1_; } std::string param2() const { return param2_; } int32_t param3() const { return param3_; } private: bool param1_{false}; std::string param2_{\"\"}; int32_t param3_{9}; }; class TestConfig2 { public: void setup(ConfigurationManager& config) { config.setSectionName(\"Base configuration\", \"\"); config.addParameter(param1_, \"param1\", \"\"); config.addParameter(param2_, \"param2\", \"\"); config.addParameter(param3_, \"param3\", \"\"); } bool param1() const { return param1_; } std::string param2() const { return param2_; } int32_t param3() const { return param3_; } private: bool param1_{true}; std::string param2_{\"xxxx\"}; int32_t param3_{9}; }; } // namespace TEST(CommandlineTestSuite, Configuration) { { ConfigurationManager configuration_manager; configuration_manager.addConfig<TestConfig1>(); ParameterParser parser; configuration_manager.setupArguments(parser); char* args[] = {\"main\", \"--param1\", \"--param2\", \"hello\", \"--param3\", \"1337\"}; parser.parseArgs(6, args); configuration_manager.configure(parser); auto& config = configuration_manager.get<TestConfig1>(); EXPECT_EQ(config.param1(), true); EXPECT_EQ(config.param2(), \"hello\"); EXPECT_EQ(config.param3(), 1337); } { ConfigurationManager configuration_manager; configuration_manager.addConfig<TestConfig1>(); ParameterParser parser; configuration_manager.setupArguments(parser); char* args[] = {\"main\", \"--no-param1\", \"--param2\", \"ms\", \"--param3\", \"17372\"}; parser.parseArgs(6, args); configuration_manager.configure(parser); auto& config = configuration_manager.get<TestConfig1>(); EXPECT_EQ(config.param1(), false); EXPECT_EQ(config.param2(), \"ms\"); EXPECT_EQ(config.param3(), 17372); } // Testing default values { // Testing default arguments ConfigurationManager configuration_manager; configuration_manager.addConfig<TestConfig2>(); ParameterParser parser; configuration_manager.setupArguments(parser); char* args[] = {\"main\"}; parser.parseArgs(1, args); configuration_manager.configure(parser); auto& config = configuration_manager.get<TestConfig2>(); EXPECT_EQ(config.param1(), true); EXPECT_EQ(config.param2(), \"xxxx\"); EXPECT_EQ(config.param3(), 9); } // Testing opposite boolean default { ConfigurationManager configuration_manager; configuration_manager.addConfig<TestConfig2>(); ParameterParser parser; configuration_manager.setupArguments(parser); char* args[] = {\"main\", \"--no-param1\", \"--param2\", \"msss\", \"--param3\", \"17372\"}; parser.parseArgs(6, args); configuration_manager.configure(parser); auto& config = configuration_manager.get<TestConfig2>(); EXPECT_EQ(config.param1(), false); EXPECT_EQ(config.param2(), \"msss\"); EXPECT_EQ(config.param3(), 17372); } } Updated on 22 November 2021 at 10:28:34 UTC","title":"Commandline/Tests/Unit/configuration.cpp"},{"location":"Api/Files/configuration_8cpp/#commandlinetestsunitconfigurationcpp","text":"","title":"Commandline/Tests/Unit/configuration.cpp"},{"location":"Api/Files/configuration_8cpp/#functions","text":"Name TEST (CommandlineTestSuite , Configuration )","title":"Functions"},{"location":"Api/Files/configuration_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Files/configuration_8cpp/#function-test","text":"TEST( CommandlineTestSuite , Configuration )","title":"function TEST"},{"location":"Api/Files/configuration_8cpp/#source-code","text":"// Copyright (c) Microsoft Corporation. // Licensed under the MIT License. #include \"AllocationManager/AllocationManager.hpp\" #include \"Commandline/ConfigurationManager.hpp\" #include \"gtest/gtest.h\" using namespace microsoft::quantum; namespace { class TestConfig1 { public: void setup(ConfigurationManager& config) { config.setSectionName(\"Base configuration\", \"\"); config.addParameter(param1_, \"param1\", \"\"); config.addParameter(param2_, \"param2\", \"\"); config.addParameter(param3_, \"param3\", \"\"); } bool param1() const { return param1_; } std::string param2() const { return param2_; } int32_t param3() const { return param3_; } private: bool param1_{false}; std::string param2_{\"\"}; int32_t param3_{9}; }; class TestConfig2 { public: void setup(ConfigurationManager& config) { config.setSectionName(\"Base configuration\", \"\"); config.addParameter(param1_, \"param1\", \"\"); config.addParameter(param2_, \"param2\", \"\"); config.addParameter(param3_, \"param3\", \"\"); } bool param1() const { return param1_; } std::string param2() const { return param2_; } int32_t param3() const { return param3_; } private: bool param1_{true}; std::string param2_{\"xxxx\"}; int32_t param3_{9}; }; } // namespace TEST(CommandlineTestSuite, Configuration) { { ConfigurationManager configuration_manager; configuration_manager.addConfig<TestConfig1>(); ParameterParser parser; configuration_manager.setupArguments(parser); char* args[] = {\"main\", \"--param1\", \"--param2\", \"hello\", \"--param3\", \"1337\"}; parser.parseArgs(6, args); configuration_manager.configure(parser); auto& config = configuration_manager.get<TestConfig1>(); EXPECT_EQ(config.param1(), true); EXPECT_EQ(config.param2(), \"hello\"); EXPECT_EQ(config.param3(), 1337); } { ConfigurationManager configuration_manager; configuration_manager.addConfig<TestConfig1>(); ParameterParser parser; configuration_manager.setupArguments(parser); char* args[] = {\"main\", \"--no-param1\", \"--param2\", \"ms\", \"--param3\", \"17372\"}; parser.parseArgs(6, args); configuration_manager.configure(parser); auto& config = configuration_manager.get<TestConfig1>(); EXPECT_EQ(config.param1(), false); EXPECT_EQ(config.param2(), \"ms\"); EXPECT_EQ(config.param3(), 17372); } // Testing default values { // Testing default arguments ConfigurationManager configuration_manager; configuration_manager.addConfig<TestConfig2>(); ParameterParser parser; configuration_manager.setupArguments(parser); char* args[] = {\"main\"}; parser.parseArgs(1, args); configuration_manager.configure(parser); auto& config = configuration_manager.get<TestConfig2>(); EXPECT_EQ(config.param1(), true); EXPECT_EQ(config.param2(), \"xxxx\"); EXPECT_EQ(config.param3(), 9); } // Testing opposite boolean default { ConfigurationManager configuration_manager; configuration_manager.addConfig<TestConfig2>(); ParameterParser parser; configuration_manager.setupArguments(parser); char* args[] = {\"main\", \"--no-param1\", \"--param2\", \"msss\", \"--param3\", \"17372\"}; parser.parseArgs(6, args); configuration_manager.configure(parser); auto& config = configuration_manager.get<TestConfig2>(); EXPECT_EQ(config.param1(), false); EXPECT_EQ(config.param2(), \"msss\"); EXPECT_EQ(config.param3(), 17372); } } Updated on 22 November 2021 at 10:28:34 UTC","title":"Source code"},{"location":"Api/Files/dir_057849f2a92a904b8f008cf0365e4758/","text":"TestTools Directories Name TestTools/Tests Files Name TestTools/IrManipulationTestHelper.cpp TestTools/IrManipulationTestHelper.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"TestTools"},{"location":"Api/Files/dir_057849f2a92a904b8f008cf0365e4758/#testtools","text":"","title":"TestTools"},{"location":"Api/Files/dir_057849f2a92a904b8f008cf0365e4758/#directories","text":"Name TestTools/Tests","title":"Directories"},{"location":"Api/Files/dir_057849f2a92a904b8f008cf0365e4758/#files","text":"Name TestTools/IrManipulationTestHelper.cpp TestTools/IrManipulationTestHelper.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Files"},{"location":"Api/Files/dir_0b342c6c6b7d2278121a0bb9c4985063/","text":"Generators Directories Name Generators/Tests Files Name Generators/DefaultProfileGenerator.cpp Generators/DefaultProfileGenerator.hpp Generators/LlvmPassesConfiguration.cpp Generators/LlvmPassesConfiguration.hpp Generators/ProfileGenerator.cpp Generators/ProfileGenerator.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Generators"},{"location":"Api/Files/dir_0b342c6c6b7d2278121a0bb9c4985063/#generators","text":"","title":"Generators"},{"location":"Api/Files/dir_0b342c6c6b7d2278121a0bb9c4985063/#directories","text":"Name Generators/Tests","title":"Directories"},{"location":"Api/Files/dir_0b342c6c6b7d2278121a0bb9c4985063/#files","text":"Name Generators/DefaultProfileGenerator.cpp Generators/DefaultProfileGenerator.hpp Generators/LlvmPassesConfiguration.cpp Generators/LlvmPassesConfiguration.hpp Generators/ProfileGenerator.cpp Generators/ProfileGenerator.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Files"},{"location":"Api/Files/dir_13002e6e9a3be65aeac8e1b6c1ea9008/","text":"AllocationManager Directories Name AllocationManager/Tests Files Name AllocationManager/AllocationManager.cpp AllocationManager/AllocationManager.hpp AllocationManager/IAllocationManager.cpp AllocationManager/IAllocationManager.hpp Updated on 22 November 2021 at 10:28:35 UTC","title":"AllocationManager"},{"location":"Api/Files/dir_13002e6e9a3be65aeac8e1b6c1ea9008/#allocationmanager","text":"","title":"AllocationManager"},{"location":"Api/Files/dir_13002e6e9a3be65aeac8e1b6c1ea9008/#directories","text":"Name AllocationManager/Tests","title":"Directories"},{"location":"Api/Files/dir_13002e6e9a3be65aeac8e1b6c1ea9008/#files","text":"Name AllocationManager/AllocationManager.cpp AllocationManager/AllocationManager.hpp AllocationManager/IAllocationManager.cpp AllocationManager/IAllocationManager.hpp Updated on 22 November 2021 at 10:28:35 UTC","title":"Files"},{"location":"Api/Files/dir_1833a7894b5a75b220b1d3511201084c/","text":"Rules/Tests/Unit Files Name Rules/Tests/Unit/BasicRuleSetOps.cpp Rules/Tests/Unit/BranchOnOne.cpp Rules/Tests/Unit/BranchOnZero.cpp Rules/Tests/Unit/DisableAliasCounting.cpp Rules/Tests/Unit/DisableReferenceCounting.cpp Rules/Tests/Unit/DisableStrings.cpp Rules/Tests/Unit/FactoryConfiguration.cpp Rules/Tests/Unit/RemoveFunctionCall.cpp Rules/Tests/Unit/SelectOnOne.cpp Rules/Tests/Unit/SingleQubitAllocation.cpp Rules/Tests/Unit/StaticQubitArrayAllocation.cpp Rules/Tests/Unit/StaticResultAllocation.cpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Tests/Unit"},{"location":"Api/Files/dir_1833a7894b5a75b220b1d3511201084c/#rulestestsunit","text":"","title":"Rules/Tests/Unit"},{"location":"Api/Files/dir_1833a7894b5a75b220b1d3511201084c/#files","text":"Name Rules/Tests/Unit/BasicRuleSetOps.cpp Rules/Tests/Unit/BranchOnOne.cpp Rules/Tests/Unit/BranchOnZero.cpp Rules/Tests/Unit/DisableAliasCounting.cpp Rules/Tests/Unit/DisableReferenceCounting.cpp Rules/Tests/Unit/DisableStrings.cpp Rules/Tests/Unit/FactoryConfiguration.cpp Rules/Tests/Unit/RemoveFunctionCall.cpp Rules/Tests/Unit/SelectOnOne.cpp Rules/Tests/Unit/SingleQubitAllocation.cpp Rules/Tests/Unit/StaticQubitArrayAllocation.cpp Rules/Tests/Unit/StaticResultAllocation.cpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Files"},{"location":"Api/Files/dir_1ac31f0ad19e6e70229b8be25708d179/","text":"TestTools/Tests Directories Name TestTools/Tests/Unit Updated on 22 November 2021 at 10:28:34 UTC","title":"TestTools/Tests"},{"location":"Api/Files/dir_1ac31f0ad19e6e70229b8be25708d179/#testtoolstests","text":"","title":"TestTools/Tests"},{"location":"Api/Files/dir_1ac31f0ad19e6e70229b8be25708d179/#directories","text":"Name TestTools/Tests/Unit Updated on 22 November 2021 at 10:28:34 UTC","title":"Directories"},{"location":"Api/Files/dir_2ec174d07e4760e39ac00c02aafa05bd/","text":"Generators/Tests/Unit Files Name Generators/Tests/Unit/main.cpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Generators/Tests/Unit"},{"location":"Api/Files/dir_2ec174d07e4760e39ac00c02aafa05bd/#generatorstestsunit","text":"","title":"Generators/Tests/Unit"},{"location":"Api/Files/dir_2ec174d07e4760e39ac00c02aafa05bd/#files","text":"Name Generators/Tests/Unit/main.cpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Files"},{"location":"Api/Files/dir_330962e0cca6e5beca01291183583700/","text":"TransformationRulesPass/Tests/Unit Files Name TransformationRulesPass/Tests/Unit/LoopUnrolling.cpp TransformationRulesPass/Tests/Unit/MiniTeleChain.cpp TransformationRulesPass/Tests/Unit/PhiElimination.cpp Updated on 22 November 2021 at 10:28:34 UTC","title":"TransformationRulesPass/Tests/Unit"},{"location":"Api/Files/dir_330962e0cca6e5beca01291183583700/#transformationrulespasstestsunit","text":"","title":"TransformationRulesPass/Tests/Unit"},{"location":"Api/Files/dir_330962e0cca6e5beca01291183583700/#files","text":"Name TransformationRulesPass/Tests/Unit/LoopUnrolling.cpp TransformationRulesPass/Tests/Unit/MiniTeleChain.cpp TransformationRulesPass/Tests/Unit/PhiElimination.cpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Files"},{"location":"Api/Files/dir_46e4ac26363cdfa62d85590f6bd5db50/","text":"QatTypes Files Name QatTypes/QatTypes.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"QatTypes"},{"location":"Api/Files/dir_46e4ac26363cdfa62d85590f6bd5db50/#qattypes","text":"","title":"QatTypes"},{"location":"Api/Files/dir_46e4ac26363cdfa62d85590f6bd5db50/#files","text":"Name QatTypes/QatTypes.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Files"},{"location":"Api/Files/dir_524e0ced49e0a8528dd8fd75cd7543b6/","text":"RemoveDisallowedAttributesPass Files Name RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"RemoveDisallowedAttributesPass"},{"location":"Api/Files/dir_524e0ced49e0a8528dd8fd75cd7543b6/#removedisallowedattributespass","text":"","title":"RemoveDisallowedAttributesPass"},{"location":"Api/Files/dir_524e0ced49e0a8528dd8fd75cd7543b6/#files","text":"Name RemoveDisallowedAttributesPass/RemoveDisallowedAttributesPass.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Files"},{"location":"Api/Files/dir_6069a059e5434331e3b1d76f58abe873/","text":"Rules/Tests Directories Name Rules/Tests/Unit Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Tests"},{"location":"Api/Files/dir_6069a059e5434331e3b1d76f58abe873/#rulestests","text":"","title":"Rules/Tests"},{"location":"Api/Files/dir_6069a059e5434331e3b1d76f58abe873/#directories","text":"Name Rules/Tests/Unit Updated on 22 November 2021 at 10:28:34 UTC","title":"Directories"},{"location":"Api/Files/dir_6098f77c224c930825758694068d4cda/","text":"Apps Directories Name Apps/Qat Updated on 22 November 2021 at 10:28:34 UTC","title":"Apps"},{"location":"Api/Files/dir_6098f77c224c930825758694068d4cda/#apps","text":"","title":"Apps"},{"location":"Api/Files/dir_6098f77c224c930825758694068d4cda/#directories","text":"Name Apps/Qat Updated on 22 November 2021 at 10:28:34 UTC","title":"Directories"},{"location":"Api/Files/dir_6b8ce007e224e28261a5a1609daedfb1/","text":"TestTools/Tests/Unit Files Name TestTools/Tests/Unit/main.cpp Updated on 22 November 2021 at 10:28:34 UTC","title":"TestTools/Tests/Unit"},{"location":"Api/Files/dir_6b8ce007e224e28261a5a1609daedfb1/#testtoolstestsunit","text":"","title":"TestTools/Tests/Unit"},{"location":"Api/Files/dir_6b8ce007e224e28261a5a1609daedfb1/#files","text":"Name TestTools/Tests/Unit/main.cpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Files"},{"location":"Api/Files/dir_6e62bfc077e9135e8e7652f871dd426f/","text":"TransformationRulesPass/Tests Directories Name TransformationRulesPass/Tests/Unit Updated on 22 November 2021 at 10:28:34 UTC","title":"TransformationRulesPass/Tests"},{"location":"Api/Files/dir_6e62bfc077e9135e8e7652f871dd426f/#transformationrulespasstests","text":"","title":"TransformationRulesPass/Tests"},{"location":"Api/Files/dir_6e62bfc077e9135e8e7652f871dd426f/#directories","text":"Name TransformationRulesPass/Tests/Unit Updated on 22 November 2021 at 10:28:34 UTC","title":"Directories"},{"location":"Api/Files/dir_76e799bfaed323ed7497703f1980580e/","text":"Commandline Directories Name Commandline/Tests Files Name Commandline/ConfigBind.hpp Commandline/ConfigurationManager.cpp Commandline/ConfigurationManager.hpp Commandline/IConfigBind.cpp Commandline/IConfigBind.hpp Commandline/ParameterParser.cpp Commandline/ParameterParser.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Commandline"},{"location":"Api/Files/dir_76e799bfaed323ed7497703f1980580e/#commandline","text":"","title":"Commandline"},{"location":"Api/Files/dir_76e799bfaed323ed7497703f1980580e/#directories","text":"Name Commandline/Tests","title":"Directories"},{"location":"Api/Files/dir_76e799bfaed323ed7497703f1980580e/#files","text":"Name Commandline/ConfigBind.hpp Commandline/ConfigurationManager.cpp Commandline/ConfigurationManager.hpp Commandline/IConfigBind.cpp Commandline/IConfigBind.hpp Commandline/ParameterParser.cpp Commandline/ParameterParser.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Files"},{"location":"Api/Files/dir_82b5296fc6745e5fe86b01060885a57b/","text":"ValidationPass Files Name ValidationPass/ValidationPass.cpp ValidationPass/ValidationPass.hpp ValidationPass/ValidationPassConfiguration.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"ValidationPass"},{"location":"Api/Files/dir_82b5296fc6745e5fe86b01060885a57b/#validationpass","text":"","title":"ValidationPass"},{"location":"Api/Files/dir_82b5296fc6745e5fe86b01060885a57b/#files","text":"Name ValidationPass/ValidationPass.cpp ValidationPass/ValidationPass.hpp ValidationPass/ValidationPassConfiguration.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Files"},{"location":"Api/Files/dir_8f912e5e736424b0d79274234fdd791d/","text":"TransformationRulesPass Directories Name TransformationRulesPass/Tests Files Name TransformationRulesPass/TransformationRulesPass.cpp TransformationRulesPass/TransformationRulesPass.hpp TransformationRulesPass/TransformationRulesPassConfiguration.cpp TransformationRulesPass/TransformationRulesPassConfiguration.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"TransformationRulesPass"},{"location":"Api/Files/dir_8f912e5e736424b0d79274234fdd791d/#transformationrulespass","text":"","title":"TransformationRulesPass"},{"location":"Api/Files/dir_8f912e5e736424b0d79274234fdd791d/#directories","text":"Name TransformationRulesPass/Tests","title":"Directories"},{"location":"Api/Files/dir_8f912e5e736424b0d79274234fdd791d/#files","text":"Name TransformationRulesPass/TransformationRulesPass.cpp TransformationRulesPass/TransformationRulesPass.hpp TransformationRulesPass/TransformationRulesPassConfiguration.cpp TransformationRulesPass/TransformationRulesPassConfiguration.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Files"},{"location":"Api/Files/dir_98fd089881264eb613bf89a45540d12f/","text":"AllocationManager/Tests Directories Name AllocationManager/Tests/Unit Updated on 22 November 2021 at 10:28:35 UTC","title":"AllocationManager/Tests"},{"location":"Api/Files/dir_98fd089881264eb613bf89a45540d12f/#allocationmanagertests","text":"","title":"AllocationManager/Tests"},{"location":"Api/Files/dir_98fd089881264eb613bf89a45540d12f/#directories","text":"Name AllocationManager/Tests/Unit Updated on 22 November 2021 at 10:28:35 UTC","title":"Directories"},{"location":"Api/Files/dir_9986e114415b3247b7f935fba61974ba/","text":"Llvm Files Name Llvm/Llvm.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Llvm"},{"location":"Api/Files/dir_9986e114415b3247b7f935fba61974ba/#llvm","text":"","title":"Llvm"},{"location":"Api/Files/dir_9986e114415b3247b7f935fba61974ba/#files","text":"Name Llvm/Llvm.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Files"},{"location":"Api/Files/dir_9d1d7e504383a34af727f7e894e011d6/","text":"AllocationManager/Tests/Unit Files Name AllocationManager/Tests/Unit/main.cpp Updated on 22 November 2021 at 10:28:35 UTC","title":"AllocationManager/Tests/Unit"},{"location":"Api/Files/dir_9d1d7e504383a34af727f7e894e011d6/#allocationmanagertestsunit","text":"","title":"AllocationManager/Tests/Unit"},{"location":"Api/Files/dir_9d1d7e504383a34af727f7e894e011d6/#files","text":"Name AllocationManager/Tests/Unit/main.cpp Updated on 22 November 2021 at 10:28:35 UTC","title":"Files"},{"location":"Api/Files/dir_a39c9fcb9602962ff81ab62a3013c5cf/","text":"Apps/Qat Files Name Apps/Qat/Qat.cpp Apps/Qat/QatConfig.cpp Apps/Qat/QatConfig.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Apps/Qat"},{"location":"Api/Files/dir_a39c9fcb9602962ff81ab62a3013c5cf/#appsqat","text":"","title":"Apps/Qat"},{"location":"Api/Files/dir_a39c9fcb9602962ff81ab62a3013c5cf/#files","text":"Name Apps/Qat/Qat.cpp Apps/Qat/QatConfig.cpp Apps/Qat/QatConfig.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Files"},{"location":"Api/Files/dir_b392e36b8bc0ffd1fb6a4bd773438243/","text":"Rules/Notation Files Name Rules/Notation/BasicBlock.cpp Rules/Notation/BitCast.cpp Rules/Notation/Branch.cpp Rules/Notation/Call.hpp Rules/Notation/Call.ipp Rules/Notation/CallByNameOnly.cpp Rules/Notation/Capture.cpp Rules/Notation/ConstInt.cpp Rules/Notation/IntToPtr.cpp Rules/Notation/Load.cpp Rules/Notation/Notation.cpp Rules/Notation/Notation.hpp Rules/Notation/Phi.ipp Rules/Notation/Select.cpp Rules/Notation/Store.cpp Rules/Notation/Switch.cpp Rules/Notation/UnnamedInvoke.cpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Notation"},{"location":"Api/Files/dir_b392e36b8bc0ffd1fb6a4bd773438243/#rulesnotation","text":"","title":"Rules/Notation"},{"location":"Api/Files/dir_b392e36b8bc0ffd1fb6a4bd773438243/#files","text":"Name Rules/Notation/BasicBlock.cpp Rules/Notation/BitCast.cpp Rules/Notation/Branch.cpp Rules/Notation/Call.hpp Rules/Notation/Call.ipp Rules/Notation/CallByNameOnly.cpp Rules/Notation/Capture.cpp Rules/Notation/ConstInt.cpp Rules/Notation/IntToPtr.cpp Rules/Notation/Load.cpp Rules/Notation/Notation.cpp Rules/Notation/Notation.hpp Rules/Notation/Phi.ipp Rules/Notation/Select.cpp Rules/Notation/Store.cpp Rules/Notation/Switch.cpp Rules/Notation/UnnamedInvoke.cpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Files"},{"location":"Api/Files/dir_b5c395f6bcd29dee1bce472ffc86b45d/","text":"Commandline/Tests Directories Name Commandline/Tests/Unit Updated on 22 November 2021 at 10:28:34 UTC","title":"Commandline/Tests"},{"location":"Api/Files/dir_b5c395f6bcd29dee1bce472ffc86b45d/#commandlinetests","text":"","title":"Commandline/Tests"},{"location":"Api/Files/dir_b5c395f6bcd29dee1bce472ffc86b45d/#directories","text":"Name Commandline/Tests/Unit Updated on 22 November 2021 at 10:28:34 UTC","title":"Directories"},{"location":"Api/Files/dir_b933e80d7be585e33e0b215013198969/","text":"Generators/Tests Directories Name Generators/Tests/Unit Updated on 22 November 2021 at 10:28:34 UTC","title":"Generators/Tests"},{"location":"Api/Files/dir_b933e80d7be585e33e0b215013198969/#generatorstests","text":"","title":"Generators/Tests"},{"location":"Api/Files/dir_b933e80d7be585e33e0b215013198969/#directories","text":"Name Generators/Tests/Unit Updated on 22 November 2021 at 10:28:34 UTC","title":"Directories"},{"location":"Api/Files/dir_ba276cc22cfffca1a089fe33ae082ee3/","text":"Profile Files Name Profile/Profile.cpp Profile/Profile.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Profile"},{"location":"Api/Files/dir_ba276cc22cfffca1a089fe33ae082ee3/#profile","text":"","title":"Profile"},{"location":"Api/Files/dir_ba276cc22cfffca1a089fe33ae082ee3/#files","text":"Name Profile/Profile.cpp Profile/Profile.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Files"},{"location":"Api/Files/dir_d31ef966b0cb1225b2b298e923bbc249/","text":"ModuleLoader Files Name ModuleLoader/ModuleLoader.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"ModuleLoader"},{"location":"Api/Files/dir_d31ef966b0cb1225b2b298e923bbc249/#moduleloader","text":"","title":"ModuleLoader"},{"location":"Api/Files/dir_d31ef966b0cb1225b2b298e923bbc249/#files","text":"Name ModuleLoader/ModuleLoader.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Files"},{"location":"Api/Files/dir_d9949a2e036493f8647151a4ab6ee0ce/","text":"Logging Files Name Logging/CommentLogger.cpp Logging/CommentLogger.hpp Logging/ILogger.cpp Logging/ILogger.hpp Logging/LogCollection.cpp Logging/LogCollection.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Logging"},{"location":"Api/Files/dir_d9949a2e036493f8647151a4ab6ee0ce/#logging","text":"","title":"Logging"},{"location":"Api/Files/dir_d9949a2e036493f8647151a4ab6ee0ce/#files","text":"Name Logging/CommentLogger.cpp Logging/CommentLogger.hpp Logging/ILogger.cpp Logging/ILogger.hpp Logging/LogCollection.cpp Logging/LogCollection.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Files"},{"location":"Api/Files/dir_e3ce76e123ee2294d37cd4ff5e418b83/","text":"Commandline/Tests/Unit Files Name Commandline/Tests/Unit/configuration.cpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Commandline/Tests/Unit"},{"location":"Api/Files/dir_e3ce76e123ee2294d37cd4ff5e418b83/#commandlinetestsunit","text":"","title":"Commandline/Tests/Unit"},{"location":"Api/Files/dir_e3ce76e123ee2294d37cd4ff5e418b83/#files","text":"Name Commandline/Tests/Unit/configuration.cpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Files"},{"location":"Api/Files/dir_ed349e2d4b607ef61e27eb2c0c0c4b3d/","text":"Rules Directories Name Rules/Notation Rules/Patterns Rules/Tests Files Name Rules/Factory.cpp Rules/Factory.hpp Rules/FactoryConfig.hpp Rules/IOperandPrototype.cpp Rules/IOperandPrototype.hpp Rules/ReplacementRule.cpp Rules/ReplacementRule.hpp Rules/RuleSet.cpp Rules/RuleSet.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules"},{"location":"Api/Files/dir_ed349e2d4b607ef61e27eb2c0c0c4b3d/#rules","text":"","title":"Rules"},{"location":"Api/Files/dir_ed349e2d4b607ef61e27eb2c0c0c4b3d/#directories","text":"Name Rules/Notation Rules/Patterns Rules/Tests","title":"Directories"},{"location":"Api/Files/dir_ed349e2d4b607ef61e27eb2c0c0c4b3d/#files","text":"Name Rules/Factory.cpp Rules/Factory.hpp Rules/FactoryConfig.hpp Rules/IOperandPrototype.cpp Rules/IOperandPrototype.hpp Rules/ReplacementRule.cpp Rules/ReplacementRule.hpp Rules/RuleSet.cpp Rules/RuleSet.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Files"},{"location":"Api/Files/dir_f11d3c47e762e38fcdfbd4cfb049caab/","text":"Rules/Patterns Files Name Rules/Patterns/AnyPattern.cpp Rules/Patterns/AnyPattern.hpp Rules/Patterns/CallPattern.cpp Rules/Patterns/CallPattern.hpp Rules/Patterns/Instruction.cpp Rules/Patterns/Instruction.hpp Rules/Patterns/PhiPattern.cpp Rules/Patterns/PhiPattern.hpp Rules/Patterns/UnnamedInvokePattern.cpp Rules/Patterns/UnnamedInvokePattern.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Rules/Patterns"},{"location":"Api/Files/dir_f11d3c47e762e38fcdfbd4cfb049caab/#rulespatterns","text":"","title":"Rules/Patterns"},{"location":"Api/Files/dir_f11d3c47e762e38fcdfbd4cfb049caab/#files","text":"Name Rules/Patterns/AnyPattern.cpp Rules/Patterns/AnyPattern.hpp Rules/Patterns/CallPattern.cpp Rules/Patterns/CallPattern.hpp Rules/Patterns/Instruction.cpp Rules/Patterns/Instruction.hpp Rules/Patterns/PhiPattern.cpp Rules/Patterns/PhiPattern.hpp Rules/Patterns/UnnamedInvokePattern.cpp Rules/Patterns/UnnamedInvokePattern.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Files"},{"location":"Api/Files/dir_f32fa1f684a45b73f347439bab6df68d/","text":"Validator Files Name Validator/Validator.cpp Validator/Validator.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Validator"},{"location":"Api/Files/dir_f32fa1f684a45b73f347439bab6df68d/#validator","text":"","title":"Validator"},{"location":"Api/Files/dir_f32fa1f684a45b73f347439bab6df68d/#files","text":"Name Validator/Validator.cpp Validator/Validator.hpp Updated on 22 November 2021 at 10:28:34 UTC","title":"Files"},{"location":"Api/Modules/","text":"Modules group Shorthand Notation Updated on 22 November 2021 at 10:28:35 UTC","title":"Modules"},{"location":"Api/Modules/#modules","text":"group Shorthand Notation Updated on 22 November 2021 at 10:28:35 UTC","title":"Modules"},{"location":"Api/Modules/group__shorthand_notation/","text":"Shorthand Notation More... Functions Name Capture (std::string const & name) Explicit creation using string name constructor. IOperandPrototypePtr operator= (IOperandPrototypePtr const & other) template <typename... Args> IOperandPrototypePtr call (std::string const & name, Args... args) IOperandPrototypePtr unnamedInvoke () Matches a invoke instruction. template <typename... Args> IOperandPrototypePtr phi (Args... args) Matches a phi node with N arguments. IOperandPrototypePtr callByNameOnly (std::string const & name) IOperandPrototypePtr bitCast (IOperandPrototypePtr const & arg) Matches the llvm::BitCast instructruction. IOperandPrototypePtr intToPtr (IOperandPrototypePtr const & arg) Matches the llvm::IntToPtr instructruction. IOperandPrototypePtr constInt () Matches the llvm::ConstantInt instructruction. IOperandPrototypePtr branch (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a branch instruction given a condition and two arguments. IOperandPrototypePtr switchOp (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) IOperandPrototypePtr select (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a select instruction given a condition and two arguments. IOperandPrototypePtr load (IOperandPrototypePtr const & arg) Matches a load instruction with one argument. IOperandPrototypePtr store (IOperandPrototypePtr const & target, IOperandPrototypePtr const & value) IOperandPrototypePtr basicBlock () Matches a load instruction with one argument. ReplacerFunction deleteInstruction () Capture operator\"\"_cap (char const * name, std::size_t ) Attributes Name const std::shared_ptr< AnyPattern > _ Detailed Description Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern auto get_one = call(\"__quantum__rt__result_get_one\"); addRule( {branch(\"cond\"_cap = call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), _, _), replace_branch_positive}); which matches IRs of the form %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: cond , result and one each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function). The module further has shorthand notation for often encountered patterns such as any operand. The module also implements shorthand notation for common replacers. Literals which ease the burned of capturing values and increase readibility of the code. Functions Documentation function Capture explicit Capture( std::string const & name ) Explicit creation using string name constructor. function operator= IOperandPrototypePtr operator=( IOperandPrototypePtr const & other ) function call template <typename... Args> IOperandPrototypePtr call( std::string const & name, Args... args ) Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern auto get_one = call(\"__quantum__rt__result_get_one\"); addRule( {branch(\"cond\"_cap = call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), _, _), replace_branch_positive}); which matches IRs of the form %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: cond , result and one each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function). Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments. Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments. function unnamedInvoke IOperandPrototypePtr unnamedInvoke() Matches a invoke instruction. function phi template <typename... Args> IOperandPrototypePtr phi( Args... args ) Matches a phi node with N arguments. function callByNameOnly IOperandPrototypePtr callByNameOnly( std::string const & name ) Shorthand notation to match an instruction with a specified name. Unlike call, this pattern matches by name only and ignore the arguments. addRule({callByNameOnly(\"foo\"), deleteInstruction()}); matches calls to the function foo regardless of the number of arguments. function bitCast IOperandPrototypePtr bitCast( IOperandPrototypePtr const & arg ) Matches the llvm::BitCast instructruction. function intToPtr IOperandPrototypePtr intToPtr( IOperandPrototypePtr const & arg ) Matches the llvm::IntToPtr instructruction. function constInt IOperandPrototypePtr constInt() Matches the llvm::ConstantInt instructruction. function branch IOperandPrototypePtr branch( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a branch instruction given a condition and two arguments. function switchOp IOperandPrototypePtr switchOp( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) function select IOperandPrototypePtr select( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a select instruction given a condition and two arguments. function load IOperandPrototypePtr load( IOperandPrototypePtr const & arg ) Matches a load instruction with one argument. function store IOperandPrototypePtr store( IOperandPrototypePtr const & target, IOperandPrototypePtr const & value ) Matches a store instruction with a target and a value. addRule({store(\"target\"_cap = _, \"value\"_cap = _), replaceConstExpr}); where we want to match all store instructions and do not really care about how the target or value came about. In this case, we may want to capture the values to, for instance, make assignment at compile time. function basicBlock IOperandPrototypePtr basicBlock() Matches a load instruction with one argument. function deleteInstruction ReplacerFunction deleteInstruction() Shorthand notation to delete an instruction. If passed as the replacement function, this function generates a replacer that deletes the instruction. This is a shorthand notation for deleting an instruction that can be used with a custom rule when building a ruleset. This function can be used with shorthand notation for patterns as follows: addRule({callByNameOnly(name), deleteInstruction()}); to delete the instructions that calls functions with the name name . function operator\"\"_cap Capture operator\"\"_cap( char const * name, std::size_t ) Literal for specifying the capture of a llvm::Value*. This literal calls the IOperandPrototype::enableCapture through the assignment of a IOperandPrototypePtr to the class Capture . As an example, one may want to match the pattern foo(bar(baz(x)), y) and extract the variable x to add meta data to it. The corresponding IR could look like: %1 = call %Type* @baz(%Type* %0) %2 = call %Type* @bar(%Type* %1) call void @foo(%Type* %2, %Type* %3) To match this pattern, one would create the pattern call(\"foo\", call(\"bar\", call(\"baz\", \"x\"_cap = _)), _) . This pattern would ensure that at the time where the replacer function is called, the value stored in %0 is captured under the name x . Attributes Documentation variable _ static const std::shared_ptr< AnyPattern > _ = std::make_shared<AnyPattern>(); Shorthand notation for a wildcard which matches anything. This value is useful when for instance capturing the arguments of a function call where the origin of the value does not matter to the pattern. Updated on 22 November 2021 at 10:28:34 UTC","title":"Shorthand Notation"},{"location":"Api/Modules/group__shorthand_notation/#shorthand-notation","text":"More...","title":"Shorthand Notation"},{"location":"Api/Modules/group__shorthand_notation/#functions","text":"Name Capture (std::string const & name) Explicit creation using string name constructor. IOperandPrototypePtr operator= (IOperandPrototypePtr const & other) template <typename... Args> IOperandPrototypePtr call (std::string const & name, Args... args) IOperandPrototypePtr unnamedInvoke () Matches a invoke instruction. template <typename... Args> IOperandPrototypePtr phi (Args... args) Matches a phi node with N arguments. IOperandPrototypePtr callByNameOnly (std::string const & name) IOperandPrototypePtr bitCast (IOperandPrototypePtr const & arg) Matches the llvm::BitCast instructruction. IOperandPrototypePtr intToPtr (IOperandPrototypePtr const & arg) Matches the llvm::IntToPtr instructruction. IOperandPrototypePtr constInt () Matches the llvm::ConstantInt instructruction. IOperandPrototypePtr branch (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a branch instruction given a condition and two arguments. IOperandPrototypePtr switchOp (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) IOperandPrototypePtr select (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a select instruction given a condition and two arguments. IOperandPrototypePtr load (IOperandPrototypePtr const & arg) Matches a load instruction with one argument. IOperandPrototypePtr store (IOperandPrototypePtr const & target, IOperandPrototypePtr const & value) IOperandPrototypePtr basicBlock () Matches a load instruction with one argument. ReplacerFunction deleteInstruction () Capture operator\"\"_cap (char const * name, std::size_t )","title":"Functions"},{"location":"Api/Modules/group__shorthand_notation/#attributes","text":"Name const std::shared_ptr< AnyPattern > _","title":"Attributes"},{"location":"Api/Modules/group__shorthand_notation/#detailed-description","text":"Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern auto get_one = call(\"__quantum__rt__result_get_one\"); addRule( {branch(\"cond\"_cap = call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), _, _), replace_branch_positive}); which matches IRs of the form %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: cond , result and one each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function). The module further has shorthand notation for often encountered patterns such as any operand. The module also implements shorthand notation for common replacers. Literals which ease the burned of capturing values and increase readibility of the code.","title":"Detailed Description"},{"location":"Api/Modules/group__shorthand_notation/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Modules/group__shorthand_notation/#function-capture","text":"explicit Capture( std::string const & name ) Explicit creation using string name constructor.","title":"function Capture"},{"location":"Api/Modules/group__shorthand_notation/#function-operator","text":"IOperandPrototypePtr operator=( IOperandPrototypePtr const & other )","title":"function operator="},{"location":"Api/Modules/group__shorthand_notation/#function-call","text":"template <typename... Args> IOperandPrototypePtr call( std::string const & name, Args... args ) Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern auto get_one = call(\"__quantum__rt__result_get_one\"); addRule( {branch(\"cond\"_cap = call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), _, _), replace_branch_positive}); which matches IRs of the form %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: cond , result and one each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function). Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments. Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments.","title":"function call"},{"location":"Api/Modules/group__shorthand_notation/#function-unnamedinvoke","text":"IOperandPrototypePtr unnamedInvoke() Matches a invoke instruction.","title":"function unnamedInvoke"},{"location":"Api/Modules/group__shorthand_notation/#function-phi","text":"template <typename... Args> IOperandPrototypePtr phi( Args... args ) Matches a phi node with N arguments.","title":"function phi"},{"location":"Api/Modules/group__shorthand_notation/#function-callbynameonly","text":"IOperandPrototypePtr callByNameOnly( std::string const & name ) Shorthand notation to match an instruction with a specified name. Unlike call, this pattern matches by name only and ignore the arguments. addRule({callByNameOnly(\"foo\"), deleteInstruction()}); matches calls to the function foo regardless of the number of arguments.","title":"function callByNameOnly"},{"location":"Api/Modules/group__shorthand_notation/#function-bitcast","text":"IOperandPrototypePtr bitCast( IOperandPrototypePtr const & arg ) Matches the llvm::BitCast instructruction.","title":"function bitCast"},{"location":"Api/Modules/group__shorthand_notation/#function-inttoptr","text":"IOperandPrototypePtr intToPtr( IOperandPrototypePtr const & arg ) Matches the llvm::IntToPtr instructruction.","title":"function intToPtr"},{"location":"Api/Modules/group__shorthand_notation/#function-constint","text":"IOperandPrototypePtr constInt() Matches the llvm::ConstantInt instructruction.","title":"function constInt"},{"location":"Api/Modules/group__shorthand_notation/#function-branch","text":"IOperandPrototypePtr branch( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a branch instruction given a condition and two arguments.","title":"function branch"},{"location":"Api/Modules/group__shorthand_notation/#function-switchop","text":"IOperandPrototypePtr switchOp( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 )","title":"function switchOp"},{"location":"Api/Modules/group__shorthand_notation/#function-select","text":"IOperandPrototypePtr select( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a select instruction given a condition and two arguments.","title":"function select"},{"location":"Api/Modules/group__shorthand_notation/#function-load","text":"IOperandPrototypePtr load( IOperandPrototypePtr const & arg ) Matches a load instruction with one argument.","title":"function load"},{"location":"Api/Modules/group__shorthand_notation/#function-store","text":"IOperandPrototypePtr store( IOperandPrototypePtr const & target, IOperandPrototypePtr const & value ) Matches a store instruction with a target and a value. addRule({store(\"target\"_cap = _, \"value\"_cap = _), replaceConstExpr}); where we want to match all store instructions and do not really care about how the target or value came about. In this case, we may want to capture the values to, for instance, make assignment at compile time.","title":"function store"},{"location":"Api/Modules/group__shorthand_notation/#function-basicblock","text":"IOperandPrototypePtr basicBlock() Matches a load instruction with one argument.","title":"function basicBlock"},{"location":"Api/Modules/group__shorthand_notation/#function-deleteinstruction","text":"ReplacerFunction deleteInstruction() Shorthand notation to delete an instruction. If passed as the replacement function, this function generates a replacer that deletes the instruction. This is a shorthand notation for deleting an instruction that can be used with a custom rule when building a ruleset. This function can be used with shorthand notation for patterns as follows: addRule({callByNameOnly(name), deleteInstruction()}); to delete the instructions that calls functions with the name name .","title":"function deleteInstruction"},{"location":"Api/Modules/group__shorthand_notation/#function-operator_cap","text":"Capture operator\"\"_cap( char const * name, std::size_t ) Literal for specifying the capture of a llvm::Value*. This literal calls the IOperandPrototype::enableCapture through the assignment of a IOperandPrototypePtr to the class Capture . As an example, one may want to match the pattern foo(bar(baz(x)), y) and extract the variable x to add meta data to it. The corresponding IR could look like: %1 = call %Type* @baz(%Type* %0) %2 = call %Type* @bar(%Type* %1) call void @foo(%Type* %2, %Type* %3) To match this pattern, one would create the pattern call(\"foo\", call(\"bar\", call(\"baz\", \"x\"_cap = _)), _) . This pattern would ensure that at the time where the replacer function is called, the value stored in %0 is captured under the name x .","title":"function operator\"\"_cap"},{"location":"Api/Modules/group__shorthand_notation/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Api/Modules/group__shorthand_notation/#variable-_","text":"static const std::shared_ptr< AnyPattern > _ = std::make_shared<AnyPattern>(); Shorthand notation for a wildcard which matches anything. This value is useful when for instance capturing the arguments of a function call where the origin of the value does not matter to the pattern. Updated on 22 November 2021 at 10:28:34 UTC","title":"variable _"},{"location":"Api/Namespaces/","text":"Namespaces namespace @15 namespace @22 namespace @71 namespace @72 namespace @73 namespace @74 namespace @75 namespace @76 namespace @78 namespace @79 namespace @80 namespace @81 namespace @82 namespace @86 namespace @87 namespace @88 namespace llvm namespace microsoft namespace quantum namespace notation namespace microsoft::quantum::@35 namespace microsoft::quantum::@83 Updated on 22 November 2021 at 10:28:35 UTC","title":"Namespaces"},{"location":"Api/Namespaces/#namespaces","text":"namespace @15 namespace @22 namespace @71 namespace @72 namespace @73 namespace @74 namespace @75 namespace @76 namespace @78 namespace @79 namespace @80 namespace @81 namespace @82 namespace @86 namespace @87 namespace @88 namespace llvm namespace microsoft namespace quantum namespace notation namespace microsoft::quantum::@35 namespace microsoft::quantum::@83 Updated on 22 November 2021 at 10:28:35 UTC","title":"Namespaces"},{"location":"Api/Namespaces/namespace_0d15/","text":"title: @15 @15 Updated on 22 November 2021 at 10:28:34 UTC","title":"Namespace 0d15"},{"location":"Api/Namespaces/namespace_0d15/#15","text":"Updated on 22 November 2021 at 10:28:34 UTC","title":"@15"},{"location":"Api/Namespaces/namespace_0d22/","text":"title: @22 @22 Updated on 22 November 2021 at 10:28:34 UTC","title":"Namespace 0d22"},{"location":"Api/Namespaces/namespace_0d22/#22","text":"Updated on 22 November 2021 at 10:28:34 UTC","title":"@22"},{"location":"Api/Namespaces/namespace_0d71/","text":"title: @71 @71 Updated on 22 November 2021 at 10:28:34 UTC","title":"Namespace 0d71"},{"location":"Api/Namespaces/namespace_0d71/#71","text":"Updated on 22 November 2021 at 10:28:34 UTC","title":"@71"},{"location":"Api/Namespaces/namespace_0d72/","text":"title: @72 @72 Updated on 22 November 2021 at 10:28:34 UTC","title":"Namespace 0d72"},{"location":"Api/Namespaces/namespace_0d72/#72","text":"Updated on 22 November 2021 at 10:28:34 UTC","title":"@72"},{"location":"Api/Namespaces/namespace_0d73/","text":"title: @73 @73 Updated on 22 November 2021 at 10:28:34 UTC","title":"Namespace 0d73"},{"location":"Api/Namespaces/namespace_0d73/#73","text":"Updated on 22 November 2021 at 10:28:34 UTC","title":"@73"},{"location":"Api/Namespaces/namespace_0d74/","text":"title: @74 @74 Updated on 22 November 2021 at 10:28:34 UTC","title":"Namespace 0d74"},{"location":"Api/Namespaces/namespace_0d74/#74","text":"Updated on 22 November 2021 at 10:28:34 UTC","title":"@74"},{"location":"Api/Namespaces/namespace_0d75/","text":"title: @75 @75 Updated on 22 November 2021 at 10:28:34 UTC","title":"Namespace 0d75"},{"location":"Api/Namespaces/namespace_0d75/#75","text":"Updated on 22 November 2021 at 10:28:34 UTC","title":"@75"},{"location":"Api/Namespaces/namespace_0d76/","text":"title: @76 @76 Updated on 22 November 2021 at 10:28:34 UTC","title":"Namespace 0d76"},{"location":"Api/Namespaces/namespace_0d76/#76","text":"Updated on 22 November 2021 at 10:28:34 UTC","title":"@76"},{"location":"Api/Namespaces/namespace_0d78/","text":"title: @78 @78 Updated on 22 November 2021 at 10:28:34 UTC","title":"Namespace 0d78"},{"location":"Api/Namespaces/namespace_0d78/#78","text":"Updated on 22 November 2021 at 10:28:34 UTC","title":"@78"},{"location":"Api/Namespaces/namespace_0d79/","text":"title: @79 @79 Updated on 22 November 2021 at 10:28:34 UTC","title":"Namespace 0d79"},{"location":"Api/Namespaces/namespace_0d79/#79","text":"Updated on 22 November 2021 at 10:28:34 UTC","title":"@79"},{"location":"Api/Namespaces/namespace_0d80/","text":"title: @80 @80 Updated on 22 November 2021 at 10:28:34 UTC","title":"Namespace 0d80"},{"location":"Api/Namespaces/namespace_0d80/#80","text":"Updated on 22 November 2021 at 10:28:34 UTC","title":"@80"},{"location":"Api/Namespaces/namespace_0d81/","text":"title: @81 @81 Updated on 22 November 2021 at 10:28:34 UTC","title":"Namespace 0d81"},{"location":"Api/Namespaces/namespace_0d81/#81","text":"Updated on 22 November 2021 at 10:28:34 UTC","title":"@81"},{"location":"Api/Namespaces/namespace_0d82/","text":"title: @82 @82 Updated on 22 November 2021 at 10:28:34 UTC","title":"Namespace 0d82"},{"location":"Api/Namespaces/namespace_0d82/#82","text":"Updated on 22 November 2021 at 10:28:34 UTC","title":"@82"},{"location":"Api/Namespaces/namespace_0d86/","text":"title: @86 @86 Updated on 22 November 2021 at 10:28:34 UTC","title":"Namespace 0d86"},{"location":"Api/Namespaces/namespace_0d86/#86","text":"Updated on 22 November 2021 at 10:28:34 UTC","title":"@86"},{"location":"Api/Namespaces/namespace_0d87/","text":"title: @87 @87 Updated on 22 November 2021 at 10:28:34 UTC","title":"Namespace 0d87"},{"location":"Api/Namespaces/namespace_0d87/#87","text":"Updated on 22 November 2021 at 10:28:34 UTC","title":"@87"},{"location":"Api/Namespaces/namespace_0d88/","text":"title: @88 @88 Updated on 22 November 2021 at 10:28:34 UTC","title":"Namespace 0d88"},{"location":"Api/Namespaces/namespace_0d88/#88","text":"Updated on 22 November 2021 at 10:28:34 UTC","title":"@88"},{"location":"Api/Namespaces/namespacellvm/","text":"llvm More... Detailed Description QIR Adaptor Tool (QAT) QAT is a tool that helps the enduser to easily build and use new profiles. The tool provides a commandline interface which is configurable through YAML files to validate a specific QIR profile and generate a QIR profile compatible IR from a generic IR. The tool itself make use of LLVM passes to perform analysis and transformations of the supplied IR. These transfornations are described through high-level tasks such as useStaticQubitArrayAllocation . To provide an overview of the structure of this tool, we here provide a diagram showing the relation between different instances in the program: \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 User input \u2502 \u2502 \"Use\" relation \u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u25bc \u2502 argc, argv \u25bc \u2500 \u2500\u25b6 \"Produce\" relation \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ParameterParser \u2502\u25c0\u2500\u2510 Setup arguments \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 Load config \u2502 \u2502 \u25bc \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ConfigurationManager \u2502\u2500\u2500\u2518 \u250c \u2500 \u2500 \u2500\u25b6\u2502 Ruleset \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Provide config \u2502 \u2502 \u2502 Rules for \u25bc \u25bc transformation \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2500 \u2500 \u2500 \u2518 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ProfileGenerator \u2502\u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500\u25b6\u2502 TransformationRulesPass \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 LLVM module \u25bc pass \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 Output \u2502\u25c0\u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2524 QAT / LLVM Module Pass Manager \u2502 \u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 stdout \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Updated on 22 November 2021 at 10:28:34 UTC","title":"llvm"},{"location":"Api/Namespaces/namespacellvm/#llvm","text":"More...","title":"llvm"},{"location":"Api/Namespaces/namespacellvm/#detailed-description","text":"QIR Adaptor Tool (QAT) QAT is a tool that helps the enduser to easily build and use new profiles. The tool provides a commandline interface which is configurable through YAML files to validate a specific QIR profile and generate a QIR profile compatible IR from a generic IR. The tool itself make use of LLVM passes to perform analysis and transformations of the supplied IR. These transfornations are described through high-level tasks such as useStaticQubitArrayAllocation . To provide an overview of the structure of this tool, we here provide a diagram showing the relation between different instances in the program: \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 User input \u2502 \u2502 \"Use\" relation \u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u25bc \u2502 argc, argv \u25bc \u2500 \u2500\u25b6 \"Produce\" relation \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ParameterParser \u2502\u25c0\u2500\u2510 Setup arguments \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 Load config \u2502 \u2502 \u25bc \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ConfigurationManager \u2502\u2500\u2500\u2518 \u250c \u2500 \u2500 \u2500\u25b6\u2502 Ruleset \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Provide config \u2502 \u2502 \u2502 Rules for \u25bc \u25bc transformation \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2500 \u2500 \u2500 \u2518 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 ProfileGenerator \u2502\u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500\u25b6\u2502 TransformationRulesPass \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 LLVM module \u25bc pass \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 Output \u2502\u25c0\u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2524 QAT / LLVM Module Pass Manager \u2502 \u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 stdout \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Updated on 22 November 2021 at 10:28:34 UTC","title":"Detailed Description"},{"location":"Api/Namespaces/namespacemicrosoft/","text":"microsoft Namespaces Name microsoft::quantum Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft"},{"location":"Api/Namespaces/namespacemicrosoft/#microsoft","text":"","title":"microsoft"},{"location":"Api/Namespaces/namespacemicrosoft/#namespaces","text":"Name microsoft::quantum Updated on 22 November 2021 at 10:28:34 UTC","title":"Namespaces"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/","text":"microsoft::quantum Namespaces Name microsoft::quantum::notation Classes Name class microsoft::quantum::AnyPattern Pattern that matches any operand. class microsoft::quantum::BasicAllocationManager class microsoft::quantum::BasicBlockPattern class microsoft::quantum::BitCastPattern class microsoft::quantum::BranchPattern class microsoft::quantum::CallPattern class microsoft::quantum::CommentLogger Concrete ILogger implementation that prints all messages as IR comments to llvm::errs(). class microsoft::quantum::ConfigBind class microsoft::quantum::ConfigurationManager class microsoft::quantum::ConstIntPattern class microsoft::quantum::DefaultProfileGenerator class microsoft::quantum::FactoryConfiguration class microsoft::quantum::IAllocationManager class microsoft::quantum::IConfigBind class microsoft::quantum::ILogger class microsoft::quantum::IntToPtrPattern class microsoft::quantum::IOperandPrototype class microsoft::quantum::IrManipulationTestHelper class microsoft::quantum::LlvmPassesConfiguration class microsoft::quantum::LoadPattern class microsoft::quantum::LogCollection class microsoft::quantum::ModuleLoader class microsoft::quantum::ParameterParser class microsoft::quantum::PhiPattern class microsoft::quantum::Profile class microsoft::quantum::ProfileGenerator class microsoft::quantum::QatConfig Main configuration class for the qat command-line program. class microsoft::quantum::RemoveDisallowedAttributesPass class microsoft::quantum::ReplacementRule class microsoft::quantum::RuleFactory class microsoft::quantum::RuleSet class microsoft::quantum::SelectPattern class microsoft::quantum::StorePattern class microsoft::quantum::SwitchPattern class microsoft::quantum::TransformationRulesPass class microsoft::quantum::TransformationRulesPassConfiguration Configuration class for the RuleTransformation pass. class microsoft::quantum::UnnamedInvokePattern class microsoft::quantum::ValidationPass class microsoft::quantum::ValidationPassConfiguration class microsoft::quantum::Validator Types Name using std::string String using RuleFactory::ReplacementRulePtr ReplacementRulePtr Types Documentation using String using microsoft::quantum::String = typedef std::string; using ReplacementRulePtr using microsoft::quantum::ReplacementRulePtr = typedef RuleFactory::ReplacementRulePtr; Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#microsoftquantum","text":"","title":"microsoft::quantum"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#namespaces","text":"Name microsoft::quantum::notation","title":"Namespaces"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#classes","text":"Name class microsoft::quantum::AnyPattern Pattern that matches any operand. class microsoft::quantum::BasicAllocationManager class microsoft::quantum::BasicBlockPattern class microsoft::quantum::BitCastPattern class microsoft::quantum::BranchPattern class microsoft::quantum::CallPattern class microsoft::quantum::CommentLogger Concrete ILogger implementation that prints all messages as IR comments to llvm::errs(). class microsoft::quantum::ConfigBind class microsoft::quantum::ConfigurationManager class microsoft::quantum::ConstIntPattern class microsoft::quantum::DefaultProfileGenerator class microsoft::quantum::FactoryConfiguration class microsoft::quantum::IAllocationManager class microsoft::quantum::IConfigBind class microsoft::quantum::ILogger class microsoft::quantum::IntToPtrPattern class microsoft::quantum::IOperandPrototype class microsoft::quantum::IrManipulationTestHelper class microsoft::quantum::LlvmPassesConfiguration class microsoft::quantum::LoadPattern class microsoft::quantum::LogCollection class microsoft::quantum::ModuleLoader class microsoft::quantum::ParameterParser class microsoft::quantum::PhiPattern class microsoft::quantum::Profile class microsoft::quantum::ProfileGenerator class microsoft::quantum::QatConfig Main configuration class for the qat command-line program. class microsoft::quantum::RemoveDisallowedAttributesPass class microsoft::quantum::ReplacementRule class microsoft::quantum::RuleFactory class microsoft::quantum::RuleSet class microsoft::quantum::SelectPattern class microsoft::quantum::StorePattern class microsoft::quantum::SwitchPattern class microsoft::quantum::TransformationRulesPass class microsoft::quantum::TransformationRulesPassConfiguration Configuration class for the RuleTransformation pass. class microsoft::quantum::UnnamedInvokePattern class microsoft::quantum::ValidationPass class microsoft::quantum::ValidationPassConfiguration class microsoft::quantum::Validator","title":"Classes"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#types","text":"Name using std::string String using RuleFactory::ReplacementRulePtr ReplacementRulePtr","title":"Types"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#types-documentation","text":"","title":"Types Documentation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#using-string","text":"using microsoft::quantum::String = typedef std::string;","title":"using String"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum/#using-replacementruleptr","text":"using microsoft::quantum::ReplacementRulePtr = typedef RuleFactory::ReplacementRulePtr; Updated on 22 November 2021 at 10:28:34 UTC","title":"using ReplacementRulePtr"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1_0d35/","text":"microsoft::quantum::@35 Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::@35"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1_0d35/#microsoftquantum35","text":"Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::@35"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1_0d83/","text":"microsoft::quantum::@83 Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::@83"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1_0d83/#microsoftquantum83","text":"Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::@83"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/","text":"microsoft::quantum::notation More... Classes Name class microsoft::quantum::notation::Capture Types Name typedef std::shared_ptr< IOperandPrototype > IOperandPrototypePtr using std::function< bool( ReplacementRule::Builder &, ReplacementRule::Value *, ReplacementRule::Captures &, ReplacementRule::Replacements &)> ReplacerFunction Functions Name IOperandPrototypePtr basicBlock () Matches a load instruction with one argument. IOperandPrototypePtr bitCast (IOperandPrototypePtr const & arg) Matches the llvm::BitCast instructruction. IOperandPrototypePtr branch (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a branch instruction given a condition and two arguments. template <typename... Args> IOperandPrototypePtr call (std::string const & name, Args... args) IOperandPrototypePtr callByNameOnly (std::string const & name) Capture operator\"\"_cap (char const * name, std::size_t ) IOperandPrototypePtr constInt () Matches the llvm::ConstantInt instructruction. IOperandPrototypePtr intToPtr (IOperandPrototypePtr const & arg) Matches the llvm::IntToPtr instructruction. IOperandPrototypePtr load (IOperandPrototypePtr const & arg) Matches a load instruction with one argument. ReplacerFunction deleteInstruction () IOperandPrototypePtr unnamedInvoke () Matches a invoke instruction. template <typename... Args> IOperandPrototypePtr phi (Args... args) Matches a phi node with N arguments. IOperandPrototypePtr switchOp (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) IOperandPrototypePtr select (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a select instruction given a condition and two arguments. IOperandPrototypePtr store (IOperandPrototypePtr const & target, IOperandPrototypePtr const & value) Attributes Name const std::shared_ptr< AnyPattern > _ Detailed Description Shorthand notations to make it easy and readible to create patterns. Types Documentation typedef IOperandPrototypePtr typedef std::shared_ptr< IOperandPrototype > microsoft::quantum::notation::IOperandPrototypePtr; using ReplacerFunction using microsoft::quantum::notation::ReplacerFunction = typedef std::function<bool( ReplacementRule::Builder&, ReplacementRule::Value*, ReplacementRule::Captures&, ReplacementRule::Replacements&)>; Functions Documentation function basicBlock IOperandPrototypePtr basicBlock() Matches a load instruction with one argument. function bitCast IOperandPrototypePtr bitCast( IOperandPrototypePtr const & arg ) Matches the llvm::BitCast instructruction. function branch IOperandPrototypePtr branch( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a branch instruction given a condition and two arguments. function call template <typename... Args> IOperandPrototypePtr call( std::string const & name, Args... args ) Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern auto get_one = call(\"__quantum__rt__result_get_one\"); addRule( {branch(\"cond\"_cap = call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), _, _), replace_branch_positive}); which matches IRs of the form %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: cond , result and one each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function). Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments. Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments. function callByNameOnly IOperandPrototypePtr callByNameOnly( std::string const & name ) Shorthand notation to match an instruction with a specified name. Unlike call, this pattern matches by name only and ignore the arguments. addRule({callByNameOnly(\"foo\"), deleteInstruction()}); matches calls to the function foo regardless of the number of arguments. function operator\"\"_cap Capture operator\"\"_cap( char const * name, std::size_t ) Literal for specifying the capture of a llvm::Value*. This literal calls the IOperandPrototype::enableCapture through the assignment of a IOperandPrototypePtr to the class Capture . As an example, one may want to match the pattern foo(bar(baz(x)), y) and extract the variable x to add meta data to it. The corresponding IR could look like: %1 = call %Type* @baz(%Type* %0) %2 = call %Type* @bar(%Type* %1) call void @foo(%Type* %2, %Type* %3) To match this pattern, one would create the pattern call(\"foo\", call(\"bar\", call(\"baz\", \"x\"_cap = _)), _) . This pattern would ensure that at the time where the replacer function is called, the value stored in %0 is captured under the name x . function constInt IOperandPrototypePtr constInt() Matches the llvm::ConstantInt instructruction. function intToPtr IOperandPrototypePtr intToPtr( IOperandPrototypePtr const & arg ) Matches the llvm::IntToPtr instructruction. function load IOperandPrototypePtr load( IOperandPrototypePtr const & arg ) Matches a load instruction with one argument. function deleteInstruction ReplacerFunction deleteInstruction() Shorthand notation to delete an instruction. If passed as the replacement function, this function generates a replacer that deletes the instruction. This is a shorthand notation for deleting an instruction that can be used with a custom rule when building a ruleset. This function can be used with shorthand notation for patterns as follows: addRule({callByNameOnly(name), deleteInstruction()}); to delete the instructions that calls functions with the name name . function unnamedInvoke IOperandPrototypePtr unnamedInvoke() Matches a invoke instruction. function phi template <typename... Args> IOperandPrototypePtr phi( Args... args ) Matches a phi node with N arguments. function switchOp IOperandPrototypePtr switchOp( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) function select IOperandPrototypePtr select( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a select instruction given a condition and two arguments. function store IOperandPrototypePtr store( IOperandPrototypePtr const & target, IOperandPrototypePtr const & value ) Matches a store instruction with a target and a value. addRule({store(\"target\"_cap = _, \"value\"_cap = _), replaceConstExpr}); where we want to match all store instructions and do not really care about how the target or value came about. In this case, we may want to capture the values to, for instance, make assignment at compile time. Attributes Documentation variable _ static const std::shared_ptr< AnyPattern > _ = std::make_shared<[AnyPattern](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/)>(); Shorthand notation for a wildcard which matches anything. This value is useful when for instance capturing the arguments of a function call where the origin of the value does not matter to the pattern. Updated on 22 November 2021 at 10:28:34 UTC","title":"microsoft::quantum::notation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#microsoftquantumnotation","text":"More...","title":"microsoft::quantum::notation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#classes","text":"Name class microsoft::quantum::notation::Capture","title":"Classes"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#types","text":"Name typedef std::shared_ptr< IOperandPrototype > IOperandPrototypePtr using std::function< bool( ReplacementRule::Builder &, ReplacementRule::Value *, ReplacementRule::Captures &, ReplacementRule::Replacements &)> ReplacerFunction","title":"Types"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#functions","text":"Name IOperandPrototypePtr basicBlock () Matches a load instruction with one argument. IOperandPrototypePtr bitCast (IOperandPrototypePtr const & arg) Matches the llvm::BitCast instructruction. IOperandPrototypePtr branch (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a branch instruction given a condition and two arguments. template <typename... Args> IOperandPrototypePtr call (std::string const & name, Args... args) IOperandPrototypePtr callByNameOnly (std::string const & name) Capture operator\"\"_cap (char const * name, std::size_t ) IOperandPrototypePtr constInt () Matches the llvm::ConstantInt instructruction. IOperandPrototypePtr intToPtr (IOperandPrototypePtr const & arg) Matches the llvm::IntToPtr instructruction. IOperandPrototypePtr load (IOperandPrototypePtr const & arg) Matches a load instruction with one argument. ReplacerFunction deleteInstruction () IOperandPrototypePtr unnamedInvoke () Matches a invoke instruction. template <typename... Args> IOperandPrototypePtr phi (Args... args) Matches a phi node with N arguments. IOperandPrototypePtr switchOp (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) IOperandPrototypePtr select (IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2) Matches a select instruction given a condition and two arguments. IOperandPrototypePtr store (IOperandPrototypePtr const & target, IOperandPrototypePtr const & value)","title":"Functions"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#attributes","text":"Name const std::shared_ptr< AnyPattern > _","title":"Attributes"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#detailed-description","text":"Shorthand notations to make it easy and readible to create patterns.","title":"Detailed Description"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#types-documentation","text":"","title":"Types Documentation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#typedef-ioperandprototypeptr","text":"typedef std::shared_ptr< IOperandPrototype > microsoft::quantum::notation::IOperandPrototypePtr;","title":"typedef IOperandPrototypePtr"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#using-replacerfunction","text":"using microsoft::quantum::notation::ReplacerFunction = typedef std::function<bool( ReplacementRule::Builder&, ReplacementRule::Value*, ReplacementRule::Captures&, ReplacementRule::Replacements&)>;","title":"using ReplacerFunction"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-basicblock","text":"IOperandPrototypePtr basicBlock() Matches a load instruction with one argument.","title":"function basicBlock"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-bitcast","text":"IOperandPrototypePtr bitCast( IOperandPrototypePtr const & arg ) Matches the llvm::BitCast instructruction.","title":"function bitCast"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-branch","text":"IOperandPrototypePtr branch( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a branch instruction given a condition and two arguments.","title":"function branch"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-call","text":"template <typename... Args> IOperandPrototypePtr call( std::string const & name, Args... args ) Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern auto get_one = call(\"__quantum__rt__result_get_one\"); addRule( {branch(\"cond\"_cap = call(\"__quantum__rt__result_equal\", \"result\"_cap = _, \"one\"_cap = get_one), _, _), replace_branch_positive}); which matches IRs of the form %1 = call %Result* @__quantum__rt__result_get_one() %2 = call i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1) br i1 %2, label %then0__1, label %continue__1 The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: cond , result and one each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function). Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments. Shorthand notation to match an instruction for a function call. The resulting IOperandPrototype matches a function call with arguments as specified by the arguments given. For instance, addRule({call(\"foo\", _, _), deleteInstruction()}); matches a call to the function foo with exactly two arguments.","title":"function call"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-callbynameonly","text":"IOperandPrototypePtr callByNameOnly( std::string const & name ) Shorthand notation to match an instruction with a specified name. Unlike call, this pattern matches by name only and ignore the arguments. addRule({callByNameOnly(\"foo\"), deleteInstruction()}); matches calls to the function foo regardless of the number of arguments.","title":"function callByNameOnly"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-operator_cap","text":"Capture operator\"\"_cap( char const * name, std::size_t ) Literal for specifying the capture of a llvm::Value*. This literal calls the IOperandPrototype::enableCapture through the assignment of a IOperandPrototypePtr to the class Capture . As an example, one may want to match the pattern foo(bar(baz(x)), y) and extract the variable x to add meta data to it. The corresponding IR could look like: %1 = call %Type* @baz(%Type* %0) %2 = call %Type* @bar(%Type* %1) call void @foo(%Type* %2, %Type* %3) To match this pattern, one would create the pattern call(\"foo\", call(\"bar\", call(\"baz\", \"x\"_cap = _)), _) . This pattern would ensure that at the time where the replacer function is called, the value stored in %0 is captured under the name x .","title":"function operator\"\"_cap"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-constint","text":"IOperandPrototypePtr constInt() Matches the llvm::ConstantInt instructruction.","title":"function constInt"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-inttoptr","text":"IOperandPrototypePtr intToPtr( IOperandPrototypePtr const & arg ) Matches the llvm::IntToPtr instructruction.","title":"function intToPtr"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-load","text":"IOperandPrototypePtr load( IOperandPrototypePtr const & arg ) Matches a load instruction with one argument.","title":"function load"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-deleteinstruction","text":"ReplacerFunction deleteInstruction() Shorthand notation to delete an instruction. If passed as the replacement function, this function generates a replacer that deletes the instruction. This is a shorthand notation for deleting an instruction that can be used with a custom rule when building a ruleset. This function can be used with shorthand notation for patterns as follows: addRule({callByNameOnly(name), deleteInstruction()}); to delete the instructions that calls functions with the name name .","title":"function deleteInstruction"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-unnamedinvoke","text":"IOperandPrototypePtr unnamedInvoke() Matches a invoke instruction.","title":"function unnamedInvoke"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-phi","text":"template <typename... Args> IOperandPrototypePtr phi( Args... args ) Matches a phi node with N arguments.","title":"function phi"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-switchop","text":"IOperandPrototypePtr switchOp( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 )","title":"function switchOp"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-select","text":"IOperandPrototypePtr select( IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2 ) Matches a select instruction given a condition and two arguments.","title":"function select"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#function-store","text":"IOperandPrototypePtr store( IOperandPrototypePtr const & target, IOperandPrototypePtr const & value ) Matches a store instruction with a target and a value. addRule({store(\"target\"_cap = _, \"value\"_cap = _), replaceConstExpr}); where we want to match all store instructions and do not really care about how the target or value came about. In this case, we may want to capture the values to, for instance, make assignment at compile time.","title":"function store"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Api/Namespaces/namespacemicrosoft_1_1quantum_1_1notation/#variable-_","text":"static const std::shared_ptr< AnyPattern > _ = std::make_shared<[AnyPattern](/qat/api/Classes/classmicrosoft_1_1quantum_1_1_any_pattern/)>(); Shorthand notation for a wildcard which matches anything. This value is useful when for instance capturing the arguments of a function call where the origin of the value does not matter to the pattern. Updated on 22 November 2021 at 10:28:34 UTC","title":"variable _"},{"location":"Api/Pages/","text":"Pages Updated on 22 November 2021 at 10:28:35 UTC","title":"Pages"},{"location":"Api/Pages/#pages","text":"Updated on 22 November 2021 at 10:28:35 UTC","title":"Pages"},{"location":"DeveloperGuide/ArchitectureOverview/","text":"Architecture Overview This document assumes familiarity with LLVM, LLVM intermediate representation (IR) , LLVM passes and the opt which is used to apply passes to IRs. We also assume that the reader is familiar with the QIR specification , the conventions used for functions and its opaque types. We further assume that the reader is familiar with basic C++. This is in particular true later on when we dig into the details of building pass components. Throughout this document we will assume that any reference to a QIR, is a valid within the specification requirements. The aim of this document is to walk the reader through the vision and architecture of the QIR adaptor tool (QAT). To this end, we will be discussing how QAT uses both native and custom written LLVM passes to transform generic QIRs into ones which are targeted specific platforms and/or capabilities. We refer to any generic QIR as just \"the QIR\" or the generic QIR where as those target for specific platforms and/or capabilities, we call specialised QIRs. The description of the requirements for the specialised QIR we call a QIR profile. When we talk about applying a profile to a generic QIR, we talk about the process which transform the generic QIR into the specialised one. Likewise, when we talk about validating that a specialised QIR fulfils the description of a profile. In building QAT, we note that there are two main challenges to overcome: 1) Applying a profile to a generic QIR and 2) validating that a QIR is compliant with a profile specification. We may on occasion refer to the former as a transformation and the latter as an analysis to clarify the similarity to LLVM passes. The architecture described in this document attempts to address both of these challenges in way that we believe to be customisable and scalable in terms of profile requirements. Before digging into the details of the design of QAT, we first note that LLVMs opt has many of the properties that we desire: Modularised, extendable in a non-invasive manner and differentiates between analysis and transformation. The downsides to opt is that we cannot pass a configuration to the individual passes, it is difficult to control which concrete passes are ran and, under the assumption that a profile is described by a collection of passes, there is no elegant way to bundle these into a single argument. In our design, it will be our goal to preserve the good aspects opt while adding the capabilities we miss to make profile transformations and validation. Before spelling the system requirements out, we consider a couple of examples of what we may need for functionality. Example: Function inlining Let us first consider the case of quantum architecture that does not support classical function calls. That is, a valid program must be all inlined. This is a task that can be handled by opt by supplying the command line argument --always-inline . This flag turns the inline pipeline on and attempts to inline as many function calls as possible. For QAT to be a useful tool, we would want a similar mechanism that allows to activate or deactivate existing (and new) LLVM passes. We would thus need something like qat --always-inline --apply -S filename.ll where --apply tells the tool to apply the profile and -S tells the tool to emit human readable LLVM IR code. Furthermore, if the inline pass is provided as an external module, we would need to be able load it qat --always-inline --load path/to/lib.(dylib|so|dll) --apply -S filename.ll We note that from a developer point of view, the underlying code would also need a way to let QAT know that it expects a command line argument --always-inline/--no-always-inline . Example: Static qubit allocation To get a better understanding of the problem at hand, lets examine another example: Qubit allocation. As we run our quantum program, we may use a simulator or we may deploy it on one of the hardware efforts. Depending on whether we are running in one environment or the other, qubits are different entities: In a computer simulation they are often objects. They could for instance be allocated on the heap in a non-sequential manner. In this context, it makes sense to talk about a qubits life time through instructions that allocates and releases them. On hardware, on the other hand, qubits are physical entities typically sequentially enumerated from 0 to N. Physical qubits may (or may not) have the constraint some qubits are unavailable to the user. Though not always, hardware may further have the constraint that user can only perform a single measurement at the end of the program execution. This means that qubits cannot be reused within one program execution. This puts requirements on what we may need from static qubit allocation. For any static allocation, we would need at least following information: Whether or not to map qubits to fixed integers Reuse qubits or not List unavailable qubits It is not hard to imagine that this could be extended even further by imposing customised allocation schemes. In contrast to the previous example, this example requires a much more detailed configuration to define the mode of operation. One could for instance imagine something along the lines of qat --use-static-allocation --reuse-qubits --defect-qubits 3,7,9 --max-qubits 10 --apply -S filename.ll Hence, unlike normal LLVM passes, we will need a detailed configuration to be passed along with the transformation. Design requirements To distinguish between LLVM passes and QAT extensions, we will refer to QAT extensions as profile components. A profile component may consist of several passes and furthermore should be accompanied by a configuration to describe its behaviour. Like LLVM opt we require that QAT must be extensible through dynamic libraries. This allow third party to easily extend the tool to their needs while benefiting from the components that QAT ships with. Architecture description TODO(issue-9): Yet to be written","title":"Architecture Overview"},{"location":"DeveloperGuide/ArchitectureOverview/#architecture-overview","text":"This document assumes familiarity with LLVM, LLVM intermediate representation (IR) , LLVM passes and the opt which is used to apply passes to IRs. We also assume that the reader is familiar with the QIR specification , the conventions used for functions and its opaque types. We further assume that the reader is familiar with basic C++. This is in particular true later on when we dig into the details of building pass components. Throughout this document we will assume that any reference to a QIR, is a valid within the specification requirements. The aim of this document is to walk the reader through the vision and architecture of the QIR adaptor tool (QAT). To this end, we will be discussing how QAT uses both native and custom written LLVM passes to transform generic QIRs into ones which are targeted specific platforms and/or capabilities. We refer to any generic QIR as just \"the QIR\" or the generic QIR where as those target for specific platforms and/or capabilities, we call specialised QIRs. The description of the requirements for the specialised QIR we call a QIR profile. When we talk about applying a profile to a generic QIR, we talk about the process which transform the generic QIR into the specialised one. Likewise, when we talk about validating that a specialised QIR fulfils the description of a profile. In building QAT, we note that there are two main challenges to overcome: 1) Applying a profile to a generic QIR and 2) validating that a QIR is compliant with a profile specification. We may on occasion refer to the former as a transformation and the latter as an analysis to clarify the similarity to LLVM passes. The architecture described in this document attempts to address both of these challenges in way that we believe to be customisable and scalable in terms of profile requirements. Before digging into the details of the design of QAT, we first note that LLVMs opt has many of the properties that we desire: Modularised, extendable in a non-invasive manner and differentiates between analysis and transformation. The downsides to opt is that we cannot pass a configuration to the individual passes, it is difficult to control which concrete passes are ran and, under the assumption that a profile is described by a collection of passes, there is no elegant way to bundle these into a single argument. In our design, it will be our goal to preserve the good aspects opt while adding the capabilities we miss to make profile transformations and validation. Before spelling the system requirements out, we consider a couple of examples of what we may need for functionality.","title":"Architecture Overview"},{"location":"DeveloperGuide/ArchitectureOverview/#example-function-inlining","text":"Let us first consider the case of quantum architecture that does not support classical function calls. That is, a valid program must be all inlined. This is a task that can be handled by opt by supplying the command line argument --always-inline . This flag turns the inline pipeline on and attempts to inline as many function calls as possible. For QAT to be a useful tool, we would want a similar mechanism that allows to activate or deactivate existing (and new) LLVM passes. We would thus need something like qat --always-inline --apply -S filename.ll where --apply tells the tool to apply the profile and -S tells the tool to emit human readable LLVM IR code. Furthermore, if the inline pass is provided as an external module, we would need to be able load it qat --always-inline --load path/to/lib.(dylib|so|dll) --apply -S filename.ll We note that from a developer point of view, the underlying code would also need a way to let QAT know that it expects a command line argument --always-inline/--no-always-inline .","title":"Example: Function inlining"},{"location":"DeveloperGuide/ArchitectureOverview/#example-static-qubit-allocation","text":"To get a better understanding of the problem at hand, lets examine another example: Qubit allocation. As we run our quantum program, we may use a simulator or we may deploy it on one of the hardware efforts. Depending on whether we are running in one environment or the other, qubits are different entities: In a computer simulation they are often objects. They could for instance be allocated on the heap in a non-sequential manner. In this context, it makes sense to talk about a qubits life time through instructions that allocates and releases them. On hardware, on the other hand, qubits are physical entities typically sequentially enumerated from 0 to N. Physical qubits may (or may not) have the constraint some qubits are unavailable to the user. Though not always, hardware may further have the constraint that user can only perform a single measurement at the end of the program execution. This means that qubits cannot be reused within one program execution. This puts requirements on what we may need from static qubit allocation. For any static allocation, we would need at least following information: Whether or not to map qubits to fixed integers Reuse qubits or not List unavailable qubits It is not hard to imagine that this could be extended even further by imposing customised allocation schemes. In contrast to the previous example, this example requires a much more detailed configuration to define the mode of operation. One could for instance imagine something along the lines of qat --use-static-allocation --reuse-qubits --defect-qubits 3,7,9 --max-qubits 10 --apply -S filename.ll Hence, unlike normal LLVM passes, we will need a detailed configuration to be passed along with the transformation.","title":"Example: Static qubit allocation"},{"location":"DeveloperGuide/ArchitectureOverview/#design-requirements","text":"To distinguish between LLVM passes and QAT extensions, we will refer to QAT extensions as profile components. A profile component may consist of several passes and furthermore should be accompanied by a configuration to describe its behaviour. Like LLVM opt we require that QAT must be extensible through dynamic libraries. This allow third party to easily extend the tool to their needs while benefiting from the components that QAT ships with.","title":"Design requirements"},{"location":"DeveloperGuide/ArchitectureOverview/#architecture-description","text":"TODO(issue-9): Yet to be written","title":"Architecture description"},{"location":"DeveloperGuide/CodeQuality/","text":"Code quality and continuous integration Using the manage tool Before making a pull request with changes to this library, please ensure that style checks passes, that the code compiles, unit test passes and that there are no erros found by the static analyser. To setup the CI environment, run following commands virtualenv develop__venv source develop__venv/bin/activate pip install -r requirements.txt These adds the necessary environment variables to ensure that you have the tasks_ci package and all required dependencies. To check the style, run ./manage stylecheck To test that the code compiles and tests passes run ./manage test Finally, to analyse the code, run ./manage lint You can run all processes by running: ./manage runci As clang-tidy and clang-format acts slightly different from version to version and on different platforms, it is recommended that you use a docker image to perform these steps. TODO(issue-10): The docker image is not added yet and this will be documented in the future. Running tests In order to run the tests, you first need to build the library. Assuming that this is already done and the corresponding build is in Debug/ , run the tests from the Debug folder: lit tests/ -v -- Testing: 2 tests, 2 workers -- PASS: Quantum-Passes :: QirAllocationAnalysis/case1.ll (1 of 2) PASS: Quantum-Passes :: QirAllocationAnalysis/case2.ll (2 of 2) Testing Time: 0.27s Passed: 2 The C++ test suite can also be ran from the debug by first building all targets: cmake .. make and then running following command: ctest Writing C++ tests TODO(issue-11): Write this section Modifying code quality requirements The continuous integration component includes: Style formatting to ensure that everything looks the same. This includes checking that relevant copyrights are in place. Static analysis Unit testing The automatic style enforcement is configurable with the ability to easily add or remove rules. Currently the source pipelines are defined as: SOURCE_PIPELINES = [ { \"name\": \"C++ Main\", \"src\": path.join(PROJECT_ROOT, \"qir/qat\"), \"pipelines\": { \"hpp\": [ require_pragma_once, enforce_cpp_license, enforce_formatting ], \"cpp\": [ enforce_cpp_license, enforce_formatting ] } }, # ... ] This part defines pipelines for .hpp files and .cpp files allowing the developer to add such requirements as having copyright in the op of the source file and ensure that formatting follows that given by .clang-format . Each of these CI stages can be executed individually using ./manage or you can run the entire CI process by invoking ./manage runci . An example of what this may look like is here: ./manage runci 2021-07-21 14:38:04,896 - FormatChecker - ERROR - /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/src/OpsCounter/OpsCounter.cpp was not correctly formatted. 2021-07-21 14:38:04,899 - FormatChecker - ERROR - Your code did not pass formatting. ./manage stylecheck --fix-issues ./manage runci -- Found LLVM 11.1.0 -- Using LLVMConfig.cmake in: /usr/local/opt/llvm@11/lib/cmake/llvm -- Configuring done -- Generating done -- Build files have been written to: /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/Debug Consolidate compiler generated dependencies of target QSharpPasses [ 50%] Building CXX object CMakeFiles/QSharpPasses.dir/src/OpsCounter/OpsCounter.cpp.o [100%] Linking CXX shared library libQSharpPasses.dylib ld: warning: directory not found for option '-L/usr/local/opt/llvm/lib' [100%] Built target QSharpPasses /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/src/OpsCounter/OpsCounter.cpp:29:7: error: invalid case style for class 'LegacyOpsCounterPass' [readability-identifier-naming,-warnings-as-errors] class LegacyOpsCounterPass : public FunctionPass ^~~~~~~~~~~~~~~~~~~~ CLegacyOpsCounterPass 113345 warnings generated. Suppressed 113345 warnings (113344 in non-user code, 1 NOLINT). Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well. 1 warning treated as error 2021-07-21 14:38:40,191 - Linter - ERROR - /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/src/OpsCounter/OpsCounter.cpp failed static analysis # ISSUES FIXED MANUALLY ./manage runci -- Found LLVM 11.1.0 -- Using LLVMConfig.cmake in: /usr/local/opt/llvm@11/lib/cmake/llvm -- Configuring done -- Generating done -- Build files have been written to: /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/Debug Consolidate compiler generated dependencies of target QSharpPasses [ 50%] Building CXX object CMakeFiles/QSharpPasses.dir/src/OpsCounter/OpsCounter.cpp.o [100%] Linking CXX shared library libQSharpPasses.dylib ld: warning: directory not found for option '-L/usr/local/opt/llvm/lib' [100%] Built target QSharpPasses -- Found LLVM 11.1.0 -- Using LLVMConfig.cmake in: /usr/local/opt/llvm@11/lib/cmake/llvm -- Configuring done -- Generating done -- Build files have been written to: /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/Debug Consolidate compiler generated dependencies of target QSharpPasses [100%] Built target QSharpPasses ********************************* No test configuration file found! ********************************* The key idea here is to make it extremely easy to be compliant with the style guide, correct any issues that might come as a result of static analysis and at the same time enforce this when a PR is made.","title":"Code quality"},{"location":"DeveloperGuide/CodeQuality/#code-quality-and-continuous-integration","text":"","title":"Code quality and continuous integration"},{"location":"DeveloperGuide/CodeQuality/#using-the-manage-tool","text":"Before making a pull request with changes to this library, please ensure that style checks passes, that the code compiles, unit test passes and that there are no erros found by the static analyser. To setup the CI environment, run following commands virtualenv develop__venv source develop__venv/bin/activate pip install -r requirements.txt These adds the necessary environment variables to ensure that you have the tasks_ci package and all required dependencies. To check the style, run ./manage stylecheck To test that the code compiles and tests passes run ./manage test Finally, to analyse the code, run ./manage lint You can run all processes by running: ./manage runci As clang-tidy and clang-format acts slightly different from version to version and on different platforms, it is recommended that you use a docker image to perform these steps. TODO(issue-10): The docker image is not added yet and this will be documented in the future.","title":"Using the manage tool"},{"location":"DeveloperGuide/CodeQuality/#running-tests","text":"In order to run the tests, you first need to build the library. Assuming that this is already done and the corresponding build is in Debug/ , run the tests from the Debug folder: lit tests/ -v -- Testing: 2 tests, 2 workers -- PASS: Quantum-Passes :: QirAllocationAnalysis/case1.ll (1 of 2) PASS: Quantum-Passes :: QirAllocationAnalysis/case2.ll (2 of 2) Testing Time: 0.27s Passed: 2 The C++ test suite can also be ran from the debug by first building all targets: cmake .. make and then running following command: ctest","title":"Running tests"},{"location":"DeveloperGuide/CodeQuality/#writing-c-tests","text":"TODO(issue-11): Write this section","title":"Writing C++ tests"},{"location":"DeveloperGuide/CodeQuality/#modifying-code-quality-requirements","text":"The continuous integration component includes: Style formatting to ensure that everything looks the same. This includes checking that relevant copyrights are in place. Static analysis Unit testing The automatic style enforcement is configurable with the ability to easily add or remove rules. Currently the source pipelines are defined as: SOURCE_PIPELINES = [ { \"name\": \"C++ Main\", \"src\": path.join(PROJECT_ROOT, \"qir/qat\"), \"pipelines\": { \"hpp\": [ require_pragma_once, enforce_cpp_license, enforce_formatting ], \"cpp\": [ enforce_cpp_license, enforce_formatting ] } }, # ... ] This part defines pipelines for .hpp files and .cpp files allowing the developer to add such requirements as having copyright in the op of the source file and ensure that formatting follows that given by .clang-format . Each of these CI stages can be executed individually using ./manage or you can run the entire CI process by invoking ./manage runci . An example of what this may look like is here: ./manage runci 2021-07-21 14:38:04,896 - FormatChecker - ERROR - /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/src/OpsCounter/OpsCounter.cpp was not correctly formatted. 2021-07-21 14:38:04,899 - FormatChecker - ERROR - Your code did not pass formatting. ./manage stylecheck --fix-issues ./manage runci -- Found LLVM 11.1.0 -- Using LLVMConfig.cmake in: /usr/local/opt/llvm@11/lib/cmake/llvm -- Configuring done -- Generating done -- Build files have been written to: /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/Debug Consolidate compiler generated dependencies of target QSharpPasses [ 50%] Building CXX object CMakeFiles/QSharpPasses.dir/src/OpsCounter/OpsCounter.cpp.o [100%] Linking CXX shared library libQSharpPasses.dylib ld: warning: directory not found for option '-L/usr/local/opt/llvm/lib' [100%] Built target QSharpPasses /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/src/OpsCounter/OpsCounter.cpp:29:7: error: invalid case style for class 'LegacyOpsCounterPass' [readability-identifier-naming,-warnings-as-errors] class LegacyOpsCounterPass : public FunctionPass ^~~~~~~~~~~~~~~~~~~~ CLegacyOpsCounterPass 113345 warnings generated. Suppressed 113345 warnings (113344 in non-user code, 1 NOLINT). Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well. 1 warning treated as error 2021-07-21 14:38:40,191 - Linter - ERROR - /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/src/OpsCounter/OpsCounter.cpp failed static analysis # ISSUES FIXED MANUALLY ./manage runci -- Found LLVM 11.1.0 -- Using LLVMConfig.cmake in: /usr/local/opt/llvm@11/lib/cmake/llvm -- Configuring done -- Generating done -- Build files have been written to: /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/Debug Consolidate compiler generated dependencies of target QSharpPasses [ 50%] Building CXX object CMakeFiles/QSharpPasses.dir/src/OpsCounter/OpsCounter.cpp.o [100%] Linking CXX shared library libQSharpPasses.dylib ld: warning: directory not found for option '-L/usr/local/opt/llvm/lib' [100%] Built target QSharpPasses -- Found LLVM 11.1.0 -- Using LLVMConfig.cmake in: /usr/local/opt/llvm@11/lib/cmake/llvm -- Configuring done -- Generating done -- Build files have been written to: /Users/tfr/Documents/Projects/qsharp-compiler/src/QsPasses/Debug Consolidate compiler generated dependencies of target QSharpPasses [100%] Built target QSharpPasses ********************************* No test configuration file found! ********************************* The key idea here is to make it extremely easy to be compliant with the style guide, correct any issues that might come as a result of static analysis and at the same time enforce this when a PR is made.","title":"Modifying code quality requirements"},{"location":"DeveloperGuide/ConfigurationLibrary/","text":"","title":"Configuration Library"},{"location":"DeveloperGuide/DeveloperFAQ/","text":"Developer FAQ Pass does not load One error that you may encounter is that an analysis pass does not load with output similar to this: opt -load-pass-plugin ../../Debug/libQSharpPasses.dylib -enable-debugify --passes=\"operation-counter\" -disable-output classical-program.bc Failed to load passes from '../../Debug/libQSharpPasses.dylib'. Request ignored. opt: unknown pass name 'operation-counter' This is likely becuase you have forgotten to instantiate static class members. For instance, in the case of an instance of llvm::AnalysisInfoMixin you are required to have a static member Key : class COpsCounterPass : public llvm::AnalysisInfoMixin<COpsCounterPass> { private: static llvm::AnalysisKey Key; //< REQUIRED by llvm registration friend struct llvm::AnalysisInfoMixin<COpsCounterPass>; }; If you forget to instantiate this variable in your corresponding .cpp file, // llvm::AnalysisKey COpsCounterPass::Key; //< Uncomment this line to make everything work everything will compile, but the pass will fail to load. There will be no linking errors either.","title":"Developer FAQ"},{"location":"DeveloperGuide/DeveloperFAQ/#developer-faq","text":"","title":"Developer FAQ"},{"location":"DeveloperGuide/DeveloperFAQ/#pass-does-not-load","text":"One error that you may encounter is that an analysis pass does not load with output similar to this: opt -load-pass-plugin ../../Debug/libQSharpPasses.dylib -enable-debugify --passes=\"operation-counter\" -disable-output classical-program.bc Failed to load passes from '../../Debug/libQSharpPasses.dylib'. Request ignored. opt: unknown pass name 'operation-counter' This is likely becuase you have forgotten to instantiate static class members. For instance, in the case of an instance of llvm::AnalysisInfoMixin you are required to have a static member Key : class COpsCounterPass : public llvm::AnalysisInfoMixin<COpsCounterPass> { private: static llvm::AnalysisKey Key; //< REQUIRED by llvm registration friend struct llvm::AnalysisInfoMixin<COpsCounterPass>; }; If you forget to instantiate this variable in your corresponding .cpp file, // llvm::AnalysisKey COpsCounterPass::Key; //< Uncomment this line to make everything work everything will compile, but the pass will fail to load. There will be no linking errors either.","title":"Pass does not load"},{"location":"DeveloperGuide/ProfileTransformationCpp/","text":"Creating a profile transformation in C++ Profile transformation as pass As an example of how one can implement a new profile pass, we here show the implementation details of our example pass which allows mapping the teleportation code to the base profile: pb.registerPipelineParsingCallback([](StringRef name, FunctionPassManager &fpm, ArrayRef<PassBuilder::PipelineElement> /*unused*/) { // Base profile if (name == \"restrict-qir<base-profile>\") { RuleSet rule_set; // Defining the mapping auto factory = RuleFactory(rule_set); factory.useStaticQuantumArrayAllocation(); factory.useStaticQuantumAllocation(); factory.useStaticResultAllocation(); factory.optimiseBranchQuatumOne(); // factory.optimiseBranchQuatumZero(); factory.disableReferenceCounting(); factory.disableAliasCounting(); factory.disableStringSupport(); fpm.addPass(TransformationRulePass(std::move(rule_set))); return true; } return false; }); }}; Transformations of the IR will happen on the basis of what rules are added to the rule set. The purpose of the factory is to make easy to add rules that serve a single purpose as well as making a basis for making rules unit testable. Implementing new rules Implementing new rules consists of two steps: Defining a pattern that one wish to replace and implementing the corresponding replacement logic. Inside a factory member function, this look as follows: auto get_element = Call(\"__quantum__rt__array_get_element_ptr_1d\", \"arrayName\"_cap = _, \"index\"_cap = _); auto cast_pattern = BitCast(\"getElement\"_cap = get_element); auto load_pattern = Load(\"cast\"_cap = cast_pattern); addRule({std::move(load_pattern), access_replacer}); where addRule adds the rule to the current rule set. Capturing patterns The pattern defined in this snippet matches IR like: %0 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %leftPreshared, i64 0) %1 = bitcast i8* %0 to %Qubit** %2 = load %Qubit*, %Qubit** %1, align 8 In the above rule, the first and a second argument of __quantum__rt__array_get_element_ptr_1d is captured as arrayName and index , respectively. Likewise, the bitcast instruction is captured as cast . Each of these captures will be available inside the replacement function access_replacer . Implementing replacement logic After a positive match is found, the lead instruction alongside a IRBuilder, a capture table and a replacement table is passed to the replacement function. Here is an example on how one can access the captured variables to perform a transformation of the IR: auto access_replacer = [qubit_alloc_manager](Builder &builder, Value *val, Captures &cap, Replacements &replacements) { // ... auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"index\"]); // ... auto llvm_size = cst->getValue(); auto offset = qubit_alloc_manager->getOffset(cap[\"arrayName\"]->getName().str()); auto idx = llvm::APInt(llvm_size.getBitWidth(), llvm_size.getZExtValue() + offset); auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto instr = new llvm::IntToPtrInst(new_index, ptr_type); instr->takeName(val); // Replacing the lead instruction with a the new instruction replacements.push_back({llvm::dyn_cast<Instruction>(val), instr}); // Deleting the getelement and cast operations replacements.push_back({llvm::dyn_cast<Instruction>(cap[\"getElement\"]), nullptr}); replacements.push_back({llvm::dyn_cast<Instruction>(cap[\"cast\"]), nullptr}); return true; };","title":"Creating a profile transformation in C++"},{"location":"DeveloperGuide/ProfileTransformationCpp/#creating-a-profile-transformation-in-c","text":"","title":"Creating a profile transformation in C++"},{"location":"DeveloperGuide/ProfileTransformationCpp/#profile-transformation-as-pass","text":"As an example of how one can implement a new profile pass, we here show the implementation details of our example pass which allows mapping the teleportation code to the base profile: pb.registerPipelineParsingCallback([](StringRef name, FunctionPassManager &fpm, ArrayRef<PassBuilder::PipelineElement> /*unused*/) { // Base profile if (name == \"restrict-qir<base-profile>\") { RuleSet rule_set; // Defining the mapping auto factory = RuleFactory(rule_set); factory.useStaticQuantumArrayAllocation(); factory.useStaticQuantumAllocation(); factory.useStaticResultAllocation(); factory.optimiseBranchQuatumOne(); // factory.optimiseBranchQuatumZero(); factory.disableReferenceCounting(); factory.disableAliasCounting(); factory.disableStringSupport(); fpm.addPass(TransformationRulePass(std::move(rule_set))); return true; } return false; }); }}; Transformations of the IR will happen on the basis of what rules are added to the rule set. The purpose of the factory is to make easy to add rules that serve a single purpose as well as making a basis for making rules unit testable.","title":"Profile transformation as pass"},{"location":"DeveloperGuide/ProfileTransformationCpp/#implementing-new-rules","text":"Implementing new rules consists of two steps: Defining a pattern that one wish to replace and implementing the corresponding replacement logic. Inside a factory member function, this look as follows: auto get_element = Call(\"__quantum__rt__array_get_element_ptr_1d\", \"arrayName\"_cap = _, \"index\"_cap = _); auto cast_pattern = BitCast(\"getElement\"_cap = get_element); auto load_pattern = Load(\"cast\"_cap = cast_pattern); addRule({std::move(load_pattern), access_replacer}); where addRule adds the rule to the current rule set.","title":"Implementing new rules"},{"location":"DeveloperGuide/ProfileTransformationCpp/#capturing-patterns","text":"The pattern defined in this snippet matches IR like: %0 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %leftPreshared, i64 0) %1 = bitcast i8* %0 to %Qubit** %2 = load %Qubit*, %Qubit** %1, align 8 In the above rule, the first and a second argument of __quantum__rt__array_get_element_ptr_1d is captured as arrayName and index , respectively. Likewise, the bitcast instruction is captured as cast . Each of these captures will be available inside the replacement function access_replacer .","title":"Capturing patterns"},{"location":"DeveloperGuide/ProfileTransformationCpp/#implementing-replacement-logic","text":"After a positive match is found, the lead instruction alongside a IRBuilder, a capture table and a replacement table is passed to the replacement function. Here is an example on how one can access the captured variables to perform a transformation of the IR: auto access_replacer = [qubit_alloc_manager](Builder &builder, Value *val, Captures &cap, Replacements &replacements) { // ... auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap[\"index\"]); // ... auto llvm_size = cst->getValue(); auto offset = qubit_alloc_manager->getOffset(cap[\"arrayName\"]->getName().str()); auto idx = llvm::APInt(llvm_size.getBitWidth(), llvm_size.getZExtValue() + offset); auto new_index = llvm::ConstantInt::get(builder.getContext(), idx); auto instr = new llvm::IntToPtrInst(new_index, ptr_type); instr->takeName(val); // Replacing the lead instruction with a the new instruction replacements.push_back({llvm::dyn_cast<Instruction>(val), instr}); // Deleting the getelement and cast operations replacements.push_back({llvm::dyn_cast<Instruction>(cap[\"getElement\"]), nullptr}); replacements.push_back({llvm::dyn_cast<Instruction>(cap[\"cast\"]), nullptr}); return true; };","title":"Implementing replacement logic"},{"location":"DeveloperGuide/WritingComponent/","text":"Tutorial: Writing a new component In this tutorial we will develop a new QAT profile component. We will make the component a separate library which is dynamically loaded through the command line interface. All examples in this tutorial can be found in ComponentExamples . Our first \"component\" will be a boilerplate hello world component which serves the purpose of giving the reader an understanding of how to define configurations for our component. We will demonstrate how to use this component from the command line. For our second component, we will use a standard LLVM pass to demonstrate how to load these. We will show how the registered configuration can be used to enable or disable the pass. To show that the effect of the pass, we use the inliner pipeline together with the QirExamples/LoopRecursion . We will see how enabling the pass results in inlining all the function calls. As QAT ships with a built-in inliner pass, it is important to remember to disable this to see the effect of our custom pass. Hello world Our first component will not do anything except for printing out a custom message upon configuring the profile. To this end, we need a configuration which allows the user to specify the message and we capture this configuration in a class which we name HelloWorldConfig : using String = std::string; class HelloWorldConfig { public: // ... private: String message_{\"Hello world\"}; }; We note the default value of our configuration is captured through the initialisation of the class member. That is, if not overridden by the command line arguments, the message will be \"Hello world\" . To fulfil the concept of being a configuration, a configuration must implement a setup function taking a reference to a ConfigurationManager as its only argument. For our configuration, this looks like class HelloWorldConfig { public: void setup(ConfigurationManager &config) { config.setSectionName(\"Hello world configuration\", \"Demonstrating how configuration works.\"); config.addParameter(message_, \"message\", \"Message which is printed when setting the component up.\"); } // ... }; The purpose of the setup(config) function is to inform the configuration manager about what the name of the configuration section and its description is as well as defining all settings and bind them to C++ variables. The benefit of this approach is that all configuration parameters for the component will be available immediately after the component is loaded by the tool. The final code to manage the configuration reads: class HelloWorldConfig { public: using String = std::string; void setup(ConfigurationManager &config) { config.setSectionName(\"Hello world configuration\", \"Demonstrating how configuration works.\"); config.addParameter(message_, \"message\", \"Message which is printed when setting the component up.\"); } String const& message() const { return message_; } private: String message_{\"Hello world\"}; }; With the configuration in place, the next thing we concern ourselves with is loading the component. This is the functionality that registers the configuration together with an ID and a profile setup function. In our case, the setup function should just print a message given a HelloWorldConfig instance. The corresponding component registration reads: extern \"C\" void loadComponent(IProfileGenerator *generator) { generator->registerProfileComponent<HelloWorldConfig>( \"hello-world\", [](HelloWorldConfig const &cfg, IProfileGenerator * /*generator*/, Profile & /*profile*/) { std::cout << \"Message: \" << cfg.message() << std::endl; }); } In this example, we will only concern ourselves with how to use the configuration and we will ignore generator and profile for now. The full source code to this example can be found in ComponentExamples/HelloWorld and it can be compiled through following steps (startig from the Passes root folder): mkdir Debug cd Debug cmake .. make HelloWorld This will generate a HelloWorld dynamic library with path ./ComponentExamples/libHelloWorld.(dylib|so|dll) . Loading the component Executing qat and loading the libHelloWorld library, we see that our new settings are added to help page: % ./qir/qat/Apps/qat --load ./ComponentExamples/libHelloWorld.dylib Usage: ./qir/qat/Apps/qat [options] filename ... Hello world configuration - Demonstration configuration for building a component boilerplate. --message Message which is printed when setting the component up. Default: Hello world ... For the next part, we assume that you have a QIR located in path/to/example.ll . To test that the setup function is invoked upon setting the profile up, we run % ./qir/qat/Apps/qat --load ./ComponentExamples/libHelloWorld.dylib path/to/example.ll Message: Hello world Creating a Pass Component Next, we make a component that just runs a single LLVM pass. We we will use the inline pipeline to this end. We create a single option for activating the pass: class InlinerConfig { public: using String = std::string; void setup(ConfigurationManager &config) { config.setSectionName(\"Inliner component\", \"Adds the LLVM Always Inline Pass to the profile\"); config.addParameter(inline_, \"custom-inliner\", \"Activating the custom inliner.\"); } bool shouldInline() const { return inline_; } private: bool inline_{false}; ///< Default behaviour is that we do not add the inliner pass }; The implementation itself is extern \"C\" void loadComponent(IProfileGenerator *generator) { generator->registerProfileComponent<InlinerConfig>( \"inliner\", [](InlinerConfig const &cfg, IProfileGenerator *ptr, Profile & /*profile*/) { if (cfg.shouldInline()) { auto &module_pass_manager = ptr->modulePassManager(); // Adds the inline pipeline auto &pass_builder = ptr->passBuilder(); auto inliner_pass = pass_builder.buildInlinerPipeline( ptr->optimisationLevel(), llvm::PassBuilder::ThinLTOPhase::None, ptr->debug()); module_pass_manager.addPass(std::move(inliner_pass)); } }); } To run this pass, ./qir/qat/Apps/qat --load ./ComponentExamples/libInlinePassComponent.dylib ../QirExamples/LoopRecursion/QSharpVersion/qir/Example.ll --S --apply --no-always-inline --custom-inliner Compare the output against ./qir/qat/Apps/qat --load ./ComponentExamples/libInlinePassComponent.dylib ../QirExamples/LoopRecursion/QSharpVersion/qir/Example.ll --S --apply --no-always-inline","title":"Writing a Component"},{"location":"DeveloperGuide/WritingComponent/#tutorial-writing-a-new-component","text":"In this tutorial we will develop a new QAT profile component. We will make the component a separate library which is dynamically loaded through the command line interface. All examples in this tutorial can be found in ComponentExamples . Our first \"component\" will be a boilerplate hello world component which serves the purpose of giving the reader an understanding of how to define configurations for our component. We will demonstrate how to use this component from the command line. For our second component, we will use a standard LLVM pass to demonstrate how to load these. We will show how the registered configuration can be used to enable or disable the pass. To show that the effect of the pass, we use the inliner pipeline together with the QirExamples/LoopRecursion . We will see how enabling the pass results in inlining all the function calls. As QAT ships with a built-in inliner pass, it is important to remember to disable this to see the effect of our custom pass.","title":"Tutorial: Writing a new component"},{"location":"DeveloperGuide/WritingComponent/#hello-world","text":"Our first component will not do anything except for printing out a custom message upon configuring the profile. To this end, we need a configuration which allows the user to specify the message and we capture this configuration in a class which we name HelloWorldConfig : using String = std::string; class HelloWorldConfig { public: // ... private: String message_{\"Hello world\"}; }; We note the default value of our configuration is captured through the initialisation of the class member. That is, if not overridden by the command line arguments, the message will be \"Hello world\" . To fulfil the concept of being a configuration, a configuration must implement a setup function taking a reference to a ConfigurationManager as its only argument. For our configuration, this looks like class HelloWorldConfig { public: void setup(ConfigurationManager &config) { config.setSectionName(\"Hello world configuration\", \"Demonstrating how configuration works.\"); config.addParameter(message_, \"message\", \"Message which is printed when setting the component up.\"); } // ... }; The purpose of the setup(config) function is to inform the configuration manager about what the name of the configuration section and its description is as well as defining all settings and bind them to C++ variables. The benefit of this approach is that all configuration parameters for the component will be available immediately after the component is loaded by the tool. The final code to manage the configuration reads: class HelloWorldConfig { public: using String = std::string; void setup(ConfigurationManager &config) { config.setSectionName(\"Hello world configuration\", \"Demonstrating how configuration works.\"); config.addParameter(message_, \"message\", \"Message which is printed when setting the component up.\"); } String const& message() const { return message_; } private: String message_{\"Hello world\"}; }; With the configuration in place, the next thing we concern ourselves with is loading the component. This is the functionality that registers the configuration together with an ID and a profile setup function. In our case, the setup function should just print a message given a HelloWorldConfig instance. The corresponding component registration reads: extern \"C\" void loadComponent(IProfileGenerator *generator) { generator->registerProfileComponent<HelloWorldConfig>( \"hello-world\", [](HelloWorldConfig const &cfg, IProfileGenerator * /*generator*/, Profile & /*profile*/) { std::cout << \"Message: \" << cfg.message() << std::endl; }); } In this example, we will only concern ourselves with how to use the configuration and we will ignore generator and profile for now. The full source code to this example can be found in ComponentExamples/HelloWorld and it can be compiled through following steps (startig from the Passes root folder): mkdir Debug cd Debug cmake .. make HelloWorld This will generate a HelloWorld dynamic library with path ./ComponentExamples/libHelloWorld.(dylib|so|dll) .","title":"Hello world"},{"location":"DeveloperGuide/WritingComponent/#loading-the-component","text":"Executing qat and loading the libHelloWorld library, we see that our new settings are added to help page: % ./qir/qat/Apps/qat --load ./ComponentExamples/libHelloWorld.dylib Usage: ./qir/qat/Apps/qat [options] filename ... Hello world configuration - Demonstration configuration for building a component boilerplate. --message Message which is printed when setting the component up. Default: Hello world ... For the next part, we assume that you have a QIR located in path/to/example.ll . To test that the setup function is invoked upon setting the profile up, we run % ./qir/qat/Apps/qat --load ./ComponentExamples/libHelloWorld.dylib path/to/example.ll Message: Hello world","title":"Loading the component"},{"location":"DeveloperGuide/WritingComponent/#creating-a-pass-component","text":"Next, we make a component that just runs a single LLVM pass. We we will use the inline pipeline to this end. We create a single option for activating the pass: class InlinerConfig { public: using String = std::string; void setup(ConfigurationManager &config) { config.setSectionName(\"Inliner component\", \"Adds the LLVM Always Inline Pass to the profile\"); config.addParameter(inline_, \"custom-inliner\", \"Activating the custom inliner.\"); } bool shouldInline() const { return inline_; } private: bool inline_{false}; ///< Default behaviour is that we do not add the inliner pass }; The implementation itself is extern \"C\" void loadComponent(IProfileGenerator *generator) { generator->registerProfileComponent<InlinerConfig>( \"inliner\", [](InlinerConfig const &cfg, IProfileGenerator *ptr, Profile & /*profile*/) { if (cfg.shouldInline()) { auto &module_pass_manager = ptr->modulePassManager(); // Adds the inline pipeline auto &pass_builder = ptr->passBuilder(); auto inliner_pass = pass_builder.buildInlinerPipeline( ptr->optimisationLevel(), llvm::PassBuilder::ThinLTOPhase::None, ptr->debug()); module_pass_manager.addPass(std::move(inliner_pass)); } }); } To run this pass, ./qir/qat/Apps/qat --load ./ComponentExamples/libInlinePassComponent.dylib ../QirExamples/LoopRecursion/QSharpVersion/qir/Example.ll --S --apply --no-always-inline --custom-inliner Compare the output against ./qir/qat/Apps/qat --load ./ComponentExamples/libInlinePassComponent.dylib ../QirExamples/LoopRecursion/QSharpVersion/qir/Example.ll --S --apply --no-always-inline","title":"Creating a Pass Component"},{"location":"DeveloperGuide/WritingRuleTests/","text":"Writing rule tests To make it easy to write tests for transformation rules, we have created two components to ease the burden of writing tests: DefaultProfileGenerator and IrManipulationTestHelper . The DefaultProfileGenerator is a profile that is dynamically defined when instatiated through a configuration lambda function. Creating the profile Creating the profile using the DefaultProfileGenerator is done by first defining the lambda function and then instantiating the DefaultProfileGenerator with the lambda function to define the profile. Using the RuleFactory , a profile for transforming the single qubit allocations is created as follows: auto configure_profile = [](RuleSet &rule_set) { auto factory = RuleFactory(rule_set); factory.useStaticQubitAllocation(); } auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); This profile is intended to transform %qubit = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %qubit) call void @__quantum__rt__qubit_release(%Qubit* %qubit) ret i8 0 by replacing all allocations with integers and stripping all release calls %qubit = inttoptr i64 0 to %Qubit* tail call void @__quantum__qis__h__body(%Qubit* %qubit) ret i8 0 Creating the IR In order to assist the testing of the above profile, we create a helper class which defines the IR we want to work on. To this end we make use of IrManipulationTestHelper which provides a number of shorthand functions to generate and test IR transformations. We start by defining the IR: auto ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareFunction(\"%Qubit* @__quantum__rt__qubit_allocate()\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); std::string script = R\"script( %qubit = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %qubit) call void @__quantum__rt__qubit_release(%Qubit* %qubit) )script\"; assert(ir_manip->fromBodyString(script)); // Will fail if the IR is invalid If we wish to verify the IR, we can print it by using the member function toString or by accessing the module directly: std::cout << ir_manip->toString() << std::endl; // OR llvm::errs() << *ir_manip->module() << \"\\n\"; Applying the profile to the IR The IrManipulationTestHelper contains a member function to run the profile on the IR to transform the module. The default behaviour of this helper function is to run without debug output at a O0 level to ensure that LLVM does not interfere with the intended test. The optimisation level and debug mode can be changed through the function calls second and third argument, but for the sake of simplicity, we will assume we are using O0 here: ir_manip->applyProfile(profile); This will run the above generated rule set on the IR we have supplied. At this point, we could print the IR to the screen and use LIT to perform that actually transformation test. However, to keep this test framework self-contained and easy to use, we supply LIT-like functionality. This has the benefit that the tests do not rely on Python and the LIT framework and that the tooling around the test is substantially simpler. Testing the modified IR Like before, we can investigate the IR by printing it and as such we could write a test that compared the full IR against an expected string. However, even minor changes in the IR (such as interchanged declarations) would break the test even if the changes would not change the semantics of the code. Instead, the IrManipulationTestHelper has another helper function hasInstructionSequence which allow us to scan for a sequence of instructions in the body of the main function. In our case, we expect following two instructions (in order): %qubit = inttoptr i64 0 to %Qubit* tail call void @__quantum__qis__h__body(%Qubit* %qubit) The corresponding test code is as follows: EXPECT_TRUE(ir_manip->hasInstructionSequence({ \"%qubit = inttoptr i64 0 to %Qubit*\", \"tail call void @__quantum__qis__h__body(%Qubit* %qubit)\" })); By design, the test would pass as long as these two instructions are found (in order) within the full set of instructions of the function body. For instance, a valid IR for this test is call void printHelloWorld() %qubit = inttoptr i64 0 to %Qubit* %q2 = inttoptr i64 1 to %Qubit* %q3 = inttoptr i64 2 to %Qubit* tail call void @__quantum__qis__h__body(%Qubit* %q3) tail call void @__quantum__qis__h__body(%Qubit* %qubit) tail call void @__quantum__qis__h__body(%Qubit* %q2) but would fail tail call void @__quantum__qis__h__body(%Qubit* %qubit) %qubit = inttoptr i64 0 to %Qubit* and %qubit = inttoptr i64 0 to %Qubit* as the first has the wrong order of the calls and the second is missing one instruction.","title":"Rule based extensions"},{"location":"DeveloperGuide/WritingRuleTests/#writing-rule-tests","text":"To make it easy to write tests for transformation rules, we have created two components to ease the burden of writing tests: DefaultProfileGenerator and IrManipulationTestHelper . The DefaultProfileGenerator is a profile that is dynamically defined when instatiated through a configuration lambda function.","title":"Writing rule tests"},{"location":"DeveloperGuide/WritingRuleTests/#creating-the-profile","text":"Creating the profile using the DefaultProfileGenerator is done by first defining the lambda function and then instantiating the DefaultProfileGenerator with the lambda function to define the profile. Using the RuleFactory , a profile for transforming the single qubit allocations is created as follows: auto configure_profile = [](RuleSet &rule_set) { auto factory = RuleFactory(rule_set); factory.useStaticQubitAllocation(); } auto profile = std::make_shared<DefaultProfileGenerator>(std::move(configure_profile)); This profile is intended to transform %qubit = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %qubit) call void @__quantum__rt__qubit_release(%Qubit* %qubit) ret i8 0 by replacing all allocations with integers and stripping all release calls %qubit = inttoptr i64 0 to %Qubit* tail call void @__quantum__qis__h__body(%Qubit* %qubit) ret i8 0","title":"Creating the profile"},{"location":"DeveloperGuide/WritingRuleTests/#creating-the-ir","text":"In order to assist the testing of the above profile, we create a helper class which defines the IR we want to work on. To this end we make use of IrManipulationTestHelper which provides a number of shorthand functions to generate and test IR transformations. We start by defining the IR: auto ir_manip = std::make_shared<IrManipulationTestHelper>(); ir_manip->declareOpaque(\"Qubit\"); ir_manip->declareFunction(\"%Qubit* @__quantum__rt__qubit_allocate()\"); ir_manip->declareFunction(\"void @__quantum__rt__qubit_release(%Qubit*)\"); ir_manip->declareFunction(\"void @__quantum__qis__h__body(%Qubit*)\"); std::string script = R\"script( %qubit = call %Qubit* @__quantum__rt__qubit_allocate() call void @__quantum__qis__h__body(%Qubit* %qubit) call void @__quantum__rt__qubit_release(%Qubit* %qubit) )script\"; assert(ir_manip->fromBodyString(script)); // Will fail if the IR is invalid If we wish to verify the IR, we can print it by using the member function toString or by accessing the module directly: std::cout << ir_manip->toString() << std::endl; // OR llvm::errs() << *ir_manip->module() << \"\\n\";","title":"Creating the IR"},{"location":"DeveloperGuide/WritingRuleTests/#applying-the-profile-to-the-ir","text":"The IrManipulationTestHelper contains a member function to run the profile on the IR to transform the module. The default behaviour of this helper function is to run without debug output at a O0 level to ensure that LLVM does not interfere with the intended test. The optimisation level and debug mode can be changed through the function calls second and third argument, but for the sake of simplicity, we will assume we are using O0 here: ir_manip->applyProfile(profile); This will run the above generated rule set on the IR we have supplied. At this point, we could print the IR to the screen and use LIT to perform that actually transformation test. However, to keep this test framework self-contained and easy to use, we supply LIT-like functionality. This has the benefit that the tests do not rely on Python and the LIT framework and that the tooling around the test is substantially simpler.","title":"Applying the profile to the IR"},{"location":"DeveloperGuide/WritingRuleTests/#testing-the-modified-ir","text":"Like before, we can investigate the IR by printing it and as such we could write a test that compared the full IR against an expected string. However, even minor changes in the IR (such as interchanged declarations) would break the test even if the changes would not change the semantics of the code. Instead, the IrManipulationTestHelper has another helper function hasInstructionSequence which allow us to scan for a sequence of instructions in the body of the main function. In our case, we expect following two instructions (in order): %qubit = inttoptr i64 0 to %Qubit* tail call void @__quantum__qis__h__body(%Qubit* %qubit) The corresponding test code is as follows: EXPECT_TRUE(ir_manip->hasInstructionSequence({ \"%qubit = inttoptr i64 0 to %Qubit*\", \"tail call void @__quantum__qis__h__body(%Qubit* %qubit)\" })); By design, the test would pass as long as these two instructions are found (in order) within the full set of instructions of the function body. For instance, a valid IR for this test is call void printHelloWorld() %qubit = inttoptr i64 0 to %Qubit* %q2 = inttoptr i64 1 to %Qubit* %q3 = inttoptr i64 2 to %Qubit* tail call void @__quantum__qis__h__body(%Qubit* %q3) tail call void @__quantum__qis__h__body(%Qubit* %qubit) tail call void @__quantum__qis__h__body(%Qubit* %q2) but would fail tail call void @__quantum__qis__h__body(%Qubit* %qubit) %qubit = inttoptr i64 0 to %Qubit* and %qubit = inttoptr i64 0 to %Qubit* as the first has the wrong order of the calls and the second is missing one instruction.","title":"Testing the modified IR"},{"location":"UserGuide/BuildingLibrary/","text":"Build guide This document will guide you through all the requirements and steps that you need to follow to build the QIR adaptor tool (QAT). The first section of this guide helps you install the tools needed to build QAT. After you have finished with the second section of the guide, you should have the qat executable compiled and ready to run. As a part of the third part of this post, we will show you how to build and serve all of the documentation including the user guides, developer guides and API documentation. We will go through the steps of compiling the whole library as well as how to run all the tests suite that has been provided as the fourth part of this document. This part is only relevant if you intend to extend or modify the core codebase. There is no need for it when simply building an extension to QAT without having the need to change anything else in the core library. There is a lot more information about how to create a custom extension within the developers\u2019 section. Prerequisites It is necessary for you to have the following tools before you get started on making a new build from this project: C++ compiler CMake If you are compiling and using the command-line tool, these are necessary tools regardless of whether you plan to develop the library itself. The build configuration is handled by CMake, which informs you if a compiler needs to be installed. On Mac OS X Those using Mac OS X can install CMake through the use of a command-line tool called brew , as follows: brew install cmake It should not even be necessary to install anything else on top of macOS, since the compiler comes preinstalled. There is no need to read the next subsection ( Developer prerequisites ) if you are not intending to modify the core library and can safely jump to the section Library Dependencies On Ubuntu 20.04 Additionally to CMake, you will also require Clang in order to build Ubuntu 20.04. You can accomplish this by following the steps below: apt install clang-11 cmake You can skip straight to Library Dependencies if you do not intend to work on developing the core library. Developer prerequisites Development of the core library requires additional tools. These are used formatting, linting and managing code quality. For this purpose, the following tools and packages are used: Python 3 Python packages specified in requirements.txt clang-format clang-tidy The installation process varies depending on the platform you use. The following subsections provide details on how to install these tools on each platform. On Mac OS X TODO: On Ubuntu 20.04 Installing the clang tools on Ubuntu along with Python can be accomplished by running these commands: apt install clang-format-11 clang-tidy-11 apt install python3 python3-pip We recommend that you use version 11 of clang in order to be consistent with the version of LLVM on which the library depends. In general, the code should work with any version of clang. Make sure that the compiler environment variables are defined correctly in order to select the correct version: export CC=clang-11 export CXX=clang++-11 Common to all platforms Last but not least, we install the Python libraries that are required: pip install -r requirements.txt chmod +x manage As a result, the manage tool will be available for you to help you make sure your code is high quality. Getting a contribution merged into the code base requires the manage tools CI flow to be successful. Thus, if you plan to contribute you will most likely need to complete this step. Library Dependencies The QAT library itself is written in C++ and depends on LLVM for compilation and Google Test for testing purposes. Google test is checked out as a submodule whereas LLVM needs to be installed on the system. To get check out all submodules run git submodule update --init --recursive Installing LLVM on Mac OS X TODO: Installing LLVM on Ubuntu 20.04 For the installation of LLVM from Ubuntu we use the package manager apt . For full run installation, run the following command: apt install llvm-11 lldb-11 llvm-11-dev libllvm11 llvm-11-runtime By doing this, we will ensure that CMake can find LLVM and that all headers and libraries used by the QAT library are available. Build instructions for users From the root folder in the repository, go to src/Passes , then create a build folder Debug and use CMake to build the executable: cd Debug cmake .. make qat then ./qir/qat/Apps/qat Building the documentation To build the documentation Docker image, run: make documentation To serve the documentation locally, run: make serve-docs Building for developers To build the tool, create a new build directory and switch to that directory: mkdir Debug cd Debug/ To build the library, first configure CMake from the build directory cmake .. and then make your target make [target] The default target is all . Other valid targets are the name of the folders in libs/ found in the passes root.","title":"Building the library"},{"location":"UserGuide/BuildingLibrary/#build-guide","text":"This document will guide you through all the requirements and steps that you need to follow to build the QIR adaptor tool (QAT). The first section of this guide helps you install the tools needed to build QAT. After you have finished with the second section of the guide, you should have the qat executable compiled and ready to run. As a part of the third part of this post, we will show you how to build and serve all of the documentation including the user guides, developer guides and API documentation. We will go through the steps of compiling the whole library as well as how to run all the tests suite that has been provided as the fourth part of this document. This part is only relevant if you intend to extend or modify the core codebase. There is no need for it when simply building an extension to QAT without having the need to change anything else in the core library. There is a lot more information about how to create a custom extension within the developers\u2019 section.","title":"Build guide"},{"location":"UserGuide/BuildingLibrary/#prerequisites","text":"It is necessary for you to have the following tools before you get started on making a new build from this project: C++ compiler CMake If you are compiling and using the command-line tool, these are necessary tools regardless of whether you plan to develop the library itself. The build configuration is handled by CMake, which informs you if a compiler needs to be installed.","title":"Prerequisites"},{"location":"UserGuide/BuildingLibrary/#on-mac-os-x","text":"Those using Mac OS X can install CMake through the use of a command-line tool called brew , as follows: brew install cmake It should not even be necessary to install anything else on top of macOS, since the compiler comes preinstalled. There is no need to read the next subsection ( Developer prerequisites ) if you are not intending to modify the core library and can safely jump to the section Library Dependencies","title":"On Mac OS X"},{"location":"UserGuide/BuildingLibrary/#on-ubuntu-2004","text":"Additionally to CMake, you will also require Clang in order to build Ubuntu 20.04. You can accomplish this by following the steps below: apt install clang-11 cmake You can skip straight to Library Dependencies if you do not intend to work on developing the core library.","title":"On Ubuntu 20.04"},{"location":"UserGuide/BuildingLibrary/#developer-prerequisites","text":"Development of the core library requires additional tools. These are used formatting, linting and managing code quality. For this purpose, the following tools and packages are used: Python 3 Python packages specified in requirements.txt clang-format clang-tidy The installation process varies depending on the platform you use. The following subsections provide details on how to install these tools on each platform.","title":"Developer prerequisites"},{"location":"UserGuide/BuildingLibrary/#on-mac-os-x_1","text":"TODO:","title":"On Mac OS X"},{"location":"UserGuide/BuildingLibrary/#on-ubuntu-2004_1","text":"Installing the clang tools on Ubuntu along with Python can be accomplished by running these commands: apt install clang-format-11 clang-tidy-11 apt install python3 python3-pip We recommend that you use version 11 of clang in order to be consistent with the version of LLVM on which the library depends. In general, the code should work with any version of clang. Make sure that the compiler environment variables are defined correctly in order to select the correct version: export CC=clang-11 export CXX=clang++-11","title":"On Ubuntu 20.04"},{"location":"UserGuide/BuildingLibrary/#common-to-all-platforms","text":"Last but not least, we install the Python libraries that are required: pip install -r requirements.txt chmod +x manage As a result, the manage tool will be available for you to help you make sure your code is high quality. Getting a contribution merged into the code base requires the manage tools CI flow to be successful. Thus, if you plan to contribute you will most likely need to complete this step.","title":"Common to all platforms"},{"location":"UserGuide/BuildingLibrary/#library-dependencies","text":"The QAT library itself is written in C++ and depends on LLVM for compilation and Google Test for testing purposes. Google test is checked out as a submodule whereas LLVM needs to be installed on the system. To get check out all submodules run git submodule update --init --recursive","title":"Library Dependencies"},{"location":"UserGuide/BuildingLibrary/#installing-llvm-on-mac-os-x","text":"TODO:","title":"Installing LLVM on Mac OS X"},{"location":"UserGuide/BuildingLibrary/#installing-llvm-on-ubuntu-2004","text":"For the installation of LLVM from Ubuntu we use the package manager apt . For full run installation, run the following command: apt install llvm-11 lldb-11 llvm-11-dev libllvm11 llvm-11-runtime By doing this, we will ensure that CMake can find LLVM and that all headers and libraries used by the QAT library are available.","title":"Installing LLVM on Ubuntu 20.04"},{"location":"UserGuide/BuildingLibrary/#build-instructions-for-users","text":"From the root folder in the repository, go to src/Passes , then create a build folder Debug and use CMake to build the executable: cd Debug cmake .. make qat then ./qir/qat/Apps/qat","title":"Build instructions for users"},{"location":"UserGuide/BuildingLibrary/#building-the-documentation","text":"To build the documentation Docker image, run: make documentation To serve the documentation locally, run: make serve-docs","title":"Building the documentation"},{"location":"UserGuide/BuildingLibrary/#building-for-developers","text":"To build the tool, create a new build directory and switch to that directory: mkdir Debug cd Debug/ To build the library, first configure CMake from the build directory cmake .. and then make your target make [target] The default target is all . Other valid targets are the name of the folders in libs/ found in the passes root.","title":"Building for developers"},{"location":"UserGuide/IntroductionToProfiles/","text":"Introduction to profiles In this document we discuss QIR profiles. A QIR profile describes a subset of the generic QIR functionality and conventions. It is anticipated that most usages of the QIR specification will need to only use a subset of it. These subsets may further be subject to constraints such as how one allocate or acquire a qubit handle. We refer to such a subset with constraints as a profile. For instance, it is likely that early versions of quantum hardware will have a limited set of classical instructions available. With this in mind, the vendor or user of said hardware would define a profile that only contains a specified subset. One example of such a profile is the base profile, which only allows function calls and branching, but no arithmetic, classical memory, or classical registers. The generation of QIR according to the spec with no constraints would typically be performed by the frontend. A couple of examples are Q# or OpenQASM 2.0/3.0. However, for the generated QIR to be practical it is necessary to reduce it using a profile which is compatible with the target platform: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Frontend \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 QIR \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 QIR Adaptor Tool \u2502 <\u2500\u2500\u2500\u2500\u2500\u2500\u2500 QIR Profile \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 Adapted QIR \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Backend \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 As an example, a hardware based quantum platform may only have support for sequential gates with no branching or ability for subroutines. Likewise, some quantum platforms only allow for a single measurement at the end of executing the pipeline of quantum gates. Profiles suppose to express these nuances and restrictions which are absent in the generic QIR. Generic QIR specification See Quantum Intermediate Representation (QIR) Pipeline profile This profile assumes a quantum system where qubits and result registers fixed in availability. That is to say, that one target may have 25 qubits and 10 result registers. The pipeline profile is the profile with the least classical logic available. It only supports call , inttoptr , 64-bit integers i64 , qubit ids Qubit* and result ids Result* . It does not provide a runtime and only intrinsic quantum instructions are available to this profile. This profile is intended for client-host type infrastructure where a gate pipeline is uploaded to the client quantum system and executed one or more times. Measurements are always performed at the end of the execution and all available results. This profile only allows for defining a single function that takes no arguments and has no return type. Available types | Typename | Description | |----------|---| | Result | Used as pointer type within the ID for constant integers | | Qubit | Used as pointer type within the ID for constant integers | As an example of how these types can be used: %0 = Qubit* inttoptr 1 to Qubit* which expresses that we store the handle to qubit with ID 1 in the variable %0 . Result registers are referred to in a similar manner. Base Profile The base profile is a slight advancement to the pipeline profile Available types | Typename | | | |----------|---|---| | Array | | | | Result | | | | Qubit | | | Available quantum intrinsic functions | | | | |---|---|---| | | | | | | | | | | | | Available runtime functions | | | | |---|---|---| | | | | | | | | | | | | Available IR functionality | | | | |---|---|---| | call | | | | ret | | | | | | |","title":"Introduction to profiles"},{"location":"UserGuide/IntroductionToProfiles/#introduction-to-profiles","text":"In this document we discuss QIR profiles. A QIR profile describes a subset of the generic QIR functionality and conventions. It is anticipated that most usages of the QIR specification will need to only use a subset of it. These subsets may further be subject to constraints such as how one allocate or acquire a qubit handle. We refer to such a subset with constraints as a profile. For instance, it is likely that early versions of quantum hardware will have a limited set of classical instructions available. With this in mind, the vendor or user of said hardware would define a profile that only contains a specified subset. One example of such a profile is the base profile, which only allows function calls and branching, but no arithmetic, classical memory, or classical registers. The generation of QIR according to the spec with no constraints would typically be performed by the frontend. A couple of examples are Q# or OpenQASM 2.0/3.0. However, for the generated QIR to be practical it is necessary to reduce it using a profile which is compatible with the target platform: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Frontend \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 QIR \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 QIR Adaptor Tool \u2502 <\u2500\u2500\u2500\u2500\u2500\u2500\u2500 QIR Profile \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 Adapted QIR \u25bc \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Backend \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 As an example, a hardware based quantum platform may only have support for sequential gates with no branching or ability for subroutines. Likewise, some quantum platforms only allow for a single measurement at the end of executing the pipeline of quantum gates. Profiles suppose to express these nuances and restrictions which are absent in the generic QIR.","title":"Introduction to profiles"},{"location":"UserGuide/IntroductionToProfiles/#generic-qir-specification","text":"See Quantum Intermediate Representation (QIR)","title":"Generic QIR specification"},{"location":"UserGuide/IntroductionToProfiles/#pipeline-profile","text":"This profile assumes a quantum system where qubits and result registers fixed in availability. That is to say, that one target may have 25 qubits and 10 result registers. The pipeline profile is the profile with the least classical logic available. It only supports call , inttoptr , 64-bit integers i64 , qubit ids Qubit* and result ids Result* . It does not provide a runtime and only intrinsic quantum instructions are available to this profile. This profile is intended for client-host type infrastructure where a gate pipeline is uploaded to the client quantum system and executed one or more times. Measurements are always performed at the end of the execution and all available results. This profile only allows for defining a single function that takes no arguments and has no return type. Available types | Typename | Description | |----------|---| | Result | Used as pointer type within the ID for constant integers | | Qubit | Used as pointer type within the ID for constant integers | As an example of how these types can be used: %0 = Qubit* inttoptr 1 to Qubit* which expresses that we store the handle to qubit with ID 1 in the variable %0 . Result registers are referred to in a similar manner.","title":"Pipeline profile"},{"location":"UserGuide/IntroductionToProfiles/#base-profile","text":"The base profile is a slight advancement to the pipeline profile Available types | Typename | | | |----------|---|---| | Array | | | | Result | | | | Qubit | | | Available quantum intrinsic functions | | | | |---|---|---| | | | | | | | | | | | | Available runtime functions | | | | |---|---|---| | | | | | | | | | | | | Available IR functionality | | | | |---|---|---| | call | | | | ret | | | | | | |","title":"Base Profile"},{"location":"UserGuide/QuickStart/","text":"Quick start Before we start, you will need to build the QAT tool. To this end, enter src/Passes from the root of the repository and create a new folder Debug . Then run cmake .. and use make to build qat : mkdir Debug cd Debug cmake .. make qat A more detailed documentation of this step is available in the build steps section . Once the build has been completed successfully, we will create a QIR in order to have an example code we can apply a profile to. The next step does not need to be completed if you already have a QIR. We will be using the Q# front end to generate the QIR and use the example SimpleLoop . However, you are free to choose another example in the QirExamples folder and/or another frontend. Go to the folder ./QirExamples/SimpleLoop/QSharpVersion and type make qir/Example.ll This will generate a QIR that will have the path ./QirExamples/SimpleLoop/QSharpVersion/qir/Example.ll relative to the project root. By using an application called QAT you can transform the QIR that was generated into a QIR that is tailored to a specific profile. Performing a transformation of the QIR from the ./Debug folder is done by typing the following commands: ./qir/qat/Apps/qat --apply --profile base -S ../QirExamples/SimpleLoop/QSharpVersion/qir/Example.ll Validation of QIR profiles is not supported by the tool at the moment. We're working on this feature, and will add the quickstart documentation here when it is available. Example: SimpleLoop For the sake of demonstration, we will look at the result of applying the profile to the previous Q# code and its corresponding QIR. However, instead of giving all the 3316 lines of the original QIR, we instead present the frontend code for the QIR. It is always possible to recreate the QIR from the step that was previously explained if you are curious: namespace SimpleLoop { open Microsoft.Quantum.Intrinsic; open Microsoft.Quantum.Measurement; function Value(r : Result) : Int { return r == Zero ? 122 | 1337; } @EntryPoint() operation RunMain() : Int { let nrIter = 5; mutable ret = 1; for _ in 1 .. nrIter { use q = Qubit(); H(q); let r = MResetZ(q); set ret = Value(r); } return ret; } } The tool was ran with three options: --apply , --profile base and -S . First, it tells the tool to apply the profile to the QIR so that it can become a profile-specific QIR according to the profile selected. By specifying the value baseProfile to the argument --profile , we select which profile to use in the tool and the third argument ensures that LLVM IR will be printed to the terminal in a human readable format. The resulting code emitted (omitting declarations) is: ; ModuleID = 'QSharpVersion/qir/Example.ll' source_filename = \"QSharpVersion/qir/Example.ll\" ; ... define void @SimpleLoop__Main() local_unnamed_addr #0 { entry: tail call void @__quantum__qis__h__body(%Qubit* null) tail call void @__quantum__qis__mz__body(%Qubit* null, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* null) %0 = tail call %Result* @__quantum__rt__result_get_zero() %1 = tail call i1 @__quantum__rt__result_equal(%Result* null, %Result* %0) tail call void @__quantum__qis__h__body(%Qubit* null) tail call void @__quantum__qis__mz__body(%Qubit* null, %Result* nonnull inttoptr (i64 1 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* null) %2 = tail call %Result* @__quantum__rt__result_get_zero() %3 = tail call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 1 to %Result*), %Result* %2) tail call void @__quantum__qis__h__body(%Qubit* null) tail call void @__quantum__qis__mz__body(%Qubit* null, %Result* nonnull inttoptr (i64 2 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* null) %4 = tail call %Result* @__quantum__rt__result_get_zero() %5 = tail call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 2 to %Result*), %Result* %4) tail call void @__quantum__qis__h__body(%Qubit* null) tail call void @__quantum__qis__mz__body(%Qubit* null, %Result* nonnull inttoptr (i64 3 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* null) %6 = tail call %Result* @__quantum__rt__result_get_zero() %7 = tail call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 3 to %Result*), %Result* %6) tail call void @__quantum__qis__h__body(%Qubit* null) tail call void @__quantum__qis__mz__body(%Qubit* null, %Result* nonnull inttoptr (i64 4 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* null) %8 = tail call %Result* @__quantum__rt__result_get_zero() %9 = tail call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 4 to %Result*), %Result* %8) %10 = select i1 %9, i64 122, i64 1337 %11 = tail call %String* @__quantum__rt__int_to_string(i64 %10) ret void } ; \u2026 attributes #0 = { \"EntryPoint\" \"requiredQubits\"=\"1\" } A notable feature of the resulting code is that there are no loops, and qubit registers are assigned at compile time, meaning that you can identify each qubit instance by its unique constant integer ID. These are features of the selected profile which does not support neither loops nor dynamic qubit allocation.","title":"Quick start"},{"location":"UserGuide/QuickStart/#quick-start","text":"Before we start, you will need to build the QAT tool. To this end, enter src/Passes from the root of the repository and create a new folder Debug . Then run cmake .. and use make to build qat : mkdir Debug cd Debug cmake .. make qat A more detailed documentation of this step is available in the build steps section . Once the build has been completed successfully, we will create a QIR in order to have an example code we can apply a profile to. The next step does not need to be completed if you already have a QIR. We will be using the Q# front end to generate the QIR and use the example SimpleLoop . However, you are free to choose another example in the QirExamples folder and/or another frontend. Go to the folder ./QirExamples/SimpleLoop/QSharpVersion and type make qir/Example.ll This will generate a QIR that will have the path ./QirExamples/SimpleLoop/QSharpVersion/qir/Example.ll relative to the project root. By using an application called QAT you can transform the QIR that was generated into a QIR that is tailored to a specific profile. Performing a transformation of the QIR from the ./Debug folder is done by typing the following commands: ./qir/qat/Apps/qat --apply --profile base -S ../QirExamples/SimpleLoop/QSharpVersion/qir/Example.ll Validation of QIR profiles is not supported by the tool at the moment. We're working on this feature, and will add the quickstart documentation here when it is available.","title":"Quick start"},{"location":"UserGuide/QuickStart/#example-simpleloop","text":"For the sake of demonstration, we will look at the result of applying the profile to the previous Q# code and its corresponding QIR. However, instead of giving all the 3316 lines of the original QIR, we instead present the frontend code for the QIR. It is always possible to recreate the QIR from the step that was previously explained if you are curious: namespace SimpleLoop { open Microsoft.Quantum.Intrinsic; open Microsoft.Quantum.Measurement; function Value(r : Result) : Int { return r == Zero ? 122 | 1337; } @EntryPoint() operation RunMain() : Int { let nrIter = 5; mutable ret = 1; for _ in 1 .. nrIter { use q = Qubit(); H(q); let r = MResetZ(q); set ret = Value(r); } return ret; } } The tool was ran with three options: --apply , --profile base and -S . First, it tells the tool to apply the profile to the QIR so that it can become a profile-specific QIR according to the profile selected. By specifying the value baseProfile to the argument --profile , we select which profile to use in the tool and the third argument ensures that LLVM IR will be printed to the terminal in a human readable format. The resulting code emitted (omitting declarations) is: ; ModuleID = 'QSharpVersion/qir/Example.ll' source_filename = \"QSharpVersion/qir/Example.ll\" ; ... define void @SimpleLoop__Main() local_unnamed_addr #0 { entry: tail call void @__quantum__qis__h__body(%Qubit* null) tail call void @__quantum__qis__mz__body(%Qubit* null, %Result* null) tail call void @__quantum__qis__reset__body(%Qubit* null) %0 = tail call %Result* @__quantum__rt__result_get_zero() %1 = tail call i1 @__quantum__rt__result_equal(%Result* null, %Result* %0) tail call void @__quantum__qis__h__body(%Qubit* null) tail call void @__quantum__qis__mz__body(%Qubit* null, %Result* nonnull inttoptr (i64 1 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* null) %2 = tail call %Result* @__quantum__rt__result_get_zero() %3 = tail call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 1 to %Result*), %Result* %2) tail call void @__quantum__qis__h__body(%Qubit* null) tail call void @__quantum__qis__mz__body(%Qubit* null, %Result* nonnull inttoptr (i64 2 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* null) %4 = tail call %Result* @__quantum__rt__result_get_zero() %5 = tail call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 2 to %Result*), %Result* %4) tail call void @__quantum__qis__h__body(%Qubit* null) tail call void @__quantum__qis__mz__body(%Qubit* null, %Result* nonnull inttoptr (i64 3 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* null) %6 = tail call %Result* @__quantum__rt__result_get_zero() %7 = tail call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 3 to %Result*), %Result* %6) tail call void @__quantum__qis__h__body(%Qubit* null) tail call void @__quantum__qis__mz__body(%Qubit* null, %Result* nonnull inttoptr (i64 4 to %Result*)) tail call void @__quantum__qis__reset__body(%Qubit* null) %8 = tail call %Result* @__quantum__rt__result_get_zero() %9 = tail call i1 @__quantum__rt__result_equal(%Result* nonnull inttoptr (i64 4 to %Result*), %Result* %8) %10 = select i1 %9, i64 122, i64 1337 %11 = tail call %String* @__quantum__rt__int_to_string(i64 %10) ret void } ; \u2026 attributes #0 = { \"EntryPoint\" \"requiredQubits\"=\"1\" } A notable feature of the resulting code is that there are no loops, and qubit registers are assigned at compile time, meaning that you can identify each qubit instance by its unique constant integer ID. These are features of the selected profile which does not support neither loops nor dynamic qubit allocation.","title":"Example: SimpleLoop"}]}